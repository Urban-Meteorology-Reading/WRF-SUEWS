! sg feb 2012 - added some comments
! sg feb 2012 - changed number of surfaces to allocatable array
! lj jun 2012 - snow part added
! HW, LJ Oct 2014 - fixes to the structure
! HCW 03 Mar 2015 - tidied
! HCW 03 Jul 2015 - added albedo max & min to SUEWS_NonVeg.txt (min not used), SUEWS_Veg.txt, SUEWS_Water.txt (min not used)
! LJ 06 Jul 2015 - changed alb_snow, albsnowmin and albsnowmax to SnowAlb, SnowAlbMin and SnowAlbMax (to be systematic with
!                   other variables). Similarly denssnow changed to SnowDens. cMDS_SnowAlb=29 added.
! HCW 10 Mar 2016 - variable vsmd added for soil moisture of vegetated surfaces
! TS 14 Mar 2016 - multiple addtions for AnOHM
! HCW 14 Jun 2016 - updated columns for ESTM and column names for AnOHM
! HCW 26 Aug 2016 - CO2 flux added
! HCW 16 Jan 2017 - WhereWhen module added to store info relating to grid and datetime
! MH 16 Jun 2017 - Added biogenic CO2 and edited Site_Select
! MH 21 Jun 2017 - Added anthropogenic CO2 and edited Site_Select

!==================================================================================================
MODULE allocateArray

  IMPLICIT NONE

  ! ---- Set parameters for reading in data ------------------------------------------------------
  INTEGER, PARAMETER:: MaxNumberOfGrids=10000   !Max no. grids   !HCW changed to 2000 from 10000 so prog can run on windows (2GB lim)
  INTEGER, PARAMETER:: MaxLinesMet=8640        !Max no. lines to read in one go (for all grids, ie MaxLinesMet/NumberOfGrids each)

  ! ---- Set number of columns in input files ----------------------------------------------------
  INTEGER, PARAMETER:: ncolumnsSiteSelect=101       !SUEWS_SiteSelect.txt
  INTEGER, PARAMETER:: ncolumnsNonVeg=24            !SUEWS_NonVeg.txt
  INTEGER, PARAMETER:: ncolumnsVeg=38               !SUEWS_Veg.txt
  INTEGER, PARAMETER:: ncolumnsWater=22             !SUEWS_Water.txt
  INTEGER, PARAMETER:: ncolumnsSnow=25              !SUEWS_Snow.txt
  INTEGER, PARAMETER:: ncolumnsSoil=9               !SUEWS_Soil.txt
  INTEGER, PARAMETER:: ncolumnsConductance=13       !SUEWS_Conductance.txt
  INTEGER, PARAMETER:: ncolumnsOHMCoefficients=4    !SUEWS_OHMCoefficients.txt
  INTEGER, PARAMETER:: ncolumnsESTMCoefficients=52  !SUEWS_ESTMCoefficients.txt ! S.O. 04 Feb 2016
  INTEGER, PARAMETER:: ncolumnsAnthropogenic=34     !SUEWS_AnthropogenicHeat.txt
  INTEGER, PARAMETER:: ncolumnsIrrigation=25        !SUEWS_Irrigation.txt
  INTEGER, PARAMETER:: ncolumnsProfiles=25          !SUEWS_Profiles.txt
  INTEGER, PARAMETER:: ncolumnsWGWaterDist=10       !SUEWS_WithinGridWaterDist.txt
  INTEGER, PARAMETER:: ncolumnsBiogen=9             !SUEWS_BiogenCO2.txt
  INTEGER, PARAMETER:: ncolumnsMetForcingData=24    !Meteorological forcing file (_data.txt)
  INTEGER, PARAMETER:: ncolsESTMdata=13             !ESTM input file (_ESTM_Ts_data.txt))


  ! ---- Set number of columns in output files ---------------------------------------------------
  INTEGER, PARAMETER:: ncolumnsDataOutSUEWS=85,&    !Main output file (_5.txt). dataOutSUEWS created in SUEWS_Calculations.f95
       ncolumnsDataOutSnow=102,&
       ncolumnsdataOutSOL=31,&
       ncolumnsdataOutBL=22,&
       ncolumnsDataOutESTM=32,&
       ncolumnsDataOutDailyState=46

  ! ---- Define input file headers ---------------------------------------------------------------
  CHARACTER(len=20),DIMENSION(ncolumnsSiteSelect)::        HeaderSiteSelect_File          !Header for SiteSelect.txt
  CHARACTER(len=20),DIMENSION(ncolumnsNonVeg)::            HeaderNonVeg_File              !Header for the nonveg surface
  CHARACTER(len=20),DIMENSION(ncolumnsNonVeg)::            HeaderNonVeg_Reqd              !Expected header for the nonveg surface
  CHARACTER(len=20),DIMENSION(ncolumnsVeg)::               HeaderVeg_File                 !Header for the veg surface
  CHARACTER(len=20),DIMENSION(ncolumnsVeg)::               HeaderVeg_Reqd                 !Expected header for the veg surface
  CHARACTER(len=20),DIMENSION(ncolumnsWater)::             HeaderWater_File               !Header for water surface
  CHARACTER(len=20),DIMENSION(ncolumnsWater)::             HeaderWater_Reqd               !Expected header for water surface
  CHARACTER(len=20),DIMENSION(ncolumnsSnow)::              HeaderSnow_File                !Header for Snow surface
  CHARACTER(len=20),DIMENSION(ncolumnsSnow)::              HeaderSnow_Reqd                !Expected header for Snow surface
  CHARACTER(len=20),DIMENSION(ncolumnsSoil)::              HeaderSoil_File                !Header for soils
  CHARACTER(len=20),DIMENSION(ncolumnsSoil)::              HeaderSoil_Reqd                !Expected header for soils
  CHARACTER(len=20),DIMENSION(ncolumnsConductance)::       HeaderCond_File                !Header for conductances
  CHARACTER(len=20),DIMENSION(ncolumnsConductance)::       HeaderCond_Reqd                !Expected header for conductances
  CHARACTER(len=20),DIMENSION(ncolumnsOHMCoefficients)::   HeaderOHMCoefficients_File     !Header for soils
  CHARACTER(len=20),DIMENSION(ncolumnsOHMCoefficients)::   HeaderOHMCoefficients_Reqd     !Expected header for soils
  CHARACTER(len=20),DIMENSION(ncolumnsESTMCoefficients)::  HeaderESTMCoefficients_File    !Header for soils            ! S.O. 04 Feb 2016
  CHARACTER(len=20),DIMENSION(ncolumnsESTMCoefficients)::  HeaderESTMCoefficients_Reqd    !Expected header for soils   ! S.O. 04 Feb 2016
  CHARACTER(len=20),DIMENSION(ncolumnsAnthropogenic)::     HeaderAnthropogenic_File       !Header for QF
  CHARACTER(len=20),DIMENSION(ncolumnsAnthropogenic)::     HeaderAnthropogenic_Reqd       !Expected header for QF
  CHARACTER(len=20),DIMENSION(ncolumnsIrrigation)::        HeaderIrrigation_File          !Header for Irrigation
  CHARACTER(len=20),DIMENSION(ncolumnsIrrigation)::        HeaderIrrigation_Reqd          !Expected header for Irrigation
  CHARACTER(len=20),DIMENSION(ncolumnsProfiles)::          HeaderProfiles_File            !Header for Profiles
  CHARACTER(len=20),DIMENSION(ncolumnsProfiles)::          HeaderProfiles_Reqd            !Expected header for Profiles
  CHARACTER(len=20),DIMENSION(ncolumnsWGWaterDist)::       HeaderWGWaterDist_File         !Header for Profiles
  CHARACTER(len=20),DIMENSION(ncolumnsWGWaterDist)::       HeaderWGWaterDist_Reqd         !Expected header for Profiles
  CHARACTER(len=20),DIMENSION(ncolumnsBiogen)::            HeaderBiogen_File              !Header for Biogen
  CHARACTER(len=20),DIMENSION(ncolumnsBiogen)::            HeaderBiogen_Reqd              !Expected header for Biogen

  ! ---- Define output file headers --------------------------------------------------------------
  INTEGER,DIMENSION(:),ALLOCATABLE:: UseColumnsDataOut       !Column numbers used to select output variables
  ! If change lengths in SUEWS_Output.f95, also need to adjust here
  CHARACTER(len=14*ncolumnsDataOutSUEWS):: HeaderUse,FormatUse,HeaderUseNoSep,FormatUseNoSep    !Header and format in correct form
  CHARACTER(len=52*ncolumnsDataOutSUEWS):: LongNmUse
  CHARACTER(len=14*ncolumnsDataOutSUEWS):: UnitsUse
  CHARACTER(len=3*ncolumnsDataOutSUEWS):: AggregUse
  CHARACTER(len=4*ncolumnsDataOutSUEWS):: ColNosUse

  ! ---- Define arrays to store input information from SiteInfo spreadsheet ----------------------
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::SiteSelect                !Stores info from SiteSelect.txt
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::NonVeg_Coeff              !Coefficients for the nonveg surfaces
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Veg_Coeff                 !Coefficients for the veg surfaces
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Water_Coeff               !Coefficients for the water surface
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Snow_Coeff                !Coefficients for snow
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Soil_Coeff                !Coefficients for soil
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Conductance_Coeff         !Coefficients for conductances
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::OHMCoefficients_Coeff     !Coefficients for OHMCoefficients
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::ESTMCoefficients_Coeff    !Coefficients for ESTMCoefficients   ! S.O. 04 Feb 2016
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Anthropogenic_Coeff       !Coefficients for AnthropogenicEmissions
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Irrigation_Coeff          !Coefficients for Irrigation
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Profiles_Coeff            !Coefficients for Profiles
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::WGWaterDist_Coeff         !Coefficients for WithinGridWaterDist
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::Biogen_Coeff              !Coefficients for BiogenCO2

  ! ---- Define arrays for model calculations ----------------------------------------------------
  INTEGER,DIMENSION(:), ALLOCATABLE:: GridIDmatrix         !Array containing GridIDs in SiteSelect after sorting
  INTEGER,DIMENSION(:), ALLOCATABLE:: GridIDmatrix0        !Array containing GridIDs in SiteSelect in the original order
  REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: SurfaceChar          !Array for surface characteristics
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: MetForcingData      !Array for meteorological forcing data
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE  :: MetForcingData_grid !Array for meteorological forcing data of one grid used by AnOHM
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: ESTMForcingData      !Array for ESTM forcing data
  REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: ModelDailyState      !DailyState array
  REAL(KIND(1d0)),DIMENSION(:),    ALLOCATABLE:: DailyStateFirstOpen
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: ModelOutputData      !Output data matrix
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: dataOutSUEWS              !Main data output matrix
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: dataOutBL            !CBL output matrix
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: dataOutSOL           !SOLWEIG POI output matrix
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: dataOutSnow          !Main data output matrix
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: dataOutESTM          !ESTM output matrix
  REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: dataOutDailyState    !DailyState output array

  ! -------- output per each timestep ----------------------------------------------------------------
  REAL(KIND(1D0)),DIMENSION(5)                          ::datetimeLine     ! output of datetime info per each timestep
  REAL(KIND(1D0)),DIMENSION(ncolumnsDataOutSUEWS-5)     ::dataOutLineSUEWS ! output of SUEWS results per each timestep
  REAL(KIND(1D0)),DIMENSION(ncolumnsDataOutSnow-5)      ::dataOutLineSnow  ! output of snow results per each timestep
  REAL(KIND(1D0)),DIMENSION(ncolumnsDataOutDailyState-5)::DailyStateLine   ! output of DailyState results per each timestep

  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE:: MetForDisagg           !Array for original met forcing data (for disaggregation)
  REAL(KIND(1d0)),DIMENSION(:),  ALLOCATABLE:: MetForDisaggPrev,MetForDisaggNext !Stores last and next row of met data

  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE:: ESTMForDisagg           !Array for original ESTM forcing data (for disaggregation)
  REAL(KIND(1d0)),DIMENSION(:),  ALLOCATABLE:: ESTMForDisaggPrev,ESTMForDisaggNext !Stores last and next row of ESTM data

  ! ---- Define array for hourly profiles interpolated to tstep ----------------------------------
  ! REAL(KIND(1d0)),DIMENSION(:,:,:),ALLOCATABLE:: TstepProfiles
  ! REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: AHProf_tstep
  ! REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: WUProfM_tstep
  ! REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: WUProfA_tstep
  ! REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: HumActivity_tstep
  ! REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: TraffProf_tstep
  ! REAL(KIND(1d0)),DIMENSION(:,:),  ALLOCATABLE:: PopProf_tstep

  REAL(KIND(1d0)),DIMENSION(0:23,2):: AHProf_24hr     !Anthropogenic heat profiles for (1)weekdays / (2)weekends
  REAL(KIND(1d0)),DIMENSION(0:23,2):: HumActivity_24hr   !Human actvity profiles for (1)weekdays / (2)weekends
  REAL(KIND(1d0)),DIMENSION(0:23,2):: TraffProf_24hr   !Traffic profiles for (1)weekdays / (2)weekends
  REAL(KIND(1d0)),DIMENSION(0:23,2):: PopProf_24hr   !Population profiles for (1)weekdays / (2)weekends
  REAL(KIND(1d0)),DIMENSION(0:23,2):: WUProfM_24Hr
  REAL(KIND(1d0)),DIMENSION(0:23,2):: WUProfA_24Hr

  ! ---- For ESTM
  REAL(KIND(1d0)),ALLOCATABLE,DIMENSION(:,:):: Ts5mindata   !surface temperature input data
  REAL(KIND(1d0)),ALLOCATABLE,DIMENSION(:)  :: ts5mindata_ir !=ts5mindata(ir,:), ts input for the current timestep
  REAL(KIND(1d0)),ALLOCATABLE,DIMENSION(:)  :: Tair24HR
  REAL(KIND(1d0)),DIMENSION(27)  :: dataOutLineESTM !ESTM output for the current timestep and grid

  ! Column numbers for TstepProfiles
  INTEGER:: cTP_EnUseWD  = 1,&
       cTP_EnUseWE       = 2,&
       cTP_WUManuWD      = 3,&
       cTP_WUManuWE      = 4,&
       cTP_WUAutoWD      = 5,&
       cTP_WUAutoWE      = 6,&
       cTP_SnowCWD       = 7,&
       cTP_SnowCWE       = 8,&
       cTP_HumActivityWD = 9,&
       cTP_HumActivityWE = 10,&
       cTP_TraffProfWD   = 11,&
       cTP_TraffProfWE   = 12,&
       cTP_PopProfWD     = 13,&
       cTP_PopProfWE     = 14
  !-----------------------------------------------------------------------------------------------

  ! ---- Surface types ---------------------------------------------------------------------------
  INTEGER, PARAMETER:: nsurf=7                !Total number of surfaces
  INTEGER, PARAMETER:: NVegSurf=3             !Number of surfaces that are vegetated
  INTEGER, PARAMETER:: nsurfIncSnow=nsurf+1   !Number of surfaces + snow

  INTEGER,PARAMETER:: PavSurf   = 1,&   !When all surfaces considered together (1-7)
       BldgSurf  = 2,&
       ConifSurf = 3,&
       DecidSurf = 4,&
       GrassSurf = 5,&   !New surface classes: Grass = 5th/7 surfaces
       BSoilSurf = 6,&   !New surface classes: Bare soil = 6th/7 surfaces
       WaterSurf = 7,&
       ExcessSurf= 8,&   !Runoff or subsurface soil in WGWaterDist
       NSurfDoNotReceiveDrainage=0,&   !Number of surfaces that do not receive drainage water (green roof)
       ivConif = 1,&     !When only vegetated surfaces considered (1-3)
       ivDecid = 2,&
       ivGrass = 3

  REAL(KIND(1d0)),DIMENSION(nsurf):: sfr   !Surface fractions [-]

  ! ---- Water balance for each surface  ---------------------------------------------------------
  !These variables are expressed as depths [mm] over each surface(is); the depth therefore varies with sfr(is)
  REAL(KIND(1d0)),DIMENSION(nsurf):: AddWater       !Water from other surfaces (WGWaterDist in SUEWS_ReDistributeWater.f95) [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: AddWaterRunoff !Fraction of water going to runoff/sub-surface soil (WGWaterDist) [-]
  ! N.B. this is not an amount; drain(is)*AddWaterRunoff(is) is the amount [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: chang          !Change in state [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: drain          !Drainage of each surface type [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: evap           !Evaporation from each surface type [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: runoff         !Runoff from each surface type [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: runoffSoil     !Soil runoff from each soil sub-surface [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: smd_nsurf      !Soil moisture deficit of each sub-surface [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: smd_nsurfOut   !Soil moisture deficit of each sub-surface (written out) [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: soilmoist_id      !Soil moisture of each surface type [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: soilmoistOld   !Soil moisture of each surface type from previous timestep [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: state_id          !Wetness status of each surface type [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: stateOut       !Wetness status of each surface type (written out) [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: stateOld       !Wetness status of each surface type from previous timestep [mm]
  REAL(KIND(1D0)),DIMENSION(nsurf):: rss_nsurf      !Surface resistance after wet/partially wet adjustment for each surface

  REAL(KIND(1d0)),DIMENSION(nsurf):: WetThresh      !When state_id > WetThresh, RS=0 limit in SUEWS_evap [mm] (specified in input files)
  REAL(KIND(1d0)),DIMENSION(nsurf):: StateLimit     !Limit for state_id of each surface type [mm] (specified in input files)

  REAL(KIND(1d0)),DIMENSION(1)::     WaterDepth     !Depth of open water

  ! ---- Soil characteristics specified in input files -------------------------------------------
  REAL(KIND(1d0)),DIMENSION(nsurf):: SatHydraulicConduct !Saturated hydraulic conductivity for each soil subsurface [mm s-1]
  REAL(KIND(1d0)),DIMENSION(nsurf):: SoilDepth           !Depth of sub-surface soil store for each surface [mm]
  REAL(KIND(1d0)),DIMENSION(nsurf):: SoilStoreCap        !Capacity of soil store for each surface [mm]

  ! ---- Within-grid water distribution matrix ---------------------------------------------------
  REAL(KIND(1d0)),DIMENSION(nsurf+1,nsurf-1)::WaterDist !Within-grid water distribution to other surfaces and runoff/soil store [-]

  ! ---- Drainage characteristics ----------------------------------------------------------------
  REAL(KIND(1d0)),DIMENSION(6,nsurf):: StoreDrainPrm   !Storage capacities and drainage equation info for each surface
  ! 1 - min storage capacity [mm]
  ! 2 - Drainage equation to use
  ! 3 - Drainage coeff 1 [units depend on choice of eqn]
  ! 4 - Drainage coeff 2 [units depend on choice of eqn]
  ! 5 - max storage capacity [mm]
  ! 6 - current storage capacity [mm]
  !-----------------------------------------------------------------------------------------------

  ! ---- Define arrays at daily timestep ---------------------------------------------------------
  INTEGER, PARAMETER:: ndays = 366   !Max no. days in a year used to specify size of daily arrays
  !! Could delete NDays and allocate these elsewhere once no. days is known
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays, 5):: GDD          !Growing Degree Days (see SUEWS_DailyState.f95)
  ! REAL(KIND(1d0)),DIMENSION(-4:ndays, 6):: HDD          !Heating Degree Days (see SUEWS_DailyState.f95)
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays, 9):: WUDay       !Daily water use for EveTr, DecTr, Grass [mm] (see SUEWS_DailyState.f95)
  ! REAL(KIND(1d0)),DIMENSION(-4:ndays, nvegsurf):: LAI   !LAI for each veg surface [m2 m-2]

  REAL(KIND(1d0)),DIMENSION(5)        :: GDD_id,GDD_id_prev     !Growing Degree Days (see SUEWS_DailyState.f95)
  REAL(KIND(1d0)),DIMENSION(12)       :: HDD_id
  REAL(KIND(1d0)),DIMENSION(9)        :: WUDay_id,WUDay_id_prev !Daily water use for EveTr, DecTr, Grass [mm] (see SUEWS_DailyState.f95)
  REAL(KIND(1d0)),DIMENSION(nvegsurf) :: LAI_id,LAI_id_prev     !LAI for each veg surface [m2 m-2]

  ! Seasonality of deciduous trees accounted for by the following variables which change with time
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays):: DecidCap   !Storage capacity of deciduous trees [mm]
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays):: porosity   !Porosity of deciduous trees [-]
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays):: albDecTr     !Albedo of deciduous trees [-]
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays):: albEveTr     !Albedo of evergreen trees [-]
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays):: albGrass   !Albedo of grass[-]

  REAL(KIND(1d0)):: AlbMin_DecTr,&   !Min albedo for deciduous trees [-]
       AlbMax_DecTr,&   !Max albedo for deciduous trees [-]
       CapMin_dec,&   !Min storage capacity for deciduous trees [mm] (from input information)
       CapMax_dec,&   !Max storage capacity for deciduous trees [mm] (from input information)
       PorMin_dec,&  !Min porosity for deciduous trees
       PorMax_dec,&    !Max porosity for deciduous trees
       AlbMin_EveTr,&   !Min albedo for evergreen trees [-]
       AlbMax_EveTr,&   !Max albedo for evergreen trees [-]
       AlbMin_Grass,&   !Min albedo for grass [-]
       AlbMax_Grass     !Max albedo for grass [-]

  ! Replicate arrays needed for DailyState, adding dimension to identify the grid, HCW 27 Nov 2014
  !! Could delete MaxNumberOfGrids and allocate these elsewhere once NumberOfGrids is known
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays, 5,MaxNumberOfGrids):: GDD_grids
  ! REAL(KIND(1d0)),DIMENSION(-4:ndays, 6,MaxNumberOfGrids):: HDD_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays, 9,MaxNumberOfGrids):: WUDay_grids
  ! REAL(KIND(1d0)),DIMENSION(-4:ndays, nvegsurf,MaxNumberOfGrids):: LAI_grids

  REAL(KIND(1d0)),DIMENSION(5,MaxNumberOfGrids):: GDD_id_grids
  REAL(KIND(1d0)),DIMENSION(12,MaxNumberOfGrids):: HDD_id_grids
  REAL(KIND(1d0)),DIMENSION(9,MaxNumberOfGrids):: WUDay_id_grids
  REAL(KIND(1d0)),DIMENSION(nvegsurf,MaxNumberOfGrids):: LAI_id_grids

  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: albDecTr_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: DecidCap_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: porosity_grids
  !
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: albEveTr_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: albGrass_grids

  REAL(KIND(1d0)),DIMENSION( MaxNumberOfGrids):: DecidCap_id_grids
  REAL(KIND(1d0)),DIMENSION( MaxNumberOfGrids):: albDecTr_id_grids
  REAL(KIND(1d0)),DIMENSION( MaxNumberOfGrids):: albEveTr_id_grids
  REAL(KIND(1d0)),DIMENSION( MaxNumberOfGrids):: albGrass_id_grids
  REAL(KIND(1d0)),DIMENSION( MaxNumberOfGrids):: porosity_id_grids

  REAL(KIND(1d0)) :: DecidCap_id
  REAL(KIND(1d0)) :: albDecTr_id
  REAL(KIND(1d0)) :: albEveTr_id
  REAL(KIND(1d0)) :: albGrass_id
  REAL(KIND(1d0)) :: porosity_id

  ! AnOHM related: added by TS 01 Mar 2016
  ! store AnOHM coef. of all sfc. by TS 09 Apr 2016
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: Bo_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: mAH_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: a1AnOHM_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: a2AnOHM_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids):: a3AnOHM_grids
  ! REAL(KIND(1d0)),DIMENSION( 0:ndays,MaxNumberOfGrids,nsurf,3):: a123AnOHM_gs
  REAL(KIND(1d0)):: xBo ! daily Bowen ratio
  !! store water states for AnOHM iteration, by TS 13 Apr 2016
  !REAL(KIND(1d0)),DIMENSION(0:ndays,MaxNumberOfGrids,nsurf):: soilmoistDay   !Soil moisture of each surface type at the end of a day [mm], 13 Apr 2016 TS
  !REAL(KIND(1d0)),DIMENSION(0:ndays,MaxNumberOfGrids,nsurf):: stateDay       !Wetness status of each existing surface type at the end of a day [mm], 13 Apr 2016 TS


  ! Day of week, month and season (used for water use and energy use calculations, and in OHM)
  ! INTEGER,DIMENSION(0:ndays,3)::DayofWeek   !1 - day of week; 2 - month; 3 - season
  !-----------------------------------------------------------------------------------------------

  ! --- Vegetation phenology ---------------------------------------------------------------------
  ! Parameters provided in input information for each vegetation surface (SUEWS_Veg.txt)
  REAL(KIND(1d0)),DIMENSION(nvegsurf):: BaseT            !Base temperature for growing degree days [degC]
  REAL(KIND(1d0)),DIMENSION(nvegsurf):: BaseTe           !Base temperature for senescence degree days [degC]
  REAL(KIND(1d0)),DIMENSION(nvegsurf):: GDDFull          !Growing degree days needed for full capacity [degC]
  REAL(KIND(1d0)),DIMENSION(nvegsurf):: SDDFull          !Senescence degree days needed to initiate leaf off [degC]
  REAL(KIND(1d0)),DIMENSION(nvegsurf):: LAIMin           !Min LAI [m2 m-2]
  REAL(KIND(1d0)),DIMENSION(nvegsurf):: LAIMax           !Max LAI  [m2 m-2]
  REAL(KIND(1d0)),DIMENSION(nvegsurf):: MaxConductance   !Max conductance [mm s-1]
  REAL(KIND(1d0)),DIMENSION(4,nvegsurf):: LAIPower       !Coeffs for LAI equation: 1,2 - leaf growth; 3,4 - leaf off
  !! N.B. currently DecTr only, although input provided for all veg types
  INTEGER,DIMENSION(nvegsurf):: LAIType                  !LAI equation to use: original (0) or new (1)
  !real(kind(1d0))::GDDmax,SDDMax                        ! Max GDD and SDD across all veg types [degC] (removed HCW 03 Mar 2015)

  REAL(KIND(1d0)),DIMENSION(nvegsurf):: BiogenCO2Code,&    !Biogenic CO2 Code for SUEWS_BiogenCO2.txt
       alpha_bioCO2,&
       beta_bioCO2,&
       theta_bioCO2,&
       alpha_enh_bioCO2,&
       beta_enh_bioCO2,&
       resp_a,&
       resp_b,&
       min_res_bioCO2

  !No longer used (removed HCW 27 Nov 2014)
  !real(kind(1d0)),dimension(0:23)::runT           ! running average T for the day
  !real(kind(1d0)),dimension(0:23)::runP           ! running total Precip for the day
  !real (kind(1d0))::avT_h, totP_h                 ! daily running average Temp, Total precip
  !-----------------------------------------------------------------------------------------------

  ! ---- Variables related to NARP ---------------------------------------------------------------
  REAL(KIND(1d0)),DIMENSION(nsurf):: alb    !Albedo of each surface type [-]
  REAL(KIND(1d0)),DIMENSION(nsurf):: emis   !Emissivity of each surface type [-]

  REAL(KIND(1d0)):: bulkalbedo !Bulk albedo for whole surface (areally-weighted)

  ! Radiation balance components for different surfaces
  REAL(KIND(1d0)),DIMENSION(nsurf):: Tsurf_ind,&        !Surface temperature for each surface [degC]
       Tsurf_ind_snow,&   !Snow surface temperature for each surface [degC]
       Tsurf_ind_nosnow
  REAL(KIND(1d0)),DIMENSION(nsurf):: kup_ind,&          !Outgoing shortwave radiation for each surface [W m-2]
       kup_ind_snow,&     !Outgoing shortwave radiation for each snow surface [W m-2]
       kup_ind_nosnow
  REAL(KIND(1d0)),DIMENSION(nsurf):: lup_ind,&          !Outgoing longwave radiation for each surface [W m-2]
       lup_ind_snow,&     !Outgoing longwave radiation for each snow surface [W m-2]
       lup_ind_nosnow
  REAL(KIND(1d0)),DIMENSION(nsurf):: qn1_ind,&          !Net all-wave radiation for each surface [W m-2]
       qn1_ind_snow,&     !Net all-wave radiation for each snow surface [W m-2]
       qn1_ind_nosnow

  ! ---- NARP-specific parameters ----------------------------------------------------------------
  REAL(KIND(1d0))             :: NARP_LAT,NARP_LONG,NARP_YEAR,NARP_TZ,&
       NARP_ALB_SNOW,NARP_EMIS_SNOW,NARP_TRANS_SITE
  REAL(KIND(1D0))             :: NARP_G(365)   !!QUESTION: Should this be NDays? - HCW
  INTEGER                     :: NARP_NPERHOUR
  REAL(KIND(1D0)),ALLOCATABLE :: NARP_KDOWN_HR(:)
  ! Constants required
  REAL(KIND(1D0)),PARAMETER   :: DEG2RAD=0.017453292,&
       RAD2DEG=57.29577951,&
       SIGMA_SB=5.67E-8
  !-----------------------------------------------------------------------------------------------

  ! ---- OHM coefficients ------------------------------------------------------------------------
  REAL(KIND(1d0)),DIMENSION(nsurf+1,4,3):: OHM_coef   !Array for OHM coefficients
  REAL(KIND(1d0)),DIMENSION(nsurf+1)::     OHM_threshSW, OHM_threshWD   !Arrays for OHM thresholds
  REAL(KIND(1d0)):: a1,a2,a3   !OHM coefficients, a1 [-]; a2 [h]; a3 [W m-2]
  ! REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE:: qn1_store, qn1_S_store   !Q* values for each timestep over previous hr (_S for snow)
  ! REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE:: qn1_av_store, qn1_S_av_store  !Hourly Q* values for each timestep over previous 2 hr
  ! REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE::qn1_store_grid,qn1_av_store_grid
  ! REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE::qn1_S_store_grid,qn1_S_av_store_grid

  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE::qn1_av_grids,qn1_s_av_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE::dqndt_grids,dqnsdt_grids
  REAL(KIND(1d0))::qn1_av,dqndt
  REAL(KIND(1d0))::qn1_s_av,dqnsdt

  !-----------------------------------------------------------------------------------------------

  ! ---- Snow-related variables ------------------------------------------------------------------
  REAL(KIND(1d0)),DIMENSION(nsurf):: changSnow,&       !Change in snowpack in mm
       maxSnowVol,&      !! Maximum snow volume
       MeltWaterStore,&  !!Liquid water in the snow pack of ith surface
       ev_snow,&          !!Evaporation from snowpack in mm
       mw_ind,&           !Melt water from individual surface in mm
       mw_indDay,&        !!Melt water per day from each surface type in m3
       runoffSnow,&       !!Runoff from snowpack in mm and in m3
       SnowDens,&        !Density of snow
       SnowFrac,&         !!Surface fraction of snow cover
       iceFrac,&
       snowInit,&
       snowDepth,&       !Depth of snow in cm
       SnowToSurf,&      !Meltwater flowing from snow to surface
       volSWE,&
       StateFraction,&   !Fraction of state that can freeze
       freezMelt,&       !Amount of freezing meltwater in mm for the ith surface area
       Qm_freezState,&   !Heat by freezing of surface state
       freezState,&      !Amount of freezing state in mm for the ith surface area
       FreezStateVol,&
       Qm_melt,&         !Heat consumption by snow melt
       Qm_rain,&         !Heat by rain falling on snow
       rainOnSnow,&      !Liquid precipitation falling on snow ()
       snowD,&
       deltaQi

  REAL(KIND(1d0)),DIMENSION(nsurf):: snowPack,&        !Amount of snow on each surface in mm
       snowPackOld
  INTEGER,DIMENSION(nsurf):: heiG,&                    !snow layer height
       snowCoverForms,&
       snowCalcSwitch=0          !Defines if snow related balance is made
  !-----------------------------------------------------------------------------------------------

  ! ---- Grid connections ------------------------------------------------------------------------
  !! Grid connections needs coding, currently no water transfer between grids
  ! Added HCW 14 Nov 2014
  INTEGER,PARAMETER:: nconns = 8   !Number of grids for between-grid connections
  REAL(KIND(1d0)),DIMENSION(nconns):: GridToFrac   !Fraction of water moving to the grid specified in GridTo [-]
  REAL(KIND(1d0)),DIMENSION(nconns):: GridTo       !Grid that water moves to
  !!character(len=15),dimension(2,MaxNumberOfGrids)::GridConnections  !List of different grid corrections
  !!real (kind(1d0)),dimension(MaxNumberOfGrids)::   GridConnectionsFrac   !Fraction of water moving between the different grids
  !-----------------------------------------------------------------------------------------------

  ! ---- AnOHM related variable, added by TS, 01 Mar 2016 ---------------------------------------------------------------
  REAL(KIND(1d0)),DIMENSION(MaxNumberOfGrids) :: a1AnOHM,a2AnOHM,a3AnOHM ! OHM coefficients, a1 [-]; a2 [h]; a3 [W m-2]
  REAL(KIND(1d0)),DIMENSION(MaxNumberOfGrids) :: mAHAnOHM                ! daily mean AH [W m-2]
  REAL(KIND(1d0)),DIMENSION(MaxNumberOfGrids) :: BoAnOHMStart            ! initial Bo for interation [-]
  REAL(KIND(1d0)),DIMENSION(MaxNumberOfGrids) :: BoAnOHMEnd              ! final Bo for interation [-]
  REAL(KIND(1d0)),DIMENSION(nsurf):: cpAnOHM ! heat capacity [J m-3 K-1]
  REAL(KIND(1d0)),DIMENSION(nsurf):: kkAnOHM ! thermal conductivity [W m-1 K-1]
  REAL(KIND(1d0)),DIMENSION(nsurf):: chAnOHM ! bulk transfer coef. [-]
  !-----------------------------------------------------------------------------------------------

  ! ESTM variables for SUEWS surfaces
  REAL(KIND(1d0)),DIMENSION(5,nsurfIncSnow):: zSurf_SUEWSsurfs, &
       kSurf_SUEWSsurfs, &
       rSurf_SUEWSsurfs
  !-----------------------------------------------------------------------------------------------
  !---------------------------------- Column numbers ---------------------------------------------

  ! ---- Set column numbering for SurfaceChar ----------------------------------------------------
  ! Columns 1:80 are the same as in SiteSelect.txt and defined below
  INTEGER:: cc    !Column counter
  INTEGER,PARAMETER:: ccEndSI=ncolumnsSiteSelect

  ! Applicable to each surface
  INTEGER,DIMENSION(nsurf):: c_AlbMin     = (/(cc, cc=ccEndSI+ 0*nsurf+1,ccEndSI+ 0*nsurf+nsurf, 1)/)  !Min. albedo
  INTEGER,DIMENSION(nsurf):: c_AlbMax     = (/(cc, cc=ccEndSI+ 1*nsurf+1,ccEndSI+ 1*nsurf+nsurf, 1)/)  !Max. albedo
  INTEGER,DIMENSION(nsurf):: c_Emis       = (/(cc, cc=ccEndSI+ 2*nsurf+1,ccEndSI+ 2*nsurf+nsurf, 1)/)  !Emissivity
  INTEGER,DIMENSION(nsurf):: c_StorMin    = (/(cc, cc=ccEndSI+ 3*nsurf+1,ccEndSI+ 3*nsurf+nsurf, 1)/)  !Min. storage capacity (canopy)
  INTEGER,DIMENSION(nsurf):: c_StorMax    = (/(cc, cc=ccEndSI+ 4*nsurf+1,ccEndSI+ 4*nsurf+nsurf, 1)/)  !Max. storage capacity (canopy)
  INTEGER,DIMENSION(nsurf):: c_WetThresh  = (/(cc, cc=ccEndSI+ 5*nsurf+1,ccEndSI+ 5*nsurf+nsurf, 1)/)  !Threshold for wet evaporation [mm]
  INTEGER,DIMENSION(nsurf):: c_StateLimit = (/(cc, cc=ccEndSI+ 6*nsurf+1,ccEndSI+ 6*nsurf+nsurf, 1)/)  !Limit for surface state [mm]
  INTEGER,DIMENSION(nsurf):: c_DrEq       = (/(cc, cc=ccEndSI+ 7*nsurf+1,ccEndSI+ 7*nsurf+nsurf, 1)/)  !Drainage equation
  INTEGER,DIMENSION(nsurf):: c_DrCoef1    = (/(cc, cc=ccEndSI+ 8*nsurf+1,ccEndSI+ 8*nsurf+nsurf, 1)/)  !Drainage coef. 1
  INTEGER,DIMENSION(nsurf):: c_DrCoef2    = (/(cc, cc=ccEndSI+ 9*nsurf+1,ccEndSI+ 9*nsurf+nsurf, 1)/)  !Drainage coef. 2
  INTEGER,DIMENSION(nsurf):: c_SoilTCode  = (/(cc, cc=ccEndSI+10*nsurf+1,ccEndSI+10*nsurf+nsurf, 1)/)  !Soil type code

  ! N.B. not included in SUEWS_Water.txt
  INTEGER,DIMENSION(nsurf):: c_SnowLimPat =(/(cc, cc=ccEndSI+11*nsurf+1,ccEndSI+11*nsurf+nsurf, 1)/) !Snow limit for patchiness
  ! N.B. currently only in SUEWS_NonVeg.txt
  INTEGER,DIMENSION(nsurf):: c_SnowLimRem =(/(cc, cc=ccEndSI+12*nsurf+1,ccEndSI+12*nsurf+nsurf, 1)/) !Snow limit for removal
  ! AnOHM TS
  INTEGER,DIMENSION(nsurf):: c_CpAnOHM = (/(cc, cc=ccEndSI+13*nsurf+1,ccEndSI+13*nsurf+nsurf, 1)/) !heat capacity, AnOHM TS
  INTEGER,DIMENSION(nsurf):: c_KkAnOHM = (/(cc, cc=ccEndSI+14*nsurf+1,ccEndSI+14*nsurf+nsurf, 1)/) !heat conductivity, AnOHM TS
  INTEGER,DIMENSION(nsurf):: c_ChAnOHM = (/(cc, cc=ccEndSI+15*nsurf+1,ccEndSI+15*nsurf+nsurf, 1)/) !bulk transfer coef., AnOHM TS



  ! Find current column number
  INTEGER,PARAMETER:: ccEndI = (ccEndSI+15*nsurf+nsurf) !add columns for AnOHM, AnOHM TS

  ! Applicable to vegetated surfaces only
  INTEGER,DIMENSION(NVegSurf):: c_BaseT   =(/(cc, cc=ccEndI+ 0*nvegsurf+1,ccEndI+ 0*nvegsurf+nvegsurf, 1)/) !Base temp. for leaf-on
  INTEGER,DIMENSION(NVegSurf):: c_BaseTe  =(/(cc, cc=ccEndI+ 1*nvegsurf+1,ccEndI+ 1*nvegsurf+nvegsurf, 1)/) !Base temp. for leaf-off
  INTEGER,DIMENSION(NVegSurf):: c_GDDFull =(/(cc, cc=ccEndI+ 2*nvegsurf+1,ccEndI+ 2*nvegsurf+nvegsurf, 1)/) !GDD for full LAI
  INTEGER,DIMENSION(NVegSurf):: c_SDDFull =(/(cc, cc=ccEndI+ 3*nvegsurf+1,ccEndI+ 3*nvegsurf+nvegsurf, 1)/) !SDD for start of leaf-fall
  INTEGER,DIMENSION(NVegSurf):: c_LAIMin  =(/(cc, cc=ccEndI+ 4*nvegsurf+1,ccEndI+ 4*nvegsurf+nvegsurf, 1)/) !Min. LAI
  INTEGER,DIMENSION(NVegSurf):: c_LAIMax  =(/(cc, cc=ccEndI+ 5*nvegsurf+1,ccEndI+ 5*nvegsurf+nvegsurf, 1)/) !Max. LAI
  INTEGER,DIMENSION(NVegSurf):: c_PorosityMin  =(/(cc, cc=ccEndI+ 6*nvegsurf+1,ccEndI+ 6*nvegsurf+nvegsurf, 1)/) !Min. Porosity
  INTEGER,DIMENSION(NVegSurf):: c_PorosityMax  =(/(cc, cc=ccEndI+ 7*nvegsurf+1,ccEndI+ 7*nvegsurf+nvegsurf, 1)/) !Max. Porosity
  INTEGER,DIMENSION(NVegSurf):: c_GsMax   =(/(cc, cc=ccEndI+ 8*nvegsurf+1,ccEndI+ 8*nvegsurf+nvegsurf, 1)/) !Max. conductance
  INTEGER,DIMENSION(NVegSurf):: c_LAIEq   =(/(cc, cc=ccEndI+ 9*nvegsurf+1,ccEndI+ 9*nvegsurf+nvegsurf, 1)/) !LAI equation
  INTEGER,DIMENSION(NVegSurf):: c_LeafGP1 =(/(cc, cc=ccEndI+10*nvegsurf+1,ccEndI+10*nvegsurf+nvegsurf, 1)/) !Leaf growth power 1
  INTEGER,DIMENSION(NVegSurf):: c_LeafGP2 =(/(cc, cc=ccEndI+11*nvegsurf+1,ccEndI+11*nvegsurf+nvegsurf, 1)/) !Leaf growth power 2
  INTEGER,DIMENSION(NVegSurf):: c_LeafOP1 =(/(cc, cc=ccEndI+12*nvegsurf+1,ccEndI+12*nvegsurf+nvegsurf, 1)/) !Leaf-off power 1
  INTEGER,DIMENSION(NVegSurf):: c_LeafOP2 =(/(cc, cc=ccEndI+13*nvegsurf+1,ccEndI+13*nvegsurf+nvegsurf, 1)/) !Leaf-off power 2
  INTEGER,DIMENSION(NVegSurf):: c_BiogenCO2Code = (/(cc, cc=ccEndI+14*nvegsurf+1,ccEndI+14*nvegsurf+nvegsurf, 1)/) !Biogenic CO2 Code
  ! Find current column number
  INTEGER,PARAMETER:: ccEndP = (ccEndI+14*nvegsurf+nvegsurf)

  ! Applicable to water surfaces only
  INTEGER:: c_WaterDepth = (ccEndP+1)

  ! Find current column number
  INTEGER,PARAMETER:: ccEndW = (ccEndP+1)

  ! Applicable to snow only
  INTEGER:: c_SnowRMFactor = (ccEndW+ 1)
  INTEGER:: c_SnowTMFactor = (ccEndW+ 2)
  INTEGER:: c_SnowAlbMin   = (ccEndW+ 3)
  INTEGER:: c_SnowAlbMax   = (ccEndW+ 4)
  !integer:: c_SnowAlb      = (ccEndW+ 5)
  INTEGER:: c_SnowEmis     = (ccEndW+ 6)
  INTEGER:: c_Snowtau_a    = (ccEndW+ 7)
  INTEGER:: c_Snowtau_f    = (ccEndW+ 8)
  INTEGER:: c_SnowPLimAlb  = (ccEndW+ 9)
  INTEGER:: c_SnowSDMin    = (ccEndW+10)
  INTEGER:: c_SnowSDMax    = (ccEndW+11)
  INTEGER:: c_Snowtau_r    = (ccEndW+12)
  INTEGER:: c_SnowCRWMin   = (ccEndW+13)
  INTEGER:: c_SnowCRWMax   = (ccEndW+14)
  INTEGER:: c_SnowPLimSnow = (ccEndW+15)

  ! Find current column number
  INTEGER,PARAMETER:: ccEndSn = (ccEndW+15)

  ! Soil information
  INTEGER,DIMENSION(nsurf):: c_SoilDepth    = (/(cc, cc=ccEndSn+ 0*nsurf+1,ccEndSn+ 0*nsurf+nsurf, 1)/)  ! Volumetric SM capacity
  INTEGER,DIMENSION(nsurf):: c_SoilStCap = (/(cc, cc=ccEndSn+ 1*nsurf+1,ccEndSn+ 1*nsurf+nsurf, 1)/)  ! Volumetric SM capacity
  INTEGER,DIMENSION(nsurf):: c_KSat         = (/(cc, cc=ccEndSn+ 2*nsurf+1,ccEndSn+ 2*nsurf+nsurf, 1)/)  ! Saturated hydraulic conductivity
  INTEGER,DIMENSION(nsurf):: c_SoilDens     = (/(cc, cc=ccEndSn+ 3*nsurf+1,ccEndSn+ 3*nsurf+nsurf, 1)/)  ! Soil Density
  INTEGER,DIMENSION(nsurf):: c_SoilInfRate  = (/(cc, cc=ccEndSn+ 4*nsurf+1,ccEndSn+ 4*nsurf+nsurf, 1)/)  ! Soil infiltration rate
  INTEGER,DIMENSION(nsurf):: c_ObsSMDepth   = (/(cc, cc=ccEndSn+ 5*nsurf+1,ccEndSn+ 5*nsurf+nsurf, 1)/)  ! Depth of SM obs
  INTEGER,DIMENSION(nsurf):: c_ObsSMMax     = (/(cc, cc=ccEndSn+ 6*nsurf+1,ccEndSn+ 6*nsurf+nsurf, 1)/)  ! Obs maximum SM [kg kg-1 OR m3 m-3]
  INTEGER,DIMENSION(nsurf):: c_ObsSNRFrac   = (/(cc, cc=ccEndSn+ 7*nsurf+1,ccEndSn+ 7*nsurf+nsurf, 1)/)  ! Obs fraction of soil without rocks

  ! Find current column number
  INTEGER,PARAMETER:: ccEndSo = (ccEndSn+ 7*nsurf+nsurf)

  ! Surface conductance
  INTEGER:: c_GsG1  = (ccEndSo+ 1)
  INTEGER:: c_GsG2  = (ccEndSo+ 2)
  INTEGER:: c_GsG3  = (ccEndSo+ 3)
  INTEGER:: c_GsG4  = (ccEndSo+ 4)
  INTEGER:: c_GsG5  = (ccEndSo+ 5)
  INTEGER:: c_GsG6  = (ccEndSo+ 6)
  INTEGER:: c_GsTH  = (ccEndSo+ 7)
  INTEGER:: c_GsTL  = (ccEndSo+ 8)
  INTEGER:: c_GsS1  = (ccEndSo+ 9)
  INTEGER:: c_GsS2  = (ccEndSo+10)
  INTEGER:: c_GsKmax  = (ccEndSo+11)
  INTEGER:: c_gsModel  = (ccEndSo+12)

  ! Find current column number
  INTEGER,PARAMETER:: ccEndGs = (ccEndSo+12)

  ! OHM codes
  INTEGER,DIMENSION(nsurfIncSnow):: c_OHMCode_SWet  =(/(cc, cc=ccEndGs+ 0*nsurfIncSnow+1,&
       ccEndGs+ 0*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM code (summer wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_OHMCode_SDry  =(/(cc, cc=ccEndGs+ 1*nsurfIncSnow+1,&
       ccEndGs+ 1*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM code (summer dry)
  INTEGER,DIMENSION(nsurfIncSnow):: c_OHMCode_WWet  =(/(cc, cc=ccEndGs+ 2*nsurfIncSnow+1,&
       ccEndGs+ 2*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM code (winter wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_OHMCode_WDry  =(/(cc, cc=ccEndGs+ 3*nsurfIncSnow+1,&
       ccEndGs+ 3*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM code (winter dry)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a1_SWet       =(/(cc, cc=ccEndGs+ 4*nsurfIncSnow+1,&
       ccEndGs+ 4*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a1 (summer wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a2_SWet       =(/(cc, cc=ccEndGs+ 5*nsurfIncSnow+1,&
       ccEndGs+ 5*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a2 (summer wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a3_SWet       =(/(cc, cc=ccEndGs+ 6*nsurfIncSnow+1,&
       ccEndGs+ 6*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a3 (summer wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a1_SDry       =(/(cc, cc=ccEndGs+ 7*nsurfIncSnow+1,&
       ccEndGs+ 7*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a1 (summer dry)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a2_SDry       =(/(cc, cc=ccEndGs+ 8*nsurfIncSnow+1,&
       ccEndGs+ 8*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a2 (summer dry)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a3_SDry       =(/(cc, cc=ccEndGs+ 9*nsurfIncSnow+1,&
       ccEndGs+ 9*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a3 (summer dry)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a1_WWet       =(/(cc, cc=ccEndGs+10*nsurfIncSnow+1,&
       ccEndGs+10*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a1 (winter wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a2_WWet       =(/(cc, cc=ccEndGs+11*nsurfIncSnow+1,&
       ccEndGs+11*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a2 (winter wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a3_WWet       =(/(cc, cc=ccEndGs+12*nsurfIncSnow+1,&
       ccEndGs+12*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a3 (winter wet)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a1_WDry       =(/(cc, cc=ccEndGs+13*nsurfIncSnow+1,&
       ccEndGs+13*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a1 (winter dry)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a2_WDry       =(/(cc, cc=ccEndGs+14*nsurfIncSnow+1,&
       ccEndGs+14*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a2 (winter dry)
  INTEGER,DIMENSION(nsurfIncSnow):: c_a3_WDry       =(/(cc, cc=ccEndGs+15*nsurfIncSnow+1,&
       ccEndGs+15*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM a3 (winter dry)

  INTEGER,DIMENSION(nsurfIncSnow):: c_OHMThresh_SW  =(/(cc, cc=ccEndGs+ 16*nsurfIncSnow+1,&
       ccEndGs+ 16*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM Threshold (summer/winter)
  INTEGER,DIMENSION(nsurfIncSnow):: c_OHMThresh_WD  =(/(cc, cc=ccEndGs+ 17*nsurfIncSnow+1,&
       ccEndGs+ 17*nsurfIncSnow+nsurfIncSnow, 1)/)  !OHM Threshold (wet/dry)

  ! ESTM code for each surface inclduing snow
  INTEGER,DIMENSION(nsurfIncSnow):: c_ESTMCode      = (/(cc, cc=ccEndGs+18*nsurfIncSnow+1,&
       ccEndGs+18*nsurfIncSnow+nsurfIncSnow, 1)/)  !ESTM code

  ! Find current column number
  INTEGER,PARAMETER:: ccEndO = (ccEndGs+18*nsurfIncSnow+nsurfIncSnow)

  ! Anthropogenic Emissions
  INTEGER :: c_BaseTHDD               = (ccEndO+ 1)
  INTEGER :: c_QF_A1                  = (ccEndO+ 2)
  INTEGER :: c_QF_B1                  = (ccEndO+ 3)
  INTEGER :: c_QF_C1                  = (ccEndO+ 4)
  INTEGER :: c_QF_A2                  = (ccEndO+ 5)
  INTEGER :: c_QF_B2                  = (ccEndO+ 6)
  INTEGER :: c_QF_C2                  = (ccEndO+ 7)
  INTEGER :: c_AHMin_WD               = (ccEndO+ 8)
  INTEGER :: c_AHMin_WE               = (ccEndO+ 9)
  INTEGER :: c_AHSlopeHeating_WD      = (ccEndO+10)
  INTEGER :: c_AHSlopeHeating_WE      = (ccEndO+11)
  INTEGER :: c_AHSlopeCooling_WD      = (ccEndO+12)
  INTEGER :: c_AHSlopeCooling_WE      = (ccEndO+13)
  INTEGER :: c_TCriticHeating_WE      = (ccEndO+14)
  INTEGER :: c_TCriticHeating_WD      = (ccEndO+15)
  INTEGER :: c_TCriticCooling_WE      = (ccEndO+16)
  INTEGER :: c_TCriticCooling_WD      = (ccEndO+17)
  INTEGER :: c_EnProfWD               = (ccEndO+18)
  INTEGER :: c_EnProfWE               = (ccEndO+19)
  INTEGER :: c_CO2mWD                 = (ccEndO+20)
  INTEGER :: c_CO2mWE                 = (ccEndO+21)
  INTEGER :: c_TraffProfWD            = (ccEndO+22)
  INTEGER :: c_TraffProfWE            = (ccEndO+23)
  INTEGER :: c_PopProfWD              = (ccEndO+24)
  INTEGER :: c_PopProfWE              = (ccEndO+25)
  INTEGER :: c_MinQFMetab             = (ccEndO+26)
  INTEGER :: c_MaxQFMetab             = (ccEndO+27)
  INTEGER :: c_FrFossilFuel_Heat      = (ccEndO+28)
  INTEGER :: c_FrFossilFuel_NonHeat   = (ccEndO+29)
  INTEGER :: c_EF_umolCO2perJ         = (ccEndO+30)
  INTEGER :: c_EnEF_v_Jkm             = (ccEndO+31)
  INTEGER :: c_FcEF_v_kgkm            = (ccEndO+32)
  INTEGER :: c_TrafficUnits           = (ccEndO+33)

  ! Find current column number
  INTEGER,PARAMETER:: ccEndA = (ccEndO+33)

  ! Irrigation
  INTEGER :: c_IeStart    = (ccEndA+ 1)
  INTEGER :: c_IeEnd    = (ccEndA+ 2)
  INTEGER :: c_IntWU    = (ccEndA+ 3)
  INTEGER :: c_Faut    = (ccEndA+ 4)
  INTEGER,DIMENSION(3):: c_Ie_a      = (/(cc, cc=ccEndA+4+ 0*3+1, ccEndA+4 + 0*3+3, 1)/)  ! Automatic irrigation coeffs
  INTEGER,DIMENSION(3):: c_Ie_m      = (/(cc, cc=ccEndA+4+ 1*3+1, ccEndA+4 + 1*3+3, 1)/)  ! Manual irrigation coeffs
  INTEGER,DIMENSION(7):: c_DayWat    = (/(cc, cc=ccEndA+10+ 0*7+1,ccEndA+10+ 0*7+7, 1)/)  ! Irrigation allowed on each day
  INTEGER,DIMENSION(7):: c_DayWatPer = (/(cc, cc=ccEndA+10+ 1*7+1,ccEndA+10+ 1*7+7, 1)/)  ! Fraction properties using irrigation allowed on each day

  ! Find current column number
  INTEGER,PARAMETER:: ccEndIr = (ccEndA+10+ 1*7+7)

  ! Hourly profiles
  INTEGER,DIMENSION(24):: c_HrProfEnUseWD  = (/(cc, cc=ccEndIr+ 0*24+1, ccEndIr+ 0*24+24, 1)/)  ! Energy use, weekdays
  INTEGER,DIMENSION(24):: c_HrProfEnUseWE  = (/(cc, cc=ccEndIr+ 1*24+1, ccEndIr+ 1*24+24, 1)/)  ! Energy use, weekends
  INTEGER,DIMENSION(24):: c_HrProfWUManuWD = (/(cc, cc=ccEndIr+ 2*24+1, ccEndIr+ 2*24+24, 1)/)  ! Water use, manual, weekdays
  INTEGER,DIMENSION(24):: c_HrProfWUManuWE = (/(cc, cc=ccEndIr+ 3*24+1, ccEndIr+ 3*24+24, 1)/)  ! Water use, manual, weekends
  INTEGER,DIMENSION(24):: c_HrProfWUAutoWD = (/(cc, cc=ccEndIr+ 4*24+1, ccEndIr+ 4*24+24, 1)/)  ! Water use, automatic, weekdays
  INTEGER,DIMENSION(24):: c_HrProfWUAutoWE = (/(cc, cc=ccEndIr+ 5*24+1, ccEndIr+ 5*24+24, 1)/)  ! Water use, automatic, weekends
  INTEGER,DIMENSION(24):: c_HrProfSnowCWD  = (/(cc, cc=ccEndIr+ 6*24+1, ccEndIr+ 6*24+24, 1)/)  ! Snow clearing, weekdays
  INTEGER,DIMENSION(24):: c_HrProfSnowCWE  = (/(cc, cc=ccEndIr+ 7*24+1, ccEndIr+ 7*24+24, 1)/)  ! Snow clearing, weekends
  INTEGER,DIMENSION(24):: c_HrProfHumActivityWD = (/(cc, cc=ccEndIr+ 8*24+1, ccEndIr+ 8*24+24, 1)/)  ! Human activity, weekdays
  INTEGER,DIMENSION(24):: c_HrProfHumActivityWE = (/(cc, cc=ccEndIr+ 9*24+1, ccEndIr+ 9*24+24, 1)/)  ! Human activity, weekends
  INTEGER,DIMENSION(24):: c_HrProfTraffWD  = (/(cc, cc=ccEndIr+ 10*24+1, ccEndIr+ 10*24+24, 1)/) ! Traffic, weekdays
  INTEGER,DIMENSION(24):: c_HrProfTraffWE  = (/(cc, cc=ccEndIr+ 11*24+1, ccEndIr+ 11*24+24, 1)/) ! Traffic, weekends
  INTEGER,DIMENSION(24):: c_HrProfPopWD    = (/(cc, cc=ccEndIr+ 12*24+1, ccEndIr+ 12*24+24, 1)/) ! Population, weekdays
  INTEGER,DIMENSION(24):: c_HrProfPopWE    = (/(cc, cc=ccEndIr+ 13*24+1, ccEndIr+ 13*24+24, 1)/) ! Population, weekends


  ! Find current column number
  INTEGER,PARAMETER:: ccEndPr = (ccEndIr+ 13*24+24)

  ! Within-grid water distribution (for each surface)
  INTEGER,DIMENSION(nsurf):: c_WGToPaved = (/(cc, cc=ccEndPr+ 0*nsurf+1,ccEndPr+ 0*nsurf+nsurf, 1)/) !Water dist to Paved
  INTEGER,DIMENSION(nsurf):: c_WGToBldgs = (/(cc, cc=ccEndPr+ 1*nsurf+1,ccEndPr+ 1*nsurf+nsurf, 1)/) !Water dist to Bldgs
  INTEGER,DIMENSION(nsurf):: c_WGToEveTr = (/(cc, cc=ccEndPr+ 2*nsurf+1,ccEndPr+ 2*nsurf+nsurf, 1)/) !Water dist to EveTr
  INTEGER,DIMENSION(nsurf):: c_WGToDecTr = (/(cc, cc=ccEndPr+ 3*nsurf+1,ccEndPr+ 3*nsurf+nsurf, 1)/) !Water dist to DecTr
  INTEGER,DIMENSION(nsurf):: c_WGToGrass = (/(cc, cc=ccEndPr+ 4*nsurf+1,ccEndPr+ 4*nsurf+nsurf, 1)/) !Water dist to Grass
  INTEGER,DIMENSION(nsurf):: c_WGToBSoil = (/(cc, cc=ccEndPr+ 5*nsurf+1,ccEndPr+ 5*nsurf+nsurf, 1)/) !Water dist to BSoil
  INTEGER,DIMENSION(nsurf):: c_WGToWater = (/(cc, cc=ccEndPr+ 6*nsurf+1,ccEndPr+ 6*nsurf+nsurf, 1)/) !Water dist to Water
  INTEGER,DIMENSION(nsurf):: c_WGToRunoff    = (/(cc, cc=ccEndPr+ 7*nsurf+1,ccEndPr+ 7*nsurf+nsurf, 1)/) !Water dist to runoff
  INTEGER,DIMENSION(nsurf):: c_WGToSoilStore = (/(cc, cc=ccEndPr+ 8*nsurf+1,ccEndPr+ 8*nsurf+nsurf, 1)/) !Water dist to sub-surface soil

  ! Find current column number
  INTEGER,PARAMETER:: cBEndWG = (ccEndPr+ 8*nsurf+nsurf)

  ! Biogenic CO2
  INTEGER,DIMENSION(nvegsurf):: c_alpha_bioCO2     = (/(cc, cc=cBEndWG+ 0*nvegsurf+1,cBEndWG+ 0*nvegsurf+nvegsurf, 1)/)
  INTEGER,DIMENSION(nvegsurf):: c_beta_bioCO2      = (/(cc, cc=cBEndWG+ 1*nvegsurf+1,cBEndWG+ 1*nvegsurf+nvegsurf, 1)/)
  INTEGER,DIMENSION(nvegsurf):: c_theta_bioCO2     = (/(cc, cc=cBEndWG+ 2*nvegsurf+1,cBEndWG+ 2*nvegsurf+nvegsurf, 1)/)
  INTEGER,DIMENSION(nvegsurf):: c_alpha_enh_bioCO2 = (/(cc, cc=cBEndWG+ 3*nvegsurf+1,cBEndWG+ 3*nvegsurf+nvegsurf, 1)/)
  INTEGER,DIMENSION(nvegsurf):: c_beta_enh_bioCO2  = (/(cc, cc=cBEndWG+ 4*nvegsurf+1,cBEndWG+ 4*nvegsurf+nvegsurf, 1)/)
  INTEGER,DIMENSION(nvegsurf):: c_resp_a           = (/(cc, cc=cBEndWG+ 5*nvegsurf+1,cBEndWG+ 5*nvegsurf+nvegsurf, 1)/)
  INTEGER,DIMENSION(nvegsurf):: c_resp_b           = (/(cc, cc=cBEndWG+ 6*nvegsurf+1,cBEndWG+ 6*nvegsurf+nvegsurf, 1)/)
  INTEGER,DIMENSION(nvegsurf):: c_min_res_bioCO2   = (/(cc, cc=cBEndWG+ 7*nvegsurf+1,cBEndWG+ 7*nvegsurf+nvegsurf, 1)/)

  ! Find current column number
  INTEGER,PARAMETER:: ccEndB = (cBEndWG+7*nvegsurf+nvegsurf)

  !ESTM
  ! Roof/surface characteristics for all surfaces including snow
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_thick1  = (/(cc, cc=ccEndB+ 0*nsurfIncSnow+1,ccEndB+ 0*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_k1      = (/(cc, cc=ccEndB+ 1*nsurfIncSnow+1,ccEndB+ 1*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_rhoCp1  = (/(cc, cc=ccEndB+ 2*nsurfIncSnow+1,ccEndB+ 2*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_thick2  = (/(cc, cc=ccEndB+ 3*nsurfIncSnow+1,ccEndB+ 3*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_k2      = (/(cc, cc=ccEndB+ 4*nsurfIncSnow+1,ccEndB+ 4*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_rhoCp2  = (/(cc, cc=ccEndB+ 5*nsurfIncSnow+1,ccEndB+ 5*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_thick3  = (/(cc, cc=ccEndB+ 6*nsurfIncSnow+1,ccEndB+ 6*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_k3      = (/(cc, cc=ccEndB+ 7*nsurfIncSnow+1,ccEndB+ 7*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_rhoCp3  = (/(cc, cc=ccEndB+ 8*nsurfIncSnow+1,ccEndB+ 8*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_thick4  = (/(cc, cc=ccEndB+ 9*nsurfIncSnow+1,ccEndB+ 9*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_k4      = (/(cc, cc=ccEndB+10*nsurfIncSnow+1,ccEndB+10*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_rhoCp4  = (/(cc, cc=ccEndB+11*nsurfIncSnow+1,ccEndB+11*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_thick5  = (/(cc, cc=ccEndB+12*nsurfIncSnow+1,ccEndB+12*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_k5      = (/(cc, cc=ccEndB+13*nsurfIncSnow+1,ccEndB+13*nsurfIncSnow+nsurfIncSnow, 1)/)
  INTEGER,DIMENSION(nsurfIncSnow):: c_Surf_rhoCp5  = (/(cc, cc=ccEndB+14*nsurfIncSnow+1,ccEndB+14*nsurfIncSnow+nsurfIncSnow, 1)/)
  ! Find current column number
  INTEGER,PARAMETER:: ccEndESTMB = (ccEndB+14*nsurfIncSnow+nsurfIncSnow)
  ! Other ESTM characteristics are for built surfaces only
  INTEGER:: c_Wall_thick1  = (ccEndESTMB+ 1)
  INTEGER:: c_Wall_k1      = (ccEndESTMB+ 2)
  INTEGER:: c_Wall_rhoCp1  = (ccEndESTMB+ 3)
  INTEGER:: c_Wall_thick2  = (ccEndESTMB+ 4)
  INTEGER:: c_Wall_k2      = (ccEndESTMB+ 5)
  INTEGER:: c_Wall_rhoCp2  = (ccEndESTMB+ 6)
  INTEGER:: c_Wall_thick3  = (ccEndESTMB+ 7)
  INTEGER:: c_Wall_k3      = (ccEndESTMB+ 8)
  INTEGER:: c_Wall_rhoCp3  = (ccEndESTMB+ 9)
  INTEGER:: c_Wall_thick4  = (ccEndESTMB+10)
  INTEGER:: c_Wall_k4      = (ccEndESTMB+11)
  INTEGER:: c_Wall_rhoCp4  = (ccEndESTMB+12)
  INTEGER:: c_Wall_thick5  = (ccEndESTMB+13)
  INTEGER:: c_Wall_k5      = (ccEndESTMB+14)
  INTEGER:: c_Wall_rhoCp5  = (ccEndESTMB+15)
  INTEGER:: c_Internal_thick1  = (ccEndESTMB+16)
  INTEGER:: c_Internal_k1      = (ccEndESTMB+17)
  INTEGER:: c_Internal_rhoCp1  = (ccEndESTMB+18)
  INTEGER:: c_Internal_thick2  = (ccEndESTMB+19)
  INTEGER:: c_Internal_k2      = (ccEndESTMB+20)
  INTEGER:: c_Internal_rhoCp2  = (ccEndESTMB+21)
  INTEGER:: c_Internal_thick3  = (ccEndESTMB+22)
  INTEGER:: c_Internal_k3      = (ccEndESTMB+23)
  INTEGER:: c_Internal_rhoCp3  = (ccEndESTMB+24)
  INTEGER:: c_Internal_thick4  = (ccEndESTMB+25)
  INTEGER:: c_Internal_k4      = (ccEndESTMB+26)
  INTEGER:: c_Internal_rhoCp4  = (ccEndESTMB+27)
  INTEGER:: c_Internal_thick5  = (ccEndESTMB+28)
  INTEGER:: c_Internal_k5      = (ccEndESTMB+29)
  INTEGER:: c_Internal_rhoCp5  = (ccEndESTMB+30)
  INTEGER:: c_nroom      =  (ccEndESTMB+31)
  INTEGER:: c_alb_ibld   =  (ccEndESTMB+32)
  INTEGER:: c_em_ibld    =  (ccEndESTMB+33)
  INTEGER:: c_CH_iwall   =  (ccEndESTMB+34)
  INTEGER:: c_CH_iroof   =  (ccEndESTMB+35)
  INTEGER:: c_CH_ibld    =  (ccEndESTMB+36)
  ! Find current column number
  INTEGER,PARAMETER:: ccEndESTMM = (ccEndESTMB+36)
  ! For Paved surfaces, there are 3 possible ESTM classes (with _Surf characteristics only)
  INTEGER,DIMENSION(3):: c_Surf_thick1_Paved  = (/(cc, cc=ccEndESTMM+ 0*3+1,ccEndESTMM+ 0*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_k1_Paved      = (/(cc, cc=ccEndESTMM+ 1*3+1,ccEndESTMM+ 1*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_rhoCp1_Paved  = (/(cc, cc=ccEndESTMM+ 2*3+1,ccEndESTMM+ 2*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_thick2_Paved  = (/(cc, cc=ccEndESTMM+ 3*3+1,ccEndESTMM+ 3*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_k2_Paved      = (/(cc, cc=ccEndESTMM+ 4*3+1,ccEndESTMM+ 4*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_rhoCp2_Paved  = (/(cc, cc=ccEndESTMM+ 5*3+1,ccEndESTMM+ 5*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_thick3_Paved  = (/(cc, cc=ccEndESTMM+ 6*3+1,ccEndESTMM+ 6*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_k3_Paved      = (/(cc, cc=ccEndESTMM+ 7*3+1,ccEndESTMM+ 7*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_rhoCp3_Paved  = (/(cc, cc=ccEndESTMM+ 8*3+1,ccEndESTMM+ 8*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_thick4_Paved  = (/(cc, cc=ccEndESTMM+ 9*3+1,ccEndESTMM+ 9*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_k4_Paved      = (/(cc, cc=ccEndESTMM+10*3+1,ccEndESTMM+10*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_rhoCp4_Paved  = (/(cc, cc=ccEndESTMM+11*3+1,ccEndESTMM+11*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_thick5_Paved  = (/(cc, cc=ccEndESTMM+12*3+1,ccEndESTMM+12*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_k5_Paved      = (/(cc, cc=ccEndESTMM+13*3+1,ccEndESTMM+13*3+3, 1)/)
  INTEGER,DIMENSION(3):: c_Surf_rhoCp5_Paved  = (/(cc, cc=ccEndESTMM+14*3+1,ccEndESTMM+14*3+3, 1)/)
  ! Find current column number
  INTEGER,PARAMETER:: ccEndESTMMP = (ccEndESTMM+14*3+3)
  ! For Bldgs surfaces, there are 5 possible ESTM classes (all characteristics)
  INTEGER,DIMENSION(5):: c_Surf_thick1_Bldgs  = (/(cc, cc=ccEndESTMMP+ 0*5+1,ccEndESTMMP+ 0*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_k1_Bldgs      = (/(cc, cc=ccEndESTMMP+ 1*5+1,ccEndESTMMP+ 1*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_rhoCp1_Bldgs  = (/(cc, cc=ccEndESTMMP+ 2*5+1,ccEndESTMMP+ 2*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_thick2_Bldgs  = (/(cc, cc=ccEndESTMMP+ 3*5+1,ccEndESTMMP+ 3*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_k2_Bldgs      = (/(cc, cc=ccEndESTMMP+ 4*5+1,ccEndESTMMP+ 4*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_rhoCp2_Bldgs  = (/(cc, cc=ccEndESTMMP+ 5*5+1,ccEndESTMMP+ 5*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_thick3_Bldgs  = (/(cc, cc=ccEndESTMMP+ 6*5+1,ccEndESTMMP+ 6*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_k3_Bldgs      = (/(cc, cc=ccEndESTMMP+ 7*5+1,ccEndESTMMP+ 7*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_rhoCp3_Bldgs  = (/(cc, cc=ccEndESTMMP+ 8*5+1,ccEndESTMMP+ 8*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_thick4_Bldgs  = (/(cc, cc=ccEndESTMMP+ 9*5+1,ccEndESTMMP+ 9*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_k4_Bldgs      = (/(cc, cc=ccEndESTMMP+10*5+1,ccEndESTMMP+10*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_rhoCp4_Bldgs  = (/(cc, cc=ccEndESTMMP+11*5+1,ccEndESTMMP+11*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_thick5_Bldgs  = (/(cc, cc=ccEndESTMMP+12*5+1,ccEndESTMMP+12*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_k5_Bldgs      = (/(cc, cc=ccEndESTMMP+13*5+1,ccEndESTMMP+13*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Surf_rhoCp5_Bldgs  = (/(cc, cc=ccEndESTMMP+14*5+1,ccEndESTMMP+14*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_thick1_Bldgs  = (/(cc, cc=ccEndESTMMP+15*5+1,ccEndESTMMP+15*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_k1_Bldgs      = (/(cc, cc=ccEndESTMMP+16*5+1,ccEndESTMMP+16*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_rhoCp1_Bldgs  = (/(cc, cc=ccEndESTMMP+17*5+1,ccEndESTMMP+17*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_thick2_Bldgs  = (/(cc, cc=ccEndESTMMP+18*5+1,ccEndESTMMP+18*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_k2_Bldgs      = (/(cc, cc=ccEndESTMMP+19*5+1,ccEndESTMMP+19*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_rhoCp2_Bldgs  = (/(cc, cc=ccEndESTMMP+20*5+1,ccEndESTMMP+20*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_thick3_Bldgs  = (/(cc, cc=ccEndESTMMP+21*5+1,ccEndESTMMP+21*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_k3_Bldgs      = (/(cc, cc=ccEndESTMMP+22*5+1,ccEndESTMMP+22*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_rhoCp3_Bldgs  = (/(cc, cc=ccEndESTMMP+23*5+1,ccEndESTMMP+23*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_thick4_Bldgs  = (/(cc, cc=ccEndESTMMP+24*5+1,ccEndESTMMP+24*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_k4_Bldgs      = (/(cc, cc=ccEndESTMMP+25*5+1,ccEndESTMMP+25*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_rhoCp4_Bldgs  = (/(cc, cc=ccEndESTMMP+26*5+1,ccEndESTMMP+26*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_thick5_Bldgs  = (/(cc, cc=ccEndESTMMP+27*5+1,ccEndESTMMP+27*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_k5_Bldgs      = (/(cc, cc=ccEndESTMMP+28*5+1,ccEndESTMMP+28*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Wall_rhoCp5_Bldgs  = (/(cc, cc=ccEndESTMMP+29*5+1,ccEndESTMMP+29*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_thick1_Bldgs  = (/(cc, cc=ccEndESTMMP+30*5+1,ccEndESTMMP+30*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_k1_Bldgs      = (/(cc, cc=ccEndESTMMP+31*5+1,ccEndESTMMP+31*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_rhoCp1_Bldgs  = (/(cc, cc=ccEndESTMMP+32*5+1,ccEndESTMMP+32*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_thick2_Bldgs  = (/(cc, cc=ccEndESTMMP+33*5+1,ccEndESTMMP+33*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_k2_Bldgs      = (/(cc, cc=ccEndESTMMP+34*5+1,ccEndESTMMP+34*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_rhoCp2_Bldgs  = (/(cc, cc=ccEndESTMMP+35*5+1,ccEndESTMMP+35*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_thick3_Bldgs  = (/(cc, cc=ccEndESTMMP+36*5+1,ccEndESTMMP+36*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_k3_Bldgs      = (/(cc, cc=ccEndESTMMP+37*5+1,ccEndESTMMP+37*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_rhoCp3_Bldgs  = (/(cc, cc=ccEndESTMMP+38*5+1,ccEndESTMMP+38*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_thick4_Bldgs  = (/(cc, cc=ccEndESTMMP+39*5+1,ccEndESTMMP+39*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_k4_Bldgs      = (/(cc, cc=ccEndESTMMP+40*5+1,ccEndESTMMP+40*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_rhoCp4_Bldgs  = (/(cc, cc=ccEndESTMMP+41*5+1,ccEndESTMMP+41*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_thick5_Bldgs  = (/(cc, cc=ccEndESTMMP+42*5+1,ccEndESTMMP+42*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_k5_Bldgs      = (/(cc, cc=ccEndESTMMP+43*5+1,ccEndESTMMP+43*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_Internal_rhoCp5_Bldgs  = (/(cc, cc=ccEndESTMMP+44*5+1,ccEndESTMMP+44*5+5, 1)/)
  INTEGER,DIMENSION(5):: c_nroom_Bldgs      =  (ccEndESTMMP+44*5+5+ 1)
  INTEGER,DIMENSION(5):: c_alb_ibld_Bldgs   =  (ccEndESTMMP+44*5+5+ 2)
  INTEGER,DIMENSION(5):: c_em_ibld_Bldgs    =  (ccEndESTMMP+44*5+5+ 3)
  INTEGER,DIMENSION(5):: c_CH_iwall_Bldgs   =  (ccEndESTMMP+44*5+5+ 4)
  INTEGER,DIMENSION(5):: c_CH_iroof_Bldgs   =  (ccEndESTMMP+44*5+5+ 5)
  INTEGER,DIMENSION(5):: c_CH_ibld_Bldgs    =  (ccEndESTMMP+44*5+5+ 6)

  !Last column number for SurfaceChar array
  INTEGER,PARAMETER:: MaxNCols_c = (ccEndESTMMP+44*5+5+ 6)
  !-----------------------------------------------------------------------------------------------

  ! ---- Set column numbering for ModelOutputData ------------------------------------------------
  ! Applicable to each surface
  INTEGER,PARAMETER:: ccMOD = 32
  INTEGER,DIMENSION(nsurf):: cMOD_State          =(/(cc, cc=ccMOD+ 0*nsurf+1,ccMOD+ 0*nsurf+nsurf, 1)/)  !Above ground state
  INTEGER,DIMENSION(nsurf):: cMOD_SoilState      =(/(cc, cc=ccMOD+ 1*nsurf+1,ccMOD+ 1*nsurf+nsurf, 1)/)  !Below ground state (soil store)
  INTEGER,DIMENSION(nsurf):: cMOD_SnowWaterState =(/(cc, cc=ccMOD+ 2*nsurf+1,ccMOD+ 2*nsurf+nsurf, 1)/)  !Liquid (melted) water
  INTEGER,DIMENSION(nsurf):: cMOD_SnowPack       =(/(cc, cc=ccMOD+ 3*nsurf+1,ccMOD+ 3*nsurf+nsurf, 1)/)  !SWE
  INTEGER,DIMENSION(nsurf):: cMOD_SnowFrac       =(/(cc, cc=ccMOD+ 4*nsurf+1,ccMOD+ 4*nsurf+nsurf, 1)/)  !Snow fraction
  INTEGER,DIMENSION(nsurf):: cMOD_SnowDens       =(/(cc, cc=ccMOD+ 5*nsurf+1,ccMOD+ 5*nsurf+nsurf, 1)/)  !Snow density

  !Last column number for ModelOutputData array
  INTEGER,PARAMETER:: MaxNCols_cMOD = ccMOD+ 5*nsurf+nsurf
  !-----------------------------------------------------------------------------------------------

  ! ---- Set column numbering for ModelDailyState ------------------------------------------------
  ! Applicable to each surface
  INTEGER,PARAMETER:: ccMDS = 30
  INTEGER,DIMENSION(nsurf):: cMDS_SnowDens       =(/(cc, cc=ccMDS+ 0*nsurf+1,ccMDS+ 0*nsurf+nsurf, 1)/)  !Snow density

  !Last column number for ModelDailyState array
  INTEGER,PARAMETER:: MaxNCols_cMDS = ccMDS+ 0*nsurf+nsurf
  !-----------------------------------------------------------------------------------------------

  ! ---- Set column numbering for ESTM_Ts_data input file ===-------------------------------------
  ! HCW 15 June 2016
  INTEGER, PARAMETER:: cTs_iy = 1
  INTEGER, PARAMETER:: cTs_id = 2
  INTEGER, PARAMETER:: cTs_it = 3
  INTEGER, PARAMETER:: cTs_imin = 4
  INTEGER, PARAMETER:: cTs_Tiair = 5
  INTEGER, PARAMETER:: cTs_Tsurf = 6
  INTEGER, PARAMETER:: cTs_Troof = 7
  INTEGER, PARAMETER:: cTs_Troad = 8
  INTEGER, PARAMETER:: cTs_Twall = 9
  INTEGER, PARAMETER:: cTs_Twall_n = 10
  INTEGER, PARAMETER:: cTs_Twall_e = 11
  INTEGER, PARAMETER:: cTs_Twall_s = 12
  INTEGER, PARAMETER:: cTs_Twall_w = 13


END MODULE allocateArray
!==================================================================================================

!==================================================================================================
MODULE Initial

  IMPLICIT NONE

  INTEGER::FirstYear,&          !First year to run (specified in SiteSelect.txt)
       LastYear,&           !Last year to run  (specified in SiteSelect.txt)
       FirstGrid,&    !First grid to run (as in SiteSelect)
       LastGrid,&            !Last grid to run  (as in SiteSelect)
       NumberOfGrids,&      !Number of grids
       GridCounter,&        !Counter for grids (i.e. from 1 to NumberOfGrids)

       ReadBlocksMetData,&  !Number of blocks of met data to read (for each grid, for each year)
       ReadBlocksOrigMetData,&  !Number of blocks of original met data to read (for each grid, for each year)
       ReadLinesMetData,&   !Number of lines of met data in each block (for each grid)
       ReadLinesOrigMetData,&   !Number of lines of original met data in each block (before downscaling)
       ReadLinesOrigESTMData,&   !Number of lines of original ESTM data in each block (before downscaling)
       ReadLinesOrigMetDataMax,&   !No. lines of original met data in each block (adjusts for last block (equivalent of irMax))
       ReadLinesOrigESTMDataMax,&   !No. lines of original ESTM data in each block
       nlinesOrigMetData,&        !Number of lines in original met data file
       nlinesOrigESTMData,&        !Number of lines in original ESTM data file
       nlinesMetData,&            !Number of lines in Met Forcing file
       nlinesESTMdata,&           !Number of lines in ESTM Forcing file
       nlinesSiteSelect,&         !Number of lines in SUEWS_SiteSelect.txt
       nlinesNonVeg,&             !Number of lines in SUEWS_NonVeg.txt
       nlinesVeg,&                !Number of lines in SUEWS_Veg.txt
       nlinesWater,&             !Number of lines in SUEWS_Water.txt
       nlinesSnow,&               !Number of lines in SUEWS_Snow.txt
       nlinesSoil,&               !Number of lines in SUEWS_Soil.txt
       nlinesConductance,&        !Number of lines in SUEWS_Conductance.txt
       nlinesOHMCoefficients,&    !Number of lines in SUEWS_OHMCoefficients.txt
       nlinesESTMCoefficients,&   !Number of lines in SUEWS_ESTMCoefficients.txt
       nlinesAnthropogenic,&      !Number of lines in SUEWS_AnthropogenicHeat.txt
       nlinesIrrigation,&         !Number of lines in SUEWS_Irrigation.txt
       nlinesProfiles,&           !Number of lines in SUEWS_Profiles.txt
       nlinesWGWaterDist,&        !Number of lines in SUEWS_WGWaterDist.txt
       nlinesBiogen,&             !Number of lines in SUEWS_BiogenCO2.txt
       nlines,&                   !Number of lines in different files
       SkippedLines,&             !Number of lines to skip over before reading each block of met data
       SkippedLinesOrig,&         !Number of lines to skip over before reading each block of data from original met file
       SkippedLinesOrigESTM,&         !Number of lines to skip over before reading each block of data from original ESTM file
       iv5            !Counter for code matching.

END MODULE Initial
!==================================================================================================

!==================================================================================================
MODULE data_in

  IMPLICIT NONE

  CHARACTER (len=90)::progname='SUEWS_V2018b'

  ! ---- Run information ------------------------------------------------------------------------
  CHARACTER (len=20)::  FileCode   !Set in RunControl
  CHARACTER (len=150):: FileInputPath,&   !Filepath for input files (set in RunControl)
       FileOutputPath    !Filepath for output files (set in RunControl)
  ! ---- File names -----------------------------------------------------------------------------
  CHARACTER (len=150):: FileOut,&         !Output file name
       FileChoices,&     !Run characteristics file name
       FileMet,&         !Meteorological forcing file name
       FileOrigMet,&     !Original meteorological forcing file name (i.e. before downscaling)
       FileOrigESTM,&    !Original ESTM forcing file name (i.e. before downscaling)
       FileDscdMet,&     !Downscaled meteorological forcing file name
       FileDscdESTM,&    !Downscaled ESTM forcing file name
       FileDaily,&       !Daily State output file name
       FileESTMTs,&      !ESTM input file name
       SOLWEIGpoiOut,&   !SOLWEIG poi file name
       BLout,&             !CLB output file name
       FileOut_tt,&        !Output file name (for resolution at model time-step)
       ESTMOut_tt

  INTEGER:: SkipHeaderSiteInfo = 2   !Number of header lines to skip in SiteInfo files
  INTEGER:: SkipHeaderMet = 1        !Number of header lines to skip in met forcing file

  ! ---- Model options set in RunControl --------------------------------------------------------
  INTEGER:: EmissionsMethod,& !
       CBLuse,&               !CBL slab model used (1) or not used (0)
       MultipleMetFiles,&     !Indicates whether a single met file is used for all grids (0) or one for each grid (1)
       MultipleInitFiles,&      !Indicates whether a single initial conditions file is used for all grids (0) or one for each grid (1)
       MultipleESTMFiles,&    !Indicates whether a single ESTM input data file is used for all grids (0) or one for each grid (1)
       KeepTstepFilesIn,&     !Delete (0) or keep (1) input met files at resolution of tstep (used by python, not fortran)
       KeepTstepFilesOut,&    !Delete (0) or keep (1) output files at resolution of tstep (used by python, not fortran)
       ResolutionFilesIn,&    !Specify resolution of input file  [s]
       ResolutionFilesOut,&   !Specify resolution of output file [s]
       ResolutionFilesInESTM,&!Specify resolution of ESTM input file  [s]
       WriteOutOption,&         !Choose variables to include in main output file
       NetRadiationMethod,&   !Options for net all-wave radiation calculation
       OHMIncQF,&             !OHM calculation uses Q* only (0) or Q*+QF (1)
       StorageHeatMethod,&             !OHM (1); QS in met file (2); AnOHM(3); ESTM(4)
       SNOWuse,&              !Snow part used (1) or not used (0)
       SOLWEIGuse,&           !SOLWEIG part used (calculates Tmrt and other fluxes on a grid, FL)
       SMDMethod,&           !Use modelled (0) or observed(1,2) soil moisture
       WaterUseMethod,&            !Use modelled (0) or observed (1) water use
       RoughLenMomMethod,&              !Defines method for calculating z0 & zd
       DisaggMethod,&         ! Sets disaggregation method for original met forcing data
       DisaggMethodESTM,&         ! Sets disaggregation method for original met forcing data
       RainDisaggMethod,&     ! Sets disaggregation method for original met forcing data for rainfall
       RainAmongN,&           ! Number of subintervals over which to disaggregate rainfall
       KdownZen,&             ! Controls whether Kdown disaggregation uses zenith angle (1) or not (0)
       SuppressWarnings,&     ! Set to 1 to prevent warnings.txt file from being written
       Diagnose,&             !Set to 1 to get print-out of model progress
       DiagnoseDisagg,&       !Set to 1 to get print-out of met forcing disaggregation progress
       ncMode,&               !Write output file in netCDF (1) or not (0) , TS, 09 Dec 2016
       nRow,&                 !number of rows of checker board layout in the netCDF output, TS, 09 Dec 2016
       nCol,&                 !number of columns of checker board layout in the netCDF output, TS, 09 Dec 2016
       DiagnoseDisaggESTM,&   !Set to 1 to get print-out of ESTM forcing disaggregation progress
       DiagQN, DiagQS         !Set to 1 to print values/components

  ! For more complex downscaling allow different RainAmongN for different intensities
  INTEGER, DIMENSION(5):: MultRainAmongN           ! RainAmongN for each intensity bin
  REAL(KIND(1d0)),DIMENSION(5):: MultRainAmongNUpperI   ! Upper bound of intensity bin for which to apply MultRainAmongN

  ! ---- Model options currently set in model, but may be moved to RunControl at a later date
  INTEGER:: AlbedoChoice,&         !No additional albedo varaition (0); zenith angle calculation (1)
                                !Currently set to 0 in SUEWS_Initial
       InputMetFormat,&       !Defines format for met input data: LUMPS format(1) or SUEWS format(10)
                                !Currently set to 10 in SUEWS_Initial
       EvapMethod,&                  !Evaporation calculated according to Rutter (1) or Shuttleworth (2)
                                !Currently set to 2 in OverallRunControl
       LAIcalcYes,&           !Use observed (0) or modelled (1) LAI
                                !Currently set to 1 in OverallRunControl
       WriteDailyState        !Daily state file written (1)
  !Currently set to 1 in SUEWS_Initial

  ! ---- Other options used within model --------------------------------------------------------
  INTEGER:: ldown_option           !Parameterisation used for downward longwave radiation (1/2/3)

  ! ---- Output file numbers --------------------------------------------------------------------
  INTEGER:: lfnout,&               !Error Output write units
       lfnoutC,&              !Clean output write units
       lfnOld                 !!Was used for GridConnections

  INTEGER:: OutputFormats   !Used to control writing out of output file format


  ! ---- Other options set in RunControl --------------------------------------------------------
  REAL (KIND(1d0)):: timezone      !Timezone (GMT=0)

  ! ---- Variables in alphabetical order --------------------------------------------------------
  !! Add units
  REAL (KIND(1d0))::  alpha_qhqe,& !Alpha parameter used in LUMPS QH and QE calculations [-]
       alt,&                        !Altitude in m
       avdens,&    !Average air density
       avkdn,&     !Average downwelling shortwave radiation
       avrh,&      !Average relative humidity
       avts,&      !Average surface temperature
       avu1,&      !Average wind speed
       avU10_ms,&   !Average wind speed at 10 m
       azimuth,&   !Sun azimuth in degrees
       BaseTHDD,&  !Base temperature for QF
       BuildEnergyUse,&  ! Building energy use
       E_mod,&     !Modelled latent heat flux with LUMPS  [W m-2]
       emis_snow,& !Emissivity of snow
       Fc,&        !CO2 flux [umol m-2 s-1]
       Fc_anthro,& !CO2 flux (anthropogenic part) [umol m-2 s-1]
       Fc_biogen,& !CO2 flux (biogenic part) [umol m-2 s-1]
       Fc_photo,&  !CO2 flux (photosynthesis component) [umol m-2 s-1]
       Fc_respi,&  !CO2 flux (non-human respiration component) [umol m-2 s-1]
       Fc_metab,&  !CO2 flux (human metabolism component) [umol m-2 s-1]
       Fc_traff,&  !CO2 flux (traffic component) [umol m-2 s-1]
       Fc_build,&  !CO2 flux (building energy use component) [umol m-2 s-1]
       fcld,&      !Cloud fraction modelled
       fcld_obs,&  !Cloud fraction observed
       h_mod,&     !Modelled sensible heat flux with LUMPS [W m-2]
       kclear,&    !Theoretical downward shortwave radiation
       kdiff,&     !Diffuse shortwave radiation
       kdir,&      !Direct shortwave radiation
       kup,&       !Upward shortwave radiation
       LAI_obs,&   !LAI for study area provided in met forcing file
       lat,&       !Latitude
       ldown, &    !Downward longwave radiation
       ldown_obs,& !Downwelling longwave radiation
       lng,&       !Longitude
       lup,&       !Upward longwave radiation
       NumCapita,& !Number of people in the study area per hectare [ha-1]
       PopDensDaytime,&   ! Daytime population density [ha-1] (i.e. workers)
       PopDensNighttime,& ! Nighttime population density [ha-1] (i.e. residents)
       Precip,&    !Precipitation per timestep [mm]
       Precip_hr,&    !Precipitation [mm hr-1]
       Press_hPa,&  !Station air pressure in hPa
       Pres_kPa,&   !Station air pressure in kPa
       q2_gkg,&    ! Specific humidity at 2 m
       qe,&        !Observed latent heat flux
       qe_obs,&
       qf_obs,&        !Observed anthropogenic heat flux
       QF_SAHP,&    !Anthropogenic heat flux calculated by SAHP
       QF_SAHP_base,&    !Anthropogenic heat flux calculated by SAHP (temp independent part)
       QF_SAHP_heat,&    !Anthropogenic heat flux calculated by SAHP (heating part only)
       QF_SAHP_ac,& !AC contribution
       qh,&        !Observed sensible heat flux
       qh_obs,&
       QH_r,&      !Sensible heat flux calculated using resistance method
       qn1,&       !Net all-wave radiation for the study area
       qn1_bup,&
       qn1_obs,&   !Observed new all-wave radiation
       qn1_S,&     !Total net all-wave radiation for the SnowPack
       qn1_snowfree,&    !Total net all-wave radiation for the snowfree surface
       qs_obs,&        !Observed storage heat flux
       QSanOHM,&   !Simulated storage heat flux by AnOHM, TS 30 May 2016
       QSestm,&    !Simulated storage heat flux by ESTM, TS 30 May 2016
       snow,&      !snow cover
       snow_obs,&  !Observed snow cover
       CO2mWD,&
       CO2mWE,&
       EF_umolCO2perJ,&
       EnEF_v_Jkm,&
       EnProfWD, &
       EnProfWE,&
       TrafficUnits,&
       TraffProfWD,&
       TraffProfWE,&
       PopProfWD,&
       PopProfWE,&
       FcEF_v_kgkm,&
       FrFossilFuel_Heat,&
       FrFossilFuel_NonHeat,&
       MinQFMetab,&
       MaxQFMetab,&
       QF_build,&
       QF_metab,&
       QF_traff,&
       Temp_C,&    !Air temperature
       t2_C,&     ! air temperature at 2 m, TS 20 May 2017
       trans_site,&  !Atmospheric transmissivity
       tsurf,&   !Surface temperature
       wdir,&      ! Wind direction
       wu_m3,&     !Water use provided in met forcing file [m3]
       xsmd,&      !Measured soil moisture deficit
       year,&      !Year of the measurements
       zenith_deg  !Sun zenith angle in degrees

  REAL(KIND(1d0)),DIMENSION(2)::Qf_A,Qf_B,Qf_C,&   !Qf coefficients
       AH_MIN,&    !Minimum anthropogenic heat flux (AnthropHeatMethod = 1)
       AH_SLOPE_Heating,&  !Slope of the antrhropogenic heat flux calculation (AnthropHeatMethod = 1)
       AH_SLOPE_Cooling,&
       T_CRITIC_Heating,& !Critical temperature
       T_CRITIC_Cooling,& !Critical cooling temperature
       TrafficRate,& !Traffic rate
       QF0_BEU


  ! INTEGER,DIMENSION(2)::DayLightSavingDay   !DOY when daylight saving changes
  INTEGER::startDLS   !DOY when daylight saving starts
  INTEGER::endDLS   !DOY when daylight saving ends

  INTEGER::nCBLstep  !number of time steps of Runge-kutta methods in one hour

  !---------Water bucket (see B. Offerle's PhD)----------------------------------
  REAL (KIND(1D0)):: DRAINRT,&      !Drainage rate of the water bucket [mm hr-1]
       RAINBUCKET,&   !RAINFALL RESERVOIR [mm]
       RAINCOVER,&
       RAINMAXRES,&   !Maximum water bucket reservoir [mm]
       RAINRES,&      ! [mm]
       TEMPVEG        !TEMPORARY VEGETATIVE SURFACE FRACTION ADJUSTED BY RAINFALL

  !---------SOLWEIG variables---------------------------------------------------
  REAL(KIND(1D0)):: absL,&             ! Absorption coefficient of longwave radiation of a person
       absK,&             ! Absorption coefficient of shortwave radiation of a person
       heightgravity,&    ! Centre of gravity for a standing person
       TransMin,&         ! Tranmissivity of K through decidious vegetation (leaf on)
       TransMax           ! Tranmissivity of K through decidious vegetation (leaf off)

  INTEGER:: Posture,&                ! 1.Standing, 2.Sitting
       usevegdem,&          ! With vegetation (1)
       row,&                    ! Y coordinate for point of interest
       col,&                    ! X coordinate for point of interest
       onlyglobal,&             ! if no diffuse and direct SW, then =1
       SOLWEIGpoi_out,&         ! write output variables at point of interest
       Tmrt_out,&               ! write output Tmrt grid
       Lup2d_out,&              ! write output Lup grid
       Ldown2d_out,&            ! write output Ldown grid
       Kup2d_out,&              ! write output Kup grid
       Kdown2d_out,&            ! write output Kdown grid
       GVF_out,&                ! write output GroundViewFActor grid
       SOLWEIG_ldown,&          ! 1= use SOLWEIG code to estimate Ldown, 0=use SEUWS
       OutInterval,&            ! Output interval in minutes
       RunForGrid               ! If only one grid should be run. All grids -999

  CHARACTER (len=150):: DSMPath,&    ! Path to DSMs
       DSMname,&    ! Ground and building DSM
       CDSMname,&   ! Canopy DSM
       TDSMname,&   ! Trunk zone DSM
       SVFPath,&    ! Path to SVFs
       SVFsuffix,&  !
       buildingsname! Boolean matrix for locations of building pixels

  !--------- AnOHM related variables----------------------------------
  ! to be added here

END MODULE data_in
!==================================================================================================

!======================================================================================================
MODULE cbl_MODULE

  INTEGER::EntrainmentType,&  ! Entrainment type choice
       CO2_included,&     ! CO2 included
       InitialData_use,&  ! 1 read initial data, 0 do not
                                !qh_choice,&        ! selection of qh use to drive CBL growth 1=Suews 2=lumps 3=obs  ! moved to sues_data
       sondeflag,&      ! 1 read sonde or vertical profile data in 0 do not
       isubs          ! 1 include subsidence in equations

  INTEGER,DIMENSION(366)::cblday=0

  CHARACTER (len=200), DIMENSION(366)::FileSonde=""
  CHARACTER (len=200)::InitialDataFileName
  REAL(KIND(1D0)):: wsb       ! subsidence velocity
  REAL(KIND(1d0)),DIMENSION(1:10):: cbldata
  REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::IniCBLdata

  !Parameters in CBL code
  INTEGER::zmax,&
       nEqn=6,&  !NT changed from 4 to 6
       iCBLcount,&
       nlineInData
  REAL(KIND(1d0))::C2K=273.16

  REAL (KIND(1D0)):: usbl,ftbl,fqbl,fcbl,gamt,gamq,gamc,tpp,qpp,cp0!,tk

  REAL(KIND(1D0))::alpha3,&
       blh_m,&    ! Boundary layer height(m)
       blh1_m,&
       cm,&       ! CO2 concentration in CBL
                                !cp0,gamc,& !
       gamt_Km,&  ! Vertical gradient of theta (K/m)
       gamq_gkgm,&! Vertical gradient of specific humidity (g/kg/m)
       gamq_kgkgm,&! Vertical gradient of specific humidity (kg/kg/m)
                                !fcbl,&
       tm_C,&     ! Potential temperature in CBL (degree Celsius)
       tm_K,&     ! Potential temperature in CBL (K)
       tmp_K,&
       tp_C,&     ! Potential temperature just above Boundary layer height(degree Celsius)
       tp_K,&     ! Potential temperature just above Boundary layer height(K)
       tpp_K,&
       febl_kgkgms,&! Kinematic latent heat flux((kg/kg)*m/s)
       fhbl_Kms,&   ! Kinematic sensible heat flux(K*m/s)
       qm_gkg,&   ! Specific humidity in CBL(g/kg)
       qm_kgkg,&  ! Specific humidity in CBL(kg/kg)
       qp_gkg,&   ! Specific humidity above Boundary layer height(g/kg)
       qp_kgkg,&  ! Specific humidity above Boundary layer height(kg/kg)
       qpp_kgkg


  REAL (KIND(1D0)), DIMENSION (0:500,2):: gtheta,ghum ! Vertical gradient of theta and specific humidity from sonde data
  REAL (KIND(1D0)), DIMENSION(6)::y  ! NT set from 4 to 6

END   MODULE cbl_MODULE
!===================================================================================

MODULE snowMod
  IMPLICIT NONE

  REAL (KIND(1D0))::AdjMeltFact,&    !Factor between melt and freezing factors
       SnowfallCum,&        !Cumulative snowfall
       fwh,&              !Weighted freezing water
       lvS_J_kg,&         !Latent heat of sublimation in J/kg
       mwh,&              !Weighted hourly water melt
       MwStore,&              !Meltwater storage
       PrecipLimit,&      !Temperature limit when precipitation occurs as snow
       PrecipLimitAlb,&   !Precipitation limit for albedo change (in mm)
       Qm,&               !Snow melt associated heat flux
       QmFreez,&          !Energy released in freezing of meltwater or surface state
       QmRain,&
       qn1_snow,&         !Net all-wave radiation of SnowPack
       qn1_nosnow,&       !Same for the snow free surface
       RadMeltFact,&      !Radiation melt factor
       SnowAlb,&          !Snow albedo
       SnowAlbMin,&       !Minimum snow albedo
       SnowAlbMax,&       !Maximum snow albedo
       SnowDensMin,&      !Minimum density of snow
       SnowDensMax,&      !Maximum density of snow
       SnowLimBuild,&     !Snow removal limits for roofs in mm)
       SnowLimPaved,&     !Snow removal limits for paved surfaces in mm)
       swe,&        !Weighted snow water equivalent (in mm)
       tau_a,&            !Time constans related to albedo change
       tau_f,&
       tau_r,&            !Time constant for density increase.
       TempMeltFact,&     !Temperature melt factor
       volDay,&           !Volume of the melted water per day
       zf,&
       WaterHoldCapFrac,& !Water holding capacity factor
       CRWmin,& !Free water holding capacity of deep SnowPack
       CRWmax  !Free water holding capacity of shallow SnowPack

  REAL(KIND(1D0)), DIMENSION(2)::  SnowRemoval=0 ! Removal of snow in mm
  REAL(KIND(1d0)), DIMENSION(0:23,2):: SnowProf_24hr  ! Timing of snow removal (0 or 1) Hourly, WD/WE

  INTEGER::SnowFractionChoice=2   !Choice how fraction of snow is calculated

END MODULE snowMod
!===================================================================================

!==================================================================================================
MODULE defaultNotUsed
  IMPLICIT NONE
  REAL (KIND(1d0)):: notUsed=-55.55,reall,NAN=-999,pNAN=999
  INTEGER:: notUsedI=-55, ios_out
  INTEGER:: errorChoice, warningChoice  !errorChoice/warningChoice defines if problems.txt/warnings.txt is opened for the first time
END MODULE defaultNotUsed
!==================================================================================================

!==================================================================================================
MODULE time
  INTEGER:: iy,&            !Year
       id,&            !Day of year
       it,&            !Hour
       imin,&          !Minutes
       isec,&          !Seconds
       DLS             !day lightsavings =1 + 1h) =0

  REAL(KIND(1d0)):: dectime        !Decimal time
  REAL (KIND(1d0)):: tstepcount    !Count number of timesteps in this day
  INTEGER:: nofDaysThisYear        !Based on whether leap year or not
  INTEGER:: dt_since_start ! time since simulation starts [s]

  INTEGER:: iy_prev_t, id_prev_t   !Value of iy and id at previous timestep

END MODULE time
!==================================================================================================

!===================================================================================
MODULE mod_grav
  REAL (KIND(1d0)):: grav=9.80665  !g - gravity - physics today august 1987
END MODULE mod_grav

!===================================================================================
MODULE mod_k
  REAL(KIND(1d0)) :: k=0.4,&             !Von Karman's contant
       k2=0.16,&           !Power of Van Karman's contant
       neut_limit=0.001000 !Limit for neutral stability
END MODULE mod_k

!===================================================================================
MODULE Thresh
  REAL(KIND(1d0)) :: IPThreshold_mmhr = 10   !Threshold for intense precipitation [mm hr-1]

END MODULE Thresh


!===================================================================================
MODULE gas
  !   press (mb) ea (mb)
  IMPLICIT NONE
  REAL (KIND(1d0))::  comp=0.9995
  REAL (KIND(1d0))::  epsil=0.62197   !ratio molecular weight of water vapor/dry air (kg/mol/kg/mol)
  REAL (KIND(1d0))::  epsil_gkg=621.97   !ratio molecular weight of water vapor/dry air in g/kg
  REAL (KIND(1d0))::  dry_gas=8.31451 !Dry gas constant (J/k/mol)
  REAL (KIND(1d0))::  gas_ct_wat=461.05 !Gas constant for water (J/kg/K)
  REAL (KIND(1d0))::  molar=0.028965 !Dry air molar fraction in kg/mol
  REAL (KIND(1d0))::  molar_wat_vap=0.0180153 !Molar fraction of water vapor in kg/mol
  REAL (KIND(1d0))::  gas_ct_dry=8.31451/0.028965 !j/kg/k=dry_gas/molar
  REAL (KIND(1d0))::  gas_ct_wv=8.31451/0.0180153 !j/kg/kdry_gas/molar_wat_vap
END MODULE gas

!**********************************************
MODULE mod_z
  REAL (KIND(1d0)) :: zzd,&  !Active measurement height (meas. height-displac. height)
       z0m,&  !Aerodynamic roughness length
       zdm,&  !Displacement height
       z0m_in,&  !Aerodynamic roughness length set in SiteSelect
       zdm_in,&  !Displacement height set in SiteSelect
       z      !Windspeed height
  REAL(KIND(1E10))::z0V      !Roughness length for vapour
END MODULE mod_z

!**********************************************
MODULE resist  !Variables related surface resistance calculations (P. 1744 in G&O1991)
  IMPLICIT NONE
  REAL (KIND(1d0)):: th,&             !Maximum temperature limit
       tl,&             !Minimum temperature limit
       Kmax,&           !Annual maximum hourly solar radiation
       g1,g2,g3,g4,&    !Fitted parameters related to
       g5,g6,s1,s2,&    !surface res. calculations
       tc,&             !Temperature parameter 1
       tc2              !Temperature parameter 2
  INTEGER:: gsModel     !Choice of gs parameterisation (1 = Ja11, 2 = Wa16)
END MODULE resist

!**********************************************
MODULE moist
  IMPLICIT NONE

  REAL (KIND(1d0))::avcp,&        !Specific heat capacity
       dens_dry,&    !Dry air density kg m-3
       dq,&          !Specific humidity deficit
       Ea_hPa,&      !Water vapour pressure in hPa
       Es_hPa,&      !Saturation vapour pressure in hPa
       lv_J_kg,&     !Latent heat of vaporization in [J kg-1]
       tlv,&         !Latent heat of vaporization per timestep
                                ![J kg-1 s-1] (tlv=lv_J_kg/tstep_real)
       psyc_hPa,&    !Psychometric constant in hPa
       psycIce_hPa,& !Psychometric constant in hPa for snow
       s_Pa,&        !Vapour pressure versus temperature slope in Pa
       s_hpa,&       !Vapour pressure versus temperature slope in hPa
       sIce_hpa,&    !Vapour pressure versus temperature slope in hPa above ice/snow
       vpd_hPa,&     !Vapour pressure deficit in hPa
       vpd_pa,&      !Vapour pressure deficit in Pa
       waterDens=999.8395 !Density of water in 0 cel deg

END MODULE moist
!**********************************************

MODULE gis_data
  IMPLICIT NONE

  REAL(KIND(1d0)):: areaunir,&                   !Unirrigated area
       areair,&                     !Irrigated area
       bldgH,&                      !Mean building height
       FAIbldg,&                    !Frontal area fraction of buildings
       FAItree,&                    !Frontal area fraction of trees
       FAIEveTree,&                    !Frontal area fraction of evergreen trees
       FAIDecTree,&                    !Frontal area fraction of deciduous trees
       grassfractionirrigated,&     !Irrigated grass fraction for LUMPS
       pavedfractionirrigated,&     !Irrigated paved area fraction for LUMPS
       TreeH,&                      !Mean tree height
       EveTreeH,&                     !Height of evergreen trees
       DecTreeH,&                     !Height of deciduous trees
       treefractionirrigated,&      !Irrigated tree fraction for LUMPS
       veg_fr,&                     !Vegetation fraction from land area
                                !- For LUMPS - dependent on user choice    & water
       VegFraction, &               ! sum of vegetation -not including water
       ImpervFraction,&             ! sum of surface cover fractions for impervious surfaces
       PervFraction,&               ! sum of surface cover fractions for pervious surfaces
       NonWaterFraction,&           ! sum of surface cover fractions for all except water surfaces
       areaZh                       !=(sfr(BldgSurf)+sfr(ConifSurf)+sfr(DecidSurf)) !Total area of buildings and trees

  INTEGER:: idgis,&      !Time integers used in the code
       itgis,&      !
       Veg_type=1    !Defines how vegetation is calculated for LUMPS

END MODULE gis_data

!************************************************************
MODULE sues_data
  IMPLICIT NONE

  INTEGER:: tstep,&    !Timestep [s] at which the model is run (set in RunControl)
       tstep_prev,&    !Timestep [s] of previous timestamp !NB: not used by SUEWS, but by WRF-SUEWS for adaptive time step
       nsh,&      !Number of timesteps per hour
       nsd,&      !Number of timesteps per day
       nsdorig,&  !Number of timesteps per day for original met forcing file
       t_interval,&   !Number of seconds in an hour [s] (now set in OverallRunControl)
       Nper, NperESTM   ! Number of model time-steps per input resolution (ResolutionFilesIn/Tstep)

  REAL(KIND(1d0)):: nsh_real,&   !nsh cast as a real for use in calculations
       tstep_real,&   !tstep cast as a real for use in calculations
       Nper_real, NperESTM_real   !Nper as real

  REAL(KIND(1d0)):: halftimestep   !In decimal time based on interval

  !Options for model setup (switches, etc) mainly set in RunControl
  INTEGER:: StabilityMethod,&   !Defines stability functions used (set in RunControl)
       RoughLenHeatMethod     !Defines method for calculating roughness length for heat (set in RunControl)


  INTEGER:: in
  INTEGER:: is      !Integer to count over surface types

  !These are variables which currently have been removed from SuesInput.nml
  INTEGER::AerodynamicResistanceMethod=2 !The method used to calculate aerodynamic resistance

  INTEGER::Ie_start,&   !Starting time of water use (DOY)
       Ie_end       !Ending time of water use (DOY)

  REAL(KIND(1d0)),DIMENSION(2):: SurplusEvap !Surplus for evaporation in 5 min timestep
  ! sg -- need to determine size

  !Variables listed in SuesInput.nml
  REAL (KIND(1d0))::FlowChange,&         !Difference between the input and output flow in the water body
       PipeCapacity,&       !Capacity of pipes to transfer water
       RunoffToWater,&      !Fraction of surface runoff going to water body
       SmCap,&              !Volumetric/gravimetric soil moisture capacity
       SoilDensity,&        !Bulk density of soil
       SoilDepthMeas,&      !Soil depth of the measured soil moisture
       SoilRocks,&          !Fraction of rocks in soil
       SurfaceArea,&        !Surface area of the study area [m2]
       SurfaceArea_ha,&     !Surface area of the study area [ha]
       WaterBodyType,&      !If water body type is pond/lake (=1) or river (=2)
       WaterStorCap,&       !Capacity of water body when surface is wet
       WUAreaEveTr_m2,&     !Water use area (evergreen trees) [m2]
       WUAreaDecTr_m2,&     !Water use area (deciduous trees) [m2]
       WUAreaGrass_m2,&     !Water use area (grass) [m2]
       WUAreaTotal_m2,&     !Water use area (total) [m2]
       wu_EveTr,&              !Water use for evergreen trees/shrubs [mm]
       wu_DecTr,&              !Water use for deciduous trees/shrubs [mm]
       wu_Grass                !Water use for grass [mm]

  !Other related to SUES
  REAL (KIND(1d0))::AdditionalWater,&     !Water flow from other grids
       ch_per_interval,&     !Change in state per interval
       chSnow_per_interval,& !Change in snow state per interval
       dI_dt,&               !Water flow between two stores
       dr_per_interval,&     !Drainage per interval
       ev_per_interval,&     !Evaporation per interval
       surf_chang_per_tstep,& !Change in surface state per timestep [mm] (for whole surface)
       tot_chang_per_tstep,&  !Change in surface and SoilState per timestep [mm] (for whole surface)
       NWstate_per_tstep,&     !State per timestep [mm] (for whole surface, excluding water body)
       state_per_tstep,&     !State per timestep [mm] (for whole surface)
       drain_per_tstep,&     !Drainage per timestep [mm] (for whole surface, excluding water body)
       runoff_per_tstep,&     !Runoff per timestep [mm] (for whole surface)
       runoffSoil_per_tstep,& !Runoff to deep soil per timestep [mm] (for whole surface, excluding water body)
       ev_per_tstep,&     !Evaporation per timestep [mm] (for whole surface)
       qe_per_tstep,&     !QE [W m-2] (for whole surface)
       p_mm,&                !Inputs to surface water balance
       pin,&                 !Rain per time interval
       planF,&               !Areally weighted frontal area fraction
       rb,&                  !Boundary layer resistance
                                ! Water leaving each grid for grid-to-grid connectivity
       runoffAGimpervious,&     !Above ground runoff from impervious surface [mm] for whole surface area
       runoffAGveg,&            !Above ground runoff from vegetated surfaces [mm] for whole surface area
       runoffWaterBody,&        !Above ground runoff from water surface [mm] for whole surface area
       runoffPipes,&            !Runoff in pipes [mm] for whole surface area
       runoffAGimpervious_m3,&  !Volume of above ground runoff from impervious surface [m3]
       runoffAGveg_m3,&         !Volume of above ground runoff from vegetated surfaces [m3]
       runoffWaterBody_m3,&     !Volume of above ground runoff from water surface [m3]
       runoffPipes_m3,&         !Volume of runoff in pipes [m3]
       runoff_per_interval,&  ! Total water transported to each grid for grid-to-grid connectivity
       addImpervious,&      !Water from impervious surfaces of other grids [mm] for whole surface area
       addVeg,&             !Water from vegetated surfaces of other grids [mm] for whole surface area
       addWaterbody,&       !Water from water surface of other grids [mm] for whole surface area
       addPipes,&           !Water in pipes from other grids [mm] for whole surface area

       runoffSoil_per_interval,&
       qe_per_interval,&     !latent heat per interval
       SoilMoistCap,&
       SoilState,&        !Area-averaged soil moisture [mm] for whole surface
       st_per_interval,&!Surface state per interval
       surplusWaterBody,&  !Extra runoff that goes to water body [mm] as specified by RunoffToWater
       tlv_sub,&
       overuse=0,&
       Zh               !Areally weighted roughness element height

  !Calculation of u*,stability and aerodynamic resistance
  REAL (KIND(1d0))::H,&          !Kinematic sensible heat flux [K m s-1] used to calculate friction velocity
       l_mod,&      !Monin-Obukhov length (either measured or modelled)
       psim,&       !Stability function of momentum
       psyh,&       !Stability function of heat
       RA,&         !Aerodynamic resistance
       RAsnow,&     !Aerodynamic resistance over snow
       TStar,&      !T*
       UStar,&      !Friction velocity
       z0_gis       !Roughness length for momentum from gis input file

  !Surface resistance related variables
  REAL (KIND(1d0))::resistsurf,& !Surface resistance
       gdq,&        !G(dq)
       qnm,&        !QMAX/(QMAX+G2)
       gq,&         !G(Q*)
       gtemp,&      !G(T)
       gl,&         !G(LAI)
       sdp,&        !S1/G6+S2
       smd,&        !Soil moisture deficit of the soil surface layer
       vsmd,&       !Soil moisture deficit for vegetated surfaces only (QUESTION: what about BSoil?)
       gs,&         !G(Soil moisture deficit)
       gsc,&        !Surface Layer Conductance
       rss          !Surface resistance after wet/partially wet adjustment

  !SUES latent heat flux related variables
  REAL (KIND(1d0))::  vdrc,&     !Second term up in calculation of E
       numPM,&    !Numerator of PM equation
       sp,&       !Term in calculation of E
       sae,&      !Same
       ev,&       !Evaporation
       rst,&      !Flag in SUEWS_Evap (gets set to 1 if surface dry; 0 if surface wet)
       qeph,&     !Latent heat flux (W m^-2)
       qeOut      !Latent heat flux [W m-2]

  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: qhforCBL, qeforCBL   ! Stores previous timestep qh and qe for CBL model. Added by HCW 21 Mar 2017
  INTEGER:: qh_choice        ! selection of qh use to drive CBL growth 1=Suews 2=lumps 3=obs

  !Water use related variables
  REAL (KIND(1d0)):: ext_wu,&         !External water use for the model timestep [mm] (over whole study area)
       Faut,&           !Fraction of irrigated area using automatic irrigation
       int_wu,&         !Internal water use for the model timestep [mm] (over whole study area)
       IrrFracConif,&  !Fraction of evergreen trees which are irrigated
       IrrFracDecid,&  !Fraction of deciduous trees which are irrigated
       IrrFracGrass,&  !Fraction of grass which is irrigated
       InternalWaterUse_h !Internal water use [mm h-1]

  ! 7 - number of days in week
  REAL(KIND(1d0)),DIMENSION(7)::DayWatPer,&  !% of houses following daily water
       DayWat       !Days of watering allowed
  REAL(KIND(1d0)),DIMENSION(0:23,2):: WUProfM_24hr,&   !Hourly profiles for water use (manual irrigation)
       WUProfA_24hr   !Hourly profiles for water use (automatic irrigation)


  REAL (KIND(1d0)),DIMENSION(3)::Ie_a,Ie_m   !Coefficients for automatic and manual irrigation models

END MODULE sues_data

!**********************************************
!===================================================================================
MODULE VegPhenogy
  IMPLICIT NONE
  REAL (KIND(1d0)):: VegPhenLumps,deltaLAI
END MODULE VegPhenogy

MODULE filename
  CHARACTER (len=90)::  smithfile     !file for NARP
END MODULE filename


MODULE InitialCond

  REAL (KIND(1d0))::LAIinitialEveTr,&
       LAIinitialDecTr,&
       LAIinitialGrass,&
       porosity0,&
       DecidCap0,&
       albDecTr0,&
       albEveTr0,&
       albGrass0,&
       Temp_C0,&
       GDD_1_0,&
       GDD_2_0,&
       SoilStorePavedState,&
       SoilStoreBldgsState,&
       SoilStoreEveTrState,&
       SoilStoreDecTrstate,&
       SoilStoreGrassState,&
       SoilStoreBSoilState,&
       SnowWaterPavedState,&
       SnowWaterBldgsState,&
       SnowWaterEveTrState,&
       SnowWaterDecTrState,&
       SnowWaterGrassState,&
       SnowWaterBSoilState,&
       SnowWaterWaterstate,&
       SnowPackPaved,&
       SnowPackBldgs,&
       SnowPackEveTr,&
       SnowPackDecTr,&
       SnowPackGrass,&
       SnowPackBSoil,&
       SnowPackWater,&
       SnowAlb0!,&
  ! BoInit !initial Bo for AnOHM, TS 13 Jul 2016 ! removed, TS 30 Jan 2018

  INTEGER::ID_Prev

END MODULE InitialCond

!-------------------------------------------------
!New modules for the column numbers


!-------------------------------------------------------------------------
MODULE ColNamesModelDailyState

  IMPLICIT NONE

  !========== Columns for ModelDailyState array =========================

  INTEGER:: cMDS_id_prev    = 3, &
       cMDS_HDD1            = 4, &
       cMDS_HDD2            = 5, &
       cMDS_TempC           = 6, &
       cMDS_TempCRM         = 7, &
       cMDS_Precip          = 8, &
       cMDS_DaysSinceRain   = 9, &
       cMDS_TempCOld1       = 10,&
       cMDS_TempCOld2       = 11,&
       cMDS_TempCOld3       = 12,&
       cMDS_GDDMin          = 13,&
       cMDS_GDDMax          = 14,&
       cMDS_GDD1_0          = 15,&
       cMDS_GDD2_0          = 16,&
       cMDS_LAIInitialEveTr = 17,&
       cMDS_LAIInitialDecTr = 18,&
       cMDS_LAIInitialGrass = 19,&
       cMDS_porosity        = 20,&
       cMDS_albEveTr        = 21,&
       cMDS_albDecTr        = 22,&
       cMDS_albGrass        = 23,&
       cMDS_DecidCap        = 24,&
       cMDS_SnowfallCum     = 25,&
       cMDS_LAIEveTr        = 26,&
       cMDS_LAIDecTr        = 27,&
       cMDS_LAIGrass        = 28,&
       cMDS_SnowAlb         = 29,&
       cMDS_BoRatio         = 30,& ! noontime Bowen ratio, added by TS
       cMDS_a1AnOHM         = 31,& ! a1 of AnOHM, added by TS
       cMDS_a2AnOHM         = 32,& ! a2 of AnOHM, added by TS
       cMDS_a3AnOHM         = 33 ! a3 of AnOHM, added by TS


END MODULE ColNamesModelDailyState


!-------------------------------------------------------------------------
MODULE ColNamesInputFiles

  IMPLICIT NONE

  INTEGER:: ccc    !Column counter

  ! Column names and numbers must match the input files

  !========== Columns for SUEWS_SiteSelect.txt ==========================
  ! Columns 1:97 are the same for SurfaceChar
  INTEGER::c_Grid = 1,&
       c_Year     = 2,&
       c_StartDLS = 3,&
       c_EndDLS   = 4,&
                                ! Site info
       c_lat  = 5,&
       c_lng  = 6,&
       c_tz   = 7,&
       c_Area = 8,&
       c_Alt  = 9,&
       c_z    = 10,&
                                ! Time info
       c_id   = 11,&
       c_it   = 12,&
       c_imin = 13,&
                                ! Surface fractions
       c_FrPaved = 14,&
       c_FrBldgs = 15,&
       c_FrEveTr = 16,&
       c_FrDecTr = 17,&
       c_FrGrass = 18,&
       c_FrBSoil = 19,&
       c_FrWater = 20,&
                                ! Irrigated fractions
       c_IrrEveTrFrac = 21,&
       c_IrrDecTrFrac = 22,&
       c_IrrGrassFrac = 23,&
                                ! Height information
       c_HBldgs   = 24,&
       c_HEveTr   = 25,&
       c_HDecTr   = 26,&
       c_z0m      = 27,&
       c_zdm      = 28,&
       c_FAIBldgs = 29,&
       c_FAIEveTr = 30,&
       c_FAIDecTr = 31,&
                                ! Population
       c_PopDensDay   = 32,&
       c_PopDensNight = 33,&
       c_TrafficRate_WD  = 34,&    ! Mean traffic rate in modelled area [veh km m-2 s-1] Weekday
       c_TrafficRate_WE  = 35,&    ! Mean traffic rate in modelled area [veh km m-2 s-1] Weekend
       c_QF0_BEU_WD  = 36,&    ! Building energy use for modelled area [W m-2] - QUESTION: could change units?
       c_QF0_BEU_WE = 37,&
                                ! Codes for different surfaces
       c_PavedCode = 38,&  ! Links characteristics in SUEWS_NonVeg.txt
       c_BldgsCode = 39,&  ! Links characteristics in SUEWS_NonVeg.txt
       c_EveTrCode = 40,&  ! Links characteristics in SUEWS_Veg.txt
       c_DecTrCode = 41,&    ! Links characteristics in SUEWS_Veg.txt
       c_GrassCode = 42,&     ! Links characteristics in SUEWS_Veg.txt
       c_BSoilCode = 43,&  ! Links characteristics in SUEWS_Veg.txt
       c_WaterCode = 44,&       ! Links characteristics in SUEWS_Water.txt
                                ! LUMPS info
       c_LUMPSDr     = 45,&
       c_LUMPSCover  = 46,&
       c_LUMPSMaxRes = 47,&
                                ! NARP info
       c_NARPTrans   = 48,&
                                ! Code for conductances
       c_CondCode    = 49,&       ! Links characteristics in SUEWS_Conductance.txt
                                ! Code for snow
       c_SnowCode    = 50,&    ! Links characteristics in SUEWS_Snow.txt
                                ! Codes for human impacts on energy, water and snow
       c_SnowProfWD  = 51,&  ! Snow-clearing profile in SUEWS_Profile.txt (weekdays)
       c_SnowProfWE  = 52,&  ! Snow-clearing profile in SUEWS_Profile.txt (weekends)
       c_QFCode      = 53,&  ! Links anthropogenic heat info in SUEWS_AnthropogenicHeat.txt
       c_IrrCode     = 54,&  ! Links irrigation info in SUEWS_Irrigation.txt
       c_WProfManuWD = 55,&  ! Links to water-use profile in SUEWS_Profile.txt (manual irrigation, weekdays)
       c_WProfManuWE = 56,&  ! Links to water-use profile in SUEWS_Profile.txt (manual irrigation, weekends)
       c_WProfAutoWD = 57,&  ! Links to water-use profile in SUEWS_Profile.txt (automatic irrigation, weekdays)
       c_WProfAutoWE = 58,&  ! Links to water-use profile in SUEWS_Profile.txt (automatic irrigation, weekends)
                                ! Flow information
       c_FlowChange    =59,&  ! Difference in input & output flows for water surface
       c_RunoffToWater =60,&    ! Fraction of above-ground runoff flowing to water surface
       c_PipeCapacity  =61,&  ! Pipe capacity [mm]
                                ! Runoff (to 8 adjacent grids)
       c_GridConnection1of8 = 62,&
       c_Fraction1of8       = 63,&
       c_GridConnection2of8 = 64,&
       c_Fraction2of8       = 65,&
       c_GridConnection3of8 = 66,&
       c_Fraction3of8       = 67,&
       c_GridConnection4of8 = 68,&
       c_Fraction4of8       = 69,&
       c_GridConnection5of8 = 70,&
       c_Fraction5of8       = 71,&
       c_GridConnection6of8 = 72,&
       c_Fraction6of8       = 73,&
       c_GridConnection7of8 = 74,&
       c_Fraction7of8       = 75,&
       c_GridConnection8of8 = 76,&
       c_Fraction8of8       = 77,&
                                ! Runoff within grid (for each surface type)
       c_WGPavedCode = 78,&   ! Links to SUEWS_WaterDistibuteWithinGrid.txt
       c_WGBldgsCode = 79,&   ! Links to SUEWS_WaterDistibuteWithinGrid.txt
       c_WGEveTrCode = 80,&   ! Links to SUEWS_WaterDistibuteWithinGrid.txt
       c_WGDecTrCode = 81,&   ! Links to SUEWS_WaterDistibuteWithinGrid.txt
       c_WGGrassCode = 82,&   ! Links to SUEWS_WaterDistibuteWithinGrid.txt
       c_WGBSoilCode = 83,&   ! Links to SUEWS_WaterDistibuteWithinGrid.txt
       c_WGWaterCode = 84,&   ! Links to SUEWS_WaterDistibuteWithinGrid.txt
                                ! Additional info for ESTM
       c_AreaWall = 85   ! Wall surface fraction (Awall/Agridcell)

  INTEGER,DIMENSION(3):: c_Fr_ESTMClass_Paved =   (/(ccc,ccc=86,88,1)/) ! Fraction of Paved surface with ESTM Class 1-5
  INTEGER,DIMENSION(3)::         c_Code_ESTMClass_Paved = (/(ccc,ccc=89,91,1)/) ! Code for Paved surface ESTM Class 1-5
  INTEGER,DIMENSION(5):: c_Fr_ESTMClass_Bldgs =   (/(ccc,ccc=92,96,1)/) ! Fraction of Bldgs surface with ESTM Class 1-5
  INTEGER,DIMENSION(5)::         c_Code_ESTMClass_Bldgs = (/(ccc,ccc=97,101,1)/) ! Code for Bldgs surface ESTM Class 1-5

  !========== Columns for SUEWS_NonVeg.txt ==========================
  INTEGER :: ci_Code   = 1, &
       ci_AlbMin       = 2, &
       ci_AlbMax       = 3, &
       ci_Emis         = 4, &
       ci_StorMin      = 5, &
       ci_StorMax      = 6, &
       ci_WetThresh    = 7, &
       ci_StateLimit   = 8, &
       ci_DrEq         = 9, &
       ci_DrCoef1      = 10,&
       ci_DrCoef2      = 11,&
       ci_SoilTCode    = 12,&
       ci_SnowLimPat   = 13,&
       ci_SnowLimRem   = 14,&
       ci_OHMCode_SWet = 15,&
       ci_OHMCode_SDry = 16,&
       ci_OHMCode_WWet = 17,&
       ci_OHMCode_WDry = 18,&
       ci_OHMThresh_SW = 19,&
       ci_OHMThresh_WD = 20,&
       ci_ESTMCode     = 21,& ! ESTM code for each surface (if 0 use codes in SiteSelect instead)
       ci_CpAnOHM      = 22,& ! heat capacity, added by TS AnOHM
       ci_KkAnOHM      = 23,& ! heat conductivity, added by TS AnOHM
       ci_ChAnOHM      = 24 ! bulk transfer coef., added by TS AnOHM

  !========== Columns for SUEWS_Veg.txt ============================
  INTEGER :: cp_Code   = 1, &
       cp_AlbMin       = 2, &
       cp_AlbMax       = 3, &
       cp_Emis         = 4, &
       cp_StorMin      = 5, &
       cp_StorMax      = 6, &
       cp_WetThresh    = 7, &
       cp_StateLimit   = 8, &
       cp_DrEq         = 9, &
       cp_DrCoef1      = 10,&
       cp_DrCoef2      = 11,&
       cp_SoilTCode    = 12,&
       cp_SnowLimPat   = 13,&
       cp_BaseT        = 14,&
       cp_BaseTe       = 15,&
       cp_GDDFull      = 16,&
       cp_SDDFull      = 17,&
       cp_LAIMin       = 18,&
       cp_LAIMax       = 19,&
       cp_PorosityMin  = 20,&
       cp_PorosityMax  = 21,&
       cp_GsMax        = 22,&
       cp_LAIEq        = 23,&
       cp_LeafGP1      = 24,&
       cp_LeafGP2      = 25,&
       cp_LeafOP1      = 26,&
       cp_LeafOP2      = 27,&
       cp_OHMCode_SWet = 28,&
       cp_OHMCode_SDry = 29,&
       cp_OHMCode_WWet = 30,&
       cp_OHMCode_WDry = 31,&
       cp_OHMThresh_SW = 32,&
       cp_OHMThresh_WD = 33,&
       cp_ESTMCode     = 34,&
       cp_CpAnOHM      = 35,& ! heat capacity, added by TS AnOHM
       cp_KkAnOHM      = 36,& ! heat conductivity, added by TS AnOHM
       cp_ChAnOHM      = 37,& ! bulk transfer coef., added by TS AnOHM
       cp_BiogenCO2Code = 38


  !========== Columns for SUEWS_Water.txt ===============================
  INTEGER :: cw_Code   = 1, &
       cw_AlbMin       = 2, &
       cw_AlbMax       = 3, &
       cw_Emis         = 4, &
       cw_StorMin      = 5, &
       cw_StorMax      = 6, &
       cw_WetThresh    = 7, &
       cw_StateLimit   = 8, &
       cw_WaterDepth   = 9, &
       cw_DrEq         = 10, &
       cw_DrCoef1      = 11,&
       cw_DrCoef2      = 12,&
       cw_OHMCode_SWet = 13,&
       cw_OHMCode_SDry = 14,&
       cw_OHMCode_WWet = 15,&
       cw_OHMCode_WDry = 16,&
       cw_OHMThresh_SW = 17,&
       cw_OHMThresh_WD = 18,&
       cw_ESTMCode     = 19,&
       cw_CpAnOHM      = 20,& ! heat capacity, added by TS AnOHM
       cw_KkAnOHM      = 21,& ! heat conductivity, added by TS AnOHM
       cw_ChAnOHM      = 22 ! bulk transfer coef., added by TS AnOHM

  !========== Columns for SUEWS_Snow.txt ================================
  INTEGER :: cs_Code   = 1, &
       cs_SnowRMFactor = 2, &
       cs_SnowTMFactor = 3, &
       cs_SnowAlbMin   = 4, &
       cs_SnowAlbMax   = 5, &
       cs_SnowEmis     = 6, &
       cs_Snowtau_a    = 7, &
       cs_Snowtau_f    = 8, &
       cs_SnowPLimAlb  = 9, &
       cs_SnowSDMin    = 10,&
       cs_SnowSDMax    = 11,&
       cs_Snowtau_r    = 12,&
       cs_SnowCRWMin   = 13,&
       cs_SnowCRWMax   = 14,&
       cs_SnowPLimSnow = 15,&
       cs_OHMCode_SWet = 16,&
       cs_OHMCode_SDry = 17,&
       cs_OHMCode_WWet = 18,&
       cs_OHMCode_WDry = 19,&
       cs_OHMThresh_SW = 20,&
       cs_OHMThresh_WD = 21,&
       cs_ESTMCode     = 22,&
       cs_CpAnOHM      = 23,& ! heat capacity, added by TS
       cs_KkAnOHM      = 24,& ! heat conductivity, added by TS
       cs_ChAnOHM      = 25 ! bulk transfer coef., added by TS

  !========== Columns for SUEWS_Soil.txt ================================
  INTEGER :: cSo_Code        =  1,&
       cSo_SoilDepth   =  2,&
       cSo_SoilStCap   =  3,&
       cSo_KSat         =  4,&
       cSo_SoilDens    =  5,&
       cSo_SoilInfRate =  6,&
       cSo_ObsSMDepth  =  7,&
       cSo_ObsSMMax    =  8,&
       cSo_ObsSNRFrac  =  9

  !========== Columns for SUEWS_Conductance.txt =========================
  INTEGER :: cc_Code   =  1,&
       cc_GsG1   =  2,&
       cc_GsG2   =  3,&
       cc_GsG3   =  4,&
       cc_GsG4   =  5,&
       cc_GsG5   =  6,&
       cc_GsG6   =  7,&
       cc_GsTH   =  8,&
       cc_GsTL   =  9,&
       cc_GsS1   =  10,&
       cc_GsS2   =  11,&
       cc_GsKmax =  12,&
       cc_gsModel = 13      !Options for surface conductance calculation (1 - Ja11, 2 - Wa16)

  !========== Columns for SUEWS_OHMCoefficients.txt =====================
  INTEGER :: cO_Code = 1,&
       cO_a1  = 2,&
       cO_a2  = 3,&
       cO_a3  = 4

  !========== Columns for SUEWS_ESTMCoefficients.txt =====================!   ! S.O. 04 Feb 2016
  INTEGER::cE_Code    = 1, &
       cE_Surf_thick1 = 2, &  !Characteristics for 5x roof/surface layers
       cE_Surf_k1     = 3, &
       cE_Surf_rhoCp1 = 4, &
       cE_Surf_thick2 = 5, &
       cE_Surf_k2     = 6, &
       cE_Surf_rhoCp2 = 7, &
       cE_Surf_thick3 = 8, &
       cE_Surf_k3     = 9, &
       cE_Surf_rhoCp3 = 10, &
       cE_Surf_thick4 = 11, &
       cE_Surf_k4     = 12, &
       cE_Surf_rhoCp4 = 13, &
       cE_Surf_thick5 = 14, &
       cE_Surf_k5     = 15, &
       cE_Surf_rhoCp5 = 16, &
       cE_Wall_thick1 = 17, &   ! Characteristics for 5x external wall layers (used for Bldgs surfaces only)
       cE_Wall_k1     = 18, &
       cE_Wall_rhoCp1 = 19, &
       cE_Wall_thick2 = 20, &
       cE_Wall_k2     = 21, &
       cE_Wall_rhoCp2 = 22, &
       cE_Wall_thick3 = 23, &
       cE_Wall_k3     = 24, &
       cE_Wall_rhoCp3 = 25, &
       cE_Wall_thick4 = 26, &
       cE_Wall_k4     = 27, &
       cE_Wall_rhoCp4 = 28, &
       cE_Wall_thick5 = 29, &
       cE_Wall_k5     = 30, &
       cE_Wall_rhoCp5 = 31, &
       cE_Internal_thick1 = 32, &   ! Characteristics for 5x internal wall layers (used for Bldgs surfaces only)
       cE_Internal_k1     = 33, &
       cE_Internal_rhoCp1 = 34, &
       cE_Internal_thick2 = 35, &
       cE_Internal_k2     = 36, &
       cE_Internal_rhoCp2 = 37, &
       cE_Internal_thick3 = 38, &
       cE_Internal_k3     = 39, &
       cE_Internal_rhoCp3 = 40, &
       cE_Internal_thick4 = 41, &
       cE_Internal_k4     = 42, &
       cE_Internal_rhoCp4 = 43, &
       cE_Internal_thick5 = 44, &
       cE_Internal_k5     = 45, &
       cE_Internal_rhoCp5 = 46, &
       cE_nroom    = 47,&
       cE_alb_ibld = 48,&
       cE_em_ibld  = 49,&
       cE_CH_iwall = 50,&
       cE_CH_iroof = 51,&
       cE_CH_ibld  = 52

  !========== Columns for SUEWS_AnthropogenicHeat.txt ===================
  INTEGER ::   cA_Code    = 1,&
       cA_BaseTHDD               = 2,&
       cA_QF_A1                  = 3,&   !Weekday
       cA_QF_B1                  = 4,&   !Weekday
       cA_QF_C1                  = 5,&   !Weekday
       cA_QF_A2                  = 6,&   !Weekend
       cA_QF_B2                  = 7,&   !Weekend
       cA_QF_C2                  = 8,&   !Weekend
       cA_AHMin_WD               = 9,&   !Weekday
       cA_AHMin_WE               = 10,&  !Weekend
       cA_AHSlopeHeating_WD      = 11,&  !Weekday
       cA_AHSlopeHeating_WE      = 12,&  !Weekend
       cA_AHSlopeCooling_WD      = 13,&  !Weekday
       cA_AHSlopeCooling_WE      = 14,&  !Weekend
       cA_TCriticHeating_WD      = 15,&  !Weekday
       cA_TCriticHeating_WE      = 16,&  !Weekend
       cA_TCriticCooling_WD      = 17,&  !Weekday
       cA_TCriticCooling_WE      = 18,&  !Weekend
       cA_EnProfWD               = 19,&  !Weekday
       cA_EnProfWE               = 20,&  !Weekday
       cA_CO2mWD                 = 21,&  !Weekday
       cA_CO2mWE                 = 22,&  !Weekend
       cA_TraffProfWD            = 23,&  !Weekday
       cA_TraffProfWE            = 24,&  !Weekend
       cA_PopProfWD              = 25,&  !Weekday
       cA_PopProfWE              = 26,&  !Weekend
       cA_MinQFMetab             = 27,&
       cA_MaxQFMetab             = 28,&
       cA_FrFossilFuel_Heat      = 29,&
       cA_FrFossilFuel_NonHeat   = 30,&
       cA_EF_umolCO2perJ         = 31,&
       cA_EnEF_v_Jkm             = 32,&
       cA_FcEF_v_kgkm            = 33,&
       cA_TrafficUnits           = 34


  !========== Columns for SUEWS_Irrigation.txt ==========================

  INTEGER ::  cIr_Code     = 1,&
       cIr_IeStart     = 2,&
       cIr_IeEnd       = 3,&
       cIr_IntWU       = 4,&
       cIr_Faut        = 5,&
       cIr_Ie_a1       = 6,&
       cIr_Ie_a2       = 7,&
       cIr_Ie_a3       = 8,&
       cIr_Ie_m1       = 9,&
       cIr_Ie_m2       = 10,&
       cIr_Ie_m3       = 11,&
       cIr_DayWat1     = 12,&
       cIr_DayWat2     = 13,&
       cIr_DayWat3     = 14,&
       cIr_DayWat4     = 15,&
       cIr_DayWat5     = 16,&
       cIr_DayWat6     = 17,&
       cIr_DayWat7     = 18,&
       cIr_DayWatPer1  = 19,&
       cIr_DayWatPer2  = 20,&
       cIr_DayWatPer3  = 21,&
       cIr_DayWatPer4  = 22,&
       cIr_DayWatPer5  = 23,&
       cIr_DayWatPer6  = 24,&
       cIr_DayWatPer7  = 25

  !========== Columns for SUEWS_Profile.txt =============================

  INTEGER:: cc   !Column counter

  INTEGER:: cPr_Code = 1
  INTEGER,DIMENSION(24):: cPr_Hours = (/(cc, cc=2,25, 1)/)  ! Hourly profile data

  !========== Columns for SUEWS_WithinGridWaterDist.txt =================

  INTEGER::   cWG_Code     = 1,&
       cWG_ToPaved     = 2,&
       cWG_ToBldgs     = 3,&
       cWG_ToEveTr     = 4,&
       cWG_ToDecTr     = 5,&
       cWG_ToGrass     = 6,&
       cWG_ToBSoil     = 7,&
       cWG_ToWater     = 8,&
       cWG_ToRunoff    = 9,&
       cWG_ToSoilStore = 10

  !========== Columns for SUEWS_BiogenCO2.txt ===================
  INTEGER ::   cB_Code    = 1,&
       cB_alpha           = 2,&
       cB_beta            = 3,&
       cB_theta           = 4,&
       cB_alpha_enh       = 5,&
       cB_beta_enh        = 6,&
       cB_resp_a          = 7,&
       cB_resp_b          = 8,&
       cB_min_r           = 9


END MODULE ColNamesInputFiles

!----------------------------------------------------------------------------------------
MODULE ESTM_data !S.O. and FO

  ! =======ESTMinput.nml==============================
  INTEGER ::        evolveTibld,&
       TsurfChoice,&
       ibldCHmod

  REAL(KIND(1d0)):: LBC_soil,&        !Lowest boundary condition in soil
       THEAT_ON,&
       THEAT_OFF,&
       THEAT_fix,&
       ivf_iw,&    !Internal view factors : im
       ivf_ir,&
       ivf_ii,&
       ivf_if,&
       ivf_ww,&    !Internal view factors : wall
       ivf_wr,&
       ivf_wi,&
       ivf_wf,&
       ivf_rw,&    !Internal view factors : roof
       ivf_ri,&
       ivf_rf,&
       ivf_fw,&    !Internal view factors : floor
       ivf_fr,&
       ivf_fi


  !=======ESTMcoefficients.txt=================================
  INTEGER:: Nibld,&           !Number of layers in an internal element in buildings, calculated when the file is read.
       Nwall,&           !Number of layers in external wall
       Nroof,&           !Number of layers in roof
       Nground           !Number of layers in ground

  REAL(KIND(1d0)),DIMENSION(5):: zibld,&    !Thickness of layers in internal building
       zwall,&    !Thickness of layers in external wall
       zroof,&    !Thickness of layers in roof
       zground,&  !Thickness of layers in ground
       kibld,&    !Thermal conductivity of layers in internal building
       kwall,&    !Thermal conductivity of layers in external wall
       kroof,&    !Thermal conductivity of layers in roof
       kground,&  !Thermal conductivity of layers in ground
       ribld,&    !Volumetric heat capacity of layers in internal building
       rwall,&    !Volumetric heat capacity of layers in external wall
       rroof,&    !Volumetric heat capacity of layers in roof
       rground    !Volumetric heat capacity of layers in ground

  ! Paved and Bldgs surfaces can include 3 and 5 classes respectively
  !For the 3x Paved surfaces
  REAL(KIND(1d0)),DIMENSION(5,3):: zSurf_Paved
  REAL(KIND(1d0)),DIMENSION(5,3):: kSurf_Paved
  REAL(KIND(1d0)),DIMENSION(5,3):: rSurf_Paved
  !For the 5x Bldgs surfaces
  REAL(KIND(1d0)),DIMENSION(5,5):: zSurf_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: kSurf_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: rSurf_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: zwall_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: kwall_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: rwall_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: zibld_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: kibld_Bldgs
  REAL(KIND(1d0)),DIMENSION(5,5):: ribld_Bldgs
  REAL(KIND(1d0)),DIMENSION(5):: nroom_Bldgs
  REAL(KIND(1d0)),DIMENSION(5):: alb_ibld_Bldgs
  REAL(KIND(1d0)),DIMENSION(5):: em_ibld_Bldgs
  REAL(KIND(1d0)),DIMENSION(5):: CH_iwall_Bldgs
  REAL(KIND(1d0)),DIMENSION(5):: CH_iroof_Bldgs
  REAL(KIND(1d0)),DIMENSION(5):: CH_ibld_Bldgs

  REAL(KIND(1d0))::   nroom,&      !Number of rooms in internal building  (changed from integer to real HCW 16 Jun 2016)
       alb_ibld,& !albedo value of internal elements
       em_ibld,&  !emissivity of internal elements
       CH_iroof,& !bulk transfer coefficient of internal roof
       CH_iwall,& !bulk transfer coefficient of internal wall
       CH_ibld,&  !bulk transfer coefficient of internal building element
       fwall,&    !fraction of wall
       AreaWall   ! Area of wall within grid [m2]

  !=======ESTM Ts input=================================
  REAL(KIND(1d0)),ALLOCATABLE,DIMENSION(:)::  Tibld,Twall,Troof,Tground
  REAL(KIND(1d0)),ALLOCATABLE,DIMENSION(:,:)::  Tw_4

  REAL(KIND(1d0)),ALLOCATABLE,DIMENSION(:,:)  ::  Tibld_grids,Twall_grids,Troof_grids,Tground_grids
  REAL(KIND(1d0)),ALLOCATABLE,DIMENSION(:,:,:)::  Tw_4_grids

  !=======variables and parameters created in ESTM=============================
  REAL(KIND(1d0))                           ::  alb_avg,&
       alb_ground,&   !albedo value of ground
       alb_roof,&     !albedo value of roof
       alb_veg,&      !albedo value of veg
       CHAIR,&
       CHR,&
       em_ground,&    !emissivity of ground
       em_roof,&      !emissivity of roof
       em_veg,&       !emissivity of veg
       em_r,&         !emissivity of roof inside building
       em_w,&         !emissivity of internal wall
       em_i,&         !QUESTION: emissivity of ?
       em_f,&         !emissivity of floor
       fair,&         !fraction of air (or ratio of outdoor air volume to indoor air volume)
       fground,&      !fraction of ground
       fibld,&        !QUESTION: fraction of internal elements (?)
       finternal,&    !sum of froof, fibld and fwall
       froof,&        !fraction of roof
       fveg,&         !fraction of veg
       HW,&           !Height Width ratio
       LUP_ground,&
       LUP_ROOF,&
       LUP_VEG,&
       LUP_WALL,&
       minshc_airbld,&
       Pcoeff(5),&
       Qsground,&     !Storage heat flux into ground
       Qsroof,&       !Storage heat flux into roof
       Qswall,&       !Storage heat flux into wall
       Qs_4(4),&      !Storage heat flux into each external wall (N,E,S and W direction)
       Qsair,&        !Storage heat flux into air
       Qsibld,&       !Storage heat flux into internal building elements
       RVF_ground,&
       RVF_WALL,&
       RVF_ROOF,&
       RVF_CANYON,&
       RVF_VEG,&
       SHC_air,&
       SVF_ground,&   !Sky view factor from ground
       SVF_wall,&     !Sky view factor from wall
       SVF_roof,&     !Sky view factor from roof
       TANZENITH,&    !
       Tair1,&
       Tair2,&
       Tairday,&      !24hour average air temperature
       Tfloor,&
       Tievolve,&
       TN_roof,&
       TN_wall,&
       T0_wall,&
       T0_roof,&
       T0_ground,&
       T0_ibld,&
       WS,&           !Wind speed used in ESTM
       xvf_wall,&
       ZREF,&         !local scale reference height
       zvf_ground,&   !wall view factor from ground
       zvf_WALL     !wall view factor from ground

  ! Arrays to store variables for each grid
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: Tair2_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: lup_ground_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: lup_wall_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: lup_roof_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: Tievolve_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: T0_wall_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: T0_roof_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: T0_ground_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: T0_ibld_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: TN_roof_grids
  REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE:: TN_wall_grids

  ! Surface fractions for ESTM classes
  REAL(KIND(1d0)),DIMENSION(3):: ESTMsfr_Paved
  REAL(KIND(1d0)),DIMENSION(5):: ESTMsfr_Bldgs

  LOGICAL             ::bctype(2),&
       CFLfail=.FALSE.,&
       diagnoseTi=.FALSE.,&
       first,&
       HVAC=.FALSE.,&
       SPINDONE=.FALSE.

  REAL(KIND(1d0)),PARAMETER::alb_wall=0.23,em_wall=0.9  ! used only when radforce = T but radforce is always set to F.
  INTEGER, PARAMETER::        maxiter=100
  REAL(KIND(1d0)),PARAMETER:: conv=0.0001

  !=============variables maybe will be removed=======================================
  INTEGER             ::nalb,&
       nemis
  REAL(KIND(1d0))     ::sumalb,&
       sumemis

END MODULE ESTM_data

!----------------------------------------------------------------------------------
MODULE WhereWhen
  ! Stores grid and datetime info

  INTEGER:: GridID   !Grid number (as specified in SUEWS_SiteSelect.txt)
  CHARACTER(LEN=10):: GridID_text !Grid number as a text string
  CHARACTER(LEN=15):: datetime  ! YYYY DOY HH MM

END MODULE WhereWhen

!----------------------------------------------------------------------------------
MODULE MathConstants

  REAL (KIND(1d0)),PARAMETER ::pi=3.14159265359
  REAL (KIND(1d0)),PARAMETER ::dtr=0.0174532925, rtd=57.2957795

END MODULE MathConstants

!----------------------------------------------------------------------------------
MODULE PhysConstants

  REAL (KIND(1d0)),PARAMETER :: C2K = 273.15   !Celsius to Kelvin
  REAL (KIND(1d0)),PARAMETER :: SBConst = 5.67051e-8   !Stefan Boltzmann constant [W m-2 K-4]
  REAL (KIND(1d0)),PARAMETER :: JtoumolPAR = 4.6   ! Convert PAR from W m-2 to umol m-2 s-1
  REAL (KIND(1d0)),PARAMETER :: KdntoPAR = 0.46    ! Conversion from Kdn to PAR, originally from Tsubo and Walker (2005), used in Bellucco et al. (2017)

END MODULE PhysConstants

! curtesy by George via http://gbenthien.net/strings/index.php

module precision

! Real kinds

integer, parameter :: kr4 = selected_real_kind(6,37)       ! single precision real
integer, parameter :: kr8 = selected_real_kind(15,307)     ! double precision real

! Integer kinds

integer, parameter :: ki4 = selected_int_kind(9)           ! single precision integer
integer, parameter :: ki8 = selected_int_kind(18)          ! double precision integer

!Complex kinds

integer, parameter :: kc4 = kr4                            ! single precision complex
integer, parameter :: kc8 = kr8                            ! double precision complex

end module precision


module strings

use precision

private :: value_dr,value_sr,value_di,value_si
private :: write_dr,write_sr,write_di,write_si
private :: writeq_dr,writeq_sr,writeq_di,writeq_si

interface value  ! Generic operator for converting a number string to a
                 ! number. Calling syntax is 'call value(numstring,number,ios)'
                 ! where 'numstring' is a number string and 'number' is a
                 ! real number or an integer (single or double precision).
   module procedure value_dr
   module procedure value_sr
   module procedure value_di
   module procedure value_si
end interface

interface writenum  ! Generic  interface for writing a number to a string. The
                    ! number is left justified in the string. The calling syntax
                    ! is 'call writenum(number,string,format)' where 'number' is
                    ! a real number or an integer, 'string' is a character string
                    ! containing the result, and 'format' is the format desired,
                    ! e.g., 'e15.6' or 'i5'.
   module procedure write_dr
   module procedure write_sr
   module procedure write_di
   module procedure write_si
end interface

interface writeq  ! Generic interface equating a name to a numerical value. The
                  ! calling syntax is 'call writeq(unit,name,value,format)' where
                  ! unit is the integer output unit number, 'name' is the variable
                  ! name, 'value' is the real or integer value of the variable,
                  ! and 'format' is the format of the value. The result written to
                  ! the output unit has the form <name> = <value>.
   module procedure writeq_dr
   module procedure writeq_sr
   module procedure writeq_di
   module procedure writeq_si
end interface


!**********************************************************************

contains

!**********************************************************************

subroutine parse(str,delims,args,nargs)

! Parses the string 'str' into arguments args(1), ..., args(nargs) based on
! the delimiters contained in the string 'delims'. Preceding a delimiter in
! 'str' by a backslash (\) makes this particular instance not a delimiter.
! The integer output variable nargs contains the number of arguments found.

character(len=*) :: str,delims
character(len=len_trim(str)) :: strsav
character(len=*),dimension(:) :: args

strsav=str
call compact(str)
na=size(args)
do i=1,na
  args(i)=' '
end do
nargs=0
lenstr=len_trim(str)
if(lenstr==0) return
k=0

do
   if(len_trim(str) == 0) exit
   nargs=nargs+1
   call split(str,delims,args(nargs))
   call removebksl(args(nargs))
end do
str=strsav

end subroutine parse

!**********************************************************************

subroutine compact(str)

! Converts multiple spaces and tabs to single spaces; deletes control characters;
! removes initial spaces.

character(len=*):: str
character(len=1):: ch
character(len=len_trim(str)):: outstr

str=adjustl(str)
lenstr=len_trim(str)
outstr=' '
isp=0
k=0

do i=1,lenstr
  ch=str(i:i)
  ich=iachar(ch)

  select case(ich)

    case(9,32)     ! space or tab character
      if(isp==0) then
        k=k+1
        outstr(k:k)=' '
      end if
      isp=1

    case(33:)      ! not a space, quote, or control character
      k=k+1
      outstr(k:k)=ch
      isp=0

  end select

end do

str=adjustl(outstr)

end subroutine compact

!**********************************************************************

subroutine removesp(str)

! Removes spaces, tabs, and control characters in string str

character(len=*):: str
character(len=1):: ch
character(len=len_trim(str))::outstr

str=adjustl(str)
lenstr=len_trim(str)
outstr=' '
k=0

do i=1,lenstr
  ch=str(i:i)
  ich=iachar(ch)
  select case(ich)
    case(0:32)  ! space, tab, or control character
         cycle
    case(33:)
      k=k+1
      outstr(k:k)=ch
  end select
end do

str=adjustl(outstr)

end subroutine removesp

!**********************************************************************

subroutine value_dr(str,rnum,ios)

! Converts number string to a double precision real number

character(len=*)::str
real(kr8)::rnum
integer :: ios

ilen=len_trim(str)
ipos=scan(str,'Ee')
if(.not.is_digit(str(ilen:ilen)) .and. ipos/=0) then
   ios=3
   return
end if
read(str,*,iostat=ios) rnum

end subroutine value_dr

!**********************************************************************

subroutine value_sr(str,rnum,ios)

! Converts number string to a single precision real number

character(len=*)::str
real(kr4) :: rnum
real(kr8) :: rnumd

call value_dr(str,rnumd,ios)
if( abs(rnumd) > huge(rnum) ) then
  ios=15
  return
end if
if( abs(rnumd) < tiny(rnum) ) rnum=0.0_kr4
rnum=real(rnumd,kr4)

end subroutine value_sr

!**********************************************************************

subroutine value_di(str,inum,ios)

! Converts number string to a double precision integer value

character(len=*)::str
integer(ki8) :: inum
real(kr8) :: rnum

call value_dr(str,rnum,ios)
if(abs(rnum)>huge(real(inum,kr8))) then
  ios=15
  return
end if
inum=nint(rnum,ki8)

end subroutine value_di

!**********************************************************************

subroutine value_si(str,inum,ios)

! Converts number string to a single precision integer value

character(len=*)::str
integer(ki4) :: inum
real(kr8) :: rnum

call value_dr(str,rnum,ios)
if(abs(rnum)>huge(inum)) then
  ios=15
  return
end if
inum=nint(rnum,ki4)

end subroutine value_si

!**********************************************************************

subroutine shiftstr(str,n)

! Shifts characters in in the string 'str' n positions (positive values
! denote a right shift and negative values denote a left shift). Characters
! that are shifted off the end are lost. Positions opened up by the shift
! are replaced by spaces.

character(len=*):: str

lenstr=len(str)
nabs=iabs(n)
if(nabs>=lenstr) then
  str=repeat(' ',lenstr)
  return
end if
if(n<0) str=str(nabs+1:)//repeat(' ',nabs)  ! shift left
if(n>0) str=repeat(' ',nabs)//str(:lenstr-nabs)  ! shift right
return

end subroutine shiftstr

!**********************************************************************

subroutine insertstr(str,strins,loc)

! Inserts the string 'strins' into the string 'str' at position 'loc'.
! Characters in 'str' starting at position 'loc' are shifted right to
! make room for the inserted string. Trailing spaces of 'strins' are
! removed prior to insertion

character(len=*):: str,strins
character(len=len(str))::tempstr

lenstrins=len_trim(strins)
tempstr=str(loc:)
call shiftstr(tempstr,lenstrins)
tempstr(1:lenstrins)=strins(1:lenstrins)
str(loc:)=tempstr
return

end subroutine insertstr

!**********************************************************************

subroutine delsubstr(str,substr)

! Deletes first occurrence of substring 'substr' from string 'str' and
! shifts characters left to fill hole. Trailing spaces or blanks are
! not considered part of 'substr'.

character(len=*):: str,substr

lensubstr=len_trim(substr)
ipos=index(str,substr)
if(ipos==0) return
if(ipos == 1) then
   str=str(lensubstr+1:)
else
   str=str(:ipos-1)//str(ipos+lensubstr:)
end if
return

end subroutine delsubstr

!**********************************************************************

subroutine delall(str,substr)

! Deletes all occurrences of substring 'substr' from string 'str' and
! shifts characters left to fill holes.

character(len=*):: str,substr

lensubstr=len_trim(substr)
do
   ipos=index(str,substr)
   if(ipos == 0) exit
   if(ipos == 1) then
      str=str(lensubstr+1:)
   else
      str=str(:ipos-1)//str(ipos+lensubstr:)
   end if
end do
return

end subroutine delall

!**********************************************************************

function uppercase(str) result(ucstr)

! convert string to upper case

character (len=*):: str
character (len=len_trim(str)):: ucstr

ilen=len_trim(str)
ioffset=iachar('A')-iachar('a')
iquote=0
ucstr=str
do i=1,ilen
  iav=iachar(str(i:i))
  if(iquote==0 .and. (iav==34 .or.iav==39)) then
    iquote=1
    iqc=iav
    cycle
  end if
  if(iquote==1 .and. iav==iqc) then
    iquote=0
    cycle
  end if
  if (iquote==1) cycle
  if(iav >= iachar('a') .and. iav <= iachar('z')) then
    ucstr(i:i)=achar(iav+ioffset)
  else
    ucstr(i:i)=str(i:i)
  end if
end do
return

end function uppercase

!**********************************************************************

function lowercase(str) result(lcstr)

! convert string to lower case

character (len=*):: str
character (len=len_trim(str)):: lcstr

ilen=len_trim(str)
ioffset=iachar('A')-iachar('a')
iquote=0
lcstr=str
do i=1,ilen
  iav=iachar(str(i:i))
  if(iquote==0 .and. (iav==34 .or.iav==39)) then
    iquote=1
    iqc=iav
    cycle
  end if
  if(iquote==1 .and. iav==iqc) then
    iquote=0
    cycle
  end if
  if (iquote==1) cycle
  if(iav >= iachar('A') .and. iav <= iachar('Z')) then
    lcstr(i:i)=achar(iav-ioffset)
  else
    lcstr(i:i)=str(i:i)
  end if
end do
return

end function lowercase

!**********************************************************************

subroutine readline(nunitr,line,ios)

! Reads line from unit=nunitr, ignoring blank lines
! and deleting comments beginning with an exclamation point(!)

character (len=*):: line

do
  read(nunitr,'(a)', iostat=ios) line      ! read input line
  if(ios /= 0) return
  line=adjustl(line)
  ipos=index(line,'!')
  if(ipos == 1) cycle
  if(ipos /= 0) line=line(:ipos-1)
  if(len_trim(line) /= 0) exit
end do
return

end subroutine readline

!**********************************************************************

subroutine match(str,ipos,imatch)

! Sets imatch to the position in string of the delimiter matching the delimiter
! in position ipos. Allowable delimiters are (), [], {}, <>.

character(len=*) :: str
character :: delim1,delim2,ch

lenstr=len_trim(str)
delim1=str(ipos:ipos)
select case(delim1)
   case('(')
      idelim2=iachar(delim1)+1
      istart=ipos+1
      iend=lenstr
      inc=1
   case(')')
      idelim2=iachar(delim1)-1
      istart=ipos-1
      iend=1
      inc=-1
   case('[','{','<')
      idelim2=iachar(delim1)+2
      istart=ipos+1
      iend=lenstr
      inc=1
   case(']','}','>')
      idelim2=iachar(delim1)-2
      istart=ipos-1
      iend=1
      inc=-1
   case default
      write(*,*) delim1,' is not a valid delimiter'
      return
end select
if(istart < 1 .or. istart > lenstr) then
   write(*,*) delim1,' has no matching delimiter'
   return
end if
delim2=achar(idelim2) ! matching delimiter

isum=1
do i=istart,iend,inc
   ch=str(i:i)
   if(ch /= delim1 .and. ch /= delim2) cycle
   if(ch == delim1) isum=isum+1
   if(ch == delim2) isum=isum-1
   if(isum == 0) exit
end do
if(isum /= 0) then
   write(*,*) delim1,' has no matching delimiter'
   return
end if
imatch=i

return

end subroutine match

!**********************************************************************

subroutine write_dr(rnum,str,fmt)

! Writes double precision real number rnum to string str using format fmt

real(kr8) :: rnum
character(len=*) :: str,fmt
character(len=80) :: formt

formt='('//trim(fmt)//')'
write(str,formt) rnum
str=adjustl(str)

end subroutine write_dr

!***********************************************************************

subroutine write_sr(rnum,str,fmt)

! Writes single precision real number rnum to string str using format fmt

real(kr4) :: rnum
character(len=*) :: str,fmt
character(len=80) :: formt

formt='('//trim(fmt)//')'
write(str,formt) rnum
str=adjustl(str)

end subroutine write_sr

!***********************************************************************

subroutine write_di(inum,str,fmt)

! Writes double precision integer inum to string str using format fmt

integer(ki8) :: inum
character(len=*) :: str,fmt
character(len=80) :: formt

formt='('//trim(fmt)//')'
write(str,formt) inum
str=adjustl(str)

end subroutine write_di

!***********************************************************************

subroutine write_si(inum,str,fmt)

! Writes single precision integer inum to string str using format fmt

integer(ki4) :: inum
character(len=*) :: str,fmt
character(len=80) :: formt

formt='('//trim(fmt)//')'
write(str,formt) inum
str=adjustl(str)

end subroutine write_si

!***********************************************************************

subroutine trimzero(str)

! Deletes nonsignificant trailing zeroes from number string str. If number
! string ends in a decimal point, one trailing zero is added.

character(len=*) :: str
character :: ch
character(len=10) :: exp

ipos=scan(str,'eE')
if(ipos>0) then
   exp=str(ipos:)
   str=str(1:ipos-1)
endif
lstr=len_trim(str)
do i=lstr,1,-1
   ch=str(i:i)
   if(ch=='0') cycle
   if(ch=='.') then
      str=str(1:i)//'0'
      if(ipos>0) str=trim(str)//trim(exp)
      exit
   endif
   str=str(1:i)
   exit
end do
if(ipos>0) str=trim(str)//trim(exp)

end subroutine trimzero

!**********************************************************************

subroutine writeq_dr(unit,namestr,value,fmt)

! Writes a string of the form <name> = value to unit

real(kr8) :: value
integer :: unit
character(len=*) :: namestr,fmt
character(len=32) :: tempstr

call writenum(value,tempstr,fmt)
call trimzero(tempstr)
write(unit,*) trim(namestr)//' = '//trim(tempstr)

end subroutine writeq_dr

!**********************************************************************

subroutine writeq_sr(unit,namestr,value,fmt)

! Writes a string of the form <name> = value to unit

real(kr4) :: value
integer :: unit
character(len=*) :: namestr,fmt
character(len=32) :: tempstr

call writenum(value,tempstr,fmt)
call trimzero(tempstr)
write(unit,*) trim(namestr)//' = '//trim(tempstr)

end subroutine writeq_sr

!**********************************************************************

subroutine writeq_di(unit,namestr,ivalue,fmt)

! Writes a string of the form <name> = ivalue to unit

integer(ki8) :: ivalue
integer :: unit
character(len=*) :: namestr,fmt
character(len=32) :: tempstr
call writenum(ivalue,tempstr,fmt)
call trimzero(tempstr)
write(unit,*) trim(namestr)//' = '//trim(tempstr)

end subroutine writeq_di

!**********************************************************************

subroutine writeq_si(unit,namestr,ivalue,fmt)

! Writes a string of the form <name> = ivalue to unit

integer(ki4) :: ivalue
integer :: unit
character(len=*) :: namestr,fmt
character(len=32) :: tempstr
call writenum(ivalue,tempstr,fmt)
call trimzero(tempstr)
write(unit,*) trim(namestr)//' = '//trim(tempstr)

end subroutine writeq_si

!**********************************************************************

function is_letter(ch) result(res)

! Returns .true. if ch is a letter and .false. otherwise

character :: ch
logical :: res

select case(ch)
case('A':'Z','a':'z')
  res=.true.
case default
  res=.false.
end select
return

end function is_letter

!**********************************************************************

function is_digit(ch) result(res)

! Returns .true. if ch is a digit (0,1,...,9) and .false. otherwise

character :: ch
logical :: res

select case(ch)
case('0':'9')
  res=.true.
case default
  res=.false.
end select
return

end function is_digit

!**********************************************************************

subroutine split(str,delims,before,sep)

! Routine finds the first instance of a character from 'delims' in the
! the string 'str'. The characters before the found delimiter are
! output in 'before'. The characters after the found delimiter are
! output in 'str'. The optional output character 'sep' contains the
! found delimiter. A delimiter in 'str' is treated like an ordinary
! character if it is preceded by a backslash (\). If the backslash
! character is desired in 'str', then precede it with another backslash.

character(len=*) :: str,delims,before
character,optional :: sep
logical :: pres
character :: ch,cha

pres=present(sep)
str=adjustl(str)
call compact(str)
lenstr=len_trim(str)
if(lenstr == 0) return        ! string str is empty
k=0
ibsl=0                        ! backslash initially inactive
before=' '
do i=1,lenstr
   ch=str(i:i)
   if(ibsl == 1) then          ! backslash active
      k=k+1
      before(k:k)=ch
      ibsl=0
      cycle
   end if
   if(ch == '\') then          ! backslash with backslash inactive
      k=k+1
      before(k:k)=ch
      ibsl=1
      cycle
   end if
   ipos=index(delims,ch)
   if(ipos == 0) then          ! character is not a delimiter
      k=k+1
      before(k:k)=ch
      cycle
   end if
   if(ch /= ' ') then          ! character is a delimiter that is not a space
      str=str(i+1:)
      if(pres) sep=ch
      exit
   end if
   cha=str(i+1:i+1)            ! character is a space delimiter
   iposa=index(delims,cha)
   if(iposa > 0) then          ! next character is a delimiter
      str=str(i+2:)
      if(pres) sep=cha
      exit
   else
      str=str(i+1:)
      if(pres) sep=ch
      exit
   end if
end do
if(i >= lenstr) str=''
str=adjustl(str)              ! remove initial spaces
return

end subroutine split

!**********************************************************************

subroutine removebksl(str)

! Removes backslash (\) characters. Double backslashes (\\) are replaced
! by a single backslash.

character(len=*):: str
character(len=1):: ch
character(len=len_trim(str))::outstr

str=adjustl(str)
lenstr=len_trim(str)
outstr=' '
k=0
ibsl=0                        ! backslash initially inactive

do i=1,lenstr
  ch=str(i:i)
  if(ibsl == 1) then          ! backslash active
   k=k+1
   outstr(k:k)=ch
   ibsl=0
   cycle
  end if
  if(ch == '\') then          ! backslash with backslash inactive
   ibsl=1
   cycle
  end if
  k=k+1
  outstr(k:k)=ch              ! non-backslash with backslash inactive
end do

str=adjustl(outstr)

end subroutine removebksl

!**********************************************************************

end module strings

! Recursive Fortran 95 quicksort routine
! sorts real numbers into ascending numerical order
! Author: Juli Rew, SCD Consulting (juliana@ucar.edu), 9/03
! Based on algorithm from Cormen et al., Introduction to Algorithms,
! 1997 printing

! Made F conformant by Walt Brainerd


MODULE qsort_c_module

  IMPLICIT NONE
  PUBLIC :: QsortC
  PRIVATE :: Partition

CONTAINS

  RECURSIVE SUBROUTINE QsortC(A)
    REAL, INTENT(in out), DIMENSION(:) :: A
    INTEGER :: iq

    IF(SIZE(A) > 1) THEN
       CALL Partition(A, iq)
       CALL QsortC(A(:iq-1))
       CALL QsortC(A(iq:))
    ENDIF
  END SUBROUTINE QsortC

  SUBROUTINE Partition(A, marker)
    REAL, INTENT(in out), DIMENSION(:) :: A
    INTEGER, INTENT(out) :: marker
    INTEGER :: i, j
    REAL :: temp
    REAL :: x      ! pivot point
    x = A(1)
    i= 0
    j= SIZE(A) + 1

    DO
       j = j-1
       DO
          IF (A(j) <= x) EXIT
          j = j-1
       END DO
       i = i+1
       DO
          IF (A(i) >= x) EXIT
          i = i+1
       END DO
       IF (i < j) THEN
          ! exchange A(i) and A(j)
          temp = A(i)
          A(i) = A(j)
          A(j) = temp
       ELSEIF (i == j) THEN
          marker = i+1
          RETURN
       ELSE
          marker = i
          RETURN
       ENDIF
    END DO

  END SUBROUTINE Partition

END MODULE qsort_c_module

! subroutines included:
! day2month
!
! month2day
! leapYearCalc
!       returns -- number of days in actual year
!    	used    -- LUMPS phenology (initalization)
!
! DayofWeek
!       returns -- day of week
!       used    -- for water use and anthropogenic heat
!
! dectime_to_timevec
!       This subroutine converts dectime to individual
!       hours, minutes and seconds
!
! daylen
!       Computes solar day length
!
!sg feb 2012 - moved all time related subroutines together
!===============================================================================


SUBROUTINE day2month(b,mb,md,seas,year,latitude)
  IMPLICIT NONE
  INTEGER,INTENT(in) ::b  !b=doy   --IN
  INTEGER,INTENT(out) ::mb !month=mb  --OUT
  INTEGER,INTENT(out) ::md !date=md --OUT
  INTEGER,INTENT(out) ::seas
  INTEGER,INTENT(in) ::year
  INTEGER::t1,t2,t3
  INTEGER::k ! k- accounts for leap year

  REAL (KIND(1d0))::latitude

  !Corrected and calculation of date added LJ (Jun 2010)

  t1=4
  t2=100
  t3=400

  IF ((MODULO(year,t1)==0).AND.(MODULO(year,t2)/=0).OR.(MODULO(year,t3)==0)) THEN
     K=1
  ELSE
     K=0
  ENDIF

  IF(B<=31) THEN !January
     MB=1
     md=B
  ELSEIF(B>31 .AND. B<=59+K) THEN
     MB=2
     md=B-31
  ELSEIF(B>59+K .AND. B<=90+K) THEN
     MB=3
     md=B-(59+K)
  ELSEIF(B>90+K .AND. B<=120+K) THEN
     MB=4
     md=B-(90+K)
  ELSEIF(B>120+K .AND. B<=151+K) THEN
     MB=5
     md=B-(120+K)
  ELSEIF(B>151+K .AND. B<=181+K) THEN
     MB=6
     md=B-(151+K)
  ELSEIF(B>181+K .AND. B<=212+K) THEN
     MB=7
     md=B-(181+K)
  ELSEIF(B>212+K .AND. B<=243+K) THEN
     MB=8
     md=B-(212+K)
  ELSEIF(B>243+K .AND. B<=273+K) THEN
     MB=9
     md=B-(243+K)
  ELSEIF(B>273+K .AND. B<=304+K)THEN
     MB=10
     md=B-(273+K)
  ELSEIF(B>304+K .AND. B<=334+K) THEN
     MB=11
     md=B-(304+K)
  ELSEIF(B>334+K) THEN
     MB=12
     md=B-(334+K)
  ENDIF

  !
  IF(latitude>0)THEN  ! Northern Hemisphere
     IF (mb>3 .AND. mb<10) THEN !Summer is from Apr to Sep
        seas=1
     ELSE
        seas=2 !Winter rest of the months
     ENDIF
  ELSE  ! southern hemisphere
     IF (mb<4 .OR. mb>9) THEN !Summer is from Oct to Mar
        seas=1
     ELSE
        seas=2 !Winter rest of the months
     ENDIF
  ENDIF
  RETURN
END  SUBROUTINE day2month
!===============================================================================
SUBROUTINE month2day(mon,ne,k,b)
  IMPLICIT NONE
  INTEGER:: mon,ne,k,b

  IF(mon== 1)THEN
     NE=32-B
  ELSE IF(mon==2)THEN
     NE=60+K-B
  ELSE IF(mon==3)THEN
     NE=91+K-B
  ELSE IF(mon==4)THEN
     NE=121+K-B
  ELSE IF(mon==5) THEN
     NE=152+K-B
  ELSE IF(mon==6) THEN
     NE=182+K-B
  ELSE IF(mon==7)THEN
     NE=213+K-B
  ELSE IF(mon==8) THEN
     NE=244+K-B
     !**********PAGE 151 STARTS HERE**************
  ELSE IF(mon==9)THEN
     NE=274+K-B
  ELSE IF(mon==10) THEN
     NE=305+K-B
  ELSE IF(mon==11) THEN
     NE=335+K-B
  ELSE IF(mon==12)THEN
     NE=366+K-B
  END IF
END SUBROUTINE month2day
!===============================================================================
!Defines the number or days in each year (defines the leap year)
SUBROUTINE LeapYearCalc(year_int,nroDays)

  IMPLICIT NONE

  INTEGER :: nroDays,year_int

  IF(MOD(year_int,100)/=0.AND.MOD(year_int,4)==0) THEN
     nroDays=366
  ELSEIF(MOD(year_int,400)==0) THEN
     nroDays=366
  ELSE
     nroDays=365
  ENDIF
END SUBROUTINE LeapYearCalc

!===============================================================================
!Defines the number or days in each year (defines the leap year)
! Ting Sun 09 May 2018
ELEMENTAL FUNCTION Days_of_Year(year_int) RESULT(nDays)
  IMPLICIT NONE
  INTEGER,INTENT(in) :: year_int
  INTEGER :: nDays

  IF(MOD(year_int,100)/=0.AND.MOD(year_int,4)==0) THEN
     nDays=366
  ELSEIF(MOD(year_int,400)==0) THEN
     nDays=366
  ELSE
     nDays=365
  ENDIF

END FUNCTION Days_of_Year


!===============================================================================

SUBROUTINE Day_Of_Week(DATE, MONTH, YEAR, DOW)
  ! Calculate weekday from year, month and day information.
  ! DOW: Sunday=1,...Saturday=7
  ! YEAR fixed to integer, LJ March 2015

  IMPLICIT NONE

  INTEGER DATE, MONTH, DAY, YR, MN, N1, N2, DOW, YEAR

  YR = YEAR
  MN = MONTH

  !C
  !C       IF JANUARY OR FEBRUARY, ADJUST MONTH AND YEAR
  !C
  IF (MN>2)GO TO 10
  MN = MN + 12
  YR = YR - 1
10 N1 = (26 * (MN + 1)) / 10
  N2 = (125 * YR) / 100
  DAY = (DATE + N1 + N2 - (YR / 100) + (YR / 400) - 1)
  DOW = MOD(DAY, 7) + 1

  RETURN
END SUBROUTINE Day_Of_Week

!===============================================================================

!FL
SUBROUTINE dectime_to_timevec(dectime,HOURS,MINS,SECS)
  !This subroutine converts dectime to individual
  !hours, minutes and seconds
  INTEGER :: HOURS, MINS, doy
  REAL(KIND(1d0))    :: dectime,SECS,DH,DM,DS
  !INTEGER :: year

  doy=FLOOR(dectime)

  DH=dectime-doy !Decimal hours
  HOURS=INT(24*DH)

  DM=24*DH-HOURS !Decimal minutes
  MINS=INT(60*DM)

  DS=60*DM-MINS
  SECS=INT(60*DS)

END SUBROUTINE dectime_to_timevec

!==============================================================================

!FL
!=======================================================================
!  DAYLEN, Real Function, N.B. Pickering, 09/23/1993
!  Computes solar day length (Spitters, 1986).
!=======================================================================

SUBROUTINE DAYLEN(DOY, XLAT,DAYL, DEC, SNDN, SNUP)
  !-----------------------------------------------------------------------
  IMPLICIT NONE
  INTEGER :: DOY
  REAL(KIND(1d0)) :: DEC,DAYL,SOC,SNDN,SNUP,XLAT
  REAL(KIND(1d0)),PARAMETER :: PI=3.14159, RAD=PI/180.0

  !-----------------------------------------------------------------------
  !     Calculation of declination of sun (Eqn. 16). Amplitude= +/-23.45
  !     deg. Minimum = DOY 355 (DEC 21), maximum = DOY 172.5 (JUN 21/22).
  DEC = -23.45 * COS(2.0*PI*(DOY+10.0)/365.0)

  !     Sun angles.  SOC limited for latitudes above polar circles.
  SOC = TAN(RAD*DEC) * TAN(RAD*XLAT)
  SOC = MIN(MAX(SOC,-1.0),1.0)

  !     Calculate daylength, sunrise and sunset (Eqn. 17)
  DAYL = 12.0 + 24.0*ASIN(SOC)/PI
  SNUP = 12.0 - DAYL/2.0
  SNDN = 12.0 + DAYL/2.0

END SUBROUTINE DAYLEN

!=======================================================================
! DAYLEN Variables
!-----------------------------------------------------------------------
! DAYL  Day length on day of simulation (from sunrise to sunset)  (hr)
! DEC   Solar declination or (90o - solar elevation at noon) (deg.)
! DOY   Day of year (d)
! PI    PI=3.14159 (rad)
! RAD   RAD=PI/180. (rad./deg.)
! SNDN  Time of sunset (hr)
! SNUP  Time of sunrise (hr)
! SOC   Sine over cosine (intermediate calculation)
! XLAT  Latitude (deg.)
!=======================================================================



  ! Calculate dectime
  SUBROUTINE SUEWS_cal_dectime(&
       id,it,imin,isec,& ! input
       dectime) ! output
    IMPLICIT NONE
    INTEGER,INTENT(in)::id,it,imin,isec


    REAL(KIND(1D0)),INTENT(out)::dectime ! nsh in type real

    dectime = REAL(id-1,KIND(1d0))&
    +REAL(it,KIND(1d0))/24&
    +REAL(imin,KIND(1d0))/(60*24)&
    +REAL(isec,KIND(1d0))/(60*60*24)

  END SUBROUTINE SUEWS_cal_dectime


  ! Calculate tstep-derived variables
  SUBROUTINE SUEWS_cal_tstep(&
       tstep,& ! input
       nsh, nsh_real, tstep_real) ! output
    IMPLICIT NONE
    INTEGER,INTENT(in)::tstep ! number of timesteps per hour
    ! values that are derived from tstep
    INTEGER,INTENT(out)::nsh ! number of timesteps per hour
    REAL(KIND(1D0)),INTENT(out)::nsh_real ! nsh in type real
    REAL(KIND(1D0)),INTENT(out)::tstep_real ! tstep in type real
    nsh=3600/tstep
    nsh_real=nsh*1.0
    tstep_real=tstep*1.0

  END SUBROUTINE SUEWS_cal_tstep




  SUBROUTINE SUEWS_cal_weekday(&
       iy,id,lat,& !input
       dayofWeek_id) !output
    IMPLICIT NONE

    INTEGER,INTENT(in) :: iy  ! year
    INTEGER,INTENT(in) :: id  ! day of year
    REAL(KIND(1d0)),INTENT(in):: lat

    INTEGER,DIMENSION(3),INTENT(OUT) ::dayofWeek_id

    INTEGER::wd
    INTEGER::mb
    INTEGER::date
    INTEGER::seas



    CALL day2month(id,mb,date,seas,iy,lat) !Calculate real date from doy
    CALL Day_of_Week(date,mb,iy,wd)        !Calculate weekday (1=Sun, ..., 7=Sat)

    dayofWeek_id(1)=wd      !Day of week
    dayofWeek_id(2)=mb      !Month
    dayofweek_id(3)=seas    !Season

  END SUBROUTINE SUEWS_cal_weekday


  SUBROUTINE SUEWS_cal_DLS(&
       id,startDLS,endDLS,& !input
       DLS) !output
    IMPLICIT NONE

    INTEGER, INTENT(in) :: id,startDLS,endDLS
    INTEGER, INTENT(out) :: DLS

    DLS=0
    IF ( id>startDLS .AND. id<endDLS ) dls=1

  END SUBROUTINE SUEWS_cal_DLS

!===================================================================================
MODULE METEO

  USE MathConstants
  IMPLICIT NONE

  ! REAL (KIND(1d0)),PARAMETER ::  PI=3.141592654
  REAL (KIND(1d0)),PARAMETER ::  RAD2DEG=57.29577951
  REAL (KIND(1d0)),PARAMETER ::  DEG2RAD=0.017453292

  REAL (KIND(1d0)),PARAMETER ::  MOLMASS_AIR=0.028965             ! kg for 1 mol dry air
  REAL (KIND(1d0)),PARAMETER ::  MOLMASS_CO2=0.04401              ! kg for 1 mol CO2
  REAL (KIND(1d0)),PARAMETER ::  MOLMASS_H2O=0.0180153            ! kg for 1 mol water vapor
  REAL (KIND(1d0)),PARAMETER ::  MU_H2O=MOLMASS_AIR/MOLMASS_H2O   ! mol air/mol H2O
  REAL (KIND(1d0)),PARAMETER ::  MU_CO2=MOLMASS_AIR/MOLMASS_CO2   ! mol air/mol CO2
  REAL (KIND(1d0)),PARAMETER ::  R_DRY_MOL=8.31451                ! J/K/mol gas constant
  REAL (KIND(1D0)),PARAMETER ::  R_DRY_MASS=R_DRY_MOL/MOLMASS_AIR ! J/K/kg GAS CONSTANT
  !REAL (KIND(1d0)),PARAMETER ::  SIGMA_SB=5.67051e-8              ! Stefan-Boltzmann constant
  REAL (KIND(1d0)),PARAMETER ::  EPSIL=0.62197
  REAL (KIND(1d0)),PARAMETER ::  KB=1.3807E-25                    ! BOLTZMANN'S CONSTANT (m^3 MB K^-1)=R/A
  REAL (KIND(1d0)),PARAMETER ::  AVOGADRO=6.02252E23              ! AVOGADRO'S NUMBER (molecules/mol)

CONTAINS

  !============================================================================
  FUNCTION sat_vap_press(TK,P) RESULT(es)
    !c sg sept 99 f90
    !c     This uses eqns from Buck (1981) JAM 20, 1527-1532
    !c     units T (K) e (mb) P (mb)
    !c     f corrects for the fact that we are not dealing with pure water
    REAL(KIND(1d0))    :: TK,P,TC,es,e,f
    TC=TK-273.15
    IF(TC==0)THEN
       TC=0.001
    ENDIF
    !Valid for 50>T>-40
    e=6.1121*EXP(((18.729-TC/227.3)*TC)/(TC+257.87))
    f=1.00072+P*(3.2E-6+5.9E-10*TC**2)
    es=e*f
  END FUNCTION sat_vap_press

  REAL(KIND(1d0)) FUNCTION SOS_DRYAIR(TK)
    !SPEED OF SOUND IN DRY AIR, BEER (1991)
    REAL(KIND(1d0)) ::TK
    SOS_DRYAIR=SQRT(1.4*R_DRY_MOL*TK/(MOLMASS_AIR*1000.))
  END FUNCTION SOS_DRYAIR
  !============================================================================
  REAL(KIND(1d0)) FUNCTION POTENTIAL_TEMP(TK,P)
    !TK = ABSOLUTE TEMPERATURE
    !P  = PRESS (hPa)
    REAL(KIND(1d0))    ::TK,P
    POTENTIAL_TEMP=TK*(1000./P)**0.286
  END FUNCTION POTENTIAL_TEMP

  REAL(KIND(1d0)) FUNCTION LATENTHEAT_V(TK)
    !LATENT HEAT OF VAPORIZATION (J/kg) BOLTON(1980)
    !TK = ABSOLUTE TEMPERATURE
    REAL(KIND(1d0)) ::TK
    LATENTHEAT_V=2.501E6-2370.*(TK-273.15)
  END FUNCTION LATENTHEAT_V

  REAL(KIND(1d0)) FUNCTION LATENTHEAT_M(TK)
    !LATENT HEAT OF MELTING (J/kg) VALID BELOW 0C BOLTON(1980)
    !TK = ABSOLUTE TEMPERATURE
    REAL(KIND(1d0)) ::TK,TC
    TC=TK-273.15
    LATENTHEAT_M=3.3358E5+TC*(2030.-10.46*TC)
  END FUNCTION LATENTHEAT_M

  REAL(KIND(1d0)) FUNCTION SPEC_HEAT_DRYAIR(TK)
    ! BEER (1991) APPLIED ENVIRONMETRICS METEOROLOGICAL TABLES
    REAL(KIND(1d0)) ::TK,TC
    TC=TK-273.15
    SPEC_HEAT_DRYAIR=1005.+((TC+23.15)**2)/3364.
  END FUNCTION SPEC_HEAT_DRYAIR

  REAL(KIND(1d0)) FUNCTION SPEC_HEAT_VAPOR(TK,RH)
    ! BEER (1991) APPLIED ENVIRONMETRICS METEOROLOGICAL TABLES
    REAL(KIND(1d0)) ::TK,TC_100,RH
    TC_100=(TK-273.15)/100.
    SPEC_HEAT_VAPOR=1859.+0.13*RH+(19.3+0.569*RH)*TC_100+(10.+0.5*RH)*TC_100**2
  END FUNCTION SPEC_HEAT_VAPOR

  REAL(KIND(1d0)) FUNCTION HEATCAPACITY_AIR(TK,RH,P)
    REAL(KIND(1d0)) ::TK,RH,P
    REAL(KIND(1d0)) ::RHO_D,RHO_V
    REAL(KIND(1d0)) ::CPD,CPV
    RHO_D=DENSITY_DRYAIR(TK,P)
    RHO_V=DENSITY_VAPOR(TK,RH,P)
    CPD=SPEC_HEAT_DRYAIR(TK)
    CPV=SPEC_HEAT_VAPOR(TK,RH)
    HEATCAPACITY_AIR=RHO_D*CPD+RHO_V*CPV
  END FUNCTION HEATCAPACITY_AIR

  REAL(KIND(1d0)) FUNCTION DENSITY_MOIST(TVK,P)
    ! density of moist air FROM VIRTUAL TEMPERATURE
    !TVK = VIRTUAL TEMPERATURE (K)
    != = PRESSURE (hPa)
    REAL(KIND(1d0)) ::TVK,P
    DENSITY_MOIST=P*100./(R_DRY_MASS*TVK)
  END FUNCTION DENSITY_MOIST

  REAL(KIND(1d0)) FUNCTION DENSITY_VAPOR(TK,RH,P)
    !WATER VAPOR DENSITY
    REAL(KIND(1d0))    ::TK,P,RH,EA
    EA=SAT_VAP_PRESS(TK,P)*RH/100.
    DENSITY_VAPOR=(EA*100.*EPSIL)/(R_DRY_MASS*TK)
  END FUNCTION DENSITY_VAPOR

  REAL(KIND(1d0)) FUNCTION DENSITY_DRYAIR(TK,P)
    REAL(KIND(1d0)) ::TK,P
    DENSITY_DRYAIR=P*100./(R_DRY_MASS*TK)
  END FUNCTION DENSITY_DRYAIR

  REAL(KIND(1d0)) FUNCTION DENSITY_GAS(TK,PP,MOLMASS)
    !DENSITY FOR IDEAL GAS SPECIES GIVEN ITS PARTIAL PRESSURE (hPa) AND MOLAR MASS (kg)
    REAL(KIND(1d0)) ::TK,PP,MOLMASS
    DENSITY_GAS=PP*MOLMASS/(R_DRY_MOL*TK)
  END FUNCTION DENSITY_GAS

  REAL(KIND(1d0)) FUNCTION PARTIAL_PRESSURE(TK,N)
    !PARTIAL PRESSURE OF IDEAL GAS (hPa)
    REAL(KIND(1d0)) ::TK,N !N IS THE NUMBER DENSITY IN mol/m3
    PARTIAL_PRESSURE=N*KB*TK
  END FUNCTION PARTIAL_PRESSURE

  REAL(KIND(1d0)) FUNCTION SCALE_HEIGHT(TK)
    REAL(KIND(1d0)) ::TK
    !SCALE HEIGHT FOR DRY ATMOSPHERE IN km BEER (1991)
    SCALE_HEIGHT=R_DRY_MOL*TK/(MOLMASS_AIR*9.81)
  END FUNCTION SCALE_HEIGHT

  REAL(KIND(1d0)) FUNCTION VAISALA_BRUNT_F(TK)
    !BEER (1991)
    REAL(KIND(1d0)) ::TK
    VAISALA_BRUNT_F=SQRT(0.4/1.4*9.81/SCALE_HEIGHT(TK))
  END FUNCTION VAISALA_BRUNT_F

  !=====================================================================
  ! sg sept 99 f90
  ! Uses eqns from Buck (1981) JAM 20, 1527-1532
  ! units T (deg C) e (mb) P (mb)
  ! f corrects for the fact that we are not dealing with pure water
  ! LJ Feb 2010
  !Changed to use the updated version (Buck research manual, 1996) from Buck (1981)
  !For water different equations in cold and warm temperatures

  FUNCTION sat_vap_press_x(Temp_c,PRESS_hPa,from,dectime) RESULT(es_hPa)
    ! USE time
    ! USE defaultnotUsed
    IMPLICIT NONE

    REAL(KIND(1d0))::temp_C,press_hpa,dectime!,pw
    REAL(KIND(1d0))::e_mb,f,press_kpa,es_hPA
    INTEGER:: from,iv
    INTEGER,PARAMETER::notUsedI=-55

    !If air temperature between -0.001 -
    IF(ABS(temp_C)<0.001000)THEN
       IF(from==1) THEN  ! not from determining Tw
          iv=INT(press_Hpa)
          CALL errorHint(29,'Function sat_vap_press: temp_C, dectime,press_Hpa = ',temp_C, dectime,iv)

       ENDIF
       temp_C=0.001000
    ENDIF

    Press_kPa=Press_hPa/10

    IF(Temp_C<50.AND.Temp_C>-40)THEN
       !e_mb=6.1121*EXP(((18.729-Temp_C/227.3)*Temp_C)/(Temp_C+257.87)) !Old one
       !f=1.00072+Press_hPa*(3.2E-6+5.9D-10*Temp_C**2)

       IF (Temp_C>=0.001000) THEN
          e_mb=6.1121*EXP(((18.678-Temp_C/234.5)*Temp_C)/(Temp_C+257.14))
          f=1.00072+Press_kPa*(3.2E-6+5.9E-10*Temp_C**2)
          es_hPa=e_mb*f

       ELSEIF (Temp_C<=-0.001000) THEN
          e_mb=6.1115*EXP(((23.036-Temp_C/333.7)*Temp_C)/(Temp_C+279.82))
          f=1.00022+Press_kPa*(3.83E-6+6.4E-10*Temp_C**2)
          es_hPa=e_mb*f
       ENDIF

    ELSE
       CALL ErrorHint(28,'FUNCTION sat_vap_press: [Temperature is out of range], Temp_C,dectime',Temp_C,dectime,notUsedI)

    ENDIF

    RETURN
  END FUNCTION sat_vap_press_x


  FUNCTION sat_vap_pressIce(Temp_c,PRESS_hPa,from,dectime) RESULT(es_hPa)
    ! USE time
    ! USE defaultnotUsed
    IMPLICIT NONE

    REAL(KIND(1d0))::e_mb,f,temp_C,press_hpa,press_kpa,es_hPA,dectime!,pw
    INTEGER:: from,iv
    INTEGER,PARAMETER::notUsedI=-55

    !If air temperature between -0.001 -
    IF(ABS(temp_C)<0.001000)THEN
       IF(from==1) THEN  ! not from determining Tw
          iv=INT(press_Hpa)
          CALL errorHint(29,'Function sat_vap_press: temp_C, dectime,press_Hpa = ',temp_C, dectime,iv)

       ENDIF
       temp_C=0.001000
    ENDIF

    Press_kPa=Press_hPa/10

    IF(Temp_C<50.AND.Temp_C>-40)THEN
       e_mb=6.1115*EXP(((23.036-Temp_C/333.7)*Temp_C)/(Temp_C+279.82))
       f=1.00022+Press_kPa*(3.83E-6+6.4E-10*Temp_C**2) !In hPa
       es_hPa=e_mb*f

    ELSE
       CALL ErrorHint(28,'FUNCTION sat_vap_press: [Temperature is out of range], Temp_C,dectime',Temp_C,dectime,notUsedI)

    ENDIF

    RETURN
  END FUNCTION sat_vap_pressIce

  !==========================================================
  !Output: specific humidity deficit in g/kg
  !Input: Dry air density and air pressure in hPa
  FUNCTION spec_hum_def(vpd_hPa,press_hPa) RESULT(dq)
    ! USE gas
    IMPLICIT NONE
    REAL(KIND(1d0))           :: press_hPa,vpd_hPa,dq
    REAL(KIND(1d0)),PARAMETER :: epsil_gkg = 621.97 !ratio molecular weight of water vapor/dry air in g/kg
    dq=epsil_gkg*vpd_hPa/press_hPa ! Phd Thesis II.13 p 196
  END FUNCTION spec_hum_def

  ! ==============================================================================
  FUNCTION spec_heat_beer(Temp_C,rh,rho_v,rho_d) RESULT (cp)
    ! Input: Air temperature, relative humidity, water vapour and dry air densities
    ! Output: heat capacity in units J kg-1 K-1
    ! Reference: Tom Beer, CSIRO, 1990. Applied Environmetrics Meteorological Tables.
    ! Can be found from SG:s office from Atmmos Moist map
    !-------------------------------------------------------------------------------

    ! USE defaultnotUsed
    IMPLICIT NONE

    REAL(KIND(1d0))::cp,cpd,cpm,rho_v,rho_d,rh,temp_C

    !Garratt equation a20 (1992)
    CPd = 1005.0+((Temp_C+23.16)**2)/3364.0 !Changed from 23.15 to 23.16

    !Beer (1990) for water vapor
    cpm = 1859 + 0.13*rH+ (19.3+0.569*rH)*(Temp_C/100.) + &
         (10.+0.5*rH)*(Temp_C/100.)**2

    IF(ABS(rho_d)<0.000100.OR.ABS(rho_v)<0.000100.OR.ABS(rho_d+rho_v)<0.000100)THEN
       CALL ErrorHint(42,'spec-heat_beer',rho_v,rho_d,INT(Temp_C))
    ENDIF

    cp=cpd*(rho_d/(rho_d+rho_v))+cpm*(rho_v/(rho_d+rho_v))

    !   print*,"cp: ",cp,cpd,rho_d,rho_v,cpm,rh
  END FUNCTION spec_heat_beer

  !==========================================================
  !Latent_heat.f sg nov 96
  !sg sep 99 converted f90 FUNCTION
  !Added calcualation of latent heat of sublimation, LJ June 2012

  FUNCTION Lat_vap(Temp_C,Ea_hPa,Press_hPa,cp,dectime) RESULT (lv_J_kg)
    !Input: Air temperature, Water vapour pressure, Air pressure, heat capacity
    !Output: latent heat of vaporization

    ! USE time
    ! USE SnowMod
    ! USE defaultnotUsed

    IMPLICIT NONE
    REAL(KIND(1d0))::cp,lv_J_kg,ea_fix,tw,&
         incr,es_tw,psyc,ea_est,press_hPa,ea_HPa, temp_C,dectime!,Temp_K
    ! REAL(KIND(1d0))::sat_vap_press,psyc_const ! functions

    LOGICAL:: switch1=.FALSE.,switch2=.FALSE.!,debug=.true.
    INTEGER:: ii,from=2
    REAL(KIND(1d0)),PARAMETER::notUsed=-55.55

    ea_fix=ea_hPa
    !if(debug) write(*,*)Temp_C, 'LV'
    !Temp_K=temp_C+273.16

    !lv=1.91846E6*(Temp_K/(Temp_K-33.91))**2

    lv_J_kg=(2500.25-2.365*temp_C)*1000  !First guess for lv in units J/kg


    tw=Temp_C/2.  !First estimate for wet bulb temperature
    incr=3.
    DO ii=1,100
       IF(Press_hPa<900) THEN
          CALL ErrorHint(45,'function Lat_vap',Press_hPA,notUsed,ii)
       ENDIF

       ! if(debug.and.dectime>55.13.and.dectime<55.2)write(35,*)'% 1',Tw

       es_tw=sat_vap_press_x(Tw,Press_hPa,from,dectime)  !Calculate saturation vapour pressure in hPa

       !if(debug.and.dectime>55.13.and.dectime<55.2)write(35,*)'% 2',Tw

       IF(Press_hPa<900) THEN
          CALL ErrorHint(45,'function Lat_vap - 2',Press_hPA,notUsed,ii)
       ENDIF

       psyc=psyc_const(cp,Press_hPa,lv_J_kg) !in units hPa/K

       IF(Press_hPa<900) THEN
          CALL ErrorHint(45,'function Lat _vap -31',Press_hPA,notUsed,ii)
       ENDIF

       ea_est=es_tw-psyc*(temp_C-tw)

       lv_J_kg=(2500.25-2.365*tw)*1e3

       IF(switch1.AND.switch2)THEN
          incr=incr/10.
          switch1=.FALSE.
          switch2=.FALSE.
       ENDIF
       IF(ABS(ea_est-ea_fix)<0.001000)THEN
          RETURN
       ELSEIF(ea_est > ea_fix)THEN
          tw=tw-incr
          switch1=.TRUE.
       ELSEIF(ea_est< ea_fix)THEN
          tw=tw+incr
          switch2=.TRUE.
       ENDIF
    ENDDO

    RETURN
  END FUNCTION Lat_vap


  FUNCTION Lat_vapSublim(Temp_C,Ea_hPa,Press_hPa,cp) RESULT (lvS_J_kg)
    !Input: Air temperature, Water vapour pressure, Air pressure, heat capacity
    !Output: latent heat of sublimation in units J/kg

    ! USE time

    IMPLICIT NONE

    REAL(KIND(1d0))::lvS_J_kg,temp_C,tw,incr,Ea_hPa,Press_hPa,cp
    ! REAL(KIND(1d0))::ea_fix,es_tw,psyc,ea_est,Temp_K
    ! REAL(KIND(1d0))::sat_vap_pressIce,psyc_const ! functions
    ! LOGICAL:: switch1=.FALSE.,switch2=.FALSE.!,debug=.true.
    ! INTEGER:: ii,from=2

    !Latent heat for sublimation
    !From Rogers&Yau (A short course in cloud physics), Wikipedia

    ! ea_fix=ea_hPa

    lvS_J_kg=(2834.1-0.29*temp_C)*1e3 !First guess for Ls in J/kg

    tw=Temp_C/2.  !First estimate for wet bulb temperature
    incr=3.
    Press_hPa=Press_hPa
    Ea_hPa=Ea_hPa
    cp=cp

    !DO ii=1,100

    !    es_tw=sat_vap_pressIce(Tw,Press_hPa,from)  !Calculate saturation vapour pressure in hPa

    ! psyc=psyc_const(cp,Press_hPa,lv_J_kg)

    !   ea_est=es_tw-psyc*(temp_C-tw)
    !  lvS_J_kg=(2834.1-0.29*tw)*1e3

    !   IF(switch1.AND.switch2)THEN
    !      incr=incr/10.
    !     switch1=.FALSE.
    !     switch2=.FALSE.
    !    ENDIF

    !   IF(ABS(ea_est-ea_fix)<0.001)THEN
    !     RETURN
    !   ELSEIF(ea_est > ea_fix)THEN
    !      tw=tw-incr
    !      switch1=.TRUE.
    !   ELSEIF(ea_est< ea_fix)THEN
    !      tw=tw+incr
    !      switch2=.TRUE.
    !    ENDIF
    !   ENDDO

    ! RETURN
  END FUNCTION Lat_vapSublim

  !=====================================================================
  !psyc_const.f   sg   nov 96
  !sg june 99 f90
  !calculate psyc - psychrometic constant Fritschen and Gay (1979)

  FUNCTION psyc_const(cp,Press_hPa,lv_J_kg) RESULT(psyc_hPa) !In units hPa/K
    USE gas

    IMPLICIT NONE
    REAL (KIND(1d0))::cp,lv_J_kg,press_hPa,psyc_hpa

    ! cp for moist air (shuttleworth p 4.13)
    IF(cp*press_hPa<900.OR.lv_J_kg<10000)THEN
       CALL errorHint(19,'in psychrometric constant calculation:  cp [J kg-1 K-1], p [hPa], Lv [J kg-1]',cp,Press_hPa,INT(lv_J_kg))
    ENDIF

    psyc_hPa=(cp*press_hPa)/(epsil*lv_J_kg)
    !    if(debug)write(*,*)psyc_hpa, 'g',cp,press_HPa,lv
    ! LV MJKg-1
    !www.cimis.water.ca.gov/infoEotPmEquation.jsp
    !psyc_hPa=(0.00163*(Press_hPa/10)/LV)*10
    ! write(*,*)psyc_hpa
    !psyc=psyc*100.! convert into Pa
  END FUNCTION psyc_const

  !==========================================================

  FUNCTION dewpoint(ea_hPa) RESULT(Temp_C_dew)
    ! ea = vapor pressure (hPa)
    ! td = dewpoint (oC)
    !calculates dewpoint in degC from
    ! http://www.atd.ucar.edu/weather_fl/dewpoint.html
    !     dewpoint = (237.3 * ln(e_vp/6.1078)) / (17.27 - (ln(e_vp/6.1078)))

    REAL(KIND(1d0))::ea_hPa,temp_C_dew
    Temp_C_dew = (237.3 * LOG(ea_hPa/6.1078)) / (17.27 - (LOG(ea_hPa/6.1078)))
  END FUNCTION dewpoint
  !===============================================================================
  FUNCTION slope_svp(temp_C) RESULT(s_hPa)
    !COEFFICENTS FOR CALCULATING desat/dT
    !Slope of the saturation vapor pressure vst air temperature curve

    IMPLICIT  NONE

    REAL (KIND(1d0)):: b1,b2,b3,b4,b5,b6,b7,S_hPa,temp_C
    B1=4.438099984D-1
    B2=2.857002636D-2
    B3=7.938054040D-4
    B4=1.215215065D-5
    B5=1.036561403D-7
    B6=3.532421810D-10
    B7=-7.090244804D-13

    !     s - slope of saturation vapour pressure curve - Lowe (1977) -T (K)
    !     mb /K
    S_hPa=B1+temp_C*(B2+temp_C*(B3+temp_C*(B4+temp_C*(B5+temp_C*(B6+B7*temp_C)))))
    ! write(*,*)'s',s_hpa,temp_C
    !s_Pa=s_Pa*100  ! Pa/K
    !www.cimis.water.ca.gov/infoEotPmEquation.jsp
    ! s_hPa=(((4099 *(es_hPa/10))/(Temp_C+273.3)**2))*10
    ! if(debug)write(*,*)s_hpa
    RETURN
  END FUNCTION slope_svp

  !===============================================================================
  FUNCTION slopeIce_svp(temp_C) RESULT(s_hPa)
    !COEFFICENTS FOR CALCULATING desat/dT
    !Slope of the saturation vapor pressure vst air temperature curve

    IMPLICIT  NONE

    REAL (KIND(1d0)):: b1,b2,b3,b4,b5,b6,b7,S_hPa,temp_C

    B1=5.030305237D-1
    B2=3.773255020D-2
    B3=1.267995369D-3
    B4=2.477563108D-5
    B5=3.005693132D-7
    B6=2.158542548D-9
    B7=7.131097725D-12

    ! s - slope of saturation vapour pressure curve - Lowe (1977) -T (K)
    ! mb /K
    S_hPa=B1+temp_C*(B2+temp_C*(B3+temp_C*(B4+temp_C*(B5+temp_C*(B6+B7*temp_C)))))

    RETURN
  END FUNCTION slopeIce_svp

  !------------------------------------------------------------------------
  FUNCTION qsatf(T,PMB) RESULT(qsat)
    !       MRR, 1987
    ! AT TEMPERATURE T (DEG C) AND PRESSURE PMB (MB), GET SATURATION SPECIFIC
    !       HUMIDITY (KG/KG) FROM TETEN FORMULA

    REAL (KIND(1D0))::T,es,qsat,PMB

    REAL (KIND(1D0)),PARAMETER::&

                                !Teten coefficients
         A=6.106,&
         B=17.27,&
         C=237.3,&
         molar=0.028965,& !Dry air molar fraction in kg/mol
         molar_wat_vap=0.0180153 !Molar fraction of water vapor in kg/mol


    IF(t>55)THEN
       CALL ErrorHint(34,'Function qsatf',T,0.00D0,-55)
    ENDIF

    ES = A*dEXP(B*T/(C+T))
    qsat = (molar_wat_vap/molar)*ES/PMB!(rmh2o/rmair)*ES/PMB
  END FUNCTION qsatf



  FUNCTION RH2qa(RH,pres_hPa,Ta_degC) RESULT(qa)
    ! convert relative humidity to specific humidity
    ! TS 31 Jul 2018: initial version
    ! Brutasert (2005) section 2.1.2, eqn 2.2, 2.4 and 2.5.
    REAL(KIND(1D0)), INTENT(in) :: RH ! relative humidity in decimal
    REAL(KIND(1D0)), INTENT(in) :: pres_hPa ! atmospheric pressure in hPa
    REAL(KIND(1D0)), INTENT(in) :: Ta_degC ! air temperature in degC

    REAL(KIND(1d0)) ::es ! saturation vapour pressure in hPa
    REAL(KIND(1d0)) ::ea ! vapour pressure in hPa
    REAL(KIND(1d0)) ::qa ! specific humidity in (g kg-1)

    es=sat_vap_press(Ta_degC+273.15,pres_hPa)
    ea=es*RH ! Brutasert (2005) section 2.1.2, eqn 2.3
    qa=0.622*ea/(pres_hPa-0.378*ea)*1000 ! eqn 2.2, 2.4 and 2.5.

  END FUNCTION RH2qa

  FUNCTION qa2RH(qa,pres_hPa,Ta_degC) RESULT(RH)
    ! convert specific humidity to relative humidity
    ! TS 31 Jul 2018: initial version
    ! Brutasert (2005) section 2.1.2, eqn 2.2, 2.4 and 2.5.
    REAL(KIND(1d0)), INTENT(in) :: qa       ! specific humidity in (g kg-1)
    REAL(KIND(1D0)), INTENT(in) :: pres_hPa ! atmospheric pressure in hPa
    REAL(KIND(1D0)), INTENT(in) :: Ta_degC  ! air temperature in degC
    REAL(KIND(1D0))             :: RH       ! relative humidity in decimal

    REAL(KIND(1d0))    ::es ! saturation vapour pressure in hPa
    REAL(KIND(1d0))    ::ea ! vapour pressure in hPa
    REAL(KIND(1d0))    ::qa_kgkg !specific humidity in (kg kg-1)

    qa_kgkg=qa/1000
    es=sat_vap_press(Ta_degC+273.15,pres_hPa)
    ea=500*pres_hPa*qa_kgkg/(311+189*qa_kgkg)
    ! qa=0.622*ea/(pres_hPa-0.378*ea)*1000 ! eqn 2.2, 2.4 and 2.5.
    RH=ea/es ! Brutasert (2005) section 2.1.2, eqn 2.3


  END FUNCTION qa2RH

END MODULE METEO

! Courtesy of wavebitscientific
! https://wavebitscientific.github.io/datetime-fortran/


!
! datetime-fortran - A Fortran library for date and time manipulation
! Copyright (c) 2013-2017, Wavebit Scientific LLC
! All rights reserved.
!
! Licensed under the BSD 3-clause license. See LICENSE for details.
!
module mod_strftime
!=======================================================================
!
! mod_strftime: Interfaces to strftime and strptime procedures from
! from C/C++ standard library.
!
!=======================================================================

use,intrinsic :: iso_c_binding,only:c_char,c_int

implicit none

private

public :: tm_struct
public :: c_strftime
public :: c_strptime

type,bind(c) :: tm_struct

  !! A derived type provided for compatibility with C/C++ time struct.
  !! Allows for calling strftime and strptime procedures through the
  !! iso_c_binding.

  integer(kind=c_int) :: tm_sec   !! Seconds      [0-60] (1 leap second)
  integer(kind=c_int) :: tm_min   !! Minutes      [0-59]
  integer(kind=c_int) :: tm_hour  !! Hours        [0-23]
  integer(kind=c_int) :: tm_mday  !! Day          [1-31]
  integer(kind=c_int) :: tm_mon   !! Month        [0-11]
  integer(kind=c_int) :: tm_year  !! Year - 1900
  integer(kind=c_int) :: tm_wday  !! Day of week  [0-6]
  integer(kind=c_int) :: tm_yday  !! Days in year [0-365]
  integer(kind=c_int) :: tm_isdst !! DST          [-1/0/1]

endtype tm_struct
!=======================================================================



interface

  !! Interface to C procedures strftime and strptime through
  !! iso_c_binding.

  function c_strftime(str,slen,format,tm)&
    bind(c,name='strftime') result(rc)

    !! Returns a formatted time string, given input time struct and
    !! format. Refer to C standard library documentation for more
    !! information.

    import :: c_char,c_int
    import :: tm_struct

    implicit none

    ! Arguments
    character(kind=c_char),dimension(*),intent(out) :: str    !! result string
    integer(kind=c_int),value,          intent(in)  :: slen   !! string length
    character(kind=c_char),dimension(*),intent(in)  :: format !! time format
    type(tm_struct),                    intent(in)  :: tm     !! tm_struct instance
    integer(kind=c_int)                             :: rc     !! return code

  endfunction c_strftime



  function c_strptime(str,format,tm) bind(c,name='strptime') result(rc)

    !! Returns a time struct object based on the input time string str,
    !! formatted using format. Refer to C standard library documentation
    !! for more information.

    import :: c_char,c_int
    import :: tm_struct

    implicit none

    ! Arguments
    character(kind=c_char),dimension(*),intent(in)  :: str    !! input string
    character(kind=c_char),dimension(*),intent(in)  :: format !! time format
    type(tm_struct),                    intent(out) :: tm     !! result tm_struct
    integer(kind=c_int)                             :: rc     !! return code

  endfunction c_strptime

endinterface
!=======================================================================
endmodule mod_strftime



!
! datetime-fortran - A Fortran library for date and time manipulation
! Copyright (c) 2013-2016, Wavebit Scientific LLC
! All rights reserved.
!
! Licensed under the BSD-3 clause license. See LICENSE for details.
!
module mod_constants
!=======================================================================
!
! mod_constants: Basic constants and time conversion factors.
!
!=======================================================================

use,intrinsic :: iso_fortran_env,only:real32,real64

implicit none

private

public :: zero,one,d2h,h2d,d2m,m2d,m2h,s2d,d2s,h2s,s2h,m2s,s2m,MAXSTRLEN

real(kind=real64),parameter :: zero = 0_real64 !! 0
real(kind=real64),parameter :: one  = 1_real64 !! 1

! Constant multipliers that transform a number
! of some time unit to another:
real(kind=real64),parameter :: d2h  = 24_real64     !! day    -> hour
real(kind=real64),parameter :: h2d  = one/d2h       !! hour   -> day
real(kind=real64),parameter :: d2m  = d2h*60_real64 !! day    -> minute
real(kind=real64),parameter :: m2d  = one/d2m       !! minute -> day
real(kind=real64),parameter :: m2h  = one/60_real64 !! minute -> hour
real(kind=real64),parameter :: s2d  = m2d/60_real64 !! second -> day
real(kind=real64),parameter :: d2s  = 86400_real64  !! day    -> second
real(kind=real64),parameter :: h2s  = 3600_real64   !! hour   -> second
real(kind=real64),parameter :: s2h  = one/h2s       !! second -> hour
real(kind=real64),parameter :: m2s  = 60_real64     !! minute -> second
real(kind=real64),parameter :: s2m  = one/m2s       !! second -> minute

! Maximum string length for strftime.
! Constant for now; may become a preprocessor macro later.
integer,parameter :: MAXSTRLEN = 99

!=======================================================================
endmodule mod_constants

!
! datetime-fortran - A Fortran library for date and time manipulation
! Copyright (c) 2013-2017, Wavebit Scientific LLC
! All rights reserved.
!
! Licensed under the BSD 3-clause license. See LICENSE for details.
!
module mod_timedelta
!=======================================================================
!
! mod_timedelta: Module that provides the timedelta class and its
!                type-bound methods and operators.
!
!=======================================================================

use,intrinsic :: iso_fortran_env,only:real32,real64

implicit none

private

public :: timedelta

type :: timedelta

  !! Class of objects that define difference between two datetime
  !! instances.

  private

  integer :: days         = 0 !! number of days
  integer :: hours        = 0 !! number of hours
  integer :: minutes      = 0 !! number of minutes
  integer :: seconds      = 0 !! number of seconds
  integer :: milliseconds = 0 !! number of milliseconds

  contains

  ! getter functions
  procedure,pass(self),public :: getDays
  procedure,pass(self),public :: getHours
  procedure,pass(self),public :: getMinutes
  procedure,pass(self),public :: getSeconds
  procedure,pass(self),public :: getMilliseconds

  ! public methods
  procedure,public :: total_seconds

  ! operator overloading procedures
  procedure,private :: timedelta_plus_timedelta
  procedure,private :: timedelta_minus_timedelta
  procedure,private :: unary_minus_timedelta
  procedure,private :: eq
  procedure,private :: neq
  procedure,private :: gt
  procedure,private :: ge
  procedure,private :: lt
  procedure,private :: le

  generic :: operator(+)  => timedelta_plus_timedelta
  generic :: operator(-)  => timedelta_minus_timedelta,&
                             unary_minus_timedelta
  generic :: operator(==) => eq
  generic :: operator(/=) => neq
  generic :: operator(>)  => gt
  generic :: operator(>=) => ge
  generic :: operator(<)  => lt
  generic :: operator(<=) => le

endtype timedelta

interface timedelta
  module procedure :: timedelta_constructor
endinterface timedelta

!=======================================================================
contains



pure elemental type(timedelta) function timedelta_constructor(days,&
  hours,minutes,seconds,milliseconds)

  !! Constructor function for the `timedelta` class.

  integer,intent(in),optional :: days         !! number of days
  integer,intent(in),optional :: hours        !! number of hours
  integer,intent(in),optional :: minutes      !! number of minutes
  integer,intent(in),optional :: seconds      !! number of seconds
  integer,intent(in),optional :: milliseconds !! number of milliseconds

  if(present(days))then
    timedelta_constructor % days = days
  else
    timedelta_constructor % days = 0
  endif

  if(present(hours))then
    timedelta_constructor % hours = hours
  else
    timedelta_constructor % hours = 0
  endif

  if(present(minutes))then
    timedelta_constructor % minutes = minutes
  else
    timedelta_constructor % minutes = 0
  endif

  if(present(seconds))then
    timedelta_constructor % seconds = seconds
  else
    timedelta_constructor % seconds = 0
  endif

  if(present(milliseconds))then
    timedelta_constructor % milliseconds = milliseconds
  else
    timedelta_constructor % milliseconds = 0
  endif

endfunction timedelta_constructor



! timedelta getters
!=======================================================================

pure elemental integer function getDays(self)
  !! Returns the number of days.
  class(timedelta),intent(in) :: self !! `timedelta` instance
  getDays = self % days
endfunction getDays



pure elemental integer function getHours(self)
  !! Returns the number of hours.
  class(timedelta),intent(in) :: self !! `timedelta` instance
  getHours = self % hours
endfunction getHours



pure elemental integer function getMinutes(self)
  !! Returns the number of minutes.
  class(timedelta),intent(in) :: self !! `timedelta` instance
  getMinutes = self % minutes
endfunction getMinutes



pure elemental integer function getSeconds(self)
  !! Returns the number of seconds.
  class(timedelta),intent(in) :: self !! `timedelta` instance
  getSeconds = self % seconds
endfunction getSeconds



pure elemental integer function getMilliseconds(self)
  !! Returns the number of milliseconds.
  class(timedelta),intent(in) :: self !! `timedelta` instance
  getMilliseconds = self % milliseconds
endfunction getMilliseconds



pure elemental real(kind=real64) function total_seconds(self)

  !! Returns a total number of seconds contained in a `timedelta`
  !! instance.

  class(timedelta),intent(in) :: self !! `timedelta` instance

  total_seconds = self % days*86400._real64&
                + self % hours*3600._real64&
                + self % minutes*60._real64&
                + self % seconds           &
                + self % milliseconds*1e-3_real64

endfunction total_seconds



pure elemental function timedelta_plus_timedelta(t0,t1) result(t)

  !! Adds two `timedelta` instances together and returns a `timedelta`
  !! instance. Overloads the operator `+`.

  class(timedelta),intent(in) :: t0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: t1 !! rhs `timedelta` instance
  type(timedelta)             :: t  !! result

  t = timedelta(days         = t0 % days         + t1 % days,   &
                hours        = t0 % hours        + t1 % hours,  &
                minutes      = t0 % minutes      + t1 % minutes,&
                seconds      = t0 % seconds      + t1 % seconds,&
                milliseconds = t0 % milliseconds + t1 % milliseconds)

endfunction timedelta_plus_timedelta



pure elemental function timedelta_minus_timedelta(t0,t1) result(t)

  !! Subtracts a `timedelta` instance from another. Returns a
  !! `timedelta` instance. Overloads the operator `-`.

  class(timedelta),intent(in) :: t0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: t1 !! lhs `timedelta` instance
  type(timedelta)             :: t  !! result

  t = t0 + (-t1)

endfunction timedelta_minus_timedelta



pure elemental function unary_minus_timedelta(t0) result(t)

  !! Takes a negative of a `timedelta` instance. Overloads the operator
  !! `-`.

  class(timedelta),intent(in) :: t0 !! `timedelta` instance
  type(timedelta)             :: t  !! result

  t % days         = -t0 % days
  t % hours        = -t0 % hours
  t % minutes      = -t0 % minutes
  t % seconds      = -t0 % seconds
  t % milliseconds = -t0 % milliseconds

endfunction unary_minus_timedelta



pure elemental logical function eq(td0,td1)

  !! `timedelta` object comparison operator. Returns `.true.` if `td0`
  !! is equal to `td1` and `.false.` otherwise. Overloads the operator
  !! `==`.

  class(timedelta),intent(in) :: td0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: td1 !! rhs `timedelta` instance

  eq = td0 % total_seconds() == td1 % total_seconds()

endfunction eq



pure elemental logical function neq(td0,td1)

  !! `timedelta` object comparison operator. Returns `.true.` if `td0`
  !! is not equal to `td1` and `.false.` otherwise. Overloads the
  !! operator `/=`.

  class(timedelta),intent(in) :: td0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: td1 !! rhs `timedelta` instance

  neq = .not. (td0 % total_seconds() == td1 % total_seconds())

endfunction neq



pure elemental logical function gt(td0,td1)

  !! `timedelta` object comparison operator. Returns `.true.` if
  !! `td0` is greater than `td1` and `.false.` otherwise. Overloads the
  !! operator `>`.

  class(timedelta),intent(in) :: td0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: td1 !! rhs `timedelta` instance

  gt = td0 % total_seconds() > td1 % total_seconds()

endfunction gt



pure elemental logical function ge(td0,td1)

  !! `timedelta` object comparison operator. Returns `.true.` if `td0`
  !! is greater than or equal to `td1` and `.false.` otherwise.
  !! Overloads the operator >=.

  class(timedelta),intent(in) :: td0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: td1 !! rhs `timedelta` instance

  ge = td0 % total_seconds() >= td1 % total_seconds()

endfunction ge



pure elemental logical function lt(td0,td1)

  !! `timedelta` object comparison operator. Returns `.true.` if `td0`
  !! is less than `td1` and `.false.` otherwise. Overloads the operator
  !! `<`.

  class(timedelta),intent(in) :: td0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: td1 !! rhs `timedelta` instance

  lt = td0 % total_seconds() < td1 % total_seconds()

endfunction lt



pure elemental logical function le(td0,td1)

  !! `timedelta` object comparison operator. Returns `.true.` if `td0`
  !! is less than or equal to `td1` and `.false.` otherwise. Overloads
  !! the operator `<=`.

  class(timedelta),intent(in) :: td0 !! lhs `timedelta` instance
  type(timedelta), intent(in) :: td1 !! rhs `timedelta` instance

  le = td0 % total_seconds() <= td1 % total_seconds()

endfunction le
!=======================================================================
endmodule mod_timedelta






!
! datetime-fortran - A Fortran library for date and time manipulation
! Copyright (c) 2013-2017, Wavebit Scientific LLC
! All rights reserved.
!
! Licensed under the BSD 3-clause license. See LICENSE for details.
!
module mod_datetime
!=======================================================================
!
! mod_datetime: Module that provides the datetime class and its
!               type-bound methods and operators. At the time being,
!               this module also includes some procedures not
!               associated with datetime.
!
!=======================================================================

use,intrinsic :: iso_fortran_env,only:real32,real64
use,intrinsic :: iso_c_binding,only:c_char,c_int,c_null_char
use :: mod_timedelta,only:timedelta
use :: mod_strftime, only:tm_struct,c_strftime,c_strptime
use :: mod_constants

implicit none

private

public :: datetime
public :: date2num
public :: datetimeRange
public :: daysInMonth
public :: daysInYear
public :: isLeapYear
public :: num2date
public :: strptime
public :: tm2date

type :: datetime

  !! Main datetime class for date and time representation.

  private

  integer :: year        = 1 !! year [1-HUGE(year)]
  integer :: month       = 1 !! month in year [1-12]
  integer :: day         = 1 !! day in month [1-31]
  integer :: hour        = 0 !! hour in day [0-23]
  integer :: minute      = 0 !! minute in hour [0-59]
  integer :: second      = 0 !! second in minute [0-59]
  integer :: millisecond = 0 !! milliseconds in second [0-999]

  real(kind=real64) :: tz = 0 !! timezone offset from UTC [hours]

  contains

  ! getter functions
  procedure,pass(self),public :: getYear
  procedure,pass(self),public :: getMonth
  procedure,pass(self),public :: getDay
  procedure,pass(self),public :: getHour
  procedure,pass(self),public :: getMinute
  procedure,pass(self),public :: getSecond
  procedure,pass(self),public :: getMillisecond
  procedure,pass(self),public :: getTz

  ! public methods
  procedure,pass(self),public :: isocalendar
  procedure,pass(self),public :: isoformat
  procedure,pass(self),public :: isValid
  procedure,nopass,    public :: now
  procedure,pass(self),public :: secondsSinceEpoch
  procedure,pass(self),public :: strftime
  procedure,pass(self),public :: tm
  procedure,pass(self),public :: tzOffset
  procedure,pass(self),public :: utc
  procedure,pass(self),public :: weekday
  procedure,pass(self),public :: isoweekday
  procedure,pass(self),public :: weekdayLong
  procedure,pass(self),public :: isoweekdayLong
  procedure,pass(self),public :: weekdayShort
  procedure,pass(self),public :: isoweekdayShort
  procedure,pass(self),public :: yearday

  ! private methods
  procedure,pass(self),private :: addMilliseconds
  procedure,pass(self),private :: addSeconds
  procedure,pass(self),private :: addMinutes
  procedure,pass(self),private :: addHours
  procedure,pass(self),private :: addDays

  ! operator overloading procedures
  procedure,pass(d0),private :: datetime_plus_timedelta
  procedure,pass(d0),private :: timedelta_plus_datetime
  procedure,pass(d0),private :: datetime_minus_datetime
  procedure,pass(d0),private :: datetime_minus_timedelta
  procedure,pass(d0),private :: eq
  procedure,pass(d0),private :: neq
  procedure,pass(d0),private :: gt
  procedure,pass(d0),private :: ge
  procedure,pass(d0),private :: lt
  procedure,pass(d0),private :: le

  generic :: operator(+)  => datetime_plus_timedelta,&
                             timedelta_plus_datetime
  generic :: operator(-)  => datetime_minus_datetime,&
                             datetime_minus_timedelta
  generic :: operator(==) => eq
  generic :: operator(/=) => neq
  generic :: operator(>)  => gt
  generic :: operator(>=) => ge
  generic :: operator(<)  => lt
  generic :: operator(<=) => le

endtype datetime

interface datetime
  module procedure :: datetime_constructor
endinterface datetime

!=======================================================================
contains



pure elemental type(datetime) function datetime_constructor(year,month,&
  day,hour,minute,second,millisecond,tz)

  !! Constructor function for the `datetime` class.

  integer,          intent(in),optional :: year        !! year
  integer,          intent(in),optional :: month       !! month
  integer,          intent(in),optional :: day         !! day
  integer,          intent(in),optional :: hour        !! hour
  integer,          intent(in),optional :: minute      !! minute
  integer,          intent(in),optional :: second      !! second
  integer,          intent(in),optional :: millisecond !! millisecond
  real(kind=real64),intent(in),optional :: tz          !! timezone offset in hours

  if(present(year))then
    datetime_constructor % year = year
  else
    datetime_constructor % year = 1
  endif

  if(present(month))then
    datetime_constructor % month = month
  else
    datetime_constructor % month = 1
  endif

  if(present(day))then
    datetime_constructor % day = day
  else
    datetime_constructor % day = 1
  endif

  if(present(hour))then
    datetime_constructor % hour = hour
  else
    datetime_constructor % hour = 0
  endif

  if(present(minute))then
    datetime_constructor % minute = minute
  else
    datetime_constructor % minute = 0
  endif

  if(present(second))then
    datetime_constructor % second = second
  else
    datetime_constructor % second = 0
  endif

  if(present(millisecond))then
    datetime_constructor % millisecond = millisecond
  else
    datetime_constructor % millisecond = 0
  endif

  if(present(tz))then
    datetime_constructor % tz = tz
  else
    datetime_constructor % tz = 0
  endif

endfunction datetime_constructor



! datetime getters
!=======================================================================

pure elemental integer function getYear(self)
  !! Returns the year component
  class(datetime),intent(in) :: self !! `datetime` instance
  getYear = self % year
endfunction getYear



pure elemental integer function getMonth(self)
  !! Returns the year component
  class(datetime),intent(in) :: self !! `datetime` instance
  getMonth = self % month
endfunction getMonth



pure elemental integer function getDay(self)
  !! Returns the year component
  class(datetime),intent(in) :: self !! `datetime` instance
  getDay = self % day
endfunction getDay



pure elemental integer function getHour(self)
  !! Returns the year component
  class(datetime),intent(in) :: self !! `datetime` instance
  getHour = self % hour
endfunction getHour



pure elemental integer function getMinute(self)
  !! Returns the year component
  class(datetime),intent(in) :: self !! `datetime` instance
  getMinute = self % minute
endfunction getMinute



pure elemental integer function getSecond(self)
  !! Returns the year component
  class(datetime),intent(in) :: self !! `datetime` instance
  getSecond = self % second
endfunction getSecond



pure elemental integer function getMillisecond(self)
  !! Returns the year component
  class(datetime),intent(in) :: self !! `datetime` instance
  getMillisecond = self % millisecond
endfunction getMillisecond



pure elemental real(kind=real64) function getTz(self)
  !! Returns the timezone offset component
  class(datetime),intent(in) :: self !! `datetime` instance
  getTz = self % tz
endfunction getTz



pure elemental subroutine addMilliseconds(self,ms)

  !! Adds an integer number of milliseconds to self. Called by `datetime`
  !! addition (`+`) and subtraction (`-`) operators.

  class(datetime),intent(inout) :: self !! `datetime` instance
  integer,        intent(in)    :: ms   !! number of milliseconds to add

  self % millisecond = self % millisecond+ms

  do
    if(self % millisecond >= 1000)then
      call self % addSeconds(self % millisecond/1000)
      self % millisecond = mod(self % millisecond,1000)
    elseif(self % millisecond < 0)then
      call self % addSeconds(self % millisecond/1000-1)
      self % millisecond = mod(self % millisecond,1000)+1000
    else
      exit
    endif
  enddo

endsubroutine addMilliseconds


! datetime-bound methods
!=======================================================================

pure elemental subroutine addSeconds(self,s)

  !! Adds an integer number of seconds to self. Called by `datetime`
  !! addition (`+`) and subtraction (`-`) operators.

  class(datetime),intent(inout) :: self !! `datetime` instance
  integer,        intent(in)    :: s    !! number of seconds to add

  self % second = self % second+s

  do
    if(self % second >= 60)then
      call self % addMinutes(self % second/60)
      self % second = mod(self % second,60)
    elseif(self % second < 0)then
      call self % addMinutes(self % second/60-1)
      self % second = mod(self % second,60)+60
    else
      exit
    endif
  enddo

endsubroutine addSeconds



pure elemental subroutine addMinutes(self,m)

  !! Adds an integer number of minutes to self. Called by `datetime`
  !! addition (`+`) and subtraction (`-`) operators.

  class(datetime),intent(inout) :: self !! `datetime` instance
  integer,        intent(in)    :: m    !! number of minutes to add

  self % minute = self % minute+m

  do
    if(self % minute >= 60)then
      call self % addHours(self % minute/60)
      self % minute = mod(self % minute,60)
    elseif(self % minute < 0)then
      call self % addHours(self % minute/60-1)
      self % minute = mod(self % minute,60)+60
    else
      exit
    endif
  enddo

endsubroutine addMinutes



pure elemental subroutine addHours(self,h)

  !! Adds an integer number of hours to self. Called by `datetime`
  !! addition (`+`) and subtraction (`-`) operators.

  class(datetime),intent(inout) :: self !! `datetime` instance
  integer,        intent(in)    :: h    !! number of hours to add

  self % hour = self % hour+h

  do
    if(self % hour >= 24)then
      call self % addDays(self % hour/24)
      self % hour = mod(self % hour,24)
    elseif(self % hour < 0)then
      call self % addDays(self % hour/24-1)
      self % hour = mod(self % hour,24)+24
    else
      exit
    endif
  enddo

endsubroutine addHours



pure elemental subroutine addDays(self,d)

  !! Adds an integer number of dayss to self. Called by `datetime`
  !! addition (`+`) and subtraction (`-`) operators.

  class(datetime),intent(inout) :: self !! `datetime` instance
  integer,        intent(in)    :: d    !! number of days to add

  integer :: daysInCurrentMonth

  self % day = self % day+d
  do
    daysInCurrentMonth = daysInMonth(self % month,self % year)
    if(self % day > daysInCurrentMonth)then
      self % day = self % day-daysInCurrentMonth
      self % month = self % month+1
      if(self % month > 12)then
        self % year = self % year+self % month/12
        self % month = mod(self % month,12)
      endif
    elseif(self % day < 1)then
      self % month = self % month-1
      if(self % month < 1)then
        self % year = self % year+self % month/12-1
        self % month = 12+mod(self % month,12)
      endif
      self % day = self % day+daysInMonth(self % month,self % year)
    else
      exit
    endif
  enddo

endsubroutine addDays



pure elemental character(len=23) function isoformat(self,sep)

  !! Returns character string with time in ISO 8601 format.

  class(datetime), intent(in)          :: self !! `datetime instance`
  character(len=1),intent(in),optional :: sep
    !! separator character, 'T' is default

  character(len=1) :: separator

  if(present(sep))then
    separator = sep
  else
    separator = 'T'
  endif

  ! TODO below is a bit cumbersome and was implemented
  ! at a time before the interface to strftime. Now we
  ! could do something like:
  !
  ! isoformat = self % strftime('%Y-%m-%d'//separator//'%H:%M:%S')
  !
  isoformat = int2str(self % year,       4)//'-'//      &
              int2str(self % month,      2)//'-'//      &
              int2str(self % day,        2)//separator//&
              int2str(self % hour,       2)//':'//      &
              int2str(self % minute,     2)//':'//      &
              int2str(self % second,     2)//'.'//      &
              int2str(self % millisecond,3)

endfunction isoformat



pure elemental logical function isValid(self)

  !! Checks whether the `datetime` instance has valid component values.
  !! Returns `.true.` if the `datetime` instance is valid, and `.false.`
  !! otherwise.

  class(datetime),intent(in) :: self !! `datetime` instance

  ! assume valid
  isValid = .true.

  if(self % year < 1)then
    isValid = .false.
    return
  endif

  if(self % month < 1 .or. self % month > 12)then
    isValid = .false.
    return
  endif

  if(self % day < 1 .or. &
     self % day > daysInMonth(self % month,self % year))then
    isValid = .false.
    return
  endif

  if(self % hour < 0 .or. self % hour > 23)then
    isValid = .false.
    return
  endif

  if(self % minute < 0 .or. self % minute > 59)then
    isValid = .false.
    return
  endif

  if(self % second < 0 .or. self % second > 59)then
    isValid = .false.
    return
  endif

  if(self % millisecond < 0 .or. self % millisecond > 999)then
    isValid = .false.
    return
  endif

endfunction isValid



type(datetime) function now()

  !! Returns a `datetime` instance with current time.
  !! No input arguments.

  character(len=5)     :: zone
  integer,dimension(8) :: values

  integer :: hour,minute

  ! Obtain local machine time zone information
  call date_and_time(zone=zone,values=values)

  read(unit=zone(1:3),fmt='(I3)')hour
  read(unit=zone(4:5),fmt='(I2)')minute

  now = datetime(year        = values(1),&
                 month       = values(2),&
                 day         = values(3),&
                 hour        = values(5),&
                 minute      = values(6),&
                 second      = values(7),&
                 millisecond = values(8))

  now % tz = hour+minute*m2h

endfunction now



pure elemental integer function weekday(self)

  !! Returns the day of the week calculated using Zeller's congruence.
  !! Returned value is an integer scalar in the range [0-6], such that:
  !!
  !! 0: Sunday
  !! 1: Monday
  !! 2: Tuesday
  !! 3: Wednesday
  !! 4: Thursday
  !! 5: Friday
  !! 6: Saturday

  class(datetime),intent(in) :: self !! `datetime` instance

  integer :: year,month
  integer :: j,k

  year  = self % year
  month = self % month

  if(month <= 2)then
    month = month+12
    year  = year-1
  endif

  j = year/100
  k = mod(year,100)

  weekday = mod(self % day+((month+1)*26)/10+k+k/4+j/4+5*j,7)-1

  if(weekday < 0)weekday = 6

endfunction weekday



pure elemental integer function isoweekday(self)

  !! Returns the day of the week per ISO 8601 returned from weekday().
  !! Returned value is an integer scalar in the range [1-7], such that:
  !!
  !! 1: Monday
  !! 2: Tuesday
  !! 3: Wednesday
  !! 4: Thursday
  !! 5: Friday
  !! 6: Saturday
  !! 7: Sunday

  class(datetime),intent(in) :: self !! `datetime` instance

  isoweekday = self % weekday()

  if (isoweekday == 0) then
    isoweekday = 7
  end if

endfunction isoweekday



pure elemental character(len=9) function weekdayLong(self)

  !! Returns the full name of the day of the week.

  class(datetime),intent(in) :: self !! `datetime` instance

  character(len=9),parameter,dimension(7) :: &
  days = ['Sunday   ','Monday   ','Tuesday  ','Wednesday',&
          'Thursday ','Friday   ','Saturday ']

  weekdayLong = days(self % weekday()+1)

endfunction weekdayLong



pure elemental character(len=9) function isoweekdayLong(self)

  !! Returns the full name of the day of the week for ISO 8601
  !! ordered weekdays.

  class(datetime),intent(in) :: self !! `datetime` instance

  character(len=9),parameter,dimension(7) :: &
  days = ['Monday   ','Tuesday  ','Wednesday','Thursday ',&
          'Friday   ','Saturday ','Sunday   ']

  isoweekdayLong = days(self % isoweekday())

endfunction isoweekdayLong



pure elemental character(len=3) function weekdayShort(self)

  !! Returns the short (3-letter) name of the day of the week.

  class(datetime),intent(in) :: self !! `datetime` instance

  character(len=3),parameter,dimension(7) :: &
                   days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']

  weekdayShort = days(self % weekday()+1)

endfunction weekdayShort



pure elemental character(len=3) function isoweekdayShort(self)

  !! Returns the short (3-letter) name of the day of the week
  !! based on ISO 8601 ordering.

  class(datetime),intent(in) :: self !! `datetime` instance

  character(len=3),parameter,dimension(7) :: &
                   days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']

  isoweekdayShort = days(self % isoweekday())

endfunction isoweekdayShort


function isocalendar(self)

  !! Returns an array of 3 integers, year, week number, and week day,
  !! as defined by ISO 8601 week date. Essentially a wrapper around C
  !! `strftime` function.

  class(datetime),intent(in) :: self !! `datetime` instance

  integer,dimension(3) :: isocalendar
  integer              :: year,week,wday
  integer              :: rc
  character(len=20)    :: string

  rc = c_strftime(string,len(string),'%G %V %u'//c_null_char,&
                  self % tm())

  read(unit=string(1:4),fmt='(I4)')year
  read(unit=string(6:7),fmt='(I2)')week
  read(unit=string(9:9),fmt='(I1)')wday

  isocalendar = [year,week,wday]

endfunction isocalendar



integer function secondsSinceEpoch(self)

  !! Returns an integer number of seconds since the UNIX Epoch,
  !! `1970-01-01 00:00:00`. Note that this is a wrapper around C's
  !! `strftime('%s')`, so the number of seconds will reflect the time
  !! zone of the local machine on which the function is being called.

  class(datetime),intent(in) :: self !! `datetime` instance

  character(len=11) :: string

  string = self % strftime('%s')
  read(unit=string,fmt='(I10)')secondsSinceEpoch

endfunction secondsSinceEpoch



function strftime(self,format)

  !! Wrapper around C/C++ `strftime` function.

  class(datetime), intent(in)  :: self   !! `datetime` instance
  character(len=*),intent(in)  :: format !! format string

  character(len=:),allocatable :: strftime

  integer                  :: n,rc
  character(len=MAXSTRLEN) :: resultString

  resultString = ""
  rc = c_strftime(resultString,MAXSTRLEN,trim(format)//c_null_char,&
                  self % tm())
  strftime = trim(resultString)
  n = len(strftime)
  strftime = strftime(1:n-1)

endfunction strftime



pure elemental type(tm_struct) function tm(self)

  !! Returns a `tm_struct` instance of the current `datetime`.

  class(datetime),intent(in) :: self !! `datetime` instance

  tm % tm_sec   = self % second
  tm % tm_min   = self % minute
  tm % tm_hour  = self % hour
  tm % tm_mday  = self % day
  tm % tm_mon   = self % month-1
  tm % tm_year  = self % year-1900
  tm % tm_wday  = self % weekday()
  tm % tm_yday  = self % yearday()-1
  tm % tm_isdst = -1

endfunction tm



pure elemental character(len=5) function tzOffset(self)

  !! Returns a character string with timezone offset in hours from UTC,
  !! in format +/-[hh][mm].

  class(datetime),intent(in) :: self !! `datetime` instance

  integer :: hours,minutes

  if(self % tz < 0)then
    tzOffset(1:1) = '-'
  else
    tzOffset(1:1) = '+'
  endif

  hours   = int(abs(self % tz))
  minutes = nint((abs(self % tz)-hours)*60)

  if(minutes == 60)then
    minutes = 0
    hours = hours+1
  endif

  write(unit=tzOffset(2:5),fmt='(2I2.2)')hours,minutes

endfunction tzOffset



pure elemental type(datetime) function utc(self)

  !! Returns the `datetime` instance at Coordinated Universal Time (UTC).

  class(datetime),intent(in) :: self !! `datetime` instance

  integer :: hours,minutes,sgn

  hours   = int(abs(self % tz))
  minutes = nint((abs(self % tz)-hours)*60)
  sgn     = int(sign(one,self % tz))

  utc      = self-timedelta(hours=sgn*hours,minutes=sgn*minutes)
  utc % tz = 0

endfunction utc



pure elemental integer function yearday(self)

  !! Returns the integer day of the year (ordinal date).

  class(datetime),intent(in) :: self !! `datetime` instance

  integer :: month

  yearday = 0
  do month=1,self % month-1
    yearday = yearday+daysInMonth(month,self % year)
  enddo
  yearday = yearday+self % day

endfunction yearday



! datetime operators
!=======================================================================

pure elemental function datetime_plus_timedelta(d0,t) result(d)

  !! Adds a `timedelta` instance to a `datetime` instance, and returns a
  !! new `datetime` instance. Overloads the operator `+`.

  class(datetime), intent(in) :: d0 !! `datetime` instance
  class(timedelta),intent(in) :: t  !! `timedelta` instance
  type(datetime)              :: d

  integer :: milliseconds,seconds,minutes,hours,days

  d = datetime(year        = d0 % getYear(),       &
               month       = d0 % getMonth(),      &
               day         = d0 % getDay(),        &
               hour        = d0 % getHour(),       &
               minute      = d0 % getMinute(),     &
               second      = d0 % getSecond(),     &
               millisecond = d0 % getMillisecond(),&
               tz          = d0 % getTz())

  milliseconds = t % getMilliseconds()
  seconds      = t % getSeconds()
  minutes      = t % getMinutes()
  hours        = t % getHours()
  days         = t % getDays()

  if(milliseconds /= 0)call d % addMilliseconds(milliseconds)
  if(seconds      /= 0)call d % addSeconds(seconds)
  if(minutes      /= 0)call d % addMinutes(minutes)
  if(hours        /= 0)call d % addHours(hours)
  if(days         /= 0)call d % addDays(days)

endfunction datetime_plus_timedelta



pure elemental function timedelta_plus_datetime(t,d0) result(d)

  !! Adds a `timedelta` instance to a `datetime` instance, and returns a
  !! new `datetime` instance. Overloads the operator `+`.

  class(timedelta),intent(in) :: t  !! `timedelta` instance
  class(datetime), intent(in) :: d0 !! `datetime` instance
  type(datetime)              :: d

  d = d0 + t

endfunction timedelta_plus_datetime



pure elemental function datetime_minus_timedelta(d0,t) result(d)

  !! Subtracts a `timedelta` instance from a `datetime` instance and
  !! returns a new `datetime` instance. Overloads the operator `-`.

  class(datetime), intent(in) :: d0 !! `datetime` instance
  class(timedelta),intent(in) :: t  !! `timedelta` instance
  type(datetime)              :: d

  d = d0 + (-t)

endfunction datetime_minus_timedelta



pure elemental function datetime_minus_datetime(d0,d1) result(t)

  !! Subtracts a `datetime` instance from another `datetime` instance,
  !! and returns a `timedelta` instance. Overloads the operator `-`.

  class(datetime),intent(in) :: d0 !! lhs `datetime` instance
  class(datetime),intent(in) :: d1 !! rhs `datetime` instance
  type(timedelta)            :: t

  real(kind=real64) :: daysDiff
  integer :: days,hours,minutes,seconds,milliseconds
  integer :: sign_

  daysDiff = date2num(d0)-date2num(d1)

  if(daysDiff < 0)then
    sign_ = -1
    daysDiff = ABS(daysDiff)
  else
    sign_ = 1
  endif

  days         = int(daysDiff)
  hours        = int((daysDiff-days)*d2h)
  minutes      = int((daysDiff-days-hours*h2d)*d2m)
  seconds      = int((daysDiff-days-hours*h2d-minutes*m2d)*d2s)
  milliseconds = nint((daysDiff-days-hours*h2d-minutes*m2d&
                               -seconds*s2d)*d2s*1e3_real64)

  t = timedelta(sign_*days,sign_*hours,sign_*minutes,sign_*seconds,&
                sign_*milliseconds)

endfunction datetime_minus_datetime



pure elemental logical function gt(d0,d1)

  !! `datetime` comparison operator that eturns `.true.` if `d0` is
  !! greater than `d1` and `.false.` otherwise. Overloads the
  !! operator `>`.

  class(datetime),intent(in) :: d0 !! lhs `datetime` instance
  class(datetime),intent(in) :: d1 !! rhs `datetime` instance

  type(datetime) :: d0_utc,d1_utc

  ! Convert to UTC before making comparison
  d0_utc = d0 % utc()
  d1_utc = d1 % utc()

  ! Year comparison block
  if(d0_utc % year > d1_utc % year)then
    gt = .true.
  elseif(d0_utc % year < d1_utc % year)then
    gt = .false.
  else

    ! Month comparison block
    if(d0_utc % month > d1_utc % month)then
      gt = .true.
    elseif(d0_utc % month < d1_utc % month)then
      gt = .false.
    else

      ! Day comparison block
      if(d0_utc % day > d1_utc % day)then
        gt = .true.
      elseif(d0_utc % day < d1_utc % day)then
        gt = .false.
      else

        ! Hour comparison block
        if(d0_utc % hour > d1_utc % hour)then
          gt = .true.
        elseif(d0_utc % hour < d1_utc % hour)then
          gt = .false.
        else

          ! Minute comparison block
          if(d0_utc % minute > d1_utc % minute)then
            gt = .true.
          elseif(d0_utc % minute < d1_utc % minute)then
            gt = .false.
          else

            ! Second comparison block
            if(d0_utc % second > d1_utc % second)then
              gt = .true.
            elseif(d0_utc % second < d1_utc % second)then
              gt = .false.
            else

              ! Millisecond comparison block
              if(d0_utc % millisecond > d1_utc % millisecond)then
                gt = .true.
              else
                gt = .false.
              endif

            endif
          endif
        endif
      endif
    endif
  endif

endfunction gt



pure elemental logical function lt(d0,d1)

  !! `datetime` comparison operator that returns `.true.` if `d0` is
  !! less than `d1` and `.false.` otherwise. Overloads the operator `<`.

  class(datetime),intent(in) :: d0 !! lhs `datetime` instance
  class(datetime),intent(in) :: d1 !! rhs `datetime` instance

  lt = d1 > d0

endfunction lt



pure elemental logical function eq(d0,d1)

  !! `datetime` comparison operator that returns `.true.` if `d0` is
  !! equal to `d1` and `.false.` otherwise. Overloads the operator `==`.

  class(datetime),intent(in) :: d0 !! lhs `datetime` instance
  class(datetime),intent(in) :: d1 !! rhs `datetime` instance

  type(datetime) :: d0_utc,d1_utc

  ! Convert to UTC before making comparison
  d0_utc = d0 % utc()
  d1_utc = d1 % utc()

  eq = d0_utc % year        == d1_utc % year   .and. &
       d0_utc % month       == d1_utc % month  .and. &
       d0_utc % day         == d1_utc % day    .and. &
       d0_utc % hour        == d1_utc % hour   .and. &
       d0_utc % minute      == d1_utc % minute .and. &
       d0_utc % second      == d1_utc % second .and. &
       d0_utc % millisecond == d1_utc % millisecond

endfunction eq



pure elemental logical function neq(d0,d1)

  !! `datetime` comparison operator that eturns `.true.` if `d0` is
  !! not equal to `d1` and `.false.` otherwise. Overloads the operator `/=`.

  class(datetime),intent(in) :: d0 !! lhs `datetime` instance
  class(datetime),intent(in) :: d1 !! rhs `datetime` instance

  neq = .not. d0 == d1

endfunction neq



pure elemental logical function ge(d0,d1)

  !! `datetime` comparison operator. Returns `.true.` if `d0` is greater
  !! than or equal to `d1` and `.false.` otherwise. Overloads the
  !! operator `>=`.

  class(datetime),intent(in) :: d0 !! lhs `datetime` instance
  class(datetime),intent(in) :: d1 !! rhs `datetime` instance

  ge = d0 > d1 .or. d0 == d1

endfunction ge



pure elemental logical function le(d0,d1)

  !! `datetime` comparison operator. Returns `.true.` if `d0` is less
  !! than or equal to `d1`, and `.false.` otherwise. Overloads the
  !! operator `<=`.

  class(datetime),intent(in) :: d0 !! lhs `datetime` instance
  class(datetime),intent(in) :: d1 !! rhs `datetime` instance

  le = d1 > d0 .or. d0 == d1

endfunction le



! public procedures
!=======================================================================

pure elemental logical function isLeapYear(year)

  !! Returns `.true.` if year is leap year and `.false.` otherwise.

  integer,intent(in) :: year !! year

  isLeapYear = (mod(year,4) == 0 .and. .not. mod(year,100) == 0)&
          .or. (mod(year,400) == 0)

endfunction isLeapYear



pure function datetimeRange(d0,d1,t)

  !! Given start and end `datetime` instances `d0` and `d1` and time
  !! increment as `timedelta` instance `t`, returns an array of
  !! `datetime` instances. The number of elements is the number of whole
  !! time increments contained between datetimes `d0` and `d1`.

  type(datetime), intent(in) :: d0 !! start time
  type(datetime), intent(in) :: d1 !! end time
  type(timedelta),intent(in) :: t  !! time increment

  real(kind=real64) :: datenum0,datenum1,increment
  real(kind=real64) :: eps

  type(datetime),dimension(:),allocatable :: datetimeRange

  integer :: n,nm

  eps = 1e-10_real64

  datenum0 = date2num(d0)
  datenum1 = date2num(d1)

  increment = t % total_seconds() * s2d

  nm = floor((datenum1-datenum0+eps)/increment)+1

  allocate(datetimeRange(nm))

  do n = 1,nm
    datetimeRange(n) = num2date(datenum0 + (n-1)*increment)
  enddo

endfunction datetimeRange



pure elemental integer function daysInMonth(month,year)

  !! Given integer month and year, returns an integer number
  !! of days in that particular month.

  integer,intent(in) :: month !! month
  integer,intent(in) :: year  !! year

  integer,parameter,dimension(12) :: &
          days = [31,28,31,30,31,30,31,31,30,31,30,31]

  if(month < 1 .or. month > 12)then
    ! Should raise an error and abort here, however we want to keep
    ! the pure and elemental attributes. Make sure this function is
    ! called with the month argument in range.
    daysInMonth = 0
    return
  endif

  if(month == 2 .and. isLeapYear(year))then
    daysInMonth = 29
  else
    daysInMonth = days(month)
  endif

endfunction daysInMonth



pure elemental integer function daysInYear(year)

  !! Returns the number of days in year.

  integer,intent(in) :: year !! year

  if(isLeapYear(year))then
    daysInYear = 366
  else
    daysInYear = 365
  endif

endfunction daysInYear



pure elemental real(kind=real64) function date2num(d)

  !! Given a datetime instance d, returns number of days since
  !! `0001-01-01 00:00:00`, taking into account the timezone offset.

  type(datetime),intent(in) :: d !! `datetime` instance

  type(datetime) :: d_utc
  integer :: year

  ! Convert to UTC first
  d_utc = d % utc()

  ! d_utc % year must be positive:
  if(d_utc % year < 1)then
    date2num = 0
    return
  endif

  date2num = 0
  do year = 1,d_utc % year-1
    date2num = date2num + daysInYear(year)
  enddo

  date2num = date2num          &
           + d_utc % yearday() &
           + d_utc % hour*h2d  &
           + d_utc % minute*m2d&
           + (d_utc % second+1e-3_real64*d_utc % millisecond)*s2d

endfunction date2num



pure elemental type(datetime) function num2date(num)

  !! Given number of days since `0001-01-01 00:00:00`, returns a
  !! correspoding `datetime` instance.

  real(kind=real64),intent(in) :: num
    !! number of days since `0001-01-01 00:00:00`

  integer :: year,month,day,hour,minute,second,millisecond
  real(kind=real64) :: days,totseconds

  ! num must be positive:
  if(num < 0)then
    num2date = datetime(1)
    return
  endif

  days = num

  year = 1
  do
    if(int(days) <= daysInYear(year))exit
    days = days-daysInYear(year)
    year = year+1
  enddo

  month = 1
  do
    if(inT(days) <= daysInMonth(month,year))exit
    days = days-daysInMonth(month,year)
    month = month+1
  enddo

  day         = int(days)
  totseconds  = (days-day)*d2s
  hour        = int(totseconds*s2h)
  minute      = int((totseconds-hour*h2s)*s2m)
  second      = int(totseconds-hour*h2s-minute*m2s)
  millisecond = nint((totseconds-int(totseconds))*1e3_real64)

  num2date = datetime(year,month,day,hour,minute,second,millisecond,tz=zero)

  ! Handle a special case caused by floating-point arithmethic:
  if(num2date % millisecond == 1000)then
    num2date % millisecond = 0
    call num2date % addSeconds(1)
  endif

  if(num2date % second == 60)then
    num2date % second = 0
    call num2date % addMinutes(1)
  endif
  if(num2date % minute == 60)then
    num2date % minute = 0
    call num2date % addHours(1)
  endif
  if(num2date % hour == 60)then
    num2date % hour = 0
    call num2date % addDays(1)
  endif

endfunction num2date



type(datetime) function strptime(str,format)

  !! A wrapper function around C/C++ strptime function.
  !! Returns a `datetime` instance.

  character(len=*),intent(in) :: str    !! time string
  character(len=*),intent(in) :: format !! time format

  integer         :: rc
  type(tm_struct) :: tm

  rc = c_strptime(trim(str)//c_null_char,trim(format)//c_null_char,tm)
  strptime = tm2date(tm)

endfunction strptime



pure elemental type(datetime) function tm2date(ctime)

  !! Given a `tm_struct` instance, returns a corresponding `datetime`
  !! instance.

  type(tm_struct),intent(in) :: ctime !! C-style time struct

  tm2date % millisecond = 0
  tm2date % second      = ctime % tm_sec
  tm2date % minute      = ctime % tm_min
  tm2date % hour        = ctime % tm_hour
  tm2date % day         = ctime % tm_mday
  tm2date % month       = ctime % tm_mon+1
  tm2date % year        = ctime % tm_year+1900
  tm2date % tz          = 0

endfunction tm2date



! private procedures
!=======================================================================

pure function int2str(i,length)

  !! Converts an integer `i` into a character string of requested length,
  !! pre-pending zeros if necessary.

  integer,intent(in) :: i      !! integer to convert to string
  integer,intent(in) :: length !! desired length of string

  character(len=length) :: int2str
  character(len=2)      :: string

  write(unit=string,fmt='(I2)')length
  write(unit=int2str,fmt='(I'//string//'.'//string//')')i

endfunction int2str
!=======================================================================
endmodule mod_datetime


!
! datetime-fortran - A Fortran library for date and time manipulation
! Copyright (c) 2013-2017, Wavebit Scientific LLC
! All rights reserved.
!
! Licensed under the BSD 3-clause license. See LICENSE for details.
!
module mod_clock
!=======================================================================
!
! mod_clock
!
!=======================================================================

use,intrinsic :: iso_fortran_env,only:real32,real64
use,intrinsic :: iso_c_binding,only:c_char,c_int,c_null_char
use :: mod_datetime,only:datetime
use :: mod_timedelta,only:timedelta

implicit none

private

! Derived types:
public :: clock

type :: clock

  !! A clock object with a start, stop and current times, tick interval
  !! and tick methods.

  type(datetime) :: startTime
  type(datetime) :: stopTime
  type(datetime) :: currentTime

  type(timedelta) :: tickInterval

  ! May become Alarm class in some future release;
  ! for now, just a switch
  logical :: alarm = .false.

  ! Clock status flags
  logical :: started = .false.
  logical :: stopped = .false.

  contains

  procedure :: reset
  procedure :: tick

endtype clock
!=======================================================================
contains


!=======================================================================
pure elemental subroutine reset(self)

  !! Resets the clock to its start time.

  class(clock),intent(inout) :: self

  self % currentTime = self % startTime

  self % started = .false.
  self % stopped = .false.

endsubroutine reset
!=======================================================================



!=======================================================================
pure elemental subroutine tick(self)

  !! Increments the currentTime of the clock instance by one tickInterval.

  class(clock),intent(inout) :: self

  if(self % stopped)then
    return
  endif

  if(.not.self % started)then
    self % started = .true.
    self % currentTime = self % startTime
  endif

  self % currentTime = self % currentTime + self % tickInterval

  if(self % currentTime >= self % stopTime)then
    self % stopped = .true.
  endif

endsubroutine tick
!=======================================================================
endmodule mod_clock

! datetime-fortran - A Fortran library for date and time manipulation
! Copyright (c) 2013-2017, Wavebit Scientific LLC
! All rights reserved.
!
! Licensed under the BSD-3 clause license. See LICENSE for details.
!
module datetime_module

!! Provides entry point to all items defined in datetime, timedelta,
!! clock and strftime modules.

use mod_datetime
use mod_timedelta
use mod_clock
use mod_strftime

endmodule datetime_module

subroutine chkder ( m, n, x, fvec, fjac, ldfjac, xp, fvecp, mode, err )

!*****************************************************************************80
!
!! CHKDER checks the gradients of M functions of N variables.
!
!  Discussion:
!
!    CHKDER checks the gradients of M nonlinear functions in N variables,
!    evaluated at a point X, for consistency with the functions themselves.
!
!    The user calls CHKDER twice, first with MODE = 1 and then with MODE = 2.
!
!    MODE = 1.
!      On input,
!        X contains the point of evaluation.
!      On output,
!        XP is set to a neighboring point.
!
!    Now the user must evaluate the function and gradients at X, and the
!    function at XP.  Then the subroutine is called again:
!
!    MODE = 2.
!      On input,
!        FVEC contains the function values at X,
!        FJAC contains the function gradients at X.
!        FVECP contains the functions evaluated at XP.
!      On output,
!        ERR contains measures of correctness of the respective gradients.
!
!    The subroutine does not perform reliably if cancellation or
!    rounding errors cause a severe loss of significance in the
!    evaluation of a function.  Therefore, none of the components
!    of X should be unusually small (in particular, zero) or any
!    other value which may cause loss of significance.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) M, is the number of functions.
!
!    Input, integer ( kind = 4 ) N, is the number of variables.
!
!    Input, real ( kind = 8 ) X(N), the point at which the jacobian is to be
!    evaluated.
!
!    Input, real ( kind = 8 ) FVEC(M), is used only when MODE = 2.
!    In that case, it should contain the function values at X.
!
!    Input, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  When MODE = 2,
!    FJAC(I,J) should contain the value of dF(I)/dX(J).
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC.
!    LDFJAC must be at least M.
!
!    Output, real ( kind = 8 ) XP(N), on output with MODE = 1, is a neighboring
!    point of X, at which the function is to be evaluated.
!
!    Input, real ( kind = 8 ) FVECP(M), on input with MODE = 2, is the function
!    value at XP.
!
!    Input, integer ( kind = 4 ) MODE, should be set to 1 on the first call, and
!    2 on the second.
!
!    Output, real ( kind = 8 ) ERR(M).  On output when MODE = 2, ERR contains
!    measures of correctness of the respective gradients.  If there is no
!    severe loss of significance, then if ERR(I):
!      = 1.0D+00, the I-th gradient is correct,
!      = 0.0D+00, the I-th gradient is incorrect.
!      > 0.5D+00, the I-th gradient is probably correct.
!      < 0.5D+00, the I-th gradient is probably incorrect.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) eps
  real ( kind = 8 ) epsf
  real ( kind = 8 ) epslog
  real ( kind = 8 ) epsmch
  real ( kind = 8 ) err(m)
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fvec(m)
  real ( kind = 8 ) fvecp(m)
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  integer ( kind = 4 ) mode
  real ( kind = 8 ) temp
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xp(n)

  epsmch = epsilon ( epsmch )
  eps = sqrt ( epsmch )
!
!  MODE = 1.
!
  if ( mode == 1 ) then

    do j = 1, n
      temp = eps * abs ( x(j) )
      if ( temp == 0.0D+00 ) then
        temp = eps
      end if
      xp(j) = x(j) + temp
    end do
!
!  MODE = 2.
!
  else if ( mode == 2 ) then

    epsf = 100.0D+00 * epsmch
    epslog = log10 ( eps )

    err = 0.0D+00

    do j = 1, n
      temp = abs ( x(j) )
      if ( temp == 0.0D+00 ) then
        temp = 1.0D+00
      end if
      err(1:m) = err(1:m) + temp * fjac(1:m,j)
    end do

    do i = 1, m

      temp = 1.0D+00

      if ( fvec(i) /= 0.0D+00 .and. fvecp(i) /= 0.0D+00 .and. &
        abs ( fvecp(i)-fvec(i)) >= epsf * abs ( fvec(i) ) ) then
        temp = eps * abs ( (fvecp(i)-fvec(i)) / eps - err(i) ) &
          / ( abs ( fvec(i) ) + abs ( fvecp(i) ) )
      end if

      err(i) = 1.0D+00

      if ( epsmch < temp .and. temp < eps ) then
        err(i) = ( log10 ( temp ) - epslog ) / epslog
      end if

      if ( eps <= temp ) then
        err(i) = 0.0D+00
      end if

    end do

  end if

  return
end subroutine chkder
subroutine dogleg ( n, r, lr, diag, qtb, delta, x )

!*****************************************************************************80
!
!! DOGLEG finds the minimizing combination of Gauss-Newton and gradient steps.
!
!  Discussion:
!
!    Given an M by N matrix A, an N by N nonsingular diagonal
!    matrix D, an M-vector B, and a positive number DELTA, the
!    problem is to determine the convex combination X of the
!    Gauss-Newton and scaled gradient directions that minimizes
!    (A*X - B) in the least squares sense, subject to the
!    restriction that the euclidean norm of D*X be at most DELTA.
!
!    This subroutine completes the solution of the problem
!    if it is provided with the necessary information from the
!    QR factorization of A.  That is, if A = Q*R, where Q has
!    orthogonal columns and R is an upper triangular matrix,
!    then DOGLEG expects the full upper triangle of R and
!    the first N components of Q'*B.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the order of the matrix R.
!
!    Input, real ( kind = 8 ) R(LR), the upper triangular matrix R stored
!    by rows.
!
!    Input, integer ( kind = 4 ) LR, the size of the R array, which must be
!    no less than (N*(N+1))/2.
!
!    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D.
!
!    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'* B.
!
!    Input, real ( kind = 8 ) DELTA, is a positive upper bound on the
!    euclidean norm of D*X(1:N).
!
!    Output, real ( kind = 8 ) X(N), the desired convex combination of the
!    Gauss-Newton direction and the scaled gradient direction.
!
  implicit none

  integer ( kind = 4 ) lr
  integer ( kind = 4 ) n

  real ( kind = 8 ) alpha
  real ( kind = 8 ) bnorm
  real ( kind = 8 ) delta
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) enorm
  real ( kind = 8 ) epsmch
  real ( kind = 8 ) gnorm
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  integer ( kind = 4 ) jj
  integer ( kind = 4 ) k
  integer ( kind = 4 ) l
  real ( kind = 8 ) qnorm
  real ( kind = 8 ) qtb(n)
  real ( kind = 8 ) r(lr)
  real ( kind = 8 ) sgnorm
  real ( kind = 8 ) sum2
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) x(n)

  epsmch = epsilon ( epsmch )
!
!  Calculate the Gauss-Newton direction.
!
  jj = ( n * ( n + 1 ) ) / 2 + 1

  do k = 1, n

     j = n - k + 1
     jj = jj - k
     l = jj + 1
     sum2 = 0.0D+00

     do i = j + 1, n
       sum2 = sum2 + r(l) * x(i)
       l = l + 1
     end do

     temp = r(jj)

     if ( temp == 0.0D+00 ) then

       l = j
       do i = 1, j
         temp = max ( temp, abs ( r(l)) )
         l = l + n - i
       end do

       if ( temp == 0.0D+00 ) then
         temp = epsmch
       else
         temp = epsmch * temp
       end if

     end if

     x(j) = ( qtb(j) - sum2 ) / temp

  end do
!
!  Test whether the Gauss-Newton direction is acceptable.
!
  wa1(1:n) = 0.0D+00
  wa2(1:n) = diag(1:n) * x(1:n)
  qnorm = enorm ( n, wa2 )

  if ( qnorm <= delta ) then
    return
  end if
!
!  The Gauss-Newton direction is not acceptable.
!  Calculate the scaled gradient direction.
!
  l = 1
  do j = 1, n
     temp = qtb(j)
     do i = j, n
       wa1(i) = wa1(i) + r(l) * temp
       l = l + 1
     end do
     wa1(j) = wa1(j) / diag(j)
  end do
!
!  Calculate the norm of the scaled gradient.
!  Test for the special case in which the scaled gradient is zero.
!
  gnorm = enorm ( n, wa1 )
  sgnorm = 0.0D+00
  alpha = delta / qnorm

  if ( gnorm /= 0.0D+00 ) then
!
!  Calculate the point along the scaled gradient which minimizes the quadratic.
!
    wa1(1:n) = ( wa1(1:n) / gnorm ) / diag(1:n)

    l = 1
    do j = 1, n
      sum2 = 0.0D+00
      do i = j, n
        sum2 = sum2 + r(l) * wa1(i)
        l = l + 1
      end do
      wa2(j) = sum2
    end do

    temp = enorm ( n, wa2 )
    sgnorm = ( gnorm / temp ) / temp
!
!  Test whether the scaled gradient direction is acceptable.
!
    alpha = 0.0D+00
!
!  The scaled gradient direction is not acceptable.
!  Calculate the point along the dogleg at which the quadratic is minimized.
!
    if ( sgnorm < delta ) then

      bnorm = enorm ( n, qtb )
      temp = ( bnorm / gnorm ) * ( bnorm / qnorm ) * ( sgnorm / delta )
      temp = temp - ( delta / qnorm ) * ( sgnorm / delta) ** 2 &
        + sqrt ( ( temp - ( delta / qnorm ) ) ** 2 &
        + ( 1.0D+00 - ( delta / qnorm ) ** 2 ) &
        * ( 1.0D+00 - ( sgnorm / delta ) ** 2 ) )

      alpha = ( ( delta / qnorm ) * ( 1.0D+00 - ( sgnorm / delta ) ** 2 ) ) &
        / temp

    end if

  end if
!
!  Form appropriate convex combination of the Gauss-Newton
!  direction and the scaled gradient direction.
!
  temp = ( 1.0D+00 - alpha ) * min ( sgnorm, delta )

  x(1:n) = temp * wa1(1:n) + alpha * x(1:n)

  return
end subroutine dogleg
function enorm ( n, x )

!*****************************************************************************80
!
!! ENORM computes the Euclidean norm of a vector.
!
!  Discussion:
!
!    This is an extremely simplified version of the original ENORM
!    routine, which has been renamed to "ENORM2".
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, is the length of the vector.
!
!    Input, real ( kind = 8 ) X(N), the vector whose norm is desired.
!
!    Output, real ( kind = 8 ) ENORM, the Euclidean norm of the vector.
!
  implicit none

  integer ( kind = 4 ) n
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) enorm

  enorm = sqrt ( sum ( x(1:n) ** 2 ))

  return
end function enorm
function enorm2 ( n, x )

!*****************************************************************************80
!
!! ENORM2 computes the Euclidean norm of a vector.
!
!  Discussion:
!
!    This routine was named ENORM.  It has been renamed "ENORM2",
!    and a simplified routine has been substituted.
!
!    The Euclidean norm is computed by accumulating the sum of
!    squares in three different sums.  The sums of squares for the
!    small and large components are scaled so that no overflows
!    occur.  Non-destructive underflows are permitted.  Underflows
!    and overflows do not occur in the computation of the unscaled
!    sum of squares for the intermediate components.
!
!    The definitions of small, intermediate and large components
!    depend on two constants, RDWARF and RGIANT.  The main
!    restrictions on these constants are that RDWARF^2 not
!    underflow and RGIANT^2 not overflow.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1
!    Argonne National Laboratory,
!    Argonne, Illinois.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, is the length of the vector.
!
!    Input, real ( kind = 8 ) X(N), the vector whose norm is desired.
!
!    Output, real ( kind = 8 ) ENORM2, the Euclidean norm of the vector.
!
  implicit none

  integer ( kind = 4 ) n

  real ( kind = 8 ) agiant
  real ( kind = 8 ) enorm2
  integer ( kind = 4 ) i
  real ( kind = 8 ) rdwarf
  real ( kind = 8 ) rgiant
  real ( kind = 8 ) s1
  real ( kind = 8 ) s2
  real ( kind = 8 ) s3
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xabs
  real ( kind = 8 ) x1max
  real ( kind = 8 ) x3max

  rdwarf = sqrt ( tiny ( rdwarf ) )
  rgiant = sqrt ( huge ( rgiant ) )

  s1 = 0.0D+00
  s2 = 0.0D+00
  s3 = 0.0D+00
  x1max = 0.0D+00
  x3max = 0.0D+00
  agiant = rgiant / real ( n, kind = 8 )

  do i = 1, n

    xabs = abs ( x(i) )

    if ( xabs <= rdwarf ) then

      if ( x3max < xabs ) then
        s3 = 1.0D+00 + s3 * ( x3max / xabs ) ** 2
        x3max = xabs
      else if ( xabs /= 0.0D+00 ) then
        s3 = s3 + ( xabs / x3max ) ** 2
      end if

    else if ( agiant <= xabs ) then

      if ( x1max < xabs ) then
        s1 = 1.0D+00 + s1 * ( x1max / xabs ) ** 2
        x1max = xabs
      else
        s1 = s1 + ( xabs / x1max ) ** 2
      end if

    else

      s2 = s2 + xabs ** 2

    end if

  end do
!
!  Calculation of norm.
!
  if ( s1 /= 0.0D+00 ) then

    enorm2 = x1max * sqrt ( s1 + ( s2 / x1max ) / x1max )

  else if ( s2 /= 0.0D+00 ) then

    if ( x3max <= s2 ) then
      enorm2 = sqrt ( s2 * ( 1.0D+00 + ( x3max / s2 ) * ( x3max * s3 ) ) )
    else
      enorm2 = sqrt ( x3max * ( ( s2 / x3max ) + ( x3max * s3 ) ) )
    end if

  else

    enorm2 = x3max * sqrt ( s3 )

  end if

  return
end function enorm2
subroutine fdjac1 ( fcn, n, x, fvec, fjac, ldfjac, iflag, ml, mu, epsfcn, m, prms )

!*****************************************************************************80
!
!! FDJAC1 estimates an N by N jacobian matrix using forward differences.
!
!  Discussion:
!
!    This subroutine computes a forward-difference approximation
!    to the N by N jacobian matrix associated with a specified
!    problem of N functions in N variables. If the jacobian has
!    a banded form, then function evaluations are saved by only
!    approximating the nonzero terms.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!    30 Aug 2017: added `prms` to pass Parameters for constructing `FCN`
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions.  The routine should have the form:
!      subroutine fcn ( n, x, fvec, iflag )
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fvec(n)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) N, the number of functions and variables.
!
!    Input, real ( kind = 8 ) X(N), the point where the jacobian is evaluated.
!
!    Input, real ( kind = 8 ) FVEC(N), the functions evaluated at X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), the N by N approximate
!    jacobian matrix.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC, which
!    must not be less than N.
!
!    Output, integer ( kind = 4 ) IFLAG, is an error flag returned by FCN.
!    If FCN returns a nonzero value of IFLAG, then this routine returns
!    immediately to the calling program, with the value of IFLAG.
!
!    Input, integer ( kind = 4 ) ML, MU, specify the number of subdiagonals and
!    superdiagonals within the band of the jacobian matrix.  If the
!    jacobian is not banded, set ML and MU to N-1.
!
!    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step
!    length for the forward-difference approximation.  This approximation
!    assumes that the relative errors in the functions are of the order of
!    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that
!    the relative errors in the functions are of the order of the machine
!    precision.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) n
  integer ( kind = 4 ) m

  real ( kind = 8 ) eps
  real ( kind = 8 ) epsfcn
  real ( kind = 8 ) epsmch
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fvec(n)
  real ( kind = 8 ) h
  integer ( kind = 4 ) i
  integer ( kind = 4 ) iflag
  integer ( kind = 4 ) j
  integer ( kind = 4 ) k
  integer ( kind = 4 ) ml
  integer ( kind = 4 ) msum
  integer ( kind = 4 ) mu
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) prms(m)

  epsmch = epsilon ( epsmch )

  eps = sqrt ( max ( epsfcn, epsmch ) )
  msum = ml + mu + 1
!
!  Computation of dense approximate jacobian.
!
  if ( n <= msum ) then

     do j = 1, n

        temp = x(j)
        h = eps * abs ( temp )
        if ( h == 0.0D+00 ) then
          h = eps
        end if

        iflag = 1
        x(j) = temp + h
        call fcn ( n, x, wa1, iflag, m, prms )

        if ( iflag < 0 ) then
          exit
        end if

        x(j) = temp
        fjac(1:n,j) = ( wa1(1:n) - fvec(1:n) ) / h

     end do

  else
!
!  Computation of banded approximate jacobian.
!
     do k = 1, msum

        do j = k, n, msum
          wa2(j) = x(j)
          h = eps * abs ( wa2(j) )
          if ( h == 0.0D+00 ) then
            h = eps
          end if
          x(j) = wa2(j) + h
        end do

        iflag = 1
        call fcn ( n, x, wa1, iflag, m, prms )

        if ( iflag < 0 ) then
          exit
        end if

        do j = k, n, msum

           x(j) = wa2(j)

           h = eps * abs ( wa2(j) )
           if ( h == 0.0D+00 ) then
             h = eps
           end if

           fjac(1:n,j) = 0.0D+00

           do i = 1, n
             if ( j - mu <= i .and. i <= j + ml ) then
               fjac(i,j) = ( wa1(i) - fvec(i) ) / h
             end if
           end do

        end do

     end do

  end if

  return
end subroutine fdjac1
subroutine fdjac2 ( fcn, m, n, x, xdat, ydat, fvec, fjac, ldfjac, iflag, epsfcn )

!*****************************************************************************80
!
!! FDJAC2 estimates an M by N jacobian matrix using forward differences.
!
!  Discussion:
!
!    This subroutine computes a forward-difference approximation
!    to the M by N jacobian matrix associated with a specified
!    problem of M functions in N variables.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions.  The routine should have the form:
!      subroutine fcn ( m, n, x, xdat, ydat, fvec, iflag ) ! xdat/ydat added for AnOHM, TS 20 Jul 2017
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fvec(m)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) M, is the number of functions.
!
!    Input, integer ( kind = 4 ) N, is the number of variables.
!    N must not exceed M.
!
!    Input, real ( kind = 8 ) X(N), the point where the jacobian is evaluated.
!
!    Input, real ( kind = 8 ) FVEC(M), the functions evaluated at X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), the M by N approximate
!    jacobian matrix.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC,
!    which must not be less than M.
!
!    Output, integer ( kind = 4 ) IFLAG, is an error flag returned by FCN.
!    If FCN returns a nonzero value of IFLAG, then this routine returns
!    immediately to the calling program, with the value of IFLAG.
!
!    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable
!    step length for the forward-difference approximation.  This approximation
!    assumes that the relative errors in the functions are of the order of
!    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that
!    the relative errors in the functions are of the order of the machine
!    precision.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) eps
  real ( kind = 8 ) epsfcn
  real ( kind = 8 ) epsmch
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fvec(m),xdat(m),ydat(m)
  real ( kind = 8 ) h
  ! integer ( kind = 4 ) i
  integer ( kind = 4 ) iflag
  integer ( kind = 4 ) j
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa(m)
  real ( kind = 8 ) x(n)

  epsmch = epsilon ( epsmch )

  eps = sqrt ( max ( epsfcn, epsmch ) )

  do j = 1, n

    temp = x(j)
    h = eps * abs ( temp )
    if ( h == 0.0D+00 ) then
      h = eps
    end if

    iflag = 1
    x(j) = temp + h
    call fcn ( m, n, x, xdat, ydat, wa, iflag )

    if ( iflag < 0 ) then
      exit
    end if

    x(j) = temp
    fjac(1:m,j) = ( wa(1:m) - fvec(1:m) ) / h

  end do

  return
end subroutine fdjac2


subroutine hybrd ( fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, &
  factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, m, prms )

!*****************************************************************************80
!
!! HYBRD seeks a zero of N nonlinear equations in N variables.
!
!  Discussion:
!
!    HYBRD finds a zero of a system of N nonlinear functions in N variables
!    by a modification of the Powell hybrid method.  The user must provide a
!    subroutine which calculates the functions.  The jacobian is
!    then calculated by a forward-difference approximation.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions.  The routine should have the form:
!      subroutine fcn ( n, x, fvec, iflag )
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fvec(n)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) N, the number of functions and variables.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X.
!
!    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error
!    between two consecutive iterates is at most XTOL.  XTOL should be
!    nonnegative.
!
!    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of
!    calls to FCN is at least MAXFEV by the end of an iteration.
!
!    Input, integer ( kind = 4 ) ML, MU, specify the number of subdiagonals and
!    superdiagonals within the band of the jacobian matrix.  If the jacobian
!    is not banded, set ML and MU to at least n - 1.
!
!    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step
!    length for the forward-difference approximation.  This approximation
!    assumes that the relative errors in the functions are of the order of
!    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that
!    the relative errors in the functions are of the order of the machine
!    precision.
!
!    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set
!    internally.  If MODE = 2, then DIAG must contain positive entries that
!    serve as multiplicative scale factors for the variables.
!
!    Input, integer ( kind = 4 ) MODE, scaling option.
!    1, variables will be scaled internally.
!    2, scaling is specified by the input DIAG vector.
!
!    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This
!    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if
!    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie
!    in the interval (0.1, 100) with 100 the recommended value.
!
!    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of
!    iterates if it is positive.  In this case, FCN is called with IFLAG = 0 at
!    the beginning of the first iteration and every NPRINT iterations thereafter
!    and immediately prior to return, with X and FVEC available
!    for printing.  If NPRINT is not positive, no special calls
!    of FCN with IFLAG = 0 are made.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG.
!    See the description of FCN.
!    Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, relative error between two consecutive iterates is at most XTOL.
!    2, number of calls to FCN has reached or exceeded MAXFEV.
!    3, XTOL is too small.  No further improvement in the approximate
!       solution X is possible.
!    4, iteration is not making good progress, as measured by the improvement
!       from the last five jacobian evaluations.
!    5, iteration is not making good progress, as measured by the improvement
!       from the last ten iterations.
!
!    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array which contains
!    the orthogonal matrix Q produced by the QR factorization of the final
!    approximate jacobian.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC.
!    LDFJAC must be at least N.
!
!    Output, real ( kind = 8 ) R(LR), the upper triangular matrix produced by
!    the QR factorization of the final approximate jacobian, stored rowwise.
!
!    Input, integer ( kind = 4 ) LR, the size of the R array, which must be no
!    less than (N*(N+1))/2.
!
!    Output, real ( kind = 8 ) QTF(N), contains the vector Q'*FVEC.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) lr
  integer ( kind = 4 ) n
  integer ( kind = 4 ) m

  real ( kind = 8 ) actred
  real ( kind = 8 ) delta
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) enorm
  real ( kind = 8 ) epsfcn
  real ( kind = 8 ) epsmch
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fnorm
  real ( kind = 8 ) fnorm1
  real ( kind = 8 ) fvec(n)
  integer ( kind = 4 ) i
  integer ( kind = 4 ) iflag
  integer ( kind = 4 ) info
  integer ( kind = 4 ) iter
  integer ( kind = 4 ) iwa(1)
  integer ( kind = 4 ) j
  logical jeval
  integer ( kind = 4 ) l
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) ml
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) msum
  integer ( kind = 4 ) mu
  integer ( kind = 4 ) ncfail
  integer ( kind = 4 ) nslow1
  integer ( kind = 4 ) nslow2
  integer ( kind = 4 ) ncsuc
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) nprint
  logical pivot
  real ( kind = 8 ) pnorm
  real ( kind = 8 ) prered
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) r(lr)
  real ( kind = 8 ) ratio
  logical sing
  real ( kind = 8 ) sum2
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) wa3(n)
  real ( kind = 8 ) wa4(n)
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xnorm
  real ( kind = 8 ) xtol
  real ( kind = 8 ) prms(m)

  epsmch = epsilon ( epsmch )

  info = 0
  iflag = 0
  nfev = 0
!
!  Check the input parameters for errors.
!
  if ( n <= 0 ) then
    return
  else if ( xtol < 0.0D+00 ) then
    return
  else if ( maxfev <= 0 ) then
    return
  else if ( ml < 0 ) then
    return
  else if ( mu < 0 ) then
    return
  else if ( factor <= 0.0D+00 ) then
    return
  else if ( ldfjac < n ) then
    return
  else if ( lr < ( n * ( n + 1 ) ) / 2 ) then
    return
  end if

  if ( mode == 2 ) then

    do j = 1, n
      if ( diag(j) <= 0.0D+00 ) then
        go to 300
      end if
    end do

  end if
!
!  Evaluate the function at the starting point
!  and calculate its norm.
!
  iflag = 1
  call fcn ( n, x, fvec, iflag, m, prms )
  nfev = 1

  if ( iflag < 0 ) then
    go to 300
  end if

  fnorm = enorm ( n, fvec )
!
!  Determine the number of calls to FCN needed to compute the jacobian matrix.
!
  msum = min ( ml + mu + 1, n )
!
!  Initialize iteration counter and monitors.
!
  iter = 1
  ncsuc = 0
  ncfail = 0
  nslow1 = 0
  nslow2 = 0
!
!  Beginning of the outer loop.
!
30 continue

    jeval = .true.
!
!  Calculate the jacobian matrix.
!
    iflag = 2
    call fdjac1 ( fcn, n, x, fvec, fjac, ldfjac, iflag, ml, mu, epsfcn, m, prms )

    nfev = nfev + msum

    if ( iflag < 0 ) then
      go to 300
    end if
!
!  Compute the QR factorization of the jacobian.
!
    pivot = .false.
    call qrfac ( n, n, fjac, ldfjac, pivot, iwa, 1, wa1, wa2 )
!
!  On the first iteration, if MODE is 1, scale according
!  to the norms of the columns of the initial jacobian.
!
    if ( iter == 1 ) then

      if ( mode /= 2 ) then

        diag(1:n) = wa2(1:n)
        do j = 1, n
          if ( wa2(j) == 0.0D+00 ) then
            diag(j) = 1.0D+00
          end if
        end do

      end if
!
!  On the first iteration, calculate the norm of the scaled X
!  and initialize the step bound DELTA.
!
      wa3(1:n) = diag(1:n) * x(1:n)
      xnorm = enorm ( n, wa3 )
      delta = factor * xnorm
      if ( delta == 0.0D+00 ) then
        delta = factor
      end if

    end if
!
!  Form Q' * FVEC and store in QTF.
!
     qtf(1:n) = fvec(1:n)

     do j = 1, n

       if ( fjac(j,j) /= 0.0D+00 ) then
         temp = - dot_product ( qtf(j:n), fjac(j:n,j) ) / fjac(j,j)
         qtf(j:n) = qtf(j:n) + fjac(j:n,j) * temp
       end if

     end do
!
!  Copy the triangular factor of the QR factorization into R.
!
     sing = .false.

     do j = 1, n
        l = j
        do i = 1, j - 1
          r(l) = fjac(i,j)
          l = l + n - i
        end do
        r(l) = wa1(j)
        if ( wa1(j) == 0.0D+00 ) then
          sing = .true.
        end if
     end do
!
!  Accumulate the orthogonal factor in FJAC.
!
     call qform ( n, n, fjac, ldfjac )
!
!  Rescale if necessary.
!
     if ( mode /= 2 ) then
       do j = 1, n
         diag(j) = max ( diag(j), wa2(j) )
       end do
     end if
!
!  Beginning of the inner loop.
!
180    continue
!
!  If requested, call FCN to enable printing of iterates.
!
        if ( 0 < nprint ) then
          iflag = 0
          if ( mod ( iter - 1, nprint ) == 0 ) then
            call fcn ( n, x, fvec, iflag, m, prms )
          end if
          if ( iflag < 0 ) then
            go to 300
          end if
        end if
!
!  Determine the direction P.
!
        call dogleg ( n, r, lr, diag, qtf, delta, wa1 )
!
!  Store the direction P and X + P.
!  Calculate the norm of P.
!
        wa1(1:n) = - wa1(1:n)
        wa2(1:n) = x(1:n) + wa1(1:n)
        wa3(1:n) = diag(1:n) * wa1(1:n)

        pnorm = enorm ( n, wa3 )
!
!  On the first iteration, adjust the initial step bound.
!
        if ( iter == 1 ) then
          delta = min ( delta, pnorm )
        end if
!
!  Evaluate the function at X + P and calculate its norm.
!
        iflag = 1
        call fcn ( n, wa2, wa4, iflag, m, prms )
        nfev = nfev + 1

        if ( iflag < 0 ) then
          go to 300
        end if

        fnorm1 = enorm ( n, wa4 )
!
!  Compute the scaled actual reduction.
!
        actred = -1.0D+00
        if ( fnorm1 < fnorm ) then
          actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2
        endif
!
!  Compute the scaled predicted reduction.
!
        l = 1
        do i = 1, n
          sum2 = 0.0D+00
          do j = i, n
            sum2 = sum2 + r(l) * wa1(j)
            l = l + 1
          end do
          wa3(i) = qtf(i) + sum2
        end do

        temp = enorm ( n, wa3 )
        prered = 0.0D+00
        if ( temp < fnorm ) then
          prered = 1.0D+00 - ( temp / fnorm ) ** 2
        end if
!
!  Compute the ratio of the actual to the predicted reduction.
!
        ratio = 0.0D+00
        if ( 0.0D+00 < prered ) then
          ratio = actred / prered
        end if
!
!  Update the step bound.
!
        if ( ratio < 0.1D+00 ) then

          ncsuc = 0
          ncfail = ncfail + 1
          delta = 0.5D+00 * delta

        else

          ncfail = 0
          ncsuc = ncsuc + 1

          if ( 0.5D+00 <= ratio .or. 1 < ncsuc ) then
            delta = max ( delta, pnorm / 0.5D+00 )
          end if

          if ( abs ( ratio - 1.0D+00 ) <= 0.1D+00 ) then
            delta = pnorm / 0.5D+00
          end if

        end if
!
!  Test for successful iteration.
!
!  Successful iteration.
!  Update X, FVEC, and their norms.
!
        if ( 0.0001D+00 <= ratio ) then
          x(1:n) = wa2(1:n)
          wa2(1:n) = diag(1:n) * x(1:n)
          fvec(1:n) = wa4(1:n)
          xnorm = enorm ( n, wa2 )
          fnorm = fnorm1
          iter = iter + 1
        end if
!
!  Determine the progress of the iteration.
!
        nslow1 = nslow1 + 1
        if ( 0.001D+00 <= actred ) then
          nslow1 = 0
        end if

        if ( jeval ) then
          nslow2 = nslow2 + 1
        end if

        if ( 0.1D+00 <= actred ) then
          nslow2 = 0
        end if
!
!  Test for convergence.
!
        if ( delta <= xtol * xnorm .or. fnorm == 0.0D+00 ) then
          info = 1
        end if

        if ( info /= 0 ) then
          go to 300
        end if
!
!  Tests for termination and stringent tolerances.
!
        if ( maxfev <= nfev ) then
          info = 2
        end if

        if ( 0.1D+00 * max ( 0.1D+00 * delta, pnorm ) <= epsmch * xnorm ) then
          info = 3
        end if

        if ( nslow2 == 5 ) then
          info = 4
        end if

        if ( nslow1 == 10 ) then
          info = 5
        end if

        if ( info /= 0 ) then
          go to 300
        end if
!
!  Criterion for recalculating jacobian approximation
!  by forward differences.
!
        if ( ncfail == 2 ) then
          go to 290
        end if
!
!  Calculate the rank one modification to the jacobian
!  and update QTF if necessary.
!
        do j = 1, n
          sum2 = dot_product ( wa4(1:n), fjac(1:n,j) )
          wa2(j) = ( sum2 - wa3(j) ) / pnorm
          wa1(j) = diag(j) * ( ( diag(j) * wa1(j) ) / pnorm )
          if ( 0.0001D+00 <= ratio ) then
            qtf(j) = sum2
          end if
        end do
!
!  Compute the QR factorization of the updated jacobian.
!
        call r1updt ( n, n, r, lr, wa1, wa2, wa3, sing )
        call r1mpyq ( n, n, fjac, ldfjac, wa2, wa3 )
        call r1mpyq ( 1, n, qtf, 1, wa2, wa3 )
!
!  End of the inner loop.
!
        jeval = .false.
        go to 180

  290   continue
!
!  End of the outer loop.
!
     go to 30

  300 continue
!
!  Termination, either normal or user imposed.
!
  if ( iflag < 0 ) then
    info = iflag
  end if

  iflag = 0

  if ( 0 < nprint ) then
    call fcn ( n, x, fvec, iflag, m, prms )
  end if

  return
end subroutine hybrd


subroutine hybrd1 ( fcn, n, x, fvec, tol, info, m, prms )

!*****************************************************************************80
!
!! HYBRD1 seeks a zero of N nonlinear equations in N variables.
!
!  Discussion:
!
!    HYBRD1 finds a zero of a system of N nonlinear functions in N variables
!    by a modification of the Powell hybrid method.  This is done by using the
!    more general nonlinear equation solver HYBRD.  The user must provide a
!    subroutine which calculates the functions.  The jacobian is then
!    calculated by a forward-difference approximation.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    19 August 2016
!    30 Aug 2017: added `prms` to pass paramters for constructing `fcn`
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions.  The routine should have the form:
!      subroutine fcn ( n, x, fvec, iflag )
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fvec(n)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!      integer ( kind = 4 ) m
!      real ( kind = 8 ) prm(m)
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) N, the number of functions and variables.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Input, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X.
!
!    Input, integer ( kind = 4 ) M, the number of parameters for constructing FCN.
!
!    Input, real ( kind = 8 ) PRMS(M), static paramters for constructing FCN.
!
!    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm
!    estimates that the relative error between X and the solution is at
!    most TOL.  TOL should be nonnegative.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See the
!    description of FCN.
!    Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, algorithm estimates that the relative error between X and the
!       solution is at most TOL.
!    2, number of calls to FCN has reached or exceeded 200*(N+1).
!    3, TOL is too small.  No further improvement in the approximate
!       solution X is possible.
!    4, the iteration is not making good progress.
!
  implicit none

  ! integer ( kind = 4 ) lwa
  integer ( kind = 4 ) n
  integer ( kind = 4 ) m

  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) epsfcn
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(n,n)
  real ( kind = 8 ) fvec(n)
  integer ( kind = 4 ) info
  ! integer ( kind = 4 ) j
  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) lr
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) ml
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) mu
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) r((n*(n+1))/2)
  real ( kind = 8 ) tol
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xtol
  real ( kind = 8 ) prms(m)

  if ( n <= 0 ) then
    info = 0
    return
  end if

  if ( tol < 0.0D+00 ) then
    info = 0
    return
  end if

  xtol = tol
  maxfev = 200 * ( n + 1 )
  ml = n - 1
  mu = n - 1
  epsfcn = 0.0D+00
  diag(1:n) = 1.0D+00
  mode = 2
  factor = 100.0D+00
  nprint = 0
  info = 0
  nfev = 0
  fjac(1:n,1:n) = 0.0D+00
  ldfjac = n
  r(1:(n*(n+1))/2) = 0.0D+00
  lr = ( n * ( n + 1 ) ) / 2
  qtf(1:n) = 0.0D+00

  call hybrd ( fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, &
    factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, m, prms )

  if ( info == 5 ) then
    info = 4
  end if

  return
end subroutine hybrd1
subroutine hybrj ( fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, &
  factor, nprint, info, nfev, njev, r, lr, qtf )

!*****************************************************************************80
!
!! HYBRJ seeks a zero of N nonlinear equations in N variables.
!
!  Discussion:
!
!    HYBRJ finds a zero of a system of N nonlinear functions in N variables
!    by a modification of the Powell hybrid method.  The user must provide a
!    subroutine which calculates the functions and the jacobian.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions and the jacobian.  FCN should have the form:
!
!      subroutine fcn ( n, x, fvec, fjac, ldfjac, iflag )
!      integer ( kind = 4 ) ldfjac
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fjac(ldfjac,n)
!      real ( kind = 8 ) fvec(n)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    If IFLAG = 2 on input, FCN should calculate the jacobian at X and
!    return this matrix in FJAC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) N, the number of functions and variables.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N matrix, containing
!    the orthogonal matrix Q produced by the QR factorization
!    of the final approximate jacobian.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of the
!    array FJAC.  LDFJAC must be at least N.
!
!    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error
!    between two consecutive iterates is at most XTOL.  XTOL should be
!    nonnegative.
!
!    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of
!    calls to FCN is at least MAXFEV by the end of an iteration.
!
!    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set
!    internally.  If MODE = 2, then DIAG must contain positive entries that
!    serve as multiplicative scale factors for the variables.
!
!    Input, integer ( kind = 4 ) MODE, scaling option.
!    1, variables will be scaled internally.
!    2, scaling is specified by the input DIAG vector.
!
!    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This
!    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if
!    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie
!    in the interval (0.1, 100) with 100 the recommended value.
!
!    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates
!    if it is positive.  In this case, FCN is called with IFLAG = 0 at the
!    beginning of the first iteration and every NPRINT iterations thereafter
!    and immediately prior to return, with X and FVEC available
!    for printing.  If NPRINT is not positive, no special calls
!    of FCN with IFLAG = 0 are made.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG.
!    See the description of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, relative error between two consecutive iterates is at most XTOL.
!    2, number of calls to FCN with IFLAG = 1 has reached MAXFEV.
!    3, XTOL is too small.  No further improvement in
!       the approximate solution X is possible.
!    4, iteration is not making good progress, as measured by the
!       improvement from the last five jacobian evaluations.
!    5, iteration is not making good progress, as measured by the
!       improvement from the last ten iterations.
!
!    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN
!    with IFLAG = 1.
!
!    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN
!    with IFLAG = 2.
!
!    Output, real ( kind = 8 ) R(LR), the upper triangular matrix produced
!    by the QR factorization of the final approximate jacobian, stored rowwise.
!
!    Input, integer ( kind = 4 ) LR, the size of the R array, which must
!    be no less than (N*(N+1))/2.
!
!    Output, real ( kind = 8 ) QTF(N), contains the vector Q'*FVEC.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) lr
  integer ( kind = 4 ) n

  real ( kind = 8 ) actred
  real ( kind = 8 ) delta
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) enorm
  real ( kind = 8 ) epsmch
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fnorm
  real ( kind = 8 ) fnorm1
  real ( kind = 8 ) fvec(n)
  integer ( kind = 4 ) i
  integer ( kind = 4 ) iflag
  integer ( kind = 4 ) info
  integer ( kind = 4 ) iter
  integer ( kind = 4 ) iwa(1)
  integer ( kind = 4 ) j
  logical jeval
  integer ( kind = 4 ) l
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) ncfail
  integer ( kind = 4 ) nslow1
  integer ( kind = 4 ) nslow2
  integer ( kind = 4 ) ncsuc
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) njev
  integer ( kind = 4 ) nprint
  logical pivot
  real ( kind = 8 ) pnorm
  real ( kind = 8 ) prered
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) r(lr)
  real ( kind = 8 ) ratio
  logical sing
  real ( kind = 8 ) sum2
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) wa3(n)
  real ( kind = 8 ) wa4(n)
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xnorm
  real ( kind = 8 ) xtol

  epsmch = epsilon ( epsmch )

  info = 0
  iflag = 0
  nfev = 0
  njev = 0
!
!  Check the input parameters for errors.
!
  if ( n <= 0 ) then
    if ( iflag < 0 ) then
      info = iflag
    end if
    iflag = 0
    if ( 0 < nprint ) then
      call fcn ( n, x, fvec, fjac, ldfjac, iflag )
    end if
    return
  end if

  if ( ldfjac < n .or. &
       xtol < 0.0D+00 .or. &
       maxfev <= 0 .or. &
       factor <= 0.0D+00 .or. &
       lr < ( n * ( n + 1 ) ) / 2 ) then
    if ( iflag < 0 ) then
      info = iflag
    end if
    iflag = 0
    if ( 0 < nprint ) then
      call fcn ( n, x, fvec, fjac, ldfjac, iflag )
    end if
    return
  end if

  if ( mode == 2 ) then
    do j = 1, n
      if ( diag(j) <= 0.0D+00 ) then
        if ( iflag < 0 ) then
          info = iflag
        end if
        iflag = 0
        if ( 0 < nprint ) then
          call fcn ( n, x, fvec, fjac, ldfjac, iflag )
        end if
        return
      end if
    end do
  end if
!
!  Evaluate the function at the starting point and calculate its norm.
!
  iflag = 1
  call fcn ( n, x, fvec, fjac, ldfjac, iflag )
  nfev = 1

  if ( iflag < 0 ) then
    if ( iflag < 0 ) then
      info = iflag
    end if
    iflag = 0
    if ( 0 < nprint ) then
      call fcn ( n, x, fvec, fjac, ldfjac, iflag )
    end if
    return
  end if

  fnorm = enorm ( n, fvec )
!
!  Initialize iteration counter and monitors.
!
  iter = 1
  ncsuc = 0
  ncfail = 0
  nslow1 = 0
  nslow2 = 0
!
!  Beginning of the outer loop.
!
  do

    jeval = .true.
!
!  Calculate the jacobian matrix.
!
    iflag = 2
    call fcn ( n, x, fvec, fjac, ldfjac, iflag )
    njev = njev + 1

    if ( iflag < 0 ) then
      info = iflag
      iflag = 0
      if ( 0 < nprint ) then
        call fcn ( n, x, fvec, fjac, ldfjac, iflag )
      end if
      return
    end if
!
!  Compute the QR factorization of the jacobian.
!
    pivot = .false.
    call qrfac ( n, n, fjac, ldfjac, pivot, iwa, 1, wa1, wa2 )
!
!  On the first iteration, if MODE is 1, scale according
!  to the norms of the columns of the initial jacobian.
!
    if ( iter == 1 ) then

      if ( mode /= 2 ) then
        diag(1:n) = wa2(1:n)
        do j = 1, n
          if ( wa2(j) == 0.0D+00 ) then
            diag(j) = 1.0D+00
          end if
        end do
      end if
!
!  On the first iteration, calculate the norm of the scaled X
!  and initialize the step bound DELTA.
!
      wa3(1:n) = diag(1:n) * x(1:n)
      xnorm = enorm ( n, wa3 )
      delta = factor * xnorm
      if ( delta == 0.0D+00 ) then
        delta = factor
      end if

    end if
!
!  Form Q'*FVEC and store in QTF.
!
    qtf(1:n) = fvec(1:n)

    do j = 1, n
      if ( fjac(j,j) /= 0.0D+00 ) then
        sum2 = 0.0D+00
        do i = j, n
          sum2 = sum2 + fjac(i,j) * qtf(i)
        end do
        temp = - sum2 / fjac(j,j)
        do i = j, n
          qtf(i) = qtf(i) + fjac(i,j) * temp
        end do
      end if
    end do
!
!  Copy the triangular factor of the QR factorization into R.
!
    sing = .false.

    do j = 1, n
      l = j
      do i = 1, j - 1
        r(l) = fjac(i,j)
        l = l + n - i
      end do
      r(l) = wa1(j)
      if ( wa1(j) == 0.0D+00 ) then
        sing = .true.
      end if
    end do
!
!  Accumulate the orthogonal factor in FJAC.
!
    call qform ( n, n, fjac, ldfjac )
!
!  Rescale if necessary.
!
    if ( mode /= 2 ) then
      do j = 1, n
        diag(j) = max ( diag(j), wa2(j) )
      end do
    end if
!
!  Beginning of the inner loop.
!
    do
!
!  If requested, call FCN to enable printing of iterates.
!
      if ( 0 < nprint ) then

        iflag = 0
        if ( mod ( iter - 1, nprint ) == 0 ) then
          call fcn ( n, x, fvec, fjac, ldfjac, iflag )
        end if

        if ( iflag < 0 ) then
          info = iflag
          iflag = 0
          if ( 0 < nprint ) then
            call fcn ( n, x, fvec, fjac, ldfjac, iflag )
          end if
          return
        end if

      end if
!
!  Determine the direction P.
!
      call dogleg ( n, r, lr, diag, qtf, delta, wa1 )
!
!  Store the direction P and X + P.
!  Calculate the norm of P.
!
      wa1(1:n) = - wa1(1:n)
      wa2(1:n) = x(1:n) + wa1(1:n)
      wa3(1:n) = diag(1:n) * wa1(1:n)
      pnorm = enorm ( n, wa3 )
!
!  On the first iteration, adjust the initial step bound.
!
      if ( iter == 1 ) then
        delta = min ( delta, pnorm )
      end if
!
!  Evaluate the function at X + P and calculate its norm.
!
      iflag = 1
      call fcn ( n, wa2, wa4, fjac, ldfjac, iflag )
      nfev = nfev + 1

      if ( iflag < 0 ) then
        info = iflag
        iflag = 0
        if ( 0 < nprint ) then
          call fcn ( n, x, fvec, fjac, ldfjac, iflag )
        end if
        return
      end if

      fnorm1 = enorm ( n, wa4 )
!
!  Compute the scaled actual reduction.
!
      actred = -1.0D+00
      if ( fnorm1 < fnorm ) then
        actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2
      end if
!
!  Compute the scaled predicted reduction.
!
      l = 1
      do i = 1, n
        sum2 = 0.0D+00
        do j = i, n
          sum2 = sum2 + r(l) * wa1(j)
          l = l + 1
        end do
        wa3(i) = qtf(i) + sum2
      end do

      temp = enorm ( n, wa3 )
      prered = 0.0D+00
      if ( temp < fnorm ) then
        prered = 1.0D+00 - ( temp / fnorm ) ** 2
      end if
!
!  Compute the ratio of the actual to the predicted reduction.
!
      if ( 0.0D+00 < prered ) then
        ratio = actred / prered
      else
        ratio = 0.0D+00
      end if
!
!  Update the step bound.
!
      if ( ratio < 0.1D+00 ) then

        ncsuc = 0
        ncfail = ncfail + 1
        delta = 0.5D+00 * delta

      else

        ncfail = 0
        ncsuc = ncsuc + 1

        if ( 0.5D+00 <= ratio .or. 1 < ncsuc ) then
          delta = max ( delta, pnorm / 0.5D+00 )
        end if

        if ( abs ( ratio - 1.0D+00 ) <= 0.1D+00 ) then
          delta = pnorm / 0.5D+00
        end if

      end if
!
!  Test for successful iteration.
!

!
!  Successful iteration.
!  Update X, FVEC, and their norms.
!
      if ( 0.0001D+00 <= ratio ) then
        x(1:n) = wa2(1:n)
        wa2(1:n) = diag(1:n) * x(1:n)
        fvec(1:n) = wa4(1:n)
        xnorm = enorm ( n, wa2 )
        fnorm = fnorm1
        iter = iter + 1
      end if
!
!  Determine the progress of the iteration.
!
      nslow1 = nslow1 + 1
      if ( 0.001D+00 <= actred ) then
        nslow1 = 0
      end if

      if ( jeval ) then
        nslow2 = nslow2 + 1
      end if

      if ( 0.1D+00 <= actred ) then
        nslow2 = 0
      end if
!
!  Test for convergence.
!
      if ( delta <= xtol * xnorm .or. fnorm == 0.0D+00 ) then
        info = 1
      end if

      if ( info /= 0 ) then
        iflag = 0
        if ( 0 < nprint ) then
          call fcn ( n, x, fvec, fjac, ldfjac, iflag )
        end if
        return
      end if
!
!  Tests for termination and stringent tolerances.
!
      if ( maxfev <= nfev ) then
        info = 2
      end if

      if ( 0.1D+00 * max ( 0.1D+00 * delta, pnorm ) <= epsmch * xnorm ) then
        info = 3
      end if

      if ( nslow2 == 5 ) then
        info = 4
      end if

      if ( nslow1 == 10 ) then
        info = 5
      end if

      if ( info /= 0 ) then
        iflag = 0
        if ( 0 < nprint ) then
          call fcn ( n, x, fvec, fjac, ldfjac, iflag )
        end if
        return
      end if
!
!  Criterion for recalculating jacobian.
!
      if ( ncfail == 2 ) then
        exit
      end if
!
!  Calculate the rank one modification to the jacobian
!  and update QTF if necessary.
!
      do j = 1, n
        sum2 = dot_product ( wa4(1:n), fjac(1:n,j) )
        wa2(j) = ( sum2 - wa3(j) ) / pnorm
        wa1(j) = diag(j) * ( ( diag(j) * wa1(j) ) / pnorm )
        if ( 0.0001D+00 <= ratio ) then
          qtf(j) = sum2
        end if
      end do
!
!  Compute the QR factorization of the updated jacobian.
!
      call r1updt ( n, n, r, lr, wa1, wa2, wa3, sing )
      call r1mpyq ( n, n, fjac, ldfjac, wa2, wa3 )
      call r1mpyq ( 1, n, qtf, 1, wa2, wa3 )
!
!  End of the inner loop.
!
      jeval = .false.

    end do
!
!  End of the outer loop.
!
  end do

end subroutine hybrj
subroutine hybrj1 ( fcn, n, x, fvec, fjac, ldfjac, tol, info )

!*****************************************************************************80
!
!! HYBRJ1 seeks a zero of N equations in N variables by Powell's method.
!
!  Discussion:
!
!    HYBRJ1 finds a zero of a system of N nonlinear functions in N variables
!    by a modification of the Powell hybrid method.  This is done by using the
!    more general nonlinear equation solver HYBRJ.  The user
!    must provide a subroutine which calculates the functions
!    and the jacobian.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions and the jacobian.  FCN should have the form:
!      subroutine fcn ( n, x, fvec, fjac, ldfjac, iflag )
!      integer ( kind = 4 ) ldfjac
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fjac(ldfjac,n)
!      real ( kind = 8 ) fvec(n)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    If IFLAG = 2 on input, FCN should calculate the jacobian at X and
!    return this matrix in FJAC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) N, the number of functions and variables.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array which contains
!    the orthogonal matrix Q produced by the QR factorization of the final
!    approximate jacobian.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of  FJAC.
!    LDFJAC must be at least N.
!
!    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm
!    estimates that the relative error between X and the solution is at most
!    TOL.  TOL should be nonnegative.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See description
!    of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, algorithm estimates that the relative error between X and the
!       solution is at most TOL.
!    2, number of calls to FCN with IFLAG = 1 has reached 100*(N+1).
!    3, TOL is too small.  No further improvement in the approximate
!       solution X is possible.
!    4, iteration is not making good progress.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) n

  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fvec(n)
  integer ( kind = 4 ) info
  ! integer ( kind = 4 ) j
  integer ( kind = 4 ) lr
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) njev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) r((n*(n+1))/2)
  real ( kind = 8 ) tol
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xtol

  info = 0

  if ( n <= 0 ) then
    return
  else if ( ldfjac < n ) then
    return
  else if ( tol < 0.0D+00 ) then
    return
  end if

  maxfev = 100 * ( n + 1 )
  xtol = tol
  mode = 2
  diag(1:n) = 1.0D+00
  factor = 100.0D+00
  nprint = 0
  lr = ( n * ( n + 1 ) ) / 2

  call hybrj ( fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, &
    factor, nprint, info, nfev, njev, r, lr, qtf )

  if ( info == 5 ) then
    info = 4
  end if

  return
end subroutine hybrj1
subroutine lmder ( fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, &
  diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf )

!*****************************************************************************80
!
!! LMDER minimizes M functions in N variables by the Levenberg-Marquardt method.
!
!  Discussion:
!
!    LMDER minimizes the sum of the squares of M nonlinear functions in
!    N variables by a modification of the Levenberg-Marquardt algorithm.
!    The user must provide a subroutine which calculates the functions
!    and the jacobian.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions and the jacobian.  FCN should have the form:
!      subroutine fcn ( m, n, x, fvec, fjac, ldfjac, iflag )
!      integer ( kind = 4 ) ldfjac
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fjac(ldfjac,n)
!      real ( kind = 8 ) fvec(m)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    If IFLAG = 2 on input, FCN should calculate the jacobian at X and
!    return this matrix in FJAC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) M, is the number of functions.
!
!    Input, integer ( kind = 4 ) N, is the number of variables.
!    N must not exceed M.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper
!    N by N submatrix of FJAC contains an upper triangular matrix R with
!    diagonal elements of nonincreasing magnitude such that
!      P' * ( JAC' * JAC ) * P = R' * R,
!    where P is a permutation matrix and JAC is the final calculated jacobian.
!    Column J of P is column IPVT(J) of the identity matrix.  The lower
!    trapezoidal part of FJAC contains information generated during
!    the computation of R.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC.
!    LDFJAC must be at least M.
!
!    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual
!    and predicted relative reductions in the sum of squares are at most FTOL.
!    Therefore, FTOL measures the relative error desired in the sum of
!    squares.  FTOL should be nonnegative.
!
!    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error
!    between two consecutive iterates is at most XTOL.  XTOL should be
!    nonnegative.
!
!    Input, real ( kind = 8 ) GTOL.  Termination occurs when the cosine of the
!    angle between FVEC and any column of the jacobian is at most GTOL in
!    absolute value.  Therefore, GTOL measures the orthogonality desired
!    between the function vector and the columns of the jacobian.  GTOL should
!    be nonnegative.
!
!    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of
!    calls to FCN with IFLAG = 1 is at least MAXFEV by the end of an iteration.
!
!    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set
!    internally.  If MODE = 2, then DIAG must contain positive entries that
!    serve as multiplicative scale factors for the variables.
!
!    Input, integer ( kind = 4 ) MODE, scaling option.
!    1, variables will be scaled internally.
!    2, scaling is specified by the input DIAG vector.
!
!    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This
!    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if
!    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie
!    in the interval (0.1, 100) with 100 the recommended value.
!
!    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates
!    if it is positive.  In this case, FCN is called with IFLAG = 0 at the
!    beginning of the first iteration and every NPRINT iterations thereafter
!    and immediately prior to return, with X and FVEC available
!    for printing.  If NPRINT is not positive, no special calls
!    of FCN with IFLAG = 0 are made.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See description
!    of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, both actual and predicted relative reductions in the sum of
!       squares are at most FTOL.
!    2, relative error between two consecutive iterates is at most XTOL.
!    3, conditions for INFO = 1 and INFO = 2 both hold.
!    4, the cosine of the angle between FVEC and any column of the jacobian
!       is at most GTOL in absolute value.
!    5, number of calls to FCN with IFLAG = 1 has reached MAXFEV.
!    6, FTOL is too small.  No further reduction in the sum of squares
!       is possible.
!    7, XTOL is too small.  No further improvement in the approximate
!       solution X is possible.
!    8, GTOL is too small.  FVEC is orthogonal to the columns of the
!       jacobian to machine precision.
!
!    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN with
!    IFLAG = 1.
!
!    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN with
!    IFLAG = 2.
!
!    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P
!    such that JAC*P = Q*R, where JAC is the final calculated jacobian, Q is
!    orthogonal (not stored), and R is upper triangular with diagonal
!    elements of nonincreasing magnitude.  Column J of P is column
!    IPVT(J) of the identity matrix.
!
!    Output, real ( kind = 8 ) QTF(N), contains the first N elements of Q'*FVEC.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) actred
  real ( kind = 8 ) delta
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) dirder
  real ( kind = 8 ) enorm
  real ( kind = 8 ) epsmch
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fnorm
  real ( kind = 8 ) fnorm1
  real ( kind = 8 ) ftol
  real ( kind = 8 ) fvec(m)
  real ( kind = 8 ) gnorm
  real ( kind = 8 ) gtol
  ! integer ( kind = 4 ) i
  integer ( kind = 4 ) iflag
  integer ( kind = 4 ) info
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) iter
  integer ( kind = 4 ) j
  integer ( kind = 4 ) l
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) njev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) par
  logical pivot
  real ( kind = 8 ) pnorm
  real ( kind = 8 ) prered
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) ratio
  real ( kind = 8 ) sum2
  real ( kind = 8 ) temp
  real ( kind = 8 ) temp1
  real ( kind = 8 ) temp2
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) wa3(n)
  real ( kind = 8 ) wa4(m)
  real ( kind = 8 ) xnorm
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xtol

  epsmch = epsilon ( epsmch )

  info = 0
  iflag = 0
  nfev = 0
  njev = 0
!
!  Check the input parameters for errors.
!
  if ( n <= 0 ) then
    go to 300
  end if

  if ( m < n ) then
    go to 300
  end if

  if ( ldfjac < m &
    .or. ftol < 0.0D+00 .or. xtol < 0.0D+00 .or. gtol < 0.0D+00 &
     .or. maxfev <= 0 .or. factor <= 0.0D+00 ) then
    go to 300
  end if

  if ( mode == 2 ) then
    do j = 1, n
      if ( diag(j) <= 0.0D+00 ) then
        go to 300
      end if
    end do
  end if
!
!  Evaluate the function at the starting point and calculate its norm.
!
  iflag = 1
  call fcn ( m, n, x, fvec, fjac, ldfjac, iflag )
  nfev = 1
  if ( iflag < 0 ) then
    go to 300
  end if

  fnorm = enorm ( m, fvec )
!
!  Initialize Levenberg-Marquardt parameter and iteration counter.
!
  par = 0.0D+00
  iter = 1
!
!  Beginning of the outer loop.
!
30   continue
!
!  Calculate the jacobian matrix.
!
    iflag = 2
    call fcn ( m, n, x, fvec, fjac, ldfjac, iflag )

    njev = njev + 1

    if ( iflag < 0 ) then
      go to 300
    end if
!
!  If requested, call FCN to enable printing of iterates.
!
    if ( 0 < nprint ) then
      iflag = 0
      if ( mod ( iter - 1, nprint ) == 0 ) then
        call fcn ( m, n, x, fvec, fjac, ldfjac, iflag )
      end if
      if ( iflag < 0 ) then
        go to 300
      end if
    end if
!
!  Compute the QR factorization of the jacobian.
!
    pivot = .true.
    call qrfac ( m, n, fjac, ldfjac, pivot, ipvt, n, wa1, wa2 )
!
!  On the first iteration and if mode is 1, scale according
!  to the norms of the columns of the initial jacobian.
!
    if ( iter == 1 ) then

      if ( mode /= 2 ) then
        diag(1:n) = wa2(1:n)
        do j = 1, n
          if ( wa2(j) == 0.0D+00 ) then
            diag(j) = 1.0D+00
          end if
        end do
      end if
!
!  On the first iteration, calculate the norm of the scaled X
!  and initialize the step bound DELTA.
!
      wa3(1:n) = diag(1:n) * x(1:n)

      xnorm = enorm ( n, wa3 )
      delta = factor * xnorm
      if ( delta == 0.0D+00 ) then
        delta = factor
      end if

    end if
!
!  Form Q'*FVEC and store the first N components in QTF.
!
    wa4(1:m) = fvec(1:m)

    do j = 1, n

      if ( fjac(j,j) /= 0.0D+00 ) then
        sum2 = dot_product ( wa4(j:m), fjac(j:m,j) )
        temp = - sum2 / fjac(j,j)
        wa4(j:m) = wa4(j:m) + fjac(j:m,j) * temp
      end if

      fjac(j,j) = wa1(j)
      qtf(j) = wa4(j)

    end do
!
!  Compute the norm of the scaled gradient.
!
    gnorm = 0.0D+00

    if ( fnorm /= 0.0D+00 ) then

      do j = 1, n
        l = ipvt(j)
        if ( wa2(l) /= 0.0D+00 ) then
          sum2 = dot_product ( qtf(1:j), fjac(1:j,j) ) / fnorm
          gnorm = max ( gnorm, abs ( sum2 / wa2(l) ) )
        end if
      end do

    end if
!
!  Test for convergence of the gradient norm.
!
    if ( gnorm <= gtol ) then
      info = 4
      go to 300
    end if
!
!  Rescale if necessary.
!
    if ( mode /= 2 ) then
      do j = 1, n
        diag(j) = max ( diag(j), wa2(j) )
      end do
    end if
!
!  Beginning of the inner loop.
!
200    continue
!
!  Determine the Levenberg-Marquardt parameter.
!
    call lmpar ( n, fjac, ldfjac, ipvt, diag, qtf, delta, par, wa1, wa2 )
!
!  Store the direction p and x + p. calculate the norm of p.
!
    wa1(1:n) = - wa1(1:n)
    wa2(1:n) = x(1:n) + wa1(1:n)
    wa3(1:n) = diag(1:n) * wa1(1:n)

    pnorm = enorm ( n, wa3 )
!
!  On the first iteration, adjust the initial step bound.
!
    if ( iter == 1 ) then
      delta = min ( delta, pnorm )
    end if
!
!  Evaluate the function at x + p and calculate its norm.
!
    iflag = 1
    call fcn ( m, n, wa2, wa4, fjac, ldfjac, iflag )

    nfev = nfev + 1

    if ( iflag < 0 ) then
      go to 300
    end if

    fnorm1 = enorm ( m, wa4 )
!
!  Compute the scaled actual reduction.
!
    actred = -1.0D+00
    if ( 0.1D+00 * fnorm1 < fnorm ) then
      actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2
    end if
!
!  Compute the scaled predicted reduction and
!  the scaled directional derivative.
!
    do j = 1, n
      wa3(j) = 0.0D+00
      l = ipvt(j)
      temp = wa1(l)
      wa3(1:j) = wa3(1:j) + fjac(1:j,j) * temp
    end do

    temp1 = enorm ( n, wa3 ) / fnorm
    temp2 = ( sqrt ( par ) * pnorm ) / fnorm
    prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00
    dirder = - ( temp1 ** 2 + temp2 ** 2 )
!
!  Compute the ratio of the actual to the predicted reduction.
!
    if ( prered /= 0.0D+00 ) then
      ratio = actred / prered
    else
      ratio = 0.0D+00
    end if
!
!  Update the step bound.
!
    if ( ratio <= 0.25D+00 ) then

      if ( 0.0D+00 <= actred ) then
        temp = 0.5D+00
      end if

      if ( actred < 0.0D+00 ) then
        temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred )
      end if

      if ( 0.1D+00 * fnorm1 >= fnorm .or. temp < 0.1D+00 ) then
        temp = 0.1D+00
      end if

      delta = temp * min ( delta, pnorm / 0.1D+00 )
      par = par / temp

    else

      if ( par == 0.0D+00 .or. ratio >= 0.75D+00 ) then
        delta = 2.0D+00 * pnorm
        par = 0.5D+00 * par
      end if

    end if
!
!  Successful iteration.
!
!  Update X, FVEC, and their norms.
!
    if ( 0.0001D+00 <= ratio ) then
      x(1:n) = wa2(1:n)
      wa2(1:n) = diag(1:n) * x(1:n)
      fvec(1:m) = wa4(1:m)
      xnorm = enorm ( n, wa2 )
      fnorm = fnorm1
      iter = iter + 1
    end if
!
!  Tests for convergence.
!
    if ( abs ( actred) <= ftol .and. &
      prered <= ftol .and. &
      0.5D+00 * ratio <= 1.0D+00 ) then
      info = 1
    end if

    if ( delta <= xtol * xnorm ) then
      info = 2
    end if

    if ( abs ( actred) <= ftol .and. prered <= ftol &
      .and. 0.5D+00 * ratio <= 1.0D+00 .and. info == 2 ) then
      info = 3
    end if

    if ( info /= 0 ) then
      go to 300
    end if
!
!  Tests for termination and stringent tolerances.
!
    if ( nfev >= maxfev ) then
      info = 5
    end if

    if ( abs ( actred ) <= epsmch .and. prered <= epsmch &
      .and. 0.5D+00 * ratio <= 1.0D+00 ) then
      info = 6
    end if

    if ( delta <= epsmch * xnorm ) then
      info = 7
    end if

    if ( gnorm <= epsmch ) then
      info = 8
    end if

    if ( info /= 0 ) then
      go to 300
    end if
!
!  End of the inner loop. repeat if iteration unsuccessful.
!
    if ( ratio < 0.0001D+00 ) then
      go to 200
    end if
!
!  End of the outer loop.
!
    go to 30

  300 continue
!
!  Termination, either normal or user imposed.
!
  if ( iflag < 0 ) then
    info = iflag
  end if

  iflag = 0

  if ( 0 < nprint ) then
    call fcn ( m, n, x, fvec, fjac, ldfjac, iflag )
  end if

  return
end subroutine lmder
subroutine lmder1 ( fcn, m, n, x, fvec, fjac, ldfjac, tol, info )

!*****************************************************************************80
!
!! LMDER1 minimizes M functions in N variables by Levenberg-Marquardt method.
!
!  Discussion:
!
!    LMDER1 minimizes the sum of the squares of M nonlinear functions in
!    N variables by a modification of the Levenberg-Marquardt algorithm.
!    This is done by using the more general least-squares solver LMDER.
!    The user must provide a subroutine which calculates the functions
!    and the jacobian.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions and the jacobian.  FCN should have the form:
!      subroutine fcn ( m, n, x, fvec, fjac, ldfjac, iflag )
!      integer ( kind = 4 ) ldfjac
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fjac(ldfjac,n)
!      real ( kind = 8 ) fvec(m)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    If IFLAG = 2 on input, FCN should calculate the jacobian at X and
!    return this matrix in FJAC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) M, the number of functions.
!
!    Input, integer ( kind = 4 ) N, is the number of variables.
!    N must not exceed M.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper
!    N by N submatrix contains an upper triangular matrix R with
!    diagonal elements of nonincreasing magnitude such that
!      P' * ( JAC' * JAC ) * P = R' * R,
!    where P is a permutation matrix and JAC is the final calculated
!    jacobian.  Column J of P is column IPVT(J) of the identity matrix.
!    The lower trapezoidal part of FJAC contains information generated during
!    the computation of R.
!
!    Input, integer ( kind = 4 ) LDFJAC, is the leading dimension of FJAC,
!    which must be no less than M.
!
!    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm
!    estimates either that the relative error in the sum of squares is at
!    most TOL or that the relative error between X and the solution is at
!    most TOL.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See description
!    of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, algorithm estimates that the relative error in the sum of squares
!       is at most TOL.
!    2, algorithm estimates that the relative error between X and the
!       solution is at most TOL.
!    3, conditions for INFO = 1 and INFO = 2 both hold.
!    4, FVEC is orthogonal to the columns of the jacobian to machine precision.
!    5, number of calls to FCN with IFLAG = 1 has reached 100*(N+1).
!    6, TOL is too small.  No further reduction in the sum of squares is
!       possible.
!    7, TOL is too small.  No further improvement in the approximate
!       solution X is possible.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) ftol
  real ( kind = 8 ) fvec(m)
  real ( kind = 8 ) gtol
  integer ( kind = 4 ) info
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) njev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) tol
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xtol

  info = 0

  if ( n <= 0 ) then
    return
  else if ( m < n ) then
    return
  else if ( ldfjac < m ) then
    return
  else if ( tol < 0.0D+00 ) then
    return
  end if

  factor = 100.0D+00
  maxfev = 100 * ( n + 1 )
  ftol = tol
  xtol = tol
  gtol = 0.0D+00
  mode = 1
  nprint = 0

  call lmder ( fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, &
    diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf )

  if ( info == 8 ) then
    info = 4
  end if

  return
end subroutine lmder1
subroutine lmdif ( fcn, m, n, x, xdat, ydat, fvec, ftol, xtol, gtol, maxfev, epsfcn, &
  diag, mode, factor, nprint, info, nfev, fjac, ldfjac, ipvt, qtf )

!*****************************************************************************80
!
!! LMDIF minimizes M functions in N variables by the Levenberg-Marquardt method.
!
!  Discussion:
!
!    LMDIF minimizes the sum of the squares of M nonlinear functions in
!    N variables by a modification of the Levenberg-Marquardt algorithm.
!    The user must provide a subroutine which calculates the functions.
!    The jacobian is then calculated by a forward-difference approximation.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    20 Jul 2017
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!    adapted for AnOHM in SUEWS, Ting Sun, ting.sun@reading.ac.uk
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions.  The routine should have the form:
!      subroutine fcn ( m, n, x, xdat, ydat, fvec, iflag ) ! xdat, ydat added for AnOHM, TS 20 Jul 2017
!      integer ( kind = 4 ) m
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fvec(m),xdat(m),ydat(m)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) M, the number of functions.
!
!    Input, integer ( kind = 4 ) N, the number of variables.
!    N must not exceed M.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.

!    Input, real ( kind = 8 ) XDAT(M), YDAT(M).  On input, XDAT/YDAT must contain
!    observations to construct FVEC(M). ! added for AnOHM, TS 20 Jul 2017
!
!    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X.
!
!    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual
!    and predicted relative reductions in the sum of squares are at most FTOL.
!    Therefore, FTOL measures the relative error desired in the sum of
!    squares.  FTOL should be nonnegative.
!
!    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error
!    between two consecutive iterates is at most XTOL.  Therefore, XTOL
!    measures the relative error desired in the approximate solution.  XTOL
!    should be nonnegative.
!
!    Input, real ( kind = 8 ) GTOL. termination occurs when the cosine of the
!    angle between FVEC and any column of the jacobian is at most GTOL in
!    absolute value.  Therefore, GTOL measures the orthogonality desired
!    between the function vector and the columns of the jacobian.  GTOL should
!    be nonnegative.
!
!    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of
!    calls to FCN is at least MAXFEV by the end of an iteration.
!
!    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step
!    length for the forward-difference approximation.  This approximation
!    assumes that the relative errors in the functions are of the order of
!    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that
!    the relative errors in the functions are of the order of the machine
!    precision.
!
!    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set
!    internally.  If MODE = 2, then DIAG must contain positive entries that
!    serve as multiplicative scale factors for the variables.
!
!    Input, integer ( kind = 4 ) MODE, scaling option.
!    1, variables will be scaled internally.
!    2, scaling is specified by the input DIAG vector.
!
!    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.
!    This bound is set to the product of FACTOR and the euclidean norm of
!    DIAG*X if nonzero, or else to FACTOR itself.  In most cases, FACTOR should
!    lie in the interval (0.1, 100) with 100 the recommended value.
!
!    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates
!    if it is positive.  In this case, FCN is called with IFLAG = 0 at the
!    beginning of the first iteration and every NPRINT iterations thereafter
!    and immediately prior to return, with X and FVEC available
!    for printing.  If NPRINT is not positive, no special calls
!    of FCN with IFLAG = 0 are made.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See description
!    of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, both actual and predicted relative reductions in the sum of squares
!       are at most FTOL.
!    2, relative error between two consecutive iterates is at most XTOL.
!    3, conditions for INFO = 1 and INFO = 2 both hold.
!    4, the cosine of the angle between FVEC and any column of the jacobian
!       is at most GTOL in absolute value.
!    5, number of calls to FCN has reached or exceeded MAXFEV.
!    6, FTOL is too small.  No further reduction in the sum of squares
!       is possible.
!    7, XTOL is too small.  No further improvement in the approximate
!       solution X is possible.
!    8, GTOL is too small.  FVEC is orthogonal to the columns of the
!       jacobian to machine precision.
!
!    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper
!    N by N submatrix of FJAC contains an upper triangular matrix R with
!    diagonal elements of nonincreasing magnitude such that
!
!      P' * ( JAC' * JAC ) * P = R' * R,
!
!    where P is a permutation matrix and JAC is the final calculated jacobian.
!    Column J of P is column IPVT(J) of the identity matrix.  The lower
!    trapezoidal part of FJAC contains information generated during
!    the computation of R.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC.
!    LDFJAC must be at least M.
!
!    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P such
!    that JAC * P = Q * R, where JAC is the final calculated jacobian, Q is
!    orthogonal (not stored), and R is upper triangular with diagonal
!    elements of nonincreasing magnitude.  Column J of P is column IPVT(J)
!    of the identity matrix.
!
!    Output, real ( kind = 8 ) QTF(N), the first N elements of Q'*FVEC.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) actred
  real ( kind = 8 ) delta
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) dirder
  real ( kind = 8 ) enorm
  real ( kind = 8 ) epsfcn
  real ( kind = 8 ) epsmch
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fnorm
  real ( kind = 8 ) fnorm1
  real ( kind = 8 ) ftol
  real ( kind = 8 ) :: fvec(m),xdat(m),ydat(m)
  real ( kind = 8 ) gnorm
  real ( kind = 8 ) gtol
  integer ( kind = 4 ) i
  integer ( kind = 4 ) iflag
  integer ( kind = 4 ) iter
  integer ( kind = 4 ) info
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) j
  integer ( kind = 4 ) l
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) par
  logical pivot
  real ( kind = 8 ) pnorm
  real ( kind = 8 ) prered
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) ratio
  real ( kind = 8 ) sum2
  real ( kind = 8 ) temp
  real ( kind = 8 ) temp1
  real ( kind = 8 ) temp2
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) wa3(n)
  real ( kind = 8 ) wa4(m)
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xnorm
  real ( kind = 8 ) xtol

  epsmch = epsilon ( epsmch )

  info = 0
  iflag = 0
  nfev = 0

  if ( n <= 0 ) then
    go to 300
  else if ( m < n ) then
    go to 300
  else if ( ldfjac < m ) then
    go to 300
  else if ( ftol < 0.0D+00 ) then
    go to 300
  else if ( xtol < 0.0D+00 ) then
    go to 300
  else if ( gtol < 0.0D+00 ) then
    go to 300
  else if ( maxfev <= 0 ) then
    go to 300
  else if ( factor <= 0.0D+00 ) then
    go to 300
  end if

  if ( mode == 2 ) then
    do j = 1, n
      if ( diag(j) <= 0.0D+00 ) then
        go to 300
      end if
    end do
  end if
!
!  Evaluate the function at the starting point and calculate its norm.
!
  iflag = 1
  call fcn ( m, n, x, xdat, ydat, fvec, iflag )
  nfev = 1

  if ( iflag < 0 ) then
    go to 300
  end if

  fnorm = enorm ( m, fvec )
!
!  Initialize Levenberg-Marquardt parameter and iteration counter.
!
  par = 0.0D+00
  iter = 1
!
!  Beginning of the outer loop.
!
30 continue
!
!  Calculate the jacobian matrix.
!
  iflag = 2
  call fdjac2 ( fcn, m, n, x, xdat, ydat, fvec, fjac, ldfjac, iflag, epsfcn )
  nfev = nfev + n

  if ( iflag < 0 ) then
    go to 300
  end if
!
!  If requested, call FCN to enable printing of iterates.
!
  if ( 0 < nprint ) then
    iflag = 0
    if ( mod ( iter - 1, nprint ) == 0 ) then
      call fcn ( m, n, x, xdat, ydat, fvec, iflag )
    end if
    if ( iflag < 0 ) then
      go to 300
    end if
  end if
!
!  Compute the QR factorization of the jacobian.
!
  pivot = .true.
  call qrfac ( m, n, fjac, ldfjac, pivot, ipvt, n, wa1, wa2 )
!
!  On the first iteration and if MODE is 1, scale according
!  to the norms of the columns of the initial jacobian.
!
     if ( iter == 1 ) then

       if ( mode /= 2 ) then
         diag(1:n) = wa2(1:n)
         do j = 1, n
           if ( wa2(j) == 0.0D+00 ) then
             diag(j) = 1.0D+00
           end if
         end do
       end if
!
!  On the first iteration, calculate the norm of the scaled X
!  and initialize the step bound DELTA.
!
       wa3(1:n) = diag(1:n) * x(1:n)
       xnorm = enorm ( n, wa3 )
       delta = factor * xnorm
       if ( delta == 0.0D+00 ) then
         delta = factor
       end if
     end if
!
!  Form Q' * FVEC and store the first N components in QTF.
!
     wa4(1:m) = fvec(1:m)

     do j = 1, n

       if ( fjac(j,j) /= 0.0D+00 ) then
         sum2 = dot_product ( wa4(j:m), fjac(j:m,j) )
         temp = - sum2 / fjac(j,j)
         wa4(j:m) = wa4(j:m) + fjac(j:m,j) * temp
       end if

       fjac(j,j) = wa1(j)
       qtf(j) = wa4(j)

     end do
!
!  Compute the norm of the scaled gradient.
!
     gnorm = 0.0D+00

     if ( fnorm /= 0.0D+00 ) then

       do j = 1, n

         l = ipvt(j)

         if ( wa2(l) /= 0.0D+00 ) then
           sum2 = 0.0D+00
           do i = 1, j
             sum2 = sum2 + fjac(i,j) * ( qtf(i) / fnorm )
           end do
           gnorm = max ( gnorm, abs ( sum2 / wa2(l) ) )
         end if

       end do

     end if
!
!  Test for convergence of the gradient norm.
!
     if ( gnorm <= gtol ) then
       info = 4
       go to 300
     end if
!
!  Rescale if necessary.
!
     if ( mode /= 2 ) then
       do j = 1, n
         diag(j) = max ( diag(j), wa2(j) )
       end do
     end if
!
!  Beginning of the inner loop.
!
200  continue
!
!  Determine the Levenberg-Marquardt parameter.
!
        call lmpar ( n, fjac, ldfjac, ipvt, diag, qtf, delta, par, wa1, wa2 )
!
!  Store the direction P and X + P.
!  Calculate the norm of P.
!
        wa1(1:n) = -wa1(1:n)
        wa2(1:n) = x(1:n) + wa1(1:n)
        wa3(1:n) = diag(1:n) * wa1(1:n)

        pnorm = enorm ( n, wa3 )
!
!  On the first iteration, adjust the initial step bound.
!
        if ( iter == 1 ) then
          delta = min ( delta, pnorm )
        end if
!
!  Evaluate the function at X + P and calculate its norm.
!
        iflag = 1
        call fcn ( m, n, wa2, xdat, ydat, wa4, iflag )
        nfev = nfev + 1
        if ( iflag < 0 ) then
          go to 300
        end if
        fnorm1 = enorm ( m, wa4 )
!
!  Compute the scaled actual reduction.
!
        if ( 0.1D+00 * fnorm1 < fnorm ) then
          actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2
        else
          actred = -1.0D+00
        end if
!
!  Compute the scaled predicted reduction and the scaled directional derivative.
!
        do j = 1, n
          wa3(j) = 0.0D+00
          l = ipvt(j)
          temp = wa1(l)
          wa3(1:j) = wa3(1:j) + fjac(1:j,j) * temp
        end do

        temp1 = enorm ( n, wa3 ) / fnorm
        temp2 = ( sqrt ( par ) * pnorm ) / fnorm
        prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00
        dirder = - ( temp1 ** 2 + temp2 ** 2 )
!
!  Compute the ratio of the actual to the predicted reduction.
!
        ratio = 0.0D+00
        if ( prered /= 0.0D+00 ) then
          ratio = actred / prered
        end if
!
!  Update the step bound.
!
        if ( ratio <= 0.25D+00 ) then

           if ( actred >= 0.0D+00 ) then
             temp = 0.5D+00
           endif

           if ( actred < 0.0D+00 ) then
             temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred )
           end if

           if ( 0.1D+00 * fnorm1 >= fnorm .or. temp < 0.1D+00 ) then
             temp = 0.1D+00
           end if

           delta = temp * min ( delta, pnorm / 0.1D+00  )
           par = par / temp

        else

           if ( par == 0.0D+00 .or. ratio >= 0.75D+00 ) then
             delta = 2.0D+00 * pnorm
             par = 0.5D+00 * par
           end if

        end if
!
!  Test for successful iteration.
!

!
!  Successful iteration. update X, FVEC, and their norms.
!
        if ( 0.0001D+00 <= ratio ) then
          x(1:n) = wa2(1:n)
          wa2(1:n) = diag(1:n) * x(1:n)
          fvec(1:m) = wa4(1:m)
          xnorm = enorm ( n, wa2 )
          fnorm = fnorm1
          iter = iter + 1
        end if
!
!  Tests for convergence.
!
        if ( abs ( actred) <= ftol .and. prered <= ftol &
          .and. 0.5D+00 * ratio <= 1.0D+00 ) then
          info = 1
        end if

        if ( delta <= xtol * xnorm ) then
          info = 2
        end if

        if ( abs ( actred) <= ftol .and. prered <= ftol &
          .and. 0.5D+00 * ratio <= 1.0D+00 .and. info == 2 ) info = 3

        if ( info /= 0 ) then
          go to 300
        end if
!
!  Tests for termination and stringent tolerances.
!
        if ( maxfev <= nfev ) then
          info = 5
        end if

        if ( abs ( actred) <= epsmch .and. prered <= epsmch &
          .and. 0.5D+00 * ratio <= 1.0D+00 ) then
          info = 6
        end if

        if ( delta <= epsmch * xnorm ) then
          info = 7
        end if

        if ( gnorm <= epsmch ) then
          info = 8
        end if

        if ( info /= 0 ) then
          go to 300
        end if
!
!  End of the inner loop.  Repeat if iteration unsuccessful.
!
        if ( ratio < 0.0001D+00 ) then
          go to 200
        end if
!
!  End of the outer loop.
!
     go to 30

300 continue
!
!  Termination, either normal or user imposed.
!
  if ( iflag < 0 ) then
    info = iflag
  end if

  iflag = 0

  if ( 0 < nprint ) then
    call fcn ( m, n, x, xdat, ydat, fvec, iflag )
  end if

  return
end subroutine lmdif
subroutine lmdif1 ( fcn, m, n, x, xdat, ydat, fvec, tol, info )

!*****************************************************************************80
!
!! LMDIF1 minimizes M functions in N variables using Levenberg-Marquardt method.
!
!  Discussion:
!
!    LMDIF1 minimizes the sum of the squares of M nonlinear functions in
!    N variables by a modification of the Levenberg-Marquardt algorithm.
!    This is done by using the more general least-squares solver LMDIF.
!    The user must provide a subroutine which calculates the functions.
!    The jacobian is then calculated by a forward-difference approximation.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    20 Jul 2017
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!    adapted for AnOHM in SUEWS, Ting Sun, ting.sun@reading.ac.uk
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions.  The routine should have the form:
!      subroutine fcn ( m, n, x, xdat, ydat, fvec, iflag ) ! xdat, ydat added for AnOHM, TS 20 Jul 2017
!      integer ( kind = 4 ) m
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fvec(m),xdat(m),ydat(m)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    To terminate the algorithm, FCN may set IFLAG negative on return.
!
!    Input, integer ( kind = 4 ) M, the number of functions.
!
!    Input, integer ( kind = 4 ) N, the number of variables.
!    N must not exceed M.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.

!    Input, real ( kind = 8 ) XDAT(M), YDAT(M).  On input, XDAT/YDAT must contain
!    observations to construct FVEC(M). ! added for AnOHM, TS 20 Jul 2017
!
!    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X.
!
!    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm
!    estimates either that the relative error in the sum of squares is at
!    most TOL or that the relative error between X and the solution is at
!    most TOL.  TOL should be nonnegative.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See description
!    of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, algorithm estimates that the relative error in the sum of squares
!       is at most TOL.
!    2, algorithm estimates that the relative error between X and the
!       solution is at most TOL.
!    3, conditions for INFO = 1 and INFO = 2 both hold.
!    4, FVEC is orthogonal to the columns of the jacobian to machine precision.
!    5, number of calls to FCN has reached or exceeded 200*(N+1).
!    6, TOL is too small.  No further reduction in the sum of squares
!       is possible.
!    7, TOL is too small.  No further improvement in the approximate
!       solution X is possible.
!
  implicit none

  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) epsfcn
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(m,n)
  real ( kind = 8 ) ftol
  real ( kind = 8 ) ::fvec(m),xdat(m),ydat(m)
  real ( kind = 8 ) gtol
  integer ( kind = 4 ) info
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) tol
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xtol

  info = 0

  if ( n <= 0 ) then
    return
  else if ( m < n ) then
    return
  else if ( tol < 0.0D+00 ) then
    return
  end if

  factor = 100.0D+00
  maxfev = 200 * ( n + 1 )
  ftol = tol
  xtol = tol
  gtol = 0.0D+00
  epsfcn = 0.0D+00
  mode = 1
  nprint = 0
  ldfjac = m
! print*, 'x in limdif1',x
  call lmdif ( fcn, m, n, x, xdat, ydat, fvec, ftol, xtol, gtol, maxfev, epsfcn, &
    diag, mode, factor, nprint, info, nfev, fjac, ldfjac, ipvt, qtf )

  if ( info == 8 ) then
    info = 4
  end if

  return
end subroutine lmdif1
subroutine lmpar ( n, r, ldr, ipvt, diag, qtb, delta, par, x, sdiag )

!*****************************************************************************80
!
!! LMPAR computes a parameter for the Levenberg-Marquardt method.
!
!  Discussion:
!
!    Given an M by N matrix A, an N by N nonsingular diagonal
!    matrix D, an M-vector B, and a positive number DELTA,
!    the problem is to determine a value for the parameter
!    PAR such that if X solves the system
!
!      A*X = B,
!      sqrt ( PAR ) * D * X = 0,
!
!    in the least squares sense, and DXNORM is the euclidean
!    norm of D*X, then either PAR is zero and
!
!      ( DXNORM - DELTA ) <= 0.1 * DELTA,
!
!    or PAR is positive and
!
!      abs ( DXNORM - DELTA) <= 0.1 * DELTA.
!
!    This subroutine completes the solution of the problem
!    if it is provided with the necessary information from the
!    QR factorization, with column pivoting, of A.  That is, if
!    A*P = Q*R, where P is a permutation matrix, Q has orthogonal
!    columns, and R is an upper triangular matrix with diagonal
!    elements of nonincreasing magnitude, then LMPAR expects
!    the full upper triangle of R, the permutation matrix P,
!    and the first N components of Q'*B.  On output
!    LMPAR also provides an upper triangular matrix S such that
!
!      P' * ( A' * A + PAR * D * D ) * P = S'* S.
!
!    S is employed within LMPAR and may be of separate interest.
!
!    Only a few iterations are generally needed for convergence
!    of the algorithm.  If, however, the limit of 10 iterations
!    is reached, then the output PAR will contain the best
!    value obtained so far.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    24 January 2014
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the order of R.
!
!    Input/output, real ( kind = 8 ) R(LDR,N),the N by N matrix.  The full
!    upper triangle must contain the full upper triangle of the matrix R.
!    On output the full upper triangle is unaltered, and the strict lower
!    triangle contains the strict upper triangle (transposed) of the upper
!    triangular matrix S.
!
!    Input, integer ( kind = 4 ) LDR, the leading dimension of R.  LDR must be
!    no less than N.
!
!    Input, integer ( kind = 4 ) IPVT(N), defines the permutation matrix P
!    such that A*P = Q*R.  Column J of P is column IPVT(J) of the
!    identity matrix.
!
!    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D.
!
!    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'*B.
!
!    Input, real ( kind = 8 ) DELTA, an upper bound on the euclidean norm
!    of D*X.  DELTA should be positive.
!
!    Input/output, real ( kind = 8 ) PAR.  On input an initial estimate of the
!    Levenberg-Marquardt parameter.  On output the final estimate.
!    PAR should be nonnegative.
!
!    Output, real ( kind = 8 ) X(N), the least squares solution of the system
!    A*X = B, sqrt(PAR)*D*X = 0, for the output value of PAR.
!
!    Output, real ( kind = 8 ) SDIAG(N), the diagonal elements of the upper
!    triangular matrix S.
!
  implicit none

  integer ( kind = 4 ) ldr
  integer ( kind = 4 ) n

  real ( kind = 8 ) delta
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) dwarf
  real ( kind = 8 ) dxnorm
  real ( kind = 8 ) enorm
  real ( kind = 8 ) gnorm
  real ( kind = 8 ) fp
  ! integer ( kind = 4 ) i
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) iter
  integer ( kind = 4 ) j
  integer ( kind = 4 ) k
  integer ( kind = 4 ) l
  integer ( kind = 4 ) nsing
  real ( kind = 8 ) par
  real ( kind = 8 ) parc
  real ( kind = 8 ) parl
  real ( kind = 8 ) paru
  ! real ( kind = 8 ) qnorm
  real ( kind = 8 ) qtb(n)
  real ( kind = 8 ) r(ldr,n)
  real ( kind = 8 ) sdiag(n)
  real ( kind = 8 ) sum2
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) x(n)
!
!  DWARF is the smallest positive magnitude.
!
  dwarf = tiny ( dwarf )
!
!  Compute and store in X the Gauss-Newton direction.
!
!  If the jacobian is rank-deficient, obtain a least squares solution.
!
  nsing = n

  do j = 1, n
    wa1(j) = qtb(j)
    if ( r(j,j) == 0.0D+00 .and. nsing == n ) then
      nsing = j - 1
    end if
    if ( nsing < n ) then
      wa1(j) = 0.0D+00
    end if
  end do

  do k = 1, nsing
    j = nsing - k + 1
    wa1(j) = wa1(j) / r(j,j)
    temp = wa1(j)
    wa1(1:j-1) = wa1(1:j-1) - r(1:j-1,j) * temp
  end do

  do j = 1, n
    l = ipvt(j)
    x(l) = wa1(j)
  end do
!
!  Initialize the iteration counter.
!  Evaluate the function at the origin, and test
!  for acceptance of the Gauss-Newton direction.
!
  iter = 0
  wa2(1:n) = diag(1:n) * x(1:n)
  dxnorm = enorm ( n, wa2 )
  fp = dxnorm - delta

  if ( fp <= 0.1D+00 * delta ) then
    if ( iter == 0 ) then
      par = 0.0D+00
    end if
    return
  end if
!
!  If the jacobian is not rank deficient, the Newton
!  step provides a lower bound, PARL, for the zero of
!  the function.
!
!  Otherwise set this bound to zero.
!
  parl = 0.0D+00

  if ( n <= nsing ) then

    do j = 1, n
      l = ipvt(j)
      wa1(j) = diag(l) * ( wa2(l) / dxnorm )
    end do

    do j = 1, n
      sum2 = dot_product ( wa1(1:j-1), r(1:j-1,j) )
      wa1(j) = ( wa1(j) - sum2 ) / r(j,j)
    end do

    temp = enorm ( n, wa1 )
    parl = ( ( fp / delta ) / temp ) / temp

  end if
!
!  Calculate an upper bound, PARU, for the zero of the function.
!
  do j = 1, n
    sum2 = dot_product ( qtb(1:j), r(1:j,j) )
    l = ipvt(j)
    wa1(j) = sum2 / diag(l)
  end do

  gnorm = enorm ( n, wa1 )
  paru = gnorm / delta

  if ( paru == 0.0D+00 ) then
    paru = dwarf / min ( delta, 0.1D+00 )
  end if
!
!  If the input PAR lies outside of the interval (PARL, PARU),
!  set PAR to the closer endpoint.
!
  par = max ( par, parl )
  par = min ( par, paru )
  if ( par == 0.0D+00 ) then
    par = gnorm / dxnorm
  end if
!
!  Beginning of an iteration.
!
  do

    iter = iter + 1
!
!  Evaluate the function at the current value of PAR.
!
    if ( par == 0.0D+00 ) then
      par = max ( dwarf, 0.001D+00 * paru )
    end if

    wa1(1:n) = sqrt ( par ) * diag(1:n)

    call qrsolv ( n, r, ldr, ipvt, wa1, qtb, x, sdiag )

    wa2(1:n) = diag(1:n) * x(1:n)
    dxnorm = enorm ( n, wa2 )
    temp = fp
    fp = dxnorm - delta
!
!  If the function is small enough, accept the current value of PAR.
!
    if ( abs ( fp ) <= 0.1D+00 * delta ) then
      exit
    end if
!
!  Test for the exceptional cases where PARL
!  is zero or the number of iterations has reached 10.
!
    if ( parl == 0.0D+00 .and. fp <= temp .and. temp < 0.0D+00 ) then
      exit
    else if ( iter == 10 ) then
      exit
    end if
!
!  Compute the Newton correction.
!
    do j = 1, n
      l = ipvt(j)
      wa1(j) = diag(l) * ( wa2(l) / dxnorm )
    end do

    do j = 1, n
      wa1(j) = wa1(j) / sdiag(j)
      temp = wa1(j)
      wa1(j+1:n) = wa1(j+1:n) - r(j+1:n,j) * temp
    end do

    temp = enorm ( n, wa1 )
    parc = ( ( fp / delta ) / temp ) / temp
!
!  Depending on the sign of the function, update PARL or PARU.
!
    if ( 0.0D+00 < fp ) then
      parl = max ( parl, par )
    else if ( fp < 0.0D+00 ) then
      paru = min ( paru, par )
    end if
!
!  Compute an improved estimate for PAR.
!
    par = max ( parl, par + parc )
!
!  End of an iteration.
!
  end do
!
!  Termination.
!
  if ( iter == 0 ) then
    par = 0.0D+00
  end if

  return
end subroutine lmpar
subroutine lmstr ( fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, &
  diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf )

!*****************************************************************************80
!
!! LMSTR minimizes M functions in N variables using Levenberg-Marquardt method.
!
!  Discussion:
!
!    LMSTR minimizes the sum of the squares of M nonlinear functions in
!    N variables by a modification of the Levenberg-Marquardt algorithm
!    which uses minimal storage.
!
!    The user must provide a subroutine which calculates the functions and
!    the rows of the jacobian.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions and the rows of the jacobian.
!    FCN should have the form:
!      subroutine fcn ( m, n, x, fvec, fjrow, iflag )
!      integer ( kind = 4 ) m
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fjrow(n)
!      real ( kind = 8 ) fvec(m)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    If the input value of IFLAG is I > 1, calculate the (I-1)-st row of
!    the jacobian at X, and return this vector in FJROW.
!    To terminate the algorithm, set the output value of IFLAG negative.
!
!    Input, integer ( kind = 4 ) M, the number of functions.
!
!    Input, integer ( kind = 4 ) N, the number of variables.
!    N must not exceed M.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array.  The upper
!    triangle of FJAC contains an upper triangular matrix R such that
!
!      P' * ( JAC' * JAC ) * P = R' * R,
!
!    where P is a permutation matrix and JAC is the final calculated jacobian.
!    Column J of P is column IPVT(J) of the identity matrix.  The lower
!    triangular part of FJAC contains information generated during
!    the computation of R.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC.
!    LDFJAC must be at least N.
!
!    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual and
!    predicted relative reductions in the sum of squares are at most FTOL.
!    Therefore, FTOL measures the relative error desired in the sum of
!    squares.  FTOL should be nonnegative.
!
!    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error
!    between two consecutive iterates is at most XTOL.  XTOL should be
!    nonnegative.
!
!    Input, real ( kind = 8 ) GTOL. termination occurs when the cosine of the
!    angle between FVEC and any column of the jacobian is at most GTOL in
!    absolute value.  Therefore, GTOL measures the orthogonality desired
!    between the function vector and the columns of the jacobian.  GTOL should
!    be nonnegative.
!
!    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number
!    of calls to FCN with IFLAG = 1 is at least MAXFEV by the end of
!    an iteration.
!
!    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set
!    internally.  If MODE = 2, then DIAG must contain positive entries that
!    serve as multiplicative scale factors for the variables.
!
!    Input, integer ( kind = 4 ) MODE, scaling option.
!    1, variables will be scaled internally.
!    2, scaling is specified by the input DIAG vector.
!
!    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This
!    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if
!    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie
!    in the interval (0.1, 100) with 100 the recommended value.
!
!    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates
!    if it is positive.  In this case, FCN is called with IFLAG = 0 at the
!    beginning of the first iteration and every NPRINT iterations thereafter
!    and immediately prior to return, with X and FVEC available
!    for printing.  If NPRINT is not positive, no special calls
!    of FCN with IFLAG = 0 are made.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See the
!    description of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, both actual and predicted relative reductions in the sum of squares
!       are at most FTOL.
!    2, relative error between two consecutive iterates is at most XTOL.
!    3, conditions for INFO = 1 and INFO = 2 both hold.
!    4, the cosine of the angle between FVEC and any column of the jacobian
!       is at most GTOL in absolute value.
!    5, number of calls to FCN with IFLAG = 1 has reached MAXFEV.
!    6, FTOL is too small.  No further reduction in the sum of squares is
!       possible.
!    7, XTOL is too small.  No further improvement in the approximate
!       solution X is possible.
!    8, GTOL is too small.  FVEC is orthogonal to the columns of the
!       jacobian to machine precision.
!
!    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN
!    with IFLAG = 1.
!
!    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN
!    with IFLAG = 2.
!
!    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P such
!    that JAC * P = Q * R, where JAC is the final calculated jacobian, Q is
!    orthogonal (not stored), and R is upper triangular.
!    Column J of P is column IPVT(J) of the identity matrix.
!
!    Output, real ( kind = 8 ) QTF(N), contains the first N elements of Q'*FVEC.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) actred
  real ( kind = 8 ) delta
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) dirder
  real ( kind = 8 ) enorm
  real ( kind = 8 ) epsmch
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) fnorm
  real ( kind = 8 ) fnorm1
  real ( kind = 8 ) ftol
  real ( kind = 8 ) fvec(m)
  real ( kind = 8 ) gnorm
  real ( kind = 8 ) gtol
  integer ( kind = 4 ) i
  integer ( kind = 4 ) iflag
  integer ( kind = 4 ) info
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) iter
  integer ( kind = 4 ) j
  integer ( kind = 4 ) l
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) njev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) par
  logical pivot
  real ( kind = 8 ) pnorm
  real ( kind = 8 ) prered
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) ratio
  logical sing
  real ( kind = 8 ) sum2
  real ( kind = 8 ) temp
  real ( kind = 8 ) temp1
  real ( kind = 8 ) temp2
  real ( kind = 8 ) wa1(n)
  real ( kind = 8 ) wa2(n)
  real ( kind = 8 ) wa3(n)
  real ( kind = 8 ) wa4(m)
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xnorm
  real ( kind = 8 ) xtol

  epsmch = epsilon ( epsmch )

  info = 0
  iflag = 0
  nfev = 0
  njev = 0
!
!  Check the input parameters for errors.
!
  if ( n <= 0 ) then
    go to 340
  else if ( m < n ) then
    go to 340
  else if ( ldfjac < n ) then
    go to 340
  else if ( ftol < 0.0D+00 ) then
    go to 340
  else if ( xtol < 0.0D+00 ) then
    go to 340
  else if ( gtol < 0.0D+00 ) then
    go to 340
  else if ( maxfev <= 0 ) then
    go to 340
  else if ( factor <= 0.0D+00 ) then
    go to 340
  end if

  if ( mode == 2 ) then
    do j = 1, n
      if ( diag(j) <= 0.0D+00 ) then
        go to 340
      end if
    end do
  end if
!
!  Evaluate the function at the starting point and calculate its norm.
!
  iflag = 1
  call fcn ( m, n, x, fvec, wa3, iflag )
  nfev = 1

  if ( iflag < 0 ) then
    go to 340
  end if

  fnorm = enorm ( m, fvec )
!
!  Initialize Levenberg-Marquardt parameter and iteration counter.
!
  par = 0.0D+00
  iter = 1
!
!  Beginning of the outer loop.
!
   30 continue
!
!  If requested, call FCN to enable printing of iterates.
!
     if ( 0 < nprint ) then
       iflag = 0
       if ( mod ( iter-1, nprint ) == 0 ) then
         call fcn ( m, n, x, fvec, wa3, iflag )
       end if
       if ( iflag < 0 ) then
         go to 340
       end if
     end if
!
!  Compute the QR factorization of the jacobian matrix calculated one row
!  at a time, while simultaneously forming Q'* FVEC and storing
!  the first N components in QTF.
!
     qtf(1:n) = 0.0D+00
     fjac(1:n,1:n) = 0.0D+00
     iflag = 2

     do i = 1, m
       call fcn ( m, n, x, fvec, wa3, iflag )
       if ( iflag < 0 ) then
         go to 340
       end if
       temp = fvec(i)
       call rwupdt ( n, fjac, ldfjac, wa3, qtf, temp, wa1, wa2 )
       iflag = iflag + 1
     end do

     njev = njev + 1
!
!  If the jacobian is rank deficient, call QRFAC to
!  reorder its columns and update the components of QTF.
!
     sing = .false.
     do j = 1, n
       if ( fjac(j,j) == 0.0D+00 ) then
         sing = .true.
       end if
       ipvt(j) = j
       wa2(j) = enorm ( j, fjac(1,j) )
     end do

     if ( sing ) then

       pivot = .true.
       call qrfac ( n, n, fjac, ldfjac, pivot, ipvt, n, wa1, wa2 )

       do j = 1, n

         if ( fjac(j,j) /= 0.0D+00 ) then

           sum2 = dot_product ( qtf(j:n), fjac(j:n,j) )
           temp = - sum2 / fjac(j,j)
           qtf(j:n) = qtf(j:n) + fjac(j:n,j) * temp

         end if

         fjac(j,j) = wa1(j)

       end do

     end if
!
!  On the first iteration
!    if mode is 1,
!      scale according to the norms of the columns of the initial jacobian.
!    calculate the norm of the scaled X,
!    initialize the step bound delta.
!
     if ( iter == 1 ) then

       if ( mode /= 2 ) then

         diag(1:n) = wa2(1:n)
         do j = 1, n
           if ( wa2(j) == 0.0D+00 ) then
             diag(j) = 1.0D+00
           end if
         end do

       end if

       wa3(1:n) = diag(1:n) * x(1:n)
       xnorm = enorm ( n, wa3 )
       delta = factor * xnorm
       if ( delta == 0.0D+00 ) then
         delta = factor
       end if

     end if
!
!  Compute the norm of the scaled gradient.
!
     gnorm = 0.0D+00

     if ( fnorm /= 0.0D+00 ) then

       do j = 1, n
         l = ipvt(j)
         if ( wa2(l) /= 0.0D+00 ) then
           sum2 = dot_product ( qtf(1:j), fjac(1:j,j) ) / fnorm
           gnorm = max ( gnorm, abs ( sum2 / wa2(l) ) )
         end if
       end do

     end if
!
!  Test for convergence of the gradient norm.
!
     if ( gnorm <= gtol ) then
       info = 4
       go to 340
     end if
!
!  Rescale if necessary.
!
     if ( mode /= 2 ) then
       do j = 1, n
         diag(j) = max ( diag(j), wa2(j) )
       end do
     end if
!
!  Beginning of the inner loop.
!
240    continue
!
!  Determine the Levenberg-Marquardt parameter.
!
        call lmpar ( n, fjac, ldfjac, ipvt, diag, qtf, delta, par, wa1, wa2 )
!
!  Store the direction P and X + P.
!  Calculate the norm of P.
!
        wa1(1:n) = -wa1(1:n)
        wa2(1:n) = x(1:n) + wa1(1:n)
        wa3(1:n) = diag(1:n) * wa1(1:n)
        pnorm = enorm ( n, wa3 )
!
!  On the first iteration, adjust the initial step bound.
!
        if ( iter == 1 ) then
          delta = min ( delta, pnorm )
        end if
!
!  Evaluate the function at X + P and calculate its norm.
!
        iflag = 1
        call fcn ( m, n, wa2, wa4, wa3, iflag )
        nfev = nfev + 1
        if ( iflag < 0 ) then
          go to 340
        end if
        fnorm1 = enorm ( m, wa4 )
!
!  Compute the scaled actual reduction.
!
        if ( 0.1D+00 * fnorm1 < fnorm ) then
          actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2
        else
          actred = -1.0D+00
        end if
!
!  Compute the scaled predicted reduction and
!  the scaled directional derivative.
!
        do j = 1, n
          wa3(j) = 0.0D+00
          l = ipvt(j)
          temp = wa1(l)
          wa3(1:j) = wa3(1:j) + fjac(1:j,j) * temp
        end do

        temp1 = enorm ( n, wa3 ) / fnorm
        temp2 = ( sqrt(par) * pnorm ) / fnorm
        prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00
        dirder = - ( temp1 ** 2 + temp2 ** 2 )
!
!  Compute the ratio of the actual to the predicted reduction.
!
        if ( prered /= 0.0D+00 ) then
          ratio = actred / prered
        else
          ratio = 0.0D+00
        end if
!
!  Update the step bound.
!
        if ( ratio <= 0.25D+00 ) then

          if ( actred >= 0.0D+00 ) then
            temp = 0.5D+00
          else
            temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred )
          end if

          if ( 0.1D+00 * fnorm1 >= fnorm .or. temp < 0.1D+00 ) then
            temp = 0.1D+00
          end if

          delta = temp * min ( delta, pnorm / 0.1D+00 )
          par = par / temp

        else

          if ( par == 0.0D+00 .or. ratio >= 0.75D+00 ) then
            delta = pnorm / 0.5D+00
            par = 0.5D+00 * par
          end if

        end if
!
!  Test for successful iteration.
!
        if ( ratio >= 0.0001D+00 ) then
          x(1:n) = wa2(1:n)
          wa2(1:n) = diag(1:n) * x(1:n)
          fvec(1:m) = wa4(1:m)
          xnorm = enorm ( n, wa2 )
          fnorm = fnorm1
          iter = iter + 1
        end if
!
!  Tests for convergence, termination and stringent tolerances.
!
        if ( abs ( actred ) <= ftol .and. prered <= ftol &
          .and. 0.5D+00 * ratio <= 1.0D+00 ) then
          info = 1
        end if

        if ( delta <= xtol * xnorm ) then
          info = 2
        end if

        if ( abs ( actred ) <= ftol .and. prered <= ftol &
          .and. 0.5D+00 * ratio <= 1.0D+00 .and. info == 2 ) then
          info = 3
        end if

        if ( info /= 0 ) then
          go to 340
        end if

        if ( nfev >= maxfev) then
          info = 5
        end if

        if ( abs ( actred ) <= epsmch .and. prered <= epsmch &
          .and. 0.5D+00 * ratio <= 1.0D+00 ) then
          info = 6
        end if

        if ( delta <= epsmch * xnorm ) then
          info = 7
        end if

        if ( gnorm <= epsmch ) then
          info = 8
        end if

        if ( info /= 0 ) then
          go to 340
        end if
!
!  End of the inner loop.  Repeat if iteration unsuccessful.
!
        if ( ratio < 0.0001D+00 ) then
          go to 240
        end if
!
!  End of the outer loop.
!
     go to 30

  340 continue
!
!  Termination, either normal or user imposed.
!
  if ( iflag < 0 ) then
    info = iflag
  end if

  iflag = 0

  if ( 0 < nprint ) then
    call fcn ( m, n, x, fvec, wa3, iflag )
  end if

  return
end subroutine lmstr
subroutine lmstr1 ( fcn, m, n, x, fvec, fjac, ldfjac, tol, info )

!*****************************************************************************80
!
!! LMSTR1 minimizes M functions in N variables using Levenberg-Marquardt method.
!
!  Discussion:
!
!    LMSTR1 minimizes the sum of the squares of M nonlinear functions in
!    N variables by a modification of the Levenberg-Marquardt algorithm
!    which uses minimal storage.
!
!    This is done by using the more general least-squares solver
!    LMSTR.  The user must provide a subroutine which calculates
!    the functions and the rows of the jacobian.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    19 August 2016
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, external FCN, the name of the user-supplied subroutine which
!    calculates the functions and the rows of the jacobian.
!    FCN should have the form:
!      subroutine fcn ( m, n, x, fvec, fjrow, iflag )
!      integer ( kind = 4 ) m
!      integer ( kind = 4 ) n
!      real ( kind = 8 ) fjrow(n)
!      real ( kind = 8 ) fvec(m)
!      integer ( kind = 4 ) iflag
!      real ( kind = 8 ) x(n)
!    If IFLAG = 0 on input, then FCN is only being called to allow the user
!    to print out the current iterate.
!    If IFLAG = 1 on input, FCN should calculate the functions at X and
!    return this vector in FVEC.
!    If the input value of IFLAG is I > 1, calculate the (I-1)-st row of
!    the jacobian at X, and return this vector in FJROW.
!    To terminate the algorithm, set the output value of IFLAG negative.
!
!    Input, integer ( kind = 4 ) M, the number of functions.
!
!    Input, integer ( kind = 4 ) N, the number of variables.
!    N must not exceed M.
!
!    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial
!    estimate of the solution vector.  On output X contains the final
!    estimate of the solution vector.
!
!    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X.
!
!    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array.  The upper
!    triangle contains an upper triangular matrix R such that
!
!      P' * ( JAC' * JAC ) * P = R' * R,
!
!    where P is a permutation matrix and JAC is the final calculated
!    jacobian.  Column J of P is column IPVT(J) of the identity matrix.
!    The lower triangular part of FJAC contains information generated
!    during the computation of R.
!
!    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC.
!    LDFJAC must be at least N.
!
!    Input, real ( kind = 8 ) TOL. Termination occurs when the algorithm
!    estimates either that the relative error in the sum of squares is at
!    most TOL or that the relative error between X and the solution is at
!    most TOL.  TOL should be nonnegative.
!
!    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated
!    execution, INFO is set to the (negative) value of IFLAG. See description
!    of FCN.  Otherwise, INFO is set as follows:
!    0, improper input parameters.
!    1, algorithm estimates that the relative error in the sum of squares
!       is at most TOL.
!    2, algorithm estimates that the relative error between X and the
!       solution is at most TOL.
!    3, conditions for INFO = 1 and INFO = 2 both hold.
!    4, FVEC is orthogonal to the columns of the jacobian to machine precision.
!    5, number of calls to FCN with IFLAG = 1 has reached 100*(N+1).
!    6, TOL is too small.  No further reduction in the sum of squares
!       is possible.
!    7, TOL is too small.  No further improvement in the approximate
!       solution X is possible.
!
  implicit none

  integer ( kind = 4 ) ldfjac
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) factor
  external fcn
  real ( kind = 8 ) fjac(ldfjac,n)
  real ( kind = 8 ) ftol
  real ( kind = 8 ) fvec(m)
  real ( kind = 8 ) gtol
  integer ( kind = 4 ) info
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) maxfev
  integer ( kind = 4 ) mode
  integer ( kind = 4 ) nfev
  integer ( kind = 4 ) njev
  integer ( kind = 4 ) nprint
  real ( kind = 8 ) qtf(n)
  real ( kind = 8 ) tol
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) xtol

  if ( n <= 0 ) then
    info = 0
    return
  end if

  if ( m < n ) then
    info = 0
    return
  end if

  if ( ldfjac < n ) then
    info = 0
    return
  end if

  if ( tol < 0.0D+00 ) then
    info = 0
    return
  end if

  fvec(1:n) = 0.0D+00
  fjac(1:ldfjac,1:n) = 0.0D+00
  ftol = tol
  xtol = tol
  gtol = 0.0D+00
  maxfev = 100 * ( n + 1 )
  diag(1:n) = 0.0D+00
  mode = 1
  factor = 100.0D+00
  nprint = 0
  info = 0
  nfev = 0
  njev = 0
  ipvt(1:n) = 0
  qtf(1:n) = 0.0D+00

  call lmstr ( fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, &
    diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf )

  if ( info == 8 ) then
    info = 4
  end if

  return
end subroutine lmstr1
subroutine qform ( m, n, q, ldq )

!*****************************************************************************80
!
!! QFORM produces the explicit QR factorization of a matrix.
!
!  Discussion:
!
!    The QR factorization of a matrix is usually accumulated in implicit
!    form, that is, as a series of orthogonal transformations of the
!    original matrix.  This routine carries out those transformations,
!    to explicitly exhibit the factorization constructed by QRFAC.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) M, is a positive integer input variable set
!    to the number of rows of A and the order of Q.
!
!    Input, integer ( kind = 4 ) N, is a positive integer input variable set
!    to the number of columns of A.
!
!    Input/output, real ( kind = 8 ) Q(LDQ,M).  Q is an M by M array.
!    On input the full lower trapezoid in the first min(M,N) columns of Q
!    contains the factored form.
!    On output, Q has been accumulated into a square matrix.
!
!    Input, integer ( kind = 4 ) LDQ, is a positive integer input variable
!    not less than M which specifies the leading dimension of the array Q.
!
  implicit none

  integer ( kind = 4 ) ldq
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  integer ( kind = 4 ) j
  integer ( kind = 4 ) k
  integer ( kind = 4 ) l
  integer ( kind = 4 ) minmn
  real ( kind = 8 ) q(ldq,m)
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa(m)

  minmn = min ( m, n )

  do j = 2, minmn
    q(1:j-1,j) = 0.0D+00
  end do
!
!  Initialize remaining columns to those of the identity matrix.
!
  q(1:m,n+1:m) = 0.0D+00

  do j = n+1, m
    q(j,j) = 1.0D+00
  end do
!
!  Accumulate Q from its factored form.
!
  do l = 1, minmn

    k = minmn - l + 1

    wa(k:m) = q(k:m,k)

    q(k:m,k) = 0.0D+00
    q(k,k) = 1.0D+00

    if ( wa(k) /= 0.0D+00 ) then

      do j = k, m
        temp = dot_product ( wa(k:m), q(k:m,j) ) / wa(k)
        q(k:m,j) = q(k:m,j) - temp * wa(k:m)
      end do

    end if

  end do

  return
end subroutine qform
subroutine qrfac ( m, n, a, lda, pivot, ipvt, lipvt, rdiag, acnorm )

!*****************************************************************************80
!
!! QRFAC computes a QR factorization using Householder transformations.
!
!  Discussion:
!
!    This subroutine uses Householder transformations with column
!    pivoting (optional) to compute a QR factorization of the
!    M by N matrix A.  That is, QRFAC determines an orthogonal
!    matrix Q, a permutation matrix P, and an upper trapezoidal
!    matrix R with diagonal elements of nonincreasing magnitude,
!    such that A*P = Q*R.  The Householder transformation for
!    column K, K = 1,2,...,min(M,N), is of the form
!
!      I - ( 1 / U(K) ) * U * U'
!
!    where U has zeros in the first K-1 positions.  The form of
!    this transformation and the method of pivoting first
!    appeared in the corresponding LINPACK subroutine.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) M, the number of rows of A.
!
!    Input, integer ( kind = 4 ) N, the number of columns of A.
!
!    Input/output, real ( kind = 8 ) A(LDA,N), the M by N array.
!    On input, A contains the matrix for which the QR factorization is to
!    be computed.  On output, the strict upper trapezoidal part of A contains
!    the strict upper trapezoidal part of R, and the lower trapezoidal
!    part of A contains a factored form of Q (the non-trivial elements of
!    the U vectors described above).
!
!    Input, integer ( kind = 4 ) LDA, the leading dimension of A, which must
!    be no less than M.
!
!    Input, logical PIVOT, is TRUE if column pivoting is to be carried out.
!
!    Output, integer ( kind = 4 ) IPVT(LIPVT), defines the permutation matrix P
!    such that A*P = Q*R.  Column J of P is column IPVT(J) of the identity
!    matrix.  If PIVOT is false, IPVT is not referenced.
!
!    Input, integer ( kind = 4 ) LIPVT, the dimension of IPVT, which should
!    be N if pivoting is used.
!
!    Output, real ( kind = 8 ) RDIAG(N), contains the diagonal elements of R.
!
!    Output, real ( kind = 8 ) ACNORM(N), the norms of the corresponding
!    columns of the input matrix A.  If this information is not needed,
!    then ACNORM can coincide with RDIAG.
!
  implicit none

  integer ( kind = 4 ) lda
  integer ( kind = 4 ) lipvt
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) a(lda,n)
  real ( kind = 8 ) acnorm(n)
  real ( kind = 8 ) ajnorm
  real ( kind = 8 ) enorm
  real ( kind = 8 ) epsmch
  ! integer ( kind = 4 ) i
  integer ( kind = 4 ) i4_temp
  integer ( kind = 4 ) ipvt(lipvt)
  integer ( kind = 4 ) j
  integer ( kind = 4 ) k
  integer ( kind = 4 ) kmax
  integer ( kind = 4 ) minmn
  logical pivot
  real ( kind = 8 ) r8_temp(m)
  real ( kind = 8 ) rdiag(n)
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa(n)

  epsmch = epsilon ( epsmch )
!
!  Compute the initial column norms and initialize several arrays.
!
  do j = 1, n
    acnorm(j) = enorm ( m, a(1:m,j) )
  end do

  rdiag(1:n) = acnorm(1:n)
  wa(1:n) = acnorm(1:n)

  if ( pivot ) then
    do j = 1, n
      ipvt(j) = j
    end do
  end if
!
!  Reduce A to R with Householder transformations.
!
  minmn = min ( m, n )

  do j = 1, minmn
!
!  Bring the column of largest norm into the pivot position.
!
    if ( pivot ) then

      kmax = j

      do k = j, n
        if ( rdiag(kmax) < rdiag(k) ) then
          kmax = k
        end if
      end do

      if ( kmax /= j ) then

        r8_temp(1:m) = a(1:m,j)
        a(1:m,j)     = a(1:m,kmax)
        a(1:m,kmax)  = r8_temp(1:m)

        rdiag(kmax) = rdiag(j)
        wa(kmax) = wa(j)

        i4_temp    = ipvt(j)
        ipvt(j)    = ipvt(kmax)
        ipvt(kmax) = i4_temp

      end if

    end if
!
!  Compute the Householder transformation to reduce the
!  J-th column of A to a multiple of the J-th unit vector.
!
    ajnorm = enorm ( m-j+1, a(j,j) )

    if ( ajnorm /= 0.0D+00 ) then

      if ( a(j,j) < 0.0D+00 ) then
        ajnorm = -ajnorm
      end if

      a(j:m,j) = a(j:m,j) / ajnorm
      a(j,j) = a(j,j) + 1.0D+00
!
!  Apply the transformation to the remaining columns and update the norms.
!
      do k = j + 1, n

        temp = dot_product ( a(j:m,j), a(j:m,k) ) / a(j,j)

        a(j:m,k) = a(j:m,k) - temp * a(j:m,j)

        if ( pivot .and. rdiag(k) /= 0.0D+00 ) then

          temp = a(j,k) / rdiag(k)
          rdiag(k) = rdiag(k) * sqrt ( max ( 0.0D+00, 1.0D+00-temp ** 2 ) )

          if ( 0.05D+00 * ( rdiag(k) / wa(k) ) ** 2 <= epsmch ) then
            rdiag(k) = enorm ( m-j, a(j+1,k) )
            wa(k) = rdiag(k)
          end if

        end if

      end do

    end if

    rdiag(j) = - ajnorm

  end do

  return
end subroutine qrfac
subroutine qrsolv ( n, r, ldr, ipvt, diag, qtb, x, sdiag )

!*****************************************************************************80
!
!! QRSOLV solves a rectangular linear system A*x=b in the least squares sense.
!
!  Discussion:
!
!    Given an M by N matrix A, an N by N diagonal matrix D,
!    and an M-vector B, the problem is to determine an X which
!    solves the system
!
!      A*X = B
!      D*X = 0
!
!    in the least squares sense.
!
!    This subroutine completes the solution of the problem
!    if it is provided with the necessary information from the
!    QR factorization, with column pivoting, of A.  That is, if
!    Q*P = Q*R, where P is a permutation matrix, Q has orthogonal
!    columns, and R is an upper triangular matrix with diagonal
!    elements of nonincreasing magnitude, then QRSOLV expects
!    the full upper triangle of R, the permutation matrix p,
!    and the first N components of Q'*B.
!
!    The system is then equivalent to
!
!      R*Z = Q'*B
!      P'*D*P*Z = 0
!
!    where X = P*Z.  If this system does not have full rank,
!    then a least squares solution is obtained.  On output QRSOLV
!    also provides an upper triangular matrix S such that
!
!      P'*(A'*A + D*D)*P = S'*S.
!
!    S is computed within QRSOLV and may be of separate interest.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the order of R.
!
!    Input/output, real ( kind = 8 ) R(LDR,N), the N by N matrix.
!    On input the full upper triangle must contain the full upper triangle
!    of the matrix R.  On output the full upper triangle is unaltered, and
!    the strict lower triangle contains the strict upper triangle
!    (transposed) of the upper triangular matrix S.
!
!    Input, integer ( kind = 4 ) LDR, the leading dimension of R, which must be
!    at least N.
!
!    Input, integer ( kind = 4 ) IPVT(N), defines the permutation matrix P such
!    that A*P = Q*R.  Column J of P is column IPVT(J) of the identity matrix.
!
!    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D.
!
!    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'*B.
!
!    Output, real ( kind = 8 ) X(N), the least squares solution.
!
!    Output, real ( kind = 8 ) SDIAG(N), the diagonal elements of the upper
!    triangular matrix S.
!
  implicit none

  integer ( kind = 4 ) ldr
  integer ( kind = 4 ) n

  real ( kind = 8 ) c
  real ( kind = 8 ) cotan
  real ( kind = 8 ) diag(n)
  integer ( kind = 4 ) i
  integer ( kind = 4 ) ipvt(n)
  integer ( kind = 4 ) j
  integer ( kind = 4 ) k
  integer ( kind = 4 ) l
  integer ( kind = 4 ) nsing
  real ( kind = 8 ) qtb(n)
  real ( kind = 8 ) qtbpj
  real ( kind = 8 ) r(ldr,n)
  real ( kind = 8 ) s
  real ( kind = 8 ) sdiag(n)
  real ( kind = 8 ) sum2
  real ( kind = 8 ) t
  real ( kind = 8 ) temp
  real ( kind = 8 ) wa(n)
  real ( kind = 8 ) x(n)
!
!  Copy R and Q'*B to preserve input and initialize S.
!
!  In particular, save the diagonal elements of R in X.
!
  do j = 1, n
    r(j:n,j) = r(j,j:n)
    x(j) = r(j,j)
  end do

  wa(1:n) = qtb(1:n)
!
!  Eliminate the diagonal matrix D using a Givens rotation.
!
  do j = 1, n
!
!  Prepare the row of D to be eliminated, locating the
!  diagonal element using P from the QR factorization.
!
    l = ipvt(j)

    if ( diag(l) /= 0.0D+00 ) then

      sdiag(j:n) = 0.0D+00
      sdiag(j) = diag(l)
!
!  The transformations to eliminate the row of D
!  modify only a single element of Q'*B
!  beyond the first N, which is initially zero.
!
      qtbpj = 0.0D+00

      do k = j, n
!
!  Determine a Givens rotation which eliminates the
!  appropriate element in the current row of D.
!
        if ( sdiag(k) /= 0.0D+00 ) then

          if ( abs ( r(k,k) ) < abs ( sdiag(k) ) ) then
            cotan = r(k,k) / sdiag(k)
            s = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 )
            c = s * cotan
          else
            t = sdiag(k) / r(k,k)
            c = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * t ** 2 )
            s = c * t
          end if
!
!  Compute the modified diagonal element of R and
!  the modified element of (Q'*B,0).
!
          r(k,k) = c * r(k,k) + s * sdiag(k)
          temp = c * wa(k) + s * qtbpj
          qtbpj = - s * wa(k) + c * qtbpj
          wa(k) = temp
!
!  Accumulate the tranformation in the row of S.
!
          do i = k+1, n
            temp = c * r(i,k) + s * sdiag(i)
            sdiag(i) = - s * r(i,k) + c * sdiag(i)
            r(i,k) = temp
          end do

        end if

      end do

    end if
!
!  Store the diagonal element of S and restore
!  the corresponding diagonal element of R.
!
    sdiag(j) = r(j,j)
    r(j,j) = x(j)

  end do
!
!  Solve the triangular system for Z.  If the system is
!  singular, then obtain a least squares solution.
!
  nsing = n

  do j = 1, n

    if ( sdiag(j) == 0.0D+00 .and. nsing == n ) then
      nsing = j - 1
    end if

    if ( nsing < n ) then
      wa(j) = 0.0D+00
    end if

  end do

  do j = nsing, 1, -1
    sum2 = dot_product ( wa(j+1:nsing), r(j+1:nsing,j) )
    wa(j) = ( wa(j) - sum2 ) / sdiag(j)
  end do
!
!  Permute the components of Z back to components of X.
!
  do j = 1, n
    l = ipvt(j)
    x(l) = wa(j)
  end do

  return
end subroutine qrsolv
subroutine r1mpyq ( m, n, a, lda, v, w )

!*****************************************************************************80
!
!! R1MPYQ computes A*Q, where Q is the product of Householder transformations.
!
!  Discussion:
!
!    Given an M by N matrix A, this subroutine computes A*Q where
!    Q is the product of 2*(N - 1) transformations
!
!      GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1)
!
!    and GV(I), GW(I) are Givens rotations in the (I,N) plane which
!    eliminate elements in the I-th and N-th planes, respectively.
!    Q itself is not given, rather the information to recover the
!    GV, GW rotations is supplied.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) M, the number of rows of A.
!
!    Input, integer ( kind = 4 ) N, the number of columns of A.
!
!    Input/output, real ( kind = 8 ) A(LDA,N), the M by N array.
!    On input, the matrix A to be postmultiplied by the orthogonal matrix Q.
!    On output, the value of A*Q.
!
!    Input, integer ( kind = 4 ) LDA, the leading dimension of A, which must not
!    be less than M.
!
!    Input, real ( kind = 8 ) V(N), W(N), contain the information necessary
!    to recover the Givens rotations GV and GW.
!
  implicit none

  integer ( kind = 4 ) lda
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) a(lda,n)
  real ( kind = 8 ) c
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  real ( kind = 8 ) s
  real ( kind = 8 ) temp
  real ( kind = 8 ) v(n)
  real ( kind = 8 ) w(n)
!
!  Apply the first set of Givens rotations to A.
!
  do j = n - 1, 1, -1

     if ( 1.0D+00 < abs ( v(j) ) ) then
       c = 1.0D+00 / v(j)
       s = sqrt ( 1.0D+00 - c ** 2 )
     else
       s = v(j)
       c = sqrt ( 1.0D+00 - s ** 2 )
     end if

     do i = 1, m
        temp =   c * a(i,j) - s * a(i,n)
        a(i,n) = s * a(i,j) + c * a(i,n)
        a(i,j) = temp
     end do

  end do
!
!  Apply the second set of Givens rotations to A.
!
  do j = 1, n - 1

     if ( abs ( w(j) ) > 1.0D+00 ) then
       c = 1.0D+00 / w(j)
       s = sqrt ( 1.0D+00 - c ** 2 )
     else
       s = w(j)
       c = sqrt ( 1.0D+00 - s ** 2 )
     end if

     do i = 1, m
        temp =     c * a(i,j) + s * a(i,n)
        a(i,n) = - s * a(i,j) + c * a(i,n)
        a(i,j) = temp
     end do

  end do

  return
end subroutine r1mpyq
subroutine r1updt ( m, n, s, ls, u, v, w, sing )

!*****************************************************************************80
!
!! R1UPDT re-triangularizes a matrix after a rank one update.
!
!  Discussion:
!
!    Given an M by N lower trapezoidal matrix S, an M-vector U, and an
!    N-vector V, the problem is to determine an orthogonal matrix Q such that
!
!      (S + U * V' ) * Q
!
!    is again lower trapezoidal.
!
!    This subroutine determines Q as the product of 2 * (N - 1)
!    transformations
!
!      GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1)
!
!    where GV(I), GW(I) are Givens rotations in the (I,N) plane
!    which eliminate elements in the I-th and N-th planes,
!    respectively.  Q itself is not accumulated, rather the
!    information to recover the GV and GW rotations is returned.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) M, the number of rows of S.
!
!    Input, integer ( kind = 4 ) N, the number of columns of S.
!    N must not exceed M.
!
!    Input/output, real ( kind = 8 ) S(LS).  On input, the lower trapezoidal
!    matrix S stored by columns.  On output S contains the lower trapezoidal
!    matrix produced as described above.
!
!    Input, integer ( kind = 4 ) LS, the length of the S array.  LS must be at
!    least (N*(2*M-N+1))/2.
!
!    Input, real ( kind = 8 ) U(M), the U vector.
!
!    Input/output, real ( kind = 8 ) V(N).  On input, V must contain the
!    vector V.  On output V contains the information necessary to recover the
!    Givens rotations GV described above.
!
!    Output, real ( kind = 8 ) W(M), contains information necessary to
!    recover the Givens rotations GW described above.
!
!    Output, logical SING, is set to TRUE if any of the diagonal elements
!    of the output S are zero.  Otherwise SING is set FALSE.
!
  implicit none

  integer ( kind = 4 ) ls
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n

  real ( kind = 8 ) cos
  real ( kind = 8 ) cotan
  real ( kind = 8 ) giant
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  integer ( kind = 4 ) jj
  integer ( kind = 4 ) l
  real ( kind = 8 ) s(ls)
  real ( kind = 8 ) sin
  logical sing
  real ( kind = 8 ) tan
  real ( kind = 8 ) tau
  real ( kind = 8 ) temp
  real ( kind = 8 ) u(m)
  real ( kind = 8 ) v(n)
  real ( kind = 8 ) w(m)
!
!  GIANT is the largest magnitude.
!
  giant = huge ( giant )
!
!  Initialize the diagonal element pointer.
!
  jj = ( n * ( 2 * m - n + 1 ) ) / 2 - ( m - n )
!
!  Move the nontrivial part of the last column of S into W.
!
  l = jj
  do i = n, m
    w(i) = s(l)
    l = l + 1
  end do
!
!  Rotate the vector V into a multiple of the N-th unit vector
!  in such a way that a spike is introduced into W.
!
  do j = n - 1, 1, -1

    jj = jj - ( m - j + 1 )
    w(j) = 0.0D+00

    if ( v(j) /= 0.0D+00 ) then
!
!  Determine a Givens rotation which eliminates the
!  J-th element of V.
!
      if ( abs ( v(n) ) < abs ( v(j) ) ) then
        cotan = v(n) / v(j)
        sin = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 )
        cos = sin * cotan
        tau = 1.0D+00
        if ( abs ( cos ) * giant > 1.0D+00 ) then
          tau = 1.0D+00 / cos
        end if
      else
        tan = v(j) / v(n)
        cos = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 )
        sin = cos * tan
        tau = sin
      end if
!
!  Apply the transformation to V and store the information
!  necessary to recover the Givens rotation.
!
      v(n) = sin * v(j) + cos * v(n)
      v(j) = tau
!
!  Apply the transformation to S and extend the spike in W.
!
      l = jj
      do i = j, m
        temp = cos * s(l) - sin * w(i)
        w(i) = sin * s(l) + cos * w(i)
        s(l) = temp
        l = l + 1
      end do

    end if

  end do
!
!  Add the spike from the rank 1 update to W.
!
   w(1:m) = w(1:m) + v(n) * u(1:m)
!
!  Eliminate the spike.
!
  sing = .false.

  do j = 1, n-1

    if ( w(j) /= 0.0D+00 ) then
!
!  Determine a Givens rotation which eliminates the
!  J-th element of the spike.
!
      if ( abs ( s(jj) ) < abs ( w(j) ) ) then

        cotan = s(jj) / w(j)
        sin = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 )
        cos = sin * cotan

        if ( 1.0D+00 < abs ( cos ) * giant ) then
          tau = 1.0D+00 / cos
        else
          tau = 1.0D+00
        end if

      else

        tan = w(j) / s(jj)
        cos = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 )
        sin = cos * tan
        tau = sin

      end if
!
!  Apply the transformation to S and reduce the spike in W.
!
      l = jj
      do i = j, m
        temp = cos * s(l) + sin * w(i)
        w(i) = - sin * s(l) + cos * w(i)
        s(l) = temp
        l = l + 1
      end do
!
!  Store the information necessary to recover the Givens rotation.
!
      w(j) = tau

    end if
!
!  Test for zero diagonal elements in the output S.
!
    if ( s(jj) == 0.0D+00 ) then
      sing = .true.
    end if

    jj = jj + ( m - j + 1 )

  end do
!
!  Move W back into the last column of the output S.
!
  l = jj
  do i = n, m
    s(l) = w(i)
    l = l + 1
  end do

  if ( s(jj) == 0.0D+00 ) then
    sing = .true.
  end if

  return
end subroutine r1updt
subroutine r8vec_print ( n, a, title )

!*****************************************************************************80
!
!! R8VEC_PRINT prints an R8VEC.
!
!  Discussion:
!
!    An R8VEC is a vector of R8's.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    22 August 2000
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the number of components of the vector.
!
!    Input, real ( kind = 8 ) A(N), the vector to be printed.
!
!    Input, character ( len = * ) TITLE, a title.
!
  implicit none

  integer ( kind = 4 ) n

  real ( kind = 8 ) a(n)
  integer ( kind = 4 ) i
  character ( len = * ) title

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) trim ( title )
  write ( *, '(a)' ) ' '
  do i = 1, n
    write ( *, '(2x,i8,2x,g16.8)' ) i, a(i)
  end do

  return
end subroutine r8vec_print
subroutine rwupdt ( n, r, ldr, w, b, alpha, c, s )

!*****************************************************************************80
!
!! RWUPDT computes the decomposition of triangular matrix augmented by one row.
!
!  Discussion:
!
!    Given an N by N upper triangular matrix R, this subroutine
!    computes the QR decomposition of the matrix formed when a row
!    is added to R.  If the row is specified by the vector W, then
!    RWUPDT determines an orthogonal matrix Q such that when the
!    N+1 by N matrix composed of R augmented by W is premultiplied
!    by Q', the resulting matrix is upper trapezoidal.
!    The matrix Q' is the product of N transformations
!
!      G(N)*G(N-1)* ... *G(1)
!
!    where G(I) is a Givens rotation in the (I,N+1) plane which eliminates
!    elements in the (N+1)-st plane.  RWUPDT also computes the product
!    Q'*C where C is the (N+1)-vector (B,ALPHA).  Q itself is not
!    accumulated, rather the information to recover the G rotations is
!    supplied.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    06 April 2010
!
!  Author:
!
!    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Jorge More, Burton Garbow, Kenneth Hillstrom,
!    User Guide for MINPACK-1,
!    Technical Report ANL-80-74,
!    Argonne National Laboratory, 1980.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the order of R.
!
!    Input/output, real ( kind = 8 ) R(LDR,N).  On input the upper triangular
!    part of R must contain the matrix to be updated.  On output R contains the
!    updated triangular matrix.
!
!    Input, integer ( kind = 4 ) LDR, the leading dimension of the array R.
!    LDR must not be less than N.
!
!    Input, real ( kind = 8 ) W(N), the row vector to be added to R.
!
!    Input/output, real ( kind = 8 ) B(N).  On input, the first N elements
!    of the vector C.  On output the first N elements of the vector Q'*C.
!
!    Input/output, real ( kind = 8 ) ALPHA.  On input, the (N+1)-st element
!    of the vector C.  On output the (N+1)-st element of the vector Q'*C.
!
!    Output, real ( kind = 8 ) C(N), S(N), the cosines and sines of the
!    transforming Givens rotations.
!
  implicit none

  integer ( kind = 4 ) ldr
  integer ( kind = 4 ) n

  real ( kind = 8 ) alpha
  real ( kind = 8 ) b(n)
  real ( kind = 8 ) c(n)
  real ( kind = 8 ) cotan
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  real ( kind = 8 ) r(ldr,n)
  real ( kind = 8 ) rowj
  real ( kind = 8 ) s(n)
  real ( kind = 8 ) tan
  real ( kind = 8 ) temp
  real ( kind = 8 ) w(n)

  do j = 1, n

    rowj = w(j)
!
!  Apply the previous transformations to R(I,J), I=1,2,...,J-1, and to W(J).
!
    do i = 1, j - 1
      temp =   c(i) * r(i,j) + s(i) * rowj
      rowj = - s(i) * r(i,j) + c(i) * rowj
      r(i,j) = temp
    end do
!
!  Determine a Givens rotation which eliminates W(J).
!
    c(j) = 1.0D+00
    s(j) = 0.0D+00

    if ( rowj /= 0.0D+00 ) then

      if ( abs ( r(j,j) ) < abs ( rowj ) ) then
        cotan = r(j,j) / rowj
        s(j) = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 )
        c(j) = s(j) * cotan
      else
        tan = rowj / r(j,j)
        c(j) = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 )
        s(j) = c(j) * tan
      end if
!
!  Apply the current transformation to R(J,J), B(J), and ALPHA.
!
      r(j,j) =  c(j) * r(j,j) + s(j) * rowj
      temp =    c(j) * b(j)   + s(j) * alpha
      alpha = - s(j) * b(j)   + c(j) * alpha
      b(j) = temp

    end if

  end do

  return
end subroutine rwupdt
subroutine timestamp ( )

!*****************************************************************************80
!
!! TIMESTAMP prints the current YMDHMS date as a time stamp.
!
!  Example:
!
!    31 May 2001   9:45:54.872 AM
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    18 May 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    None
!
  implicit none

  character ( len = 8 ) ampm
  integer ( kind = 4 ) d
  integer ( kind = 4 ) h
  integer ( kind = 4 ) m
  integer ( kind = 4 ) mm
  character ( len = 9 ), parameter, dimension(12) :: month = (/ &
    'January  ', 'February ', 'March    ', 'April    ', &
    'May      ', 'June     ', 'July     ', 'August   ', &
    'September', 'October  ', 'November ', 'December ' /)
  integer ( kind = 4 ) n
  integer ( kind = 4 ) s
  integer ( kind = 4 ) values(8)
  integer ( kind = 4 ) y

  call date_and_time ( values = values )

  y = values(1)
  m = values(2)
  d = values(3)
  h = values(5)
  n = values(6)
  s = values(7)
  mm = values(8)

  if ( h < 12 ) then
    ampm = 'AM'
  else if ( h == 12 ) then
    if ( n == 0 .and. s == 0 ) then
      ampm = 'Noon'
    else
      ampm = 'PM'
    end if
  else
    h = h - 12
    if ( h < 12 ) then
      ampm = 'PM'
    else if ( h == 12 ) then
      if ( n == 0 .and. s == 0 ) then
        ampm = 'Midnight'
      else
        ampm = 'AM'
      end if
    end if
  end if

  write ( *, '(i2.2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
    d, trim ( month(m) ), y, h, ':', n, ':', s, '.', mm, trim ( ampm )

  return
end subroutine timestamp

MODULE NARP_MODULE
  !==============================================================================
  !NET ALL WAVE RADIATION PARAMETERIZATION ROUTINES
  !B. OFFERLE
  !DEPT OF GEOGRAPHY
  !INDIANA UNIVERSITY
  !bofferle@indiana.edu
  !
  !MODIFIED: 19 DEC 2002
  !CURRENTLY THE SMITH GRID IS ONLY VALID FOR THE N. HEMISPHERE
  !
  !Thomas Loridan, May 2008
  !4.1: MODIFICATION FOR CLOUD FRACTION PARAMETERIZATION AT NIGHT USING THE RATE OF COOLING.
  !     EOSHIFT INTRINSIC FUNCTION WAS ALSO REMOVED BECAUSE IT IS COMPILER DEPENDENT.
  !
  !6.0  T. Loridan - June 2009
  !     Different longwave down options (ldown_option)
  ! 1 - LDOWN Observed (add data as last column in met file)
  ! 2 - LDOWN modelled from observed FCLD (add data as last column in met file)
  ! 3 - LDOWN modelled from FCLD(RH,TA)
  ! 4 - LDOWN modelled from FCLD(Kdown); i.e. day FCLD only
  !     cloud fraction is kept constant throught the night (Offerle et al. 2003, JAM)
  ! 5 - Option 3 at night and 4 during the day (might cause discontinuities in LDOWN)

  !SUEWS   L. Jarvi - Oct 2010
  !Currently LDOWN options 4 and 5 commented out in order to reduce input files.
  !Last modified:
  ! TS 06 Aug 2017 - interface modified to receive explict input and output arguments
  ! LJ 27 Jan 2016 - Removal of tabs, cleaning of the code
  ! FL July 2014 - Variables are moved to modules in NARP subroutine. Snow related should also in future.
  ! FL Nov 2013 - A new sun postion algorithm added
  ! LJ May 2013 - Main program NARP changed to take subsurfaces and snow into account here and not
  ! in the main program
  ! LJ Oct 2012 - Zenith angle change in the calculation of albedo added
  ! sg feb 2012 - Allocatable array module added

  !==============================================================================================
  ! USE allocateArray

  IMPLICIT NONE

CONTAINS
  !==============================================================================
  SUBROUTINE RadMethod(&
       NetRadiationMethod,&!inout
       snowUse,&!input
       NetRadiationMethodX,AlbedoChoice,ldown_option)!output
    IMPLICIT NONE
    INTEGER,INTENT(in) :: NetRadiationMethod ! the one from RunControl setting
    INTEGER,INTENT(in) ::snowUse
    INTEGER,INTENT(out)::NetRadiationMethodX ! processed NetRadiationMethod to be used for other radiation calculations
    INTEGER,INTENT(out)::AlbedoChoice,ldown_option
    !Determine what should be done with respect to radiation
    ! TODO: this can be wrapped into a subroutine, TS 20 Oct 2017
    AlbedoChoice=0
    ldown_option=0
    IF(NetRadiationMethod==0)THEN    !Observed Q* from the met input file will be used
       NetRadiationMethodX=0
       !  ldown_option is not required if NetRadiationMethodX=0 as LDOWN calculations are skipped

       IF(snowUse==1) THEN            !If snow is modelled, NARP is needed for surface temperature
          ! NetRadiationMethod=3000
          NetRadiationMethodX=3000
          ldown_option=3              !LDOWN will be modelled
          !NetRadiationMethod=NetRadiationMethod/1000
       ENDIF

    ELSEIF(NetRadiationMethod>0)THEN  !Modelled Q* is used (NARP)
       AlbedoChoice=-9
       IF(NetRadiationMethod<10) THEN
          AlbedoChoice=0
          IF(NetRadiationMethod==1)ldown_option=1
          IF(NetRadiationMethod==2)ldown_option=2
          IF(NetRadiationMethod==3)ldown_option=3
          NetRadiationMethodX=NetRadiationMethod

       ELSEIF(NetRadiationMethod>=100.AND.NetRadiationMethod<1000) THEN
          AlbedoChoice=1
          IF(NetRadiationMethod==100)ldown_option=1
          IF(NetRadiationMethod==200)ldown_option=2
          IF(NetRadiationMethod==300)ldown_option=3
          ! NetRadiationMethod=NetRadiationMethod/100
          NetRadiationMethodX=NetRadiationMethod/100
       ENDIF

       !If bad NetRadiationMethod value
       IF(NetRadiationMethodX>3.OR. AlbedoChoice==-9)THEN
          WRITE(*,*) 'NetRadiationMethod=',NetRadiationMethodX
          WRITE(*,*) 'Value not usable'
          STOP
       ENDIF
    ENDIF


  END SUBROUTINE RadMethod




  !==============================================================================
  SUBROUTINE NARP(&
       nsurf,sfr,snowFrac,alb,emis,IceFrac,&! input:
       NARP_TRANS_SITE,NARP_EMIS_SNOW,&
       DTIME,ZENITH_deg,kdown,Temp_C,RH,Press_hPa,qn1_obs,&
       SnowAlb,&
       AlbedoChoice,ldown_option,&
       NetRadiationMethodX,DiagQN,&
       QSTARall,QSTAR_SF,QSTAR_S,kclear,KUPall,LDOWN,LUPall,fcld,TSURFall,&! output:
       qn1_ind_snow,kup_ind_snow,Tsurf_ind_snow,Tsurf_ind)
    !KCLEAR,FCLD,DTIME,KDOWN,QSTARall,KUPall,LDOWN,LUPall,TSURFall,&
    !AlbedoChoice,ldown_option,Temp_C,Press_hPa,Ea_hPa,qn1_obs,RH,&
    !,zenith_degnetRadiationChoice,

    !SUBROUTINE NARP(QSTAR,DTIME,KDOWN,LDOWN,T,RH,PRESS,FCLD,SNOW)
    !returns estimate of Q* given the meteorological fields and prior
    !configuration call.

    !OUTPUT FIELDS
    !QSTARall (W/m2) = net all wave radiation
    !KCLEAR          = clear sky incoming solar radiation
    !KUPall          = reflect solar radiation
    !LDOWN           = incoming longwave radiation (observed or modelled depending on ldown_option)
    !LUPall          = outgoing longwaver radiation
    !FCLD            = estimated cloud fraction (used only for emissivity estimate)
    !                  FCLD USED AS INPUT ALSO
    !TSURFall (DEG C)= estimated surface temperature
    !QSTAR_SF        = net all wave radiation for snow free surface
    !QSTAR_S         = net all wave radiation for SnowPack

    !INPUT FIELDS
    !DTIME (days) = local time, not daylight savings
    !KDOWN (W/m2) = incoming solar radiation
    !T (DEG C)    = air temperature near model height
    !RH (%)       = relative humidity near model height
    !PRESS (mb)   = station pressure, use estimate if unavailable
    !qn1_obs      = Observed Q*


    !INTERNAL FIELDS
    ! TemP_K = air temperature in K
    ! ES_hPs = saturation vapor pressure (hPa)
    ! EA_Pa = vapor pressure (hPa)
    ! TD = dewpoint (C)
    ! ZENITH = solar zenith angle
    ! ALB0 = surface albedo
    ! EMIS0 = surface emissivity
    ! EMIS_A = atmospheric emissivity
    ! TRANS = atmospheric transmissivity
    ! LUPCORR = correction for surface heating by kdown (W/m2)
    ! SIGMATK4 = energy flux density
    ! KDOWN_HR = hourly average insolation
    ! DOY = day of year

    !Modified by LJ to calcuate snow free and SnowPack components (May 2013)
    !Modified to define variables in data_in module
    !-------------------------------------------------------------------------------
    ! USE allocateArray
    ! use gis_data
    ! use data_in ! Included 20140701, FL
    ! use moist   ! Included 20140701, FL
    ! use time    ! Included 20140701, FL
    REAL(KIND(1D0)),DIMENSION(nsurf),INTENT(in) ::sfr
    REAL(KIND(1D0)),DIMENSION(nsurf),INTENT(in) ::snowFrac
    REAL(KIND(1D0)),DIMENSION(nsurf),INTENT(in) ::alb
    REAL(KIND(1D0)),DIMENSION(nsurf),INTENT(in) ::emis
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in) ::IceFrac
    ! REAL(KIND(1D0)),DIMENSION(365),INTENT(in) ::NARP_G

    REAL(KIND(1D0)),INTENT(in) ::DTIME
    REAL(KIND(1D0)),INTENT(in) ::ZENITH_deg
    REAL(KIND(1D0)),INTENT(in) ::kdown
    REAL(KIND(1D0)),INTENT(in) ::Temp_C
    REAL(KIND(1D0)),INTENT(in) ::RH
    REAL(KIND(1D0)),INTENT(in) ::Press_hPa
    REAL(KIND(1D0)),INTENT(in) ::qn1_obs
    REAL(KIND(1D0)),INTENT(in) ::SnowAlb
    REAL(KIND(1D0)),INTENT(in) ::NARP_TRANS_SITE
    REAL(KIND(1D0)),INTENT(in) ::NARP_EMIS_SNOW

    INTEGER,INTENT(in) ::nsurf
    INTEGER,INTENT(in) ::NetRadiationMethodX ! the one processed by RadMethod
    INTEGER,INTENT(in) ::AlbedoChoice
    INTEGER,INTENT(in) ::ldown_option
    INTEGER,INTENT(in) ::DiagQN

    REAL(KIND(1D0)),INTENT(out) ::QSTARall
    REAL(KIND(1D0)),INTENT(out) ::QSTAR_SF
    REAL(KIND(1D0)),INTENT(out) ::QSTAR_S
    REAL(KIND(1D0)),INTENT(out) ::kclear
    REAL(KIND(1D0)),INTENT(out) ::KUPall
    REAL(KIND(1D0)),INTENT(out) ::LDOWN
    REAL(KIND(1D0)),INTENT(out) ::LUPall
    REAL(KIND(1D0)),INTENT(out) ::fcld
    REAL(KIND(1D0)),INTENT(out) ::TSURFall

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out) ::qn1_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out) ::kup_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out) ::Tsurf_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out) ::Tsurf_ind

    REAL(KIND(1d0)),DIMENSION(nsurf) ::qn1_ind
    REAL(KIND(1d0)),DIMENSION(nsurf) ::kup_ind
    REAL(KIND(1d0)),DIMENSION(nsurf) ::lup_ind


    REAL(KIND(1d0)),DIMENSION(nsurf) ::qn1_ind_nosnow
    REAL(KIND(1d0)),DIMENSION(nsurf) ::kup_ind_nosnow
    REAL(KIND(1d0)),DIMENSION(nsurf) ::lup_ind_nosnow
    REAL(KIND(1d0)),DIMENSION(nsurf) ::Tsurf_ind_nosnow
    REAL(KIND(1d0)),DIMENSION(nsurf) ::lup_ind_snow


    REAL(KIND(1D0)) ::Temp_K,TD,ZENITH,QSTAR,QSTAR_SNOW,KUP_SNOW,LUP_SNOW,TSURF_SNOW,KUP,LUP,TSURF
    REAL(KIND(1D0)) ::ALB0,EMIS0,EMIS_A,TRANS!,RH,DTIME,KDOWN
    REAL(KIND(1D0)) ::LUPCORR,SIGMATK4,KDOWN_HR=0.
    INTEGER         ::DOY, is

    REAL(KIND(1D0))::qn1_cum,kup_cum,lup_cum,tsurf_cum,&   !Cumulative radiation components
         qn1_is,kup_is,lup_is,tsurf_is,&       !Sub-surface radiation components
         SF_all,ALB1

    REAL(KIND(1D0)),PARAMETER   :: DEG2RAD=0.017453292
    ! REAL(KIND(1D0)),PARAMETER   ::RAD2DEG=57.29577951
    REAL(KIND(1D0)),PARAMETER   :: SIGMA_SB=5.67E-8

    ! NB: NARP_G is not assigned with a value in SUEWS_translate.
    ! 3.0 is used here as annual average for mid-latitude areas. TS 24 Oct 2017
    REAL(KIND(1D0)),DIMENSION(365),PARAMETER ::  NARP_G=3.0
    !Initialize variables
    ! RH=avrh
    ! DTIME=dectime
    ! KDOWN=avkdn
    Temp_K=Temp_C+273.16
    SIGMATK4=SIGMA_SB*Temp_K**4
    TD=DEWPOINT(Temp_C,RH)
    ! Sun postition is now calculated in the main loop, FL
    !ZENITH=SOLAR_ZENITH(NARP_LAT,NARP_LONG,NARP_TZ,DTIME)
    !call NARP_cal_SunPosition(NARP_YEAR,DTIME,NARP_TZ,NARP_LAT,NARP_LONG,Alt,AZIMUTH,ZENITH)
    ZENITH=ZENITH_deg*DEG2RAD
    DOY=INT(DTIME)
    IF(DOY==366) doy=365

    !===================================================================================
    !Calculate radiation for each sub-surface
    qn1_cum=0
    kup_cum=0
    lup_cum=0
    tsurf_cum=0

    QSTAR_SF=0
    QSTAR_S=0

    !Total snowfree surface fraction
    SF_all=0
    DO is = 1,nsurf
       IF (sfr(is)/=0) SF_all = SF_all + sfr(is)*(1-snowFrac(is))
    ENDDO

    DO is=1,nsurf
       IF(DiagQN==1) WRITE(*,*) 'is ',is

       EMIS_A=PRATA_EMIS(Temp_K,Press_hPa)

       !--------------------------------------------------
       !-------SNOW FREE SURFACE--------------------------

       IF (AlbedoChoice==1.AND.180*ZENITH/ACOS(0.0)<90) THEN
          ALB0=ALB(is)+0.5e-16*(180*ZENITH/ACOS(0.0))**8 !AIDA 1982
       ELSE
          ALB0=ALB(is)
       ENDIF
       EMIS0=EMIS(is)

       !Downward longwave radiation
       IF((ldown_option==4) .OR. (ldown_option==5)) THEN !Estimate FCLD from Kdown (Offerle et al. 2003)
          IF (ZENITH<1.5) THEN !DAYTIME CALCULATIONS
             TRANS=TRANSMISSIVITY(Press_hPa,TD,NARP_G(DOY),ZENITH)
             KCLEAR=ISURFACE(DOY,ZENITH)*TRANS*NARP_TRANS_SITE
             IF (KCLEAR>50.) THEN
                FCLD=CLOUD_FRACTION(KDOWN,KCLEAR)
                EMIS_A=EMIS_CLOUD_SQ(EMIS_A,FCLD)
             ELSE
                IF(ldown_option==5) THEN ! Use RH when Kdown can not be used
                   FCLD=WC_fraction(RH,Temp_C)
                   EMIS_A=EMIS_CLOUD(EMIS_A,FCLD)
                ELSE
                   !FCLD is left to the latest calculable value
                   EMIS_A=EMIS_CLOUD_SQ(EMIS_A,FCLD)
                ENDIF
             ENDIF
          ELSE !NIGHT TIME CALCULATIONS
             IF(ldown_option==4) THEN
                !FCLD is left to the latest calculable value
                EMIS_A=EMIS_CLOUD_SQ(EMIS_A,FCLD)
             ELSEIF((ldown_option==5)) THEN ! Use RH
                FCLD=WC_fraction(RH,Temp_C)
                EMIS_A=EMIS_CLOUD(EMIS_A,FCLD)
             ENDIF
          ENDIF
       ELSEIF(ldown_option==3) THEN !Always use RH
          FCLD=WC_fraction(RH,Temp_C)
          EMIS_A=EMIS_CLOUD(EMIS_A,FCLD)
       ELSEIF(ldown_option==2) THEN ! FCLD obs, came from input
          EMIS_A=EMIS_CLOUD(EMIS_A,FCLD)
       ENDIF
       IF(DiagQN==1) WRITE(*,*) 'ldown_option: ',ldown_option,'FCLD:',FCLD

       IF(ldown_option>1) THEN ! Forcing available if ldown_option=1, model otherwise
          LDOWN=EMIS_A*SIGMATK4
          IF(DiagQN==1) WRITE(*,*) 'EMIS_A: ',EMIS_A,'SIGMATK4:',SIGMATK4,'LDOWN: ',LDOWN
       ENDIF


       !----------------------------------------------------------------------------
       !Note that this is not averaged over the hour for cases where time step < 1hr
       KDOWN_HR=KDOWN
       IF (KDOWN_HR>0) THEN
          LUPCORR=(1-ALB0)*(0.08*KDOWN_HR)
       ELSE
          LUPCORR=0.
       ENDIF

       KUP=ALB0*KDOWN
       TSURF=((EMIS0*SIGMATK4+LUPCORR)/(EMIS0*SIGMA_SB))**0.25 !Eqs. (14) and (15),

       LUP=EMIS0*SIGMATK4+LUPCORR+(1-EMIS0)*LDOWN              !Eq (16) in Offerle et al. (2002)
       QSTAR=KDOWN-KUP+LDOWN-LUP
       TSURF=TSURF-273.16

       !======================================================================
       !Snow related parameters if snow pack existing
       IF (snowFrac(is)>0) THEN
          IF (AlbedoChoice==1.AND.180*ZENITH/ACOS(0.0)<90) THEN
             ALB1=SnowAlb+0.5e-16*(180*ZENITH/ACOS(0.0))**8 !AIDA 1982
          ELSE
             ALB1=SnowAlb
          ENDIF

          KUP_SNOW = (ALB1*(snowFrac(is)-snowFrac(is)*IceFrac(is))+ALB0*snowFrac(is)*IceFrac(is))*KDOWN
          TSURF_SNOW=((NARP_EMIS_SNOW*SIGMATK4)/(NARP_EMIS_SNOW*SIGMA_SB))**0.25 !Snow surface temperature

          !IF (TSURF_SNOW>273.16) TSURF_SNOW=min(273.16,Temp_K)!Set this to 2 degrees (melted water on top)
          !open(34,file='TestingSnowFrac.txt',position='append')
          !write(34,*) dectime,is,alb1,alb0,snowFrac(is),IceFrac(is),KDOWN,KUP_snow
          !close(34)

          LUP_SNOW = NARP_EMIS_SNOW*SIGMA_SB*TSURF_SNOW**4+(1-NARP_EMIS_SNOW)*LDOWN
          QSTAR_SNOW = KDOWN-KUP_SNOW+LDOWN-LUP_SNOW
          TSURF_SNOW = TSURF_SNOW-273.16

       ELSE
          KUP_SNOW = 0
          LUP_SNOW = 0
          TSURF_SNOW = 0
          QSTAR_SNOW = 0
          !QSTAR_ICE = 0
          !KUP_ICE = 0
       ENDIF

       qn1_ind_nosnow(is)=QSTAR          !Define sub-surface radiation components
       kup_ind_nosnow(is)=KUP
       lup_ind_nosnow(is)=LUP
       Tsurf_ind_nosnow(is)=TSURF

       qn1_ind_snow(is)=QSTAR_SNOW        !Define snow sub-surface radiation components
       kup_ind_snow(is)=KUP_SNOW
       lup_ind_snow(is)=LUP_SNOW
       Tsurf_ind_snow(is)=TSURF_SNOW


       IF (SF_all/=0)THEN
          QSTAR_SF = QSTAR_SF + QSTAR*sfr(is)*(1-snowFrac(is))/SF_all
       ELSE
          QSTAR_SF = QSTAR_SF + QSTAR*sfr(is)*(1-snowFrac(is))
       ENDIF

       IF ((1-SF_all)/=0)THEN
          QSTAR_S = QSTAR_S + QSTAR_SNOW*sfr(is)*snowFrac(is)/(1-SF_all)
       ELSE
          QSTAR_S = QSTAR_S + QSTAR_SNOW*sfr(is)*snowFrac(is)
       ENDIF

       !---------------------------------------------------------------------
       !Calculate weighted variables for each subsurface
       qn1_is = QSTAR*(1-snowFrac(is))+QSTAR_SNOW*snowFrac(is)
       kup_is = KUP*(1-snowFrac(is))+KUP_SNOW*snowFrac(is)
       lup_is = LUP*(1-snowFrac(is))+LUP_SNOW*snowFrac(is)
       tsurf_is = TSURF*(1-snowFrac(is))+TSURF_SNOW*snowFrac(is)

       IF(DiagQN==1) WRITE(*,*) 'QSTAR',QSTAR,'QSTAR_SNOW',QSTAR_SNOW,'snowFrac',snowFrac(is)

       qn1_cum=qn1_cum+(qn1_is*sfr(is))  !Calculate cumulative radiation components
       kup_cum=kup_cum+(kup_is*sfr(is))
       lup_cum=lup_cum+(lup_is*sfr(is))
       tsurf_cum=tsurf_cum+(tsurf_is*sfr(is))

       qn1_ind(is)=qn1_is                !Define sub-surface radiation components
       kup_ind(is)=kup_is
       lup_ind(is)=lup_is
       Tsurf_ind(is)=tsurf_is

       IF(DiagQN==1) WRITE(*,*) 'qn1_is: ',qn1_is

    ENDDO !End of the surface types



    !Set overall radiation components
    IF (NetRadiationMethodX/=3000) THEN !Observed Q* used and snow is modeled
       QSTARall=qn1_cum
    ELSE
       QSTARall=qn1_obs
    ENDIF

    KUPall=kup_cum
    LUPall=lup_cum
    TSURFall=tsurf_cum

    ! qn1=QSTARall
    ! kup=KUPall
    !LDOWN has same name
    ! LUP=LUPall
    tsurf=TSURFall
    !if (kup>500) then
    ! write(*,*) Kdown, kup, kup_ind(1),kup_ind(2),kup_ind(3),kup_ind(4),kup_ind(5),kup_ind(6),SnowAlb
    ! pause
    !endif

    IF(DiagQN==1) WRITE(*,*) 'kdown: ',kdown,'kup:',kup,'LDOWN: ',LDOWN,'LUP: ',LUP
    IF(DiagQN==1) WRITE(*,*) 'Qn: ',QSTARall

  END SUBROUTINE NARP


  !==============================================================================
  SUBROUTINE NARP_cal_SunPosition(year,idectime,UTC,locationlatitude,locationlongitude,locationaltitude,sunazimuth,sunzenith)
    IMPLICIT NONE

    REAL(KIND(1D0)),INTENT(in) :: year,idectime,UTC,locationlatitude,locationlongitude,locationaltitude
    REAL(KIND(1D0)),INTENT(out) ::sunazimuth,sunzenith

    REAL(KIND(1D0)):: sec
    INTEGER :: month,day,hour,min,seas,dayofyear,year_int

    REAL(KIND(1D0)) :: juliancentury,julianday,julianephemeris_century,julianephemeris_day,&
         julianephemeris_millenium
    REAL(KIND(1D0)) :: earth_heliocentric_positionlatitude,earth_heliocentric_positionlongitude,&
         earth_heliocentric_positionradius
    REAL(KIND(1D0)) :: sun_geocentric_positionlatitude, sun_geocentric_positionlongitude
    REAL(KIND(1D0)) :: nutationlongitude,nutationobliquity
    REAL(KIND(1D0)) :: corr_obliquity
    REAL(KIND(1D0)) :: aberration_correction
    REAL(KIND(1D0)) :: apparent_sun_longitude
    REAL(KIND(1D0)) :: apparent_stime_at_greenwich
    REAL(KIND(1D0)) :: sun_rigth_ascension
    REAL(KIND(1D0)) :: sun_geocentric_declination
    REAL(KIND(1D0)) :: observer_local_hour
    REAL(KIND(1D0)) :: topocentric_sun_positionrigth_ascension ,topocentric_sun_positionrigth_ascension_parallax
    REAL(KIND(1D0)) :: topocentric_sun_positiondeclination
    REAL(KIND(1D0)) :: topocentric_local_hour
    ! REAL(KIND(1D0)) :: sunazimuth,sunzenith

    ! This function compute the sun position (zenith and azimuth angle (in degrees) at the observer
    ! location) as a function of the observer local time and position.
    !
    ! Input lat and lng should be in degrees, alt in meters.
    !
    ! It is an implementation of the algorithm presented by Reda et Andreas in:
    ! Reda, I., Andreas, A. (2003) Solar position algorithm for solar
    ! radiation application. National Renewable Energy Laboratory (NREL)
    ! Technical report NREL/TP-560-34302.
    ! This document is avaLAIble at www.osti.gov/bridge
    ! Code is translated from matlab code by Fredrik Lindberg (fredrikl@gvc.gu.se)
    ! Last modified: LJ 27 Jan 2016 - Tabs removed


    ! Convert to timevectors from dectime and year
    CALL dectime_to_timevec(idectime,hour,min,sec)
    dayofyear=FLOOR(idectime)
    year_int=int(year)
    CALL day2month(dayofyear,month,day,seas,year_int,locationlatitude)

    ! 1. Calculate the Julian Day, and Century. Julian Ephemeris day, century
    ! and millenium are calculated using a mean delta_t of 33.184 seconds.
    CALL julian_calculation(year,month,day,hour,min,sec,UTC,juliancentury,julianday,julianephemeris_century,&
         julianephemeris_day,julianephemeris_millenium)

    ! 2. Calculate the Earth heliocentric longitude, latitude, and radius
    ! vector (L, B, and R)
    CALL earth_heliocentric_position_calculation(julianephemeris_millenium,earth_heliocentric_positionlatitude,&
         &earth_heliocentric_positionlongitude,earth_heliocentric_positionradius)

    ! 3. Calculate the geocentric longitude and latitude
    CALL sun_geocentric_position_calculation(earth_heliocentric_positionlongitude,earth_heliocentric_positionlatitude,&
         & sun_geocentric_positionlatitude, sun_geocentric_positionlongitude)

    ! 4. Calculate the nutation in longitude and obliquity (in degrees).
    CALL nutation_calculation(julianephemeris_century,nutationlongitude,nutationobliquity)

    ! 5. Calculate the true obliquity of the ecliptic (in degrees).
    CALL corr_obliquity_calculation(julianephemeris_millenium, nutationobliquity, corr_obliquity)

    ! 6. Calculate the aberration correction (in degrees)
    CALL abberation_correction_calculation(earth_heliocentric_positionradius, aberration_correction)

    ! 7. Calculate the apparent sun longitude in degrees)
    CALL apparent_sun_longitude_calculation(sun_geocentric_positionlongitude, nutationlongitude,&
         & aberration_correction, apparent_sun_longitude)

    ! 8. Calculate the apparent sideral time at Greenwich (in degrees)
    CALL apparent_stime_at_greenwich_calculation(julianday,juliancentury, nutationlongitude, &
         &corr_obliquity, apparent_stime_at_greenwich)

    ! 9. Calculate the sun rigth ascension (in degrees)
    CALL sun_rigth_ascension_calculation(apparent_sun_longitude, corr_obliquity, sun_geocentric_positionlatitude, &
         &sun_rigth_ascension)

    ! 10. Calculate the geocentric sun declination (in degrees). Positive or
    ! negative if the sun is north or south of the celestial equator.
    CALL sun_geocentric_declination_calculation(apparent_sun_longitude, corr_obliquity, sun_geocentric_positionlatitude, &
         &sun_geocentric_declination)

    ! 11. Calculate the observer local hour angle (in degrees, westward from south).
    CALL observer_local_hour_calculation(apparent_stime_at_greenwich, locationlongitude, sun_rigth_ascension, observer_local_hour)

    ! 12. Calculate the topocentric sun position (rigth ascension, declination and
    ! rigth ascension parallax in degrees)
    CALL topocentric_sun_position_calculate(topocentric_sun_positionrigth_ascension,&
         &topocentric_sun_positionrigth_ascension_parallax,topocentric_sun_positiondeclination,locationaltitude,&
         &locationlatitude,observer_local_hour,sun_rigth_ascension,sun_geocentric_declination,&
         &earth_heliocentric_positionradius)

    ! 13. Calculate the topocentric local hour angle (in degrees)
    CALL topocentric_local_hour_calculate(observer_local_hour, topocentric_sun_positionrigth_ascension_parallax,&
         & topocentric_local_hour)

    ! 14. Calculate the topocentric zenith and azimuth angle (in degrees)
    CALL sun_topocentric_zenith_angle_calculate(locationlatitude , topocentric_sun_positiondeclination,&
         & topocentric_local_hour, sunazimuth,sunzenith)


  END SUBROUTINE NARP_cal_SunPosition


  !================================ Subfunction definitions ========================================================!
  SUBROUTINE julian_calculation(year,month,day,hour,min,sec,UTC,juliancentury,julianday,julianephemeris_century&
       &,julianephemeris_day,julianephemeris_millenium)
    IMPLICIT NONE

    REAL(KIND(1D0)) :: A,B,D,delta_t
    REAL(KIND(1D0)) :: juliancentury
    REAL(KIND(1D0)) :: julianday
    REAL(KIND(1D0)) :: julianephemeris_century
    REAL(KIND(1D0)) :: julianephemeris_day
    REAL(KIND(1D0)) :: julianephemeris_millenium
    REAL(KIND(1D0)) :: M,sec,year,UTC
    INTEGER :: day,hour,min,month
    !REAL(KIND(1D0)) :: time      !>
    REAL(KIND(1D0)) :: ut_time ,Y !tt,
    !
    ! This function compute the julian day and julian century from the local
    ! time and timezone information. Ephemeris are calculated with a delta_t=0
    ! seconds.

    IF (month == 1 .OR. month == 2) THEN
       Y = year - 1.
       M = month + 12
    ELSE
       Y = year
       M = month
    END IF
    ut_time = ((float(hour) - UTC)/24.) + (float(min)/(60.*24.)) + (sec/(60.*60.*24.)) ! time of day in UT time.
    D = day + ut_time ! Day of month in decimal time, ex. 2sd day of month at 12:30:30UT, D=2.521180556

    ! In 1582, the gregorian calendar was adopted
    IF (year == 1582.) THEN
       IF (month == 10) THEN
          IF (day <= 4) THEN ! The Julian calendar ended on October 4, 1582
             B = 0
          ELSE IF (day >= 15) THEN ! The Gregorian calendar started on October 15, 1582
             A = FLOOR(Y/100)
             B = 2 - A + FLOOR(A/4)
          ELSE
             !disp('This date never existed!. Date automatically set to October 4, 1582')
             month = 10
             day = 4
             B = 0
          END IF
       ELSE IF (month<10) THEN ! Julian calendar
          B = 0
       ELSE ! Gregorian calendar
          A = FLOOR(Y/100)
          B = 2 - A + FLOOR(A/4)
       END IF

    ELSE IF (year<1582.) THEN ! Julian calendar
       B = 0
    ELSE
       A = FLOOR(Y/100) ! Gregorian calendar
       B = 2 - A + FLOOR(A/4)
    END IF

    julianday = FLOOR(365.25*(Y+4716.)) + FLOOR(30.6001*(M+1)) + D + B - 1524.5

    delta_t = 0. ! 33.184;
    julianephemeris_day = julianday + (delta_t/86400)

    juliancentury = (julianday - 2451545.) / 36525.

    julianephemeris_century = (julianephemeris_day - 2451545.) / 36525.

    julianephemeris_millenium = julianephemeris_century / 10.

  END SUBROUTINE julian_calculation

  SUBROUTINE earth_heliocentric_position_calculation(julianephemeris_millenium,earth_heliocentric_positionlatitude&
       &,earth_heliocentric_positionlongitude,earth_heliocentric_positionradius)
    IMPLICIT NONE

    REAL(KIND(1D0)) :: julianephemeris_millenium      !>

    REAL(KIND(1D0)),DIMENSION(64) :: A0      !>
    REAL(KIND(1D0)),DIMENSION(34) :: A1      !>
    REAL(KIND(1D0)),DIMENSION(20) :: A2      !>
    REAL(KIND(1D0)),DIMENSION(7) :: A3      !>
    REAL(KIND(1D0)),DIMENSION(3) :: A4      !>
    REAL(KIND(1D0)) :: A5      !>
    REAL(KIND(1D0)),DIMENSION(64) :: B0      !>
    REAL(KIND(1D0)),DIMENSION(34) :: B1      !>
    REAL(KIND(1D0)),DIMENSION(20) :: B2      !>
    REAL(KIND(1D0)),DIMENSION(7) :: B3      !>
    REAL(KIND(1D0)),DIMENSION(3) :: B4      !>
    REAL(KIND(1D0)) :: B5      !>
    REAL(KIND(1D0)),DIMENSION(64) :: C0      !>
    REAL(KIND(1D0)),DIMENSION(34) :: C1      !>
    REAL(KIND(1D0)),DIMENSION(20) :: C2      !>
    REAL(KIND(1D0)),DIMENSION(7) :: C3      !>
    REAL(KIND(1D0)),DIMENSION(3) :: C4      !>
    REAL(KIND(1D0)) :: C5
    REAL(KIND(1D0)),DIMENSION(40) :: A0j      !>
    REAL(KIND(1D0)),DIMENSION(10) :: A1j     !>
    REAL(KIND(1D0)),DIMENSION(6) :: A2j      !>
    REAL(KIND(1D0)),DIMENSION(2) :: A3j      !>
    REAL(KIND(1D0)) :: A4j      !>
    REAL(KIND(1D0)),DIMENSION(40) :: B0j      !>
    REAL(KIND(1D0)),DIMENSION(10) :: B1j      !>
    REAL(KIND(1D0)),DIMENSION(6) :: B2j      !>
    REAL(KIND(1D0)),DIMENSION(2) :: B3j      !>
    REAL(KIND(1D0)) :: B4j      !>
    REAL(KIND(1D0)),DIMENSION(40) :: C0j      !>
    REAL(KIND(1D0)),DIMENSION(10) :: C1j      !>
    REAL(KIND(1D0)),DIMENSION(6) :: C2j      !>
    REAL(KIND(1D0)),DIMENSION(2) :: C3j      !>
    REAL(KIND(1D0)) :: C4j      !>
    REAL(KIND(1D0)),DIMENSION(5) ::  A0i
    REAL(KIND(1D0)),DIMENSION(5) ::  B0i
    REAL(KIND(1D0)),DIMENSION(5) ::  C0i
    REAL(KIND(1D0)),DIMENSION(2) ::  A1i
    REAL(KIND(1D0)),DIMENSION(2) ::  B1i
    REAL(KIND(1D0)),DIMENSION(2) ::   C1i
    REAL(KIND(1D0)) :: earth_heliocentric_positionlatitude      !>
    REAL(KIND(1D0)) :: earth_heliocentric_positionlongitude      !>
    REAL(KIND(1D0)) :: earth_heliocentric_positionradius      !>
    REAL(KIND(1D0)) :: JME      !>
    REAL(KIND(1D0)) :: L0      !>
    !REAL(KIND(1D0)) :: L0_terms      !>
    REAL(KIND(1D0)) :: L1      !>
    !REAL(KIND(1D0)) :: L1_terms      !>
    REAL(KIND(1D0)) :: L2      !>
    !REAL(KIND(1D0)) :: L2_terms      !>
    REAL(KIND(1D0)) :: L3      !>
    !REAL(KIND(1D0)) :: L3_terms      !>
    REAL(KIND(1D0)) :: L4      !>
    !REAL(KIND(1D0)) :: L4_terms      !>
    REAL(KIND(1D0)) :: L5      !>
    !REAL(KIND(1D0)), dimension(3) :: L5_terms      !>
    !REAL(KIND(1D0)) :: R0_terms      !>
    !REAL(KIND(1D0)) :: R1_terms      !>
    !REAL(KIND(1D0)) :: R2_terms      !>
    !REAL(KIND(1D0)) :: R3_terms      !>
    !REAL(KIND(1D0)), dimension(3) :: R4_terms      !>
    REAL(KIND(1D0)),PARAMETER       :: pi=3.141592653589793d+0

    ! This function compute the earth position relative to the sun, using
    ! tabulated values.

    A0=(/175347046,3341656,34894,3497,3418,3136,2676,2343,1324,1273,1199,990,902,857,780,753,505,&
         &492,357,317,284,271,243,206,205,202,156,132,126,115,103,102,102,99,98,86,85,85,80,79,71,&
         &74,74,70,62,61,57,56,56,52,52,51,49,41,41,39,37,37,36,36,33,30,30,25/)
    B0 = (/0.,4.669256800,4.626100,2.744100,2.828900,3.627700,4.418100,6.135200,0.7425000,2.037100,&
         &1.109600,5.233000,2.045000,3.508000,1.179000,2.533000,4.583000,4.205000,2.92,5.849000,&
         &1.899000,0.315,0.345,4.806000,1.869000,2.445800,0.833,3.411000,1.083000,0.645,0.636,0.976,&
         &4.267000,6.21,0.68,5.98,1.3,3.67,1.81,3.04,1.76,3.5,4.68,0.83,3.98,1.82,2.78,4.39,3.47,0.19,&
         &1.33,0.28,0.49,5.37,2.4,6.17,6.04,2.57,1.71,1.78,0.59,0.44,2.74,3.16/)
    C0 = (/0.,6283.075850,12566.15170,5753.384900,3.523100,77713.77150,7860.419400,3930.209700,&
         &11506.76980,529.6910,1577.343500,5884.927,26.29800,398.1490,5223.694,5507.553,&
         &18849.22800,775.5230,0.067,11790.62900,796.2980,10977.07900,5486.778,2544.314,&
         &5573.143,6069.777,213.2990,2942.463,20.77500,0.98,4694.003,15720.83900,7.114000,&
         &2146.170,155.4200,161000.6900,6275.960,71430.70,17260.15,12036.46,5088.630,3154.690,&
         &801.8200,9437.760,8827.390,7084.900,6286.600,14143.50,6279.550,12139.55,1748.020,&
         &5856.480,1194.450,8429.240,19651.05,10447.39,10213.29,1059.380,2352.870,6812.770,&
         &17789.85,83996.85,1349.870,4690.480/)
    A1 = (/628331966747.000,206059.,4303.,425.,119.,109.,93.,72.,68.,67.,59.,56.,45.,36.,29.,21.,19.,19.,17.,16.,&
         &16.,15.,12.,12.,12.,12.,11.,10.,10.,9.,9.,8.,6.,6./)
    B1 =(/ 0.,2.678235,2.635100,1.59,5.796000,2.966000,2.59,1.14,1.87,4.41,2.89,2.17,0.40,0.47,&
         &2.65,5.34,1.85,4.97,2.99,0.030,1.43,1.21,2.83,3.26,5.27,2.08,0.77,1.3,4.24,2.7,5.64,&
         &5.3,2.65,4.67/)
    C1 =(/ 0.,6283.075850,12566.15170,3.523000,26.29800,1577.344,18849.23,529.6900,398.1500,&
         &5507.550,5223.690,155.4200,796.3000,775.5200,7.11,0.98,5486.780,213.3000,6275.960,&
         &2544.310,2146.170,10977.08,1748.020,5088.630,1194.450,4694.,553.5700,3286.600,&
         &1349.870,242.7300,951.7200,2352.870,9437.760,4690.480/)
    A2 =(/ 52919,8720,309,27,16,16,10,9,7,5,4,4,3,3,3,3,3,3,2,2/)
    B2 = (/0.,1.072100,0.867,0.050,5.19,3.68,0.76,2.06,0.83,4.66,1.03,3.44,5.14,6.05,1.19,&
         &6.12,0.31,2.28,4.38,3.75/)
    C2 =(/ 0.,6283.075800,12566.15200,3.52,26.3,155.4200,18849.23,77713.77,775.5200,1577.340,&
         &7.11,5573.140,796.3000,5507.550,242.7300,529.6900,398.1500,553.5700,5223.690,0.98/)
    A3 = (/289,35,17,3,1,1,1/)
    B3 = (/5.8440,0.,5.4900,5.2000,4.7200,5.3000,5.9700/)
    C3 = (/6283.076,0.,12566.15,155.4200,3.52,18849.23,242.7300/)
    A4 = (/114,8,1/)
    B4 = (/3.1420,4.1300,3.8400/)
    C4 =  (/0.,6283.08,12566.15/)
    A5 =1.
    B5 =3.1400
    C5 =0.

    JME = julianephemeris_millenium

    ! Compute the Earth Heliochentric longitude from the tabulated values.
    L0 = SUM(A0 * COS(B0 + (C0 * JME)))
    L1 = SUM(A1 * COS(B1 + (C1 * JME)))
    L2 = SUM(A2 * COS(B2 + (C2 * JME)))
    L3 = SUM(A3 * COS(B3 + (C3 * JME)))
    L4 = SUM(A4 * COS(B4 + (C4 * JME)))
    L5 = A5 * COS(B5 + (C5 * JME))

    earth_heliocentric_positionlongitude = &
         &(L0 + (L1 * JME) + (L2 * JME**2) + (L3 * JME**3) + (L4 * JME**4) + (L5 * JME**5)) / 1e8
    ! Convert the longitude to degrees.
    earth_heliocentric_positionlongitude = earth_heliocentric_positionlongitude * 180./pi
    ! Limit the range to [0,360[;
    earth_heliocentric_positionlongitude=set_to_range(earth_heliocentric_positionlongitude)

    A0i = (/280,102,80,44,32/)
    B0i = (/3.19900000000000,5.42200000000000,3.88000000000000,3.70000000000000,4./)
    C0i = (/84334.6620000000,5507.55300000000,5223.69000000000,2352.87000000000,1577.34000000000/)
    A1i = (/9,6/)
    B1i =(/3.90000000000000,1.73000000000000/)
    C1i = (/5507.55000000000,5223.69000000000/)

    L0 = SUM(A0i * COS(B0i + (C0i * JME)))
    L1 = SUM(A1i * COS(B1i + (C1i * JME)))

    earth_heliocentric_positionlatitude = (L0 + (L1 * JME)) / 1e8
    ! Convert the latitude to degrees.
    earth_heliocentric_positionlatitude = earth_heliocentric_positionlatitude * 180/pi
    ! Limit the range to [0,360];
    earth_heliocentric_positionlatitude=set_to_range(earth_heliocentric_positionlatitude)

    A0j = (/100013989,1670700,13956,3084,1628,1576,925,542,472,346,329,307,243,212,186,175,110,&
         &98,86,86,85,63,57,56,49,47,45,43,39,38,37,37,36,35,33,32,32,28,28,26/)
    B0j = (/0.,3.09846350,3.05525000,5.1985,1.1739,2.8469,5.453,4.564,3.661,0.964,5.90,0.299,&
         &4.273,5.847,5.022,3.012,5.055,0.890,5.69,1.27,0.270,0.920,2.01,5.24,3.25,2.58,5.54,&
         &6.01,5.36,2.39,0.830,4.90,1.67,1.84,0.240,0.180,1.78,1.21,1.90,4.59/)
    C0j = (/0.,6283.07585,12566.1517,77713.7715,5753.38490,7860.41940,11506.7700,3930.21000,&
         &5884.92700,5507.55300,5223.69400,5573.14300,11790.6290,1577.34400,10977.0790,18849.2280,&
         &5486.77800,6069.78000,15720.8400,161000.690,17260.1500,529.69,83996.8500,71430.7000,&
         &2544.31000,775.52,9437.76000,6275.96000,4694.,8827.39000,19651.0500,12139.5500,&
         &12036.4600,2942.46000,7084.9,5088.63000,398.15,6286.6,6279.55000,10447.3900/)
    A1j = (/103019,1721,702,32,31,25,18,10,9,9/)
    B1j = (/1.10749000,1.0644,3.142,1.02,2.84,1.32,1.42,5.91,1.42,0.270/)
    C1j = (/6283.07585,12566.1517,0.,18849.2300,5507.55000,5223.69000,1577.34000,10977.0800,&
         &6275.96000,5486.78000/)
    A2j = (/4359,124,12,9,6,3/)
    B2j = (/5.7846,5.579,3.14,3.63,1.87,5.47/)
    C2j = (/6283.07580,12566.1520,0.,77713.7700,5573.14000,18849./)
    A3j = (/145,7/)
    B3j = (/4.273,3.92/)
    C3j = (/6283.07600,12566.1500/)
    A4j = 4
    B4j = 2.56
    C4j = 6283.08000

    ! Compute the Earth heliocentric radius vector
    L0 = SUM(A0j * COS(B0j + (C0j * JME)))
    L1 = SUM(A1j * COS(B1j + (C1j * JME)))
    L2 = SUM(A2j * COS(B2j + (C2j * JME)))
    L3 = SUM(A3j * COS(B3j + (C3j * JME)))
    L4 = A4j * COS(B4j + (C4j * JME))

    ! Units are in AU
    earth_heliocentric_positionradius = &
         &(L0 + (L1 * JME) + (L2 * JME**2) + (L3 * JME**3) + (L4 * JME**4)) / 1e8

  END SUBROUTINE earth_heliocentric_position_calculation

  SUBROUTINE sun_geocentric_position_calculation(earth_heliocentric_positionlongitude,&
       &earth_heliocentric_positionlatitude, sun_geocentric_positionlatitude, &
       &sun_geocentric_positionlongitude)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: earth_heliocentric_positionlongitude      !>
    REAL(KIND(1D0)), INTENT(in) :: earth_heliocentric_positionlatitude      !>
    REAL(KIND(1D0)) :: sun_geocentric_positionlatitude      !>
    REAL(KIND(1D0)) :: sun_geocentric_positionlongitude      !>

    ! This function compute the sun position relative to the earth.

    sun_geocentric_positionlongitude = earth_heliocentric_positionlongitude + 180.0
    ! Limit the range to [0,360];
    sun_geocentric_positionlongitude=set_to_range(sun_geocentric_positionlongitude)

    sun_geocentric_positionlatitude = -earth_heliocentric_positionlatitude
    ! Limit the range to [0,360]
    sun_geocentric_positionlatitude=set_to_range(sun_geocentric_positionlatitude)
  END SUBROUTINE sun_geocentric_position_calculation

  SUBROUTINE nutation_calculation(julianephemeris_century,nutationlongitude,nutationobliquity)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: julianephemeris_century      !>
    REAL(KIND(1D0)), DIMENSION(63) :: delta_longitude      !>
    REAL(KIND(1D0)), DIMENSION(63) :: delta_obliquity      !>
    REAL(KIND(1D0)) :: JCE      !>
    REAL(KIND(1D0)) :: nutationlongitude      !>
    REAL(KIND(1D0)) :: nutationobliquity      !>
    REAL(KIND(1D0)) , DIMENSION(4) :: p0,p1,p2,p3,p4
    REAL(KIND(1D0)), DIMENSION(63) ::tabulated_argument      !>
    REAL(KIND(1D0)) :: X0      !>
    REAL(KIND(1D0)) :: X1      !>
    REAL(KIND(1D0)) :: X2      !>
    REAL(KIND(1D0)) :: X3      !>
    REAL(KIND(1D0)) :: X4      !>
    REAL(KIND(1D0)), DIMENSION(5) :: Xi      !>
    INTEGER, DIMENSION(315) :: Y_terms1     !>
    INTEGER, DIMENSION(5,63) ::Y_terms
    REAL(KIND(1D0)), DIMENSION(252) :: nutation_terms1     !>
    REAL(KIND(1D0)), DIMENSION(4,63) ::nutation_terms
    INTEGER :: i
    REAL(KIND(1D0)),PARAMETER       :: pi=3.141592653589793d+0

    ! This function compute the nutation in longtitude and in obliquity, in
    ! degrees.

    ! All Xi are in degrees.
    JCE = julianephemeris_century

    ! 1. Mean elongation of the moon from the sun
    p0 = (/ (1/189474.),-0.0019142,445267.11148,297.85036 /)
    ! X0 = polyval(p, JCE);
    X0 = p0(1) * JCE**3 + p0(2) * JCE**2 + p0(3) * JCE + p0(4) ! This is faster than polyval...

    ! 2. Mean anomaly of the sun (earth)
    p1 = (/ -(1/300000.),-0.0001603,35999.05034,357.52772 /)
    ! X1 = polyval(p, JCE);
    X1 = p1(1) * JCE**3 + p1(2) * JCE**2 + p1(3) * JCE + p1(4)

    ! 3. Mean anomaly of the moon
    p2 = (/(1/56250.),0.0086972,477198.867398,134.96298 /)
    ! X2 = polyval(p, JCE);
    X2 = p2(1) * JCE**3 + p2(2) * JCE**2 + p2(3) * JCE + p2(4)

    ! 4. Moon argument of latitude
    p3 = (/ (1/327270.),-0.0036825,483202.017538,93.27191 /)
    ! X3 = polyval(p, JCE);
    X3 = p3(1) * JCE**3 + p3(2) * JCE**2 + p3(3) * JCE + p3(4)

    ! 5. Longitude of the ascending node of the moon's mean orbit on the
    ! ecliptic, measured from the mean equinox of the date
    p4 = (/ (1/450000.),0.0020708,-1934.136261,125.04452 /)
    ! X4 = polyval(p, JCE);
    X4 = p4(1) * JCE**3 + p4(2) * JCE**2 + p4(3) * JCE + p4(4)

    ! Y tabulated terms from the original code
    Y_terms1 =  (/0,0,0,0,1,-2,0,0,2,2,0,0,0,2,2,0,0,0,0,2,0,1,0,0,0,0,0,1,0,0,-2,1,0,2,2,0,0,0,2,1, &
         0,0,1,2,2,-2,-1,0,2,2,-2,0,1,0,0,-2,0,0,2,1,0,0,-1,2,2,2,0,0,0,0,0,0,1,0,1,2,0,-1,2,2,&
         0,0,-1,0,1,0,0,1,2,1,-2,0,2,0,0,0,0,-2,2,1,2,0,0,2,2,0,0,2,2,2,0,0,2,0,0,-2,0,1,2,2,0,&
         0,0,2,0,-2,0,0,2,0,0,0,-1,2,1,0,2,0,0,0,2,0,-1,0,1,-2,2,0,2,2,0,1,0,0,1,-2,0,1,0,1,0,-1,0,0,1,0,0,&
         2,-2,0,2,0,-1,2,1,2,0,1,2,2,0,1,0,2,2,-2,1,1,0,0,0,-1,0,2,2,2,0,0,2,1,2,0,1,0,0,-2,0,2,2,2,-2,0,1,&
         2,1,2,0,-2,0,1,2,0,0,0,1,0,-1,1,0,0,-2,-1,0,2,1,-2,0,0,0,1,0,0,2,2,1,-2,0,2,0,1,-2,1,0,2,1,0,0,1,-2,&
         0,-1,0,1,0,0,-2,1,0,0,0,1,0,0,0,0,0,0,1,2,0,0,0,-2,2,2,-1,-1,1,0,0,0,1,1,0,0,0,-1,1,2,2,2,-1,-1,2,2,&
         0,0,3,2,2,2,-1,0,2,2/)
    Y_terms=RESHAPE(Y_terms1,(/5,63/))
    nutation_terms1 = (/-171996.,-174.2,92025.,8.9,-13187.,-1.6,5736.,-3.1,-2274.,-0.2,977.,-0.5,2062.,0.2,-895.,0.5,&
         1426.,-3.4,54.,-0.1,712.,0.1,-7.,0.,-517.,1.2,224.,-0.6,-386.,-0.4,200.,0.,-301.,0.,129.,-0.1,&
         217.,-0.5,-95.,0.3,-158.,0.,0.,0.,129.,0.1,-70.,0.,123.,0.,-53.,0.,63.,0.,0.,0.,63.,0.1,-33.,0.,-59.,0.,26.,0.,&
         -58.,-0.1,32.,0.,-51.,0.,27.,0.,48.,0.,0.,0.,46.,0.,-24.,0.,-38.,0.,16.,0.,-31.,0.,13.,0.,29.,0.,&
         0.,0.,29.,0.,-12.,0.,26.,0.,0.,0.,-22.,0.,0.,0.,21.,0.,-10.,0.,17.,-0.1,0.,0.,16.,0.,-8.,0.,-16.,0.1,7.,0.,&
         -15.,0.,9.,0.,-13.,0.,7.,0.,-12.,0.,6.,0.,11.,0.,0.,0.,-10.,0.,5.,0.,-8.,0.,3.,0.,7.,0.,-3.,0.,-7.,0.,0.,0.,&
         -7.,0.,3.,0.,-7.,0.,3.,0.,6.,0.,0.,0.,6.,0.,-3.,0.,6.,0.,-3.,0.,-6.,0.,3.,0.,-6.,0.,3.,0.,5.,0.,0.,0.,-5.,0.,&
         3.,0.,-5.,0.,3.,0.,-5.,0.,3.,0.,4.,0.,0.,0.,4.,0.,0.,0.,4.,0.,0.,0.,-4.,0.,0.,0.,-4.,0.,0.,0.,-4.,0.,0.,0.,&
         3.,0.,0.,0.,-3.,0.,0.,0.,-3.,0.,0.,0.,-3.,0.,0.,0.,-3.,0.,0.,0.,-3.,0.,0.,0.,-3.,0.,0.,0.,-3.,0.,0.,0./)
    nutation_terms=RESHAPE(nutation_terms1,(/4,63/))
    ! Using the tabulated values, compute the delta_longitude and
    ! delta_obliquity.
    Xi = (/X0, X1, X2, X3, X4/)

    DO i=1,63
       tabulated_argument(i)=&
            &((Y_terms(1,i)*Xi(1))+(Y_terms(2,i)*Xi(2))+(Y_terms(3,i)*Xi(3))+(Y_terms(4,i)*Xi(4))+(Y_terms(5,i)*Xi(5)))*pi/180
    END DO

    delta_longitude = ((nutation_terms(1,:) + (nutation_terms(2,:) * JCE))) * SIN(tabulated_argument)
    delta_obliquity = ((nutation_terms(3,:) + (nutation_terms(4,:) * JCE))) * COS(tabulated_argument)

    ! Nutation in longitude
    nutationlongitude = SUM(delta_longitude) / 36000000.0

    ! Nutation in obliquity
    nutationobliquity = SUM(delta_obliquity) / 36000000.0

  END SUBROUTINE nutation_calculation

  SUBROUTINE corr_obliquity_calculation(julianephemeris_millenium, nutationobliquity, corr_obliquity)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(out) :: corr_obliquity      !>
    REAL(KIND(1D0)), INTENT(in) :: julianephemeris_millenium     !>
    REAL(KIND(1D0)), INTENT(in) :: nutationobliquity     !>
    REAL(KIND(1D0)) :: mean_obliquity      !>
    REAL(KIND(1D0)), DIMENSION(11) :: p      !>
    REAL(KIND(1D0)) :: U      !>

    ! This function compute the true obliquity of the ecliptic.


    p = (/ 2.45,5.79,27.87,7.12,-39.05,-249.67,-51.38,1999.25,-1.55,-4680.93,84381.448 /)
    ! mean_obliquity = polyval(p, julian.ephemeris_millenium/10);

    U = julianephemeris_millenium/10
    mean_obliquity =&
         &p(1)*U**10 + p(2)*U**9 + p(3)*U**8 + p(4)*U**7 + p(5)*U**6 + p(6)*U**5 + p(7)*U**4 + &
         &p(8)*U**3 + p(9)*U**2 + p(10)*U + p(11)

    corr_obliquity = (mean_obliquity/3600) + nutationobliquity
  END SUBROUTINE corr_obliquity_calculation

  SUBROUTINE abberation_correction_calculation(earth_heliocentric_positionradius, aberration_correction)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(out) :: aberration_correction      !>
    REAL(KIND(1D0)), INTENT(in) :: earth_heliocentric_positionradius     !>

    ! This function compute the aberration_correction, as a function of the
    ! earth-sun distance.

    aberration_correction = -20.4898/(3600*earth_heliocentric_positionradius)

  END SUBROUTINE abberation_correction_calculation

  SUBROUTINE apparent_sun_longitude_calculation(sun_geocentric_positionlongitude, nutationlongitude,&
       & aberration_correction, apparent_sun_longitude)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: aberration_correction      !>
    REAL(KIND(1D0)), INTENT(out) :: apparent_sun_longitude      !>
    REAL(KIND(1D0)), INTENT(in) :: nutationlongitude      !>
    REAL(KIND(1D0)), INTENT(in) :: sun_geocentric_positionlongitude      !>

    ! This function compute the sun apparent longitude

    apparent_sun_longitude = sun_geocentric_positionlongitude + nutationlongitude + aberration_correction

  END SUBROUTINE apparent_sun_longitude_calculation

  SUBROUTINE apparent_stime_at_greenwich_calculation(julianday,juliancentury, nutationlongitude,&
       & corr_obliquity, apparent_stime_at_greenwich)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(out) :: apparent_stime_at_greenwich      !>
    REAL(KIND(1D0)), INTENT(in) :: corr_obliquity      !>
    REAL(KIND(1D0)), INTENT(in) :: julianday     !>
    REAL(KIND(1D0)), INTENT(in) :: juliancentury     !>
    REAL(KIND(1D0)), INTENT(in) :: nutationlongitude      !>
    REAL(KIND(1D0)) :: JC      !>
    REAL(KIND(1D0)) :: JD      !>
    REAL(KIND(1D0)) :: mean_stime      !>
    REAL(KIND(1D0)),PARAMETER       :: pi=3.14159265358979d+0

    ! This function compute the apparent sideral time at Greenwich.

    JD = julianday
    JC = juliancentury

    ! Mean sideral time, in degrees
    mean_stime = 280.46061837d+0 + (360.98564736629d+0*(JD-2451545.0d+0)) + (0.000387933d+0*JC**2) - (JC**3/38710000.0d+0)

    ! Limit the range to [0-360];
    mean_stime=set_to_range(mean_stime)

    apparent_stime_at_greenwich = mean_stime + (nutationlongitude * COS(corr_obliquity * pi/180))
  END SUBROUTINE apparent_stime_at_greenwich_calculation

  SUBROUTINE sun_rigth_ascension_calculation(apparent_sun_longitude, corr_obliquity, &
       &sun_geocentric_positionlatitude, sun_rigth_ascension)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: apparent_sun_longitude      !>
    REAL(KIND(1D0)), INTENT(in) :: corr_obliquity      !>
    REAL(KIND(1D0)), INTENT(in) :: sun_geocentric_positionlatitude      !>
    REAL(KIND(1D0)), INTENT(out) :: sun_rigth_ascension      !>
    REAL(KIND(1D0)) :: argument_denominator      !>
    REAL(KIND(1D0)) :: argument_numerator      !>
    REAL(KIND(1D0)),PARAMETER       :: pi=3.141592653589793d+0

    ! This function compute the sun rigth ascension.

    argument_numerator = (SIN(apparent_sun_longitude * pi/180.0) * COS(corr_obliquity * pi/180.0)) - &
         (TAN(sun_geocentric_positionlatitude * pi/180.0) * SIN(corr_obliquity * pi/180.0))
    argument_denominator = COS(apparent_sun_longitude * pi/180.0)

    sun_rigth_ascension = ATAN2(argument_numerator, argument_denominator) * 180.0/pi
    ! Limit the range to [0,360];
    sun_rigth_ascension=set_to_range(sun_rigth_ascension)
  END SUBROUTINE sun_rigth_ascension_calculation

  SUBROUTINE sun_geocentric_declination_calculation(apparent_sun_longitude, corr_obliquity, &
       &sun_geocentric_positionlatitude, sun_geocentric_declination)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: apparent_sun_longitude      !>
    REAL(KIND(1D0)), INTENT(in) :: corr_obliquity      !>
    REAL(KIND(1D0)), INTENT(out) :: sun_geocentric_declination      !>
    REAL(KIND(1D0)), INTENT(in) :: sun_geocentric_positionlatitude     !>
    REAL(KIND(1D0)) :: argument      !>
    REAL(KIND(1D0)),PARAMETER       :: pi=3.141592653589793d+0

    argument = (SIN(sun_geocentric_positionlatitude * pi/180.0) * COS(corr_obliquity * pi/180.0)) + &
         (COS(sun_geocentric_positionlatitude * pi/180.0) * SIN(corr_obliquity * pi/180) * SIN(apparent_sun_longitude * pi/180.0))

    sun_geocentric_declination = ASIN(argument) * 180.0/pi
  END SUBROUTINE sun_geocentric_declination_calculation

  SUBROUTINE observer_local_hour_calculation(apparent_stime_at_greenwich, locationlongitude, &
       &sun_rigth_ascension, observer_local_hour)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: apparent_stime_at_greenwich      !>
    REAL(KIND(1D0)), INTENT(in) :: locationlongitude     !>
    REAL(KIND(1D0)), INTENT(out) :: observer_local_hour      !>
    REAL(KIND(1D0)), INTENT(in) :: sun_rigth_ascension      !>


    observer_local_hour = apparent_stime_at_greenwich + locationlongitude - sun_rigth_ascension
    ! Set the range to [0-360]
    observer_local_hour=set_to_range(observer_local_hour)
  END SUBROUTINE observer_local_hour_calculation

  SUBROUTINE topocentric_sun_position_calculate(topocentric_sun_positionrigth_ascension &
       &,topocentric_sun_positionrigth_ascension_parallax,topocentric_sun_positiondeclination,&
       &locationaltitude,locationlatitude,observer_local_hour,sun_rigth_ascension,&
       &sun_geocentric_declination,earth_heliocentric_positionradius)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: earth_heliocentric_positionradius
    REAL(KIND(1D0)), INTENT(in) :: locationlatitude      !>
    REAL(KIND(1D0)), INTENT(in) :: locationaltitude
    REAL(KIND(1D0)), INTENT(in) :: observer_local_hour      !>
    REAL(KIND(1D0)),  INTENT(in) :: sun_geocentric_declination      !>
    REAL(KIND(1D0)),  INTENT(in) :: sun_rigth_ascension      !>
    REAL(KIND(1D0)) :: denominator      !>
    REAL(KIND(1D0)) :: eq_horizontal_parallax      !>
    REAL(KIND(1D0)) :: nominator      !>
    REAL(KIND(1D0)) :: sun_rigth_ascension_parallax      !>
    REAL(KIND(1D0)) :: topocentric_sun_positiondeclination      !>
    REAL(KIND(1D0)) :: topocentric_sun_positionrigth_ascension      !>
    REAL(KIND(1D0)) :: topocentric_sun_positionrigth_ascension_parallax      !>
    REAL(KIND(1D0)) :: u      !>
    REAL(KIND(1D0)) :: x      !>
    REAL(KIND(1D0)) :: y      !>
    REAL(KIND(1D0)),PARAMETER       :: pi=3.141592653589793d+0

    ! topocentric_sun_positionrigth_ascension_parallax
    ! This function compute the sun position (rigth ascension and declination)
    ! with respect to the observer local position at the Earth surface.

    ! Equatorial horizontal parallax of the sun in degrees
    eq_horizontal_parallax = 8.794 / (3600 * earth_heliocentric_positionradius)

    ! Term u, used in the following calculations (in radians)
    u = ATAN(0.99664719 * TAN(locationlatitude * pi/180))

    ! Term x, used in the following calculations
    x = COS(u) + ((locationaltitude/6378140) * COS(locationaltitude * pi/180))

    ! Term y, used in the following calculations
    y = (0.99664719d+0 * SIN(u)) + ((locationaltitude/6378140) * SIN(locationlatitude * pi/180))

    ! Parallax in the sun rigth ascension (in radians)
    nominator = -x * SIN(eq_horizontal_parallax * pi/180.0) * SIN(observer_local_hour * pi/180.0)
    denominator = COS(sun_geocentric_declination * pi/180.0) - &
         (x * SIN(eq_horizontal_parallax * pi/180.0) * COS(observer_local_hour * pi/180.0))
    sun_rigth_ascension_parallax = ATAN2(nominator, denominator)
    ! Conversion to degrees.
    topocentric_sun_positionrigth_ascension_parallax = sun_rigth_ascension_parallax * 180.0/pi

    ! Topocentric sun rigth ascension (in degrees)
    topocentric_sun_positionrigth_ascension = sun_rigth_ascension + (sun_rigth_ascension_parallax * 180.0/pi)

    ! Topocentric sun declination (in degrees)
    nominator = (SIN(sun_geocentric_declination * pi/180.0) - (y*SIN(eq_horizontal_parallax * pi/180.0)))&
         & * COS(sun_rigth_ascension_parallax)
    denominator = COS(sun_geocentric_declination * pi/180.0) - (y*SIN(eq_horizontal_parallax * pi/180.0))&
         & * COS(observer_local_hour * pi/180.0)
    topocentric_sun_positiondeclination = ATAN2(nominator, denominator) * 180.0/pi
  END SUBROUTINE topocentric_sun_position_calculate

  SUBROUTINE topocentric_local_hour_calculate(observer_local_hour, topocentric_sun_positionrigth_ascension_parallax,&
       & topocentric_local_hour)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: observer_local_hour      !>
    REAL(KIND(1D0)), INTENT(out) :: topocentric_local_hour      !>
    REAL(KIND(1D0)), INTENT(in) :: topocentric_sun_positionrigth_ascension_parallax     !>

    ! This function compute the topocentric local jour angle in degrees

    topocentric_local_hour = observer_local_hour - topocentric_sun_positionrigth_ascension_parallax
  END SUBROUTINE topocentric_local_hour_calculate

  SUBROUTINE sun_topocentric_zenith_angle_calculate(locationlatitude , topocentric_sun_positiondeclination, &
       &topocentric_local_hour, sunazimuth,sunzenith)
    IMPLICIT NONE

    REAL(KIND(1D0)), INTENT(in) :: locationlatitude     !>
    REAL(KIND(1D0)), INTENT(in) :: topocentric_local_hour      !>
    REAL(KIND(1D0)), INTENT(in) :: topocentric_sun_positiondeclination
    REAL(KIND(1D0)) :: corr_elevation      !>
    REAL(KIND(1D0)) :: apparent_elevation      !>
    REAL(KIND(1D0)) :: argument      !>
    REAL(KIND(1D0)) :: denominator      !>
    REAL(KIND(1D0)) :: nominator      !>
    REAL(KIND(1D0)) :: refraction_corr      !>
    REAL(KIND(1D0)) :: sunazimuth      !>
    REAL(KIND(1D0)) :: sunzenith      !>
    REAL(KIND(1D0)),PARAMETER       :: pi=3.141592653589793d+0
    ! This function compute the sun zenith angle, taking into account the
    ! atmospheric refraction. A default temperature of 283K and a
    ! default pressure of 1010 mbar are used.

    ! Topocentric elevation, without atmospheric refraction
    argument = (SIN(locationlatitude * pi/180.0) * SIN(topocentric_sun_positiondeclination * pi/180.0)) + &
         (COS(locationlatitude * pi/180.0) * COS(topocentric_sun_positiondeclination * pi/180.0) * &
         &COS(topocentric_local_hour * pi/180.0))
    corr_elevation = ASIN(argument) * 180.0/pi

    ! Atmospheric refraction correction (in degrees)
    argument = corr_elevation + (10.3/(corr_elevation + 5.11))
    refraction_corr = 1.02 / (60 * TAN(argument * pi/180.0))

    ! For exact pressure and temperature correction, use this,
    ! with P the pressure in mbar amd T the temperature in Kelvins:
    ! refraction_corr = (P/1010) * (283/T) * 1.02 / (60 * tan(argument * pi/180));

    ! Apparent elevation
    apparent_elevation = corr_elevation + refraction_corr

    sunzenith = 90.0 - apparent_elevation

    ! Topocentric azimuth angle. The +180 conversion is to pass from astronomer
    ! notation (westward from south) to navigation notation (eastward from
    ! north);
    nominator = SIN(topocentric_local_hour * pi/180.0)
    denominator = (COS(topocentric_local_hour * pi/180.0) * SIN(locationlatitude * pi/180.0)) - &
         (TAN(topocentric_sun_positiondeclination * pi/180.0) * COS(locationlatitude * pi/180.0))
    sunazimuth = (ATAN2(nominator, denominator) * 180.0/pi) + 180.0
    ! Set the range to [0-360]
    sunazimuth=set_to_range(sunazimuth)

  END SUBROUTINE sun_topocentric_zenith_angle_calculate

  FUNCTION set_to_range(var) RESULT(vari)
    ! This function make sure the variable is in the specified range.

    REAL(KIND(1D0)) :: max_interval      !>
    REAL(KIND(1D0)) :: min_interval      !>
    REAL(KIND(1D0)) :: var
    REAL(KIND(1D0)) :: vari
    !
    max_interval=360.0
    min_interval=0.0

    vari = var - max_interval * FLOOR(var/max_interval)

    IF (vari<min_interval) THEN
       vari = vari + max_interval
    END IF

  END FUNCTION set_to_range

  !==============================================================================
  FUNCTION dewpoint(Temp_C,rh) RESULT(td)
    ! ea = vapor pressure (hPa)
    ! td = dewpoint (oC)
    ! calculates dewpoint in degC from
    ! http://www.atd.ucar.edu/weather_fl/dewpoint.html
    ! dewpoint = (237.3 * ln(e_vp/6.1078)) / (17.27 - (ln(e_vp/6.1078)))

    REAL(KIND(1d0))::rh,td,Temp_C,g
    !http://en.wikipedia.org/wiki/Dew_point
    g=((17.27*Temp_C)/(237.7+Temp_C))+LOG(rh/100)
    Td=(237.7*g)/(17.27-g)
    !td = (237.3 * LOG(ea_hPa/6.1078)) / (17.27 - (LOG(ea_hPa/6.1078)))
  END FUNCTION dewpoint
  !===============================================================================
  FUNCTION PRATA_EMIS(Temp_K,EA_hPa) RESULT(EMIS_A)
    ! clear sky emissivity function Prata 1996
    REAL(KIND(1d0))::Temp_K,ea_hPa,EMIS_A
    REAL(KIND(1d0))::W

    W=46.5*(ea_hPa/Temp_K)
    EMIS_A=1.-(1.+W)*EXP(-SQRT(1.2+3.*W))
  END FUNCTION PRATA_EMIS
  !===============================================================================
  FUNCTION EMIS_CLOUD(EMIS_A,FCLD) RESULT(em_adj)
    !calculates adjusted emissivity due to clouds
    REAL(KIND(1d0))::EMIS_A,FCLD,em_adj
    !T. Loridan, removing the square for FCLD in the emissivity correction
    !em_adj=EMIS_A+(1.-EMIS_A)*FCLD*FCLD
    em_adj=EMIS_A+(1.-EMIS_A)*FCLD
  END FUNCTION EMIS_CLOUD
  !===============================================================================
  FUNCTION EMIS_CLOUD_SQ(EMIS_A,FCLD) RESULT(em_adj)
    !calculates adjusted emissivity due to clouds
    REAL(KIND(1d0))::EMIS_A,FCLD,em_adj
    em_adj=EMIS_A+(1.-EMIS_A)*FCLD*FCLD
  END FUNCTION EMIS_CLOUD_SQ
  !===============================================================================
  FUNCTION cloud_fraction(KDOWN,KCLEAR) RESULT(FCLD)
    REAL(KIND(1d0))::KDOWN,KCLEAR,FCLD

    FCLD=1.-KDOWN/KCLEAR
    IF(FCLD>1.) FCLD=1.
    IF(FCLD<0.) FCLD=0.
  END FUNCTION cloud_fraction
  !===============================================================================
  FUNCTION WC_fraction(RH,Temp) RESULT(FWC)
    ! Thomas Loridan, King's College London: June 2009
    ! Parameterisation of fraction water content using the relative humidity
    REAL(KIND(1d0)),INTENT(in)   :: RH      !Relative Humidity in %
    REAL(KIND(1d0)),INTENT(in)   :: Temp    !Temperature in degre C

    REAL(KIND(1d0))              :: FWC     !Fraction water content between 0 and 1
    REAL(KIND(1d0))              :: A, B    !Parameters in the expo

    !Parameters
    !A=0.078
    !B=0.026

    A=0.185
    B=0.00019*Temp+0.015

    !FWC parameterization
    FWC=A * (EXP(B * RH)-1)
    IF(FWC>1.) FWC=1.
    IF(FWC<0.) FWC=0.
  END FUNCTION WC_fraction
  !===============================================================================
  !FUNCTION solar_zenith(lat,lng,timezone,dectime) RESULT(zenith)
  !  !Stull, 1989
  !  !returns zenith in radians
  !  !lat, lng in RADS
  !  REAL(KIND(1d0)) ::lat,lng,timezone,dectime,zenith, eqtime
  !  REAL(KIND(1d0)) ::ha, decl,tst, time_offset,gamma
  !
  !  gamma=2.*3.141592654/365.25463*dectime
  !  eqtime=229.18*(7.5e-5+1.868e-3*COS(gamma)-0.032077*SIN(gamma)&
  !       -0.014615*COS(2.*gamma)-0.040849*SIN(2.*gamma))
  !  decl=6.918e-3-0.399912*COS(gamma)+0.070257*SIN(gamma)&
  !       -0.006758*COS(2.*gamma)+9.07e-4*SIN(2.*gamma)-2.697e-3*COS(3.*gamma)&
  !       +1.48e-3*SIN(3.*gamma)
  !  time_offset=eqtime-4.*lng*RAD2DEG-60.*timezone
  !  tst=(dectime-FLOOR(dectime))*1440.+time_offset
  !  ha=(tst/4.)-180.
  !  ha=ha*DEG2RAD
  !  zenith=ACOS(SIN(lat)*SIN(decl)+COS(lat)*COS(decl)*COS(ha))
  !END FUNCTION solar_zenith

  !===============================================================================
  FUNCTION ISURFACE(doy,zenith) RESULT(Isurf)
    ! Calculates ground level solar irradiance clear sky
    ! assuming transmissivity = 1
    ! let it report zero if zenith >= 90
    REAL(KIND(1d0))::zenith,Isurf
    INTEGER::doy
    REAL(KIND(1d0))::Rmean, Rse, cosZ,Itoa
    REAL(KIND(1D0)),PARAMETER   :: DEG2RAD=0.017453292

    Rmean = 149.6                 !Stull 1998
    Rse=solar_ESdist(doy)
    IF(zenith<90.*DEG2RAD) THEN
       cosZ = COS(zenith)
       Itoa = 1370.*(Rmean/Rse)**2  !top of the atmosphere
       Isurf = Itoa*cosZ            !ground level solar irradiance in W/m2
    ELSE
       Isurf = 0.
    ENDIF

  END FUNCTION ISURFACE

  !===============================================================================
  FUNCTION solar_ESdist(doy) RESULT(Rse)
    !from Stull, 1998   Keep! called from SOLWEIG_clearnessindex_2013b
    INTEGER          ::doy
    REAL(KIND(1d0))             ::Rse
    REAL(KIND(1d0)) ::MA,nu,e,a

    e = 0.0167
    a = 146.457

    MA = 2.*3.141592654*(doy-3)/365.25463 !Mean anomaly
    nu=MA+0.0333988*SIN(MA)+.0003486*SIN(2.*MA)+5e-6*SIN(3.*MA) !true anomaly
    Rse = a*(1-e*e)/(1+e*COS(nu))

  END FUNCTION solar_ESdist

  !===============================================================================
  FUNCTION SmithLambda(lat) RESULT(G)
    USE FileName
    USE defaultnotUsed
    !read kriged data based on Smith 1966 (JAM)
    ! Smith, William L.
    ! "Note on the relationship between total precipitable water and surface dew point."
    ! Journal of Applied Meteorology 5.5 (1966): 726-727.
    INTEGER :: lat,ios,ilat
    REAL(KIND(1d0)),DIMENSION(365):: G

    !open(99,file="Smith1966.grd",access="direct",action="read",recl=365*4,iostat=ios)
    !read(99,rec=lat+1,iostat=ios) G
    OPEN(99,file=smithFile,iostat=ios)
    DO ilat=1,lat
       READ(99,*)
    ENDDO
    READ(99,*,iostat=ios)ilat, G
    IF (ios/=0) THEN
       CALL  ErrorHint(11,'reading Smith1966.grd (ios).',notUsed,notUsed,ios)
    ENDIF
    CLOSE(99)
  END FUNCTION SmithLambda

  !===============================================================================
  FUNCTION transmissivity(Press_hPa,Temp_C_dew,G,zenith) RESULT(trans)
    ! bulk atmospheric transmissivity (Crawford and Duchon, 1999)
    ! P = pressure (hPa)
    ! Td = dewpoint (C)
    ! G parameter is empirical value from Smith 1966 (JAM)
    ! zenith in radians
    ! if zenith > 80 use the value for 80.

    REAL(KIND(1d0)) ::Press_hPa,TemP_C_dew,zenith,G,trans
    REAL(KIND(1d0))::m,TrTpg,u,Tw,Ta,cosZ
    REAL(KIND(1d0))::Tdf
    REAL(KIND(1D0)),PARAMETER   :: DEG2RAD=0.017453292


    IF (zenith>80.*DEG2RAD) THEN
       cosZ=COS(80.*DEG2RAD)
    ELSE
       cosZ=COS(zenith)
    ENDIF

    Tdf = TemP_C_dew*1.8+32. !celsius to fahrenheit
    !	Transmission coefficients
    m = 35*cosZ/SQRT(1224.*cosZ*cosZ+1)            !optical air mass at p=1013 mb
    !Rayleigh & permanent gases
    TrTpg = 1.021-0.084*SQRT(m*(0.000949*Press_hPa+0.051)) !first two trans coeff
    u = EXP(0.113-LOG(G+1)+0.0393*Tdf)             !precipitable water
    Tw = 1-0.077*(u*m)**0.3             !vapor transmission coe3ff.
    Ta = 0.935**m                       !4th trans coeff
    trans = TrTpg*Tw*Ta                 !bulk atmospheric transmissivity
  END FUNCTION transmissivity
  !===============================================================================
END MODULE NARP_MODULE

!Reading one line of meteorological forcing data in.
!Latest change:
!  Feb 2012, LJ:  Input fluxes qh and qe changed _obs as well as qn1_obs ending
!  Oct 2014, LJ:  Variables changed only be used in this part of code and these are passed to calling
!                 function in MetArray.
!  Jan 2015, HCW: Precip_hr, wuh and LAI_hr changed for generic timesteps
!  Jan 2016, LJ:  Removal of tabs
!  Feb 2017, HCW: Added file unit as argument so MetRead can be used for original met forcing file too
!  May 2018, TS: imporved the ability in downscaling datetime by introducing a datetime library
! To Do:
!       - Check observed SM calculation
!---------------------------------------------------------------------------------------------------
SUBROUTINE MetRead(lfn,MetArray,InputmetFormat,ldown_option,NetRadiationMethod,&
     snowUse,SMDMethod,SoilDepthMeas,SoilRocks,SoilDensity,SmCap)

  USE defaultNotUsed

  IMPLICIT NONE

  !INPUT
  REAL (KIND(1d0)),DIMENSION(24)::MetArray !Array leaving the subroutine within
  !each INTERVAL (defined in RunControl.nml)
  ! - Met data now provided at a resolution of tstep, HCW Jan 2015

  REAL (KIND(1d0))::SmCap,&
       SoilDepthMeas,&        !Measured soil depth
       SoilRocks,&            !Rocks on ground
       SoilDensity            !Density of soil

  INTEGER::InputmetFormat,&     !Format of the meteorological forcing file
       ldown_option,&       !Method of calculating Ldown
       NetRadiationMethod,& !Method of calculating Q*
       SMDMethod,&         !Method of measured soil moisture
       snowUse

  ! Variables read in
  REAL (KIND(1d0))::avkdn,&     !Average downwelling shortwave radiation
       avrh,&      !Average relative humidity
       avu1,&      !Average wind speed
       dectime,&   !Decimal time
       fcld_obs,&  !Cloud fraction observed
       iy,&        !Year
       id,&        !Day
       it,&        !Hour
       imin,&      !Minute
       kdiff,&     !Diffuse shortwave radiation
       kdir,&      !Direct shortwave radiation
       LAI_obs,&   !Overall LAI of the study area
       ldown_obs,& !Downwelling longwave radiation
       Precip,& !Rainfall [mm]
       Pres_hPa,&  !Station air pressure in hPa
       Pres_kPa,&  !Station air pressure in kPa
       snow_obs,&  !Observed surface fraction of snow (between 0 and 1)
       qe_obs,&    !Observed latent heat flux
       qf_obs,&    !Observed antrhropogeni heat flux
       qh_obs,&    !Observed sensible heat flux
       qn1_obs,&   !Observed net all-wave radiation
       qs_obs,&    !Observed storage heat flux
       Temp_C,&    !Air temperature
       wdir,&      !Wind direction
       wu_m3,&     !Water use provided in met forcing file [m3]
       xsmd        !Measured soil moisture deficit

  INTEGER::iostat_var,lfn

  !-----------------------------------------------------------------------------------
  !-----------------------------------------------------------------------------------

  IF (InputMetFormat==0) THEN   !Default format using LUMPS only

     READ(lfn,*,iostat=iostat_var)iy,id,it,imin,qn1_obs,avu1,avrh,&
          Temp_C,wdir,Pres_kPa,Precip,avkdn,snow_obs,ldown_obs,fcld_obs

     !Set other variables needed while running SUEWS to zero
     qf_obs=NaN
     qs_obs=NaN
     qh_obs=NaN
     qe_obs=NaN
     xsmd=-99999
     kdiff=NaN
     kdir=NaN
     wdir=NaN

  ELSEIF (InputMetFormat==10) THEN !SUEWS reading
     READ(lfn,*,iostat=iostat_var) iy,id,it,imin,qn1_obs,qh_obs,qe_obs,qs_obs,qf_obs,avu1,avrh,&
          Temp_C,Pres_kPa,Precip,avkdn,snow_obs,ldown_obs,fcld_obs,&
          wu_m3,xsmd,LAI_obs,kdiff,kdir,wdir


     !write(*,*) 'In LUMPS_MetRead (1)'
     !write(*,*) 'imin',imin
     !write(*,*) 'it',it
     !write(*,*) 'id',id
     !write(*,*) 'iy',iy


     !Calculate observed soil moisture deficits from either volumetric or gravimetric SoilStates
     IF (SMDMethod==1.AND.xsmd/=-999) THEN !Soil moisture - volumetric
        xsmd=(SmCap-xsmd)*SoilDepthMeas*SoilRocks
     ELSEIF (SMDMethod==2.AND.xsmd/=-999) THEN !Soil moisture -gravimetric
        xsmd=(SmCap-xsmd)*SoilDensity*SoilDepthMeas*SoilRocks
     ELSE
        xsmd=-999
     ENDIF

  ELSE
     CALL ErrorHint(55,'RunControl.nml, InputMetFormat not usable.',notUsed,notUsed,InputmetFormat)
  ENDIF

  !===============Meteorological variables reading done==========================
  Pres_hPa=Pres_kPa*10. ! convert to hPa


  IF(iostat_var<0)THEN
     iostat_var=0
     CLOSE(lfn)
     RETURN
  ENDIF

  IF(AvKdn<0) THEN
     CALL ErrorHint(27,'Met Data: avKdn - needed for StoreDrainPrm. resistance, If present, check file not tab delimited',&
          avkdn,dectime,notUsedI)
     !sg removed this is causing the problems with resistances
     !  AvKdn=0 !Solar radiation cannot be lower than 1
  ENDIF

  IF((ldown_option==1).AND.(ldown_obs<0))THEN
     CALL ErrorHint(27,'Met Data: LWdn (ldown_obs) - impact Q* calc',ldown_obs,dectime,notUsedI)

  ELSEIF(ldown_option==2) THEN
     IF(fcld_obs==-999.0.OR.fcld_obs<0.OR.fcld_obs>1) THEN
        CALL ErrorHint(27,'Met Data: flcd_obs - impacts LW & Q* radiation',fcld_obs,dectime,notUsedI)
     ENDIF
  ENDIF

  IF(qn1_obs==-999.AND.NetRadiationMethod==0) THEN  !If measured Q* is used and it is -999
     CALL ErrorHint(27,'Met Data: Q* - will impact everything', qn1_obs,dectime, notUsedI)
  ENDIF

  IF(avu1<=0) THEN !If wind speed is negative
     CALL ErrorHint(27,'Met Data: avU1 - impacts aeroydnamic resistances', avU1,dectime, notUsedI)
  ENDIF


  IF(Temp_C<-50.OR.Temp_C>60)THEN !If temperature unrealistic
     CALL ErrorHint(27,'Met Data: Temp_C - beyond what is expected', Temp_C,dectime, notUsedI)
  ENDIF

  IF(avrh>100.OR.avrh<1)THEN !If relative humidity larger than 100%
     CALL ErrorHint(27,'Met Data: avRH - beyond what is expected', avRH,dectime, notUsedI)
  ENDIF

  IF(Pres_kPa<80)THEN  !If pressure too low
     CALL ErrorHint(27,'Met Data: Pres_kPa - too low - this could be fixed in model',Pres_kPa ,dectime, notUsedI)
  ENDIF

  IF (Precip<0) THEN  !If rain in negative, set it to zero
     CALL ErrorHint(27,'Met Data: Precip - less than 0',Precip ,dectime, notUsedI)
  ENDIF

  IF (snow_obs==NAN) snow_obs=0

  IF (snowUse==0.AND.(snow_obs<0.OR.snow_obs>1)) THEN
     CALL ErrorHint(27,'Met Data: snow not between [0  1]',snow_obs ,dectime, notUsedI)
  ENDIF

  IF (xsmd<0.AND.SMDMethod==1) THEN  !If soil moisture deficit is zero
     CALL ErrorHint(27,'Met Data: xsmd - less than 0',xsmd ,dectime, notUsedI)
  ENDIF

  !Create an array to be printed out.
  MetArray(1:24)=(/iy,id,it,imin,qn1_obs,qh_obs,qe_obs,qs_obs,qf_obs,avu1,&
       avrh,Temp_C,Pres_hPa,Precip,avkdn,snow_obs,ldown_obs,&
       fcld_obs,wu_m3,xsmd,LAI_obs,kdiff,kdir,wdir/)

  !write(*,*) 'In LUMPS_MetRead (2)'
  !write(*,*) 'imin',imin
  !write(*,*) 'it',it
  !write(*,*) 'id',id
  !write(*,*) 'iy',iy

  RETURN

END SUBROUTINE MetRead

! sg Feb 2012 -- moving all related suborutine together
! subroutine run_control - checks that value is reasonable
! subrotuine skipHeader  - jumps over header rows in input files
! Last modified:
! LJ 27 Jan 2016 - Removal of tabs, cleaning of the code
!------------------------------------------------------------

!Information for the run
MODULE run_info
  IMPLICIT NONE
  CHARACTER (len=90),DIMENSION(14)::text
  INTEGER::lim0=0,lim1=1,lim2=2,lim4=4,lim3=3,lim6=6,lim8=8,lim12=12,lfn_us
  LOGICAL ::file_qs
END MODULE run_info

! run_control
! called from: LUMPS_initial

SUBROUTINE run_control(eval,LowerLimit,Upperlimit)
  ! ver - determines if value to be read is an integer or real and returns the value
  ! if ver=-9 - then use integer
  USE run_info
  IMPLICIT NONE
  INTEGER::eval,i,lowerlimit,upperlimit
  CHARACTER (len=4)::check

  IF(file_qs)THEN
101  READ(lfn_us,*)check
     WRITE(*,*)check
     DO i=1,3
        IF(check(i:i)=="#")THEN
           !   write(*,*)check(i:i),i,"check"
           GOTO 101
        ELSE
           BACKSPACE(lfn_us)
           READ(lfn_us ,*)eval
           !write(*,*)eval, TEXT(1)
           EXIT
        ENDIF
     ENDDO
  ENDIF

  WRITE(12,120)eval,text(1)

  IF(eval<Lowerlimit.OR.eval>upperlimit)THEN
     WRITE(*,*)"Value out of range"
     WRITE(*,*)eval,text(1)
     STOP
  ENDIF

  WRITE(*,120)eval,text(1)
120 FORMAT(i4,2x,a90)

  RETURN
END SUBROUTINE run_control

! Skip Headers------------------------------
SUBROUTINE SkipHeader(lfn,skip)
  USE defaultnotUsed
  IMPLICIT NONE

  INTEGER::skip,lfn,i
  DO I=1,skip
     READ(lfn,*,err=201,iostat=ios_out)
  END DO

  RETURN

201 reall=REAL(skip)
  CALL ErrorHint(20,'In SkipHeader subroutine.',reall,notUsed,ios_out)
END SUBROUTINE SkipHeader

!-------------------------------------------------------------------------
SUBROUTINE InputHeaderCheck(FileName)
  ! Checks columns in input files match the columns expected by model code
  ! Model code columns are defined here
  ! Latest update:
  !   MH 21 Jun 2017 - Added parameters to SUEWS_AnthropogenicEmissions.txt
  !   MH 16 Jun 2017 - Added SUEWS_BiogenCO2.txt
  !   TS 02 Mar 2016  - AnOHM related variables added
  !   LJ 27 Jan 2016  - Removal of tabs
  !   LJ 07 July 2015 - snow albedo removed
  !   HCW 12 Nov 2014
  !-------------------------------------------------------------------------

  USE allocateArray
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  CHARACTER (len=50):: FileName

  ! ========== Define expected column names here ==========
  ! =======================================================

  ! ========== SUEWS_NonVeg.txt =============
  HeaderNonVeg_Reqd(ci_Code)         = "Code"
  HeaderNonVeg_Reqd(ci_AlbMin)       = "AlbedoMin"
  HeaderNonVeg_Reqd(ci_AlbMax)       = "AlbedoMax"
  HeaderNonVeg_Reqd(ci_Emis)         = "Emissivity"
  HeaderNonVeg_Reqd(ci_StorMin)      = "StorageMin"
  HeaderNonVeg_Reqd(ci_StorMax)      = "StorageMax"
  HeaderNonVeg_Reqd(ci_WetThresh)    = "WetThreshold"
  HeaderNonVeg_Reqd(ci_StateLimit)   = "StateLimit"
  HeaderNonVeg_Reqd(ci_DrEq)         = "DrainageEq"
  HeaderNonVeg_Reqd(ci_DrCoef1)      = "DrainageCoef1"
  HeaderNonVeg_Reqd(ci_DrCoef2)      = "DrainageCoef2"
  HeaderNonVeg_Reqd(ci_SoilTCode)    = "SoilTypeCode"
  HeaderNonVeg_Reqd(ci_SnowLimPat)   = "SnowLimPatch"
  HeaderNonVeg_Reqd(ci_SnowLimRem)   = "SnowLimRemove"
  HeaderNonVeg_Reqd(ci_OHMCode_SWet) = "OHMCode_SummerWet"
  HeaderNonVeg_Reqd(ci_OHMCode_SDry) = "OHMCode_SummerDry"
  HeaderNonVeg_Reqd(ci_OHMCode_WWet) = "OHMCode_WinterWet"
  HeaderNonVeg_Reqd(ci_OHMCode_WDry) = "OHMCode_WinterDry"
  HeaderNonVeg_Reqd(ci_OHMThresh_SW) = "OHMThresh_SW"
  HeaderNonVeg_Reqd(ci_OHMThresh_WD) = "OHMThresh_WD"
  HeaderNonVeg_Reqd(ci_ESTMCode)     = "ESTMCode"
  HeaderNonVeg_Reqd(ci_cpAnOHM)      = "AnOHM_Cp" ! AnOHM TS
  HeaderNonVeg_Reqd(ci_kkAnOHM)      = "AnOHM_Kk" ! AnOHM TS
  HeaderNonVeg_Reqd(ci_chAnOHM)      = "AnOHM_Ch" ! AnOHM TS


  ! ========== SUEWS_Veg.txt ===============
  HeaderVeg_Reqd(cp_Code)          = "Code"
  HeaderVeg_Reqd(cp_AlbMin)        = "AlbedoMin"
  HeaderVeg_Reqd(cp_AlbMax)        = "AlbedoMax"
  HeaderVeg_Reqd(cp_Emis)          = "Emissivity"
  HeaderVeg_Reqd(cp_StorMin)       = "StorageMin"
  HeaderVeg_Reqd(cp_StorMax)       = "StorageMax"
  HeaderVeg_Reqd(cp_WetThresh)     = "WetThreshold"
  HeaderVeg_Reqd(cp_StateLimit)    = "StateLimit"
  HeaderVeg_Reqd(cp_DrEq)          = "DrainageEq"
  HeaderVeg_Reqd(cp_DrCoef1)       = "DrainageCoef1"
  HeaderVeg_Reqd(cp_DrCoef2)       = "DrainageCoef2"
  HeaderVeg_Reqd(cp_SoilTCode)     = "SoilTypeCode"
  HeaderVeg_Reqd(cp_SnowLimPat)    = "SnowLimPatch"
  HeaderVeg_Reqd(cp_BaseT)         = "BaseT"
  HeaderVeg_Reqd(cp_BaseTe)        = "BaseTe"
  HeaderVeg_Reqd(cp_GDDFull)       = "GDDFull"
  HeaderVeg_Reqd(cp_SDDFull)       = "SDDFull"
  HeaderVeg_Reqd(cp_LAIMin)        = "LAIMin"
  HeaderVeg_Reqd(cp_LAIMax)        = "LAIMax"
  HeaderVeg_Reqd(cp_PorosityMin)   = "PorosityMin"
  HeaderVeg_Reqd(cp_PorosityMax)   = "PorosityMax"
  HeaderVeg_Reqd(cp_GsMax)         = "MaxConductance"
  HeaderVeg_Reqd(cp_LAIEq)         = "LAIEq"
  HeaderVeg_Reqd(cp_LeafGP1)       = "LeafGrowthPower1"
  HeaderVeg_Reqd(cp_LeafGP2)       = "LeafGrowthPower2"
  HeaderVeg_Reqd(cp_LeafOP1)       = "LeafOffPower1"
  HeaderVeg_Reqd(cp_LeafOP2)       = "LeafOffPower2"
  HeaderVeg_Reqd(cp_OHMCode_SWet)  = "OHMCode_SummerWet"
  HeaderVeg_Reqd(cp_OHMCode_SDry)  = "OHMCode_SummerDry"
  HeaderVeg_Reqd(cp_OHMCode_WWet)  = "OHMCode_WinterWet"
  HeaderVeg_Reqd(cp_OHMCode_WDry)  = "OHMCode_WinterDry"
  HeaderVeg_Reqd(cp_OHMThresh_SW)  = "OHMThresh_SW"
  HeaderVeg_Reqd(cp_OHMThresh_WD)  = "OHMThresh_WD"
  HeaderVeg_Reqd(cp_ESTMCode)      = "ESTMCode"
  HeaderVeg_Reqd(cp_cpAnOHM)       = "AnOHM_Cp" ! AnOHM TS
  HeaderVeg_Reqd(cp_kkAnOHM)       = "AnOHM_Kk" ! AnOHM TS
  HeaderVeg_Reqd(cp_chAnOHM)       = "AnOHM_Ch" ! AnOHM TS
  HeaderVeg_Reqd(cp_BiogenCO2Code) = "BiogenCO2Code"

  ! ========== SUEWS_Water.txt ==================
  HeaderWater_Reqd(cw_Code)         = "Code"
  HeaderWater_Reqd(cw_AlbMin)       = "AlbedoMin"
  HeaderWater_Reqd(cw_AlbMax)       = "AlbedoMax"
  HeaderWater_Reqd(cw_Emis)         = "Emissivity"
  HeaderWater_Reqd(cw_StorMin)      = "StorageMin"
  HeaderWater_Reqd(cw_StorMax)      = "StorageMax"
  HeaderWater_Reqd(cw_WetThresh)    = "WetThreshold"
  HeaderWater_Reqd(cw_StateLimit)   = "StateLimit"
  HeaderWater_Reqd(cw_WaterDepth)   = "WaterDepth"
  HeaderWater_Reqd(cw_DrEq)         = "DrainageEq"
  HeaderWater_Reqd(cw_DrCoef1)      = "DrainageCoef1"
  HeaderWater_Reqd(cw_DrCoef2)      = "DrainageCoef2"
  HeaderWater_Reqd(cw_OHMCode_SWet) = "OHMCode_SummerWet"
  HeaderWater_Reqd(cw_OHMCode_SDry) = "OHMCode_SummerDry"
  HeaderWater_Reqd(cw_OHMCode_WWet) = "OHMCode_WinterWet"
  HeaderWater_Reqd(cw_OHMCode_WDry) = "OHMCode_WinterDry"
  HeaderWater_Reqd(cw_OHMThresh_SW) = "OHMThresh_SW"
  HeaderWater_Reqd(cw_OHMThresh_WD) = "OHMThresh_WD"
  HeaderWater_Reqd(cw_ESTMCode)     = "ESTMCode"
  HeaderWater_Reqd(cw_cpAnOHM)      = "AnOHM_Cp" ! AnOHM TS
  HeaderWater_Reqd(cw_kkAnOHM)      = "AnOHM_Kk" ! AnOHM TS
  HeaderWater_Reqd(cw_chAnOHM)      = "AnOHM_Ch" ! AnOHM TS

  ! ========== SUEWS_Snow.txt ===================
  HeaderSnow_Reqd(cs_Code)         = "Code"
  HeaderSnow_Reqd(cs_SnowRMFactor) = "RadMeltFactor"
  HeaderSnow_Reqd(cs_SnowTMFactor) = "TempMeltFactor"
  HeaderSnow_Reqd(cs_SnowAlbMin)   = "AlbedoMin"
  HeaderSnow_Reqd(cs_SnowAlbMax)   = "AlbedoMax"
  HeaderSnow_Reqd(cs_SnowEmis)     = "Emissivity"
  HeaderSnow_Reqd(cs_Snowtau_a)    = "tau_a"
  HeaderSnow_Reqd(cs_Snowtau_f)    = "tau_f"
  HeaderSnow_Reqd(cs_SnowPLimAlb)  = "PrecipLimAlb"
  HeaderSnow_Reqd(cs_SnowSDMin)    = "SnowDensMin"
  HeaderSnow_Reqd(cs_SnowSDMax)    = "SnowDensMax"
  HeaderSnow_Reqd(cs_Snowtau_r)    = "tau_r"
  HeaderSnow_Reqd(cs_SnowCRWMin)   = "CRWMin"
  HeaderSnow_Reqd(cs_SnowCRWMax)   = "CRWMax"
  HeaderSnow_Reqd(cs_SnowPLimSnow) = "PrecipLimSnow"
  HeaderSnow_Reqd(cs_OHMCode_SWet) = "OHMCode_SummerWet"
  HeaderSnow_Reqd(cs_OHMCode_SDry) = "OHMCode_SummerDry"
  HeaderSnow_Reqd(cs_OHMCode_WWet) = "OHMCode_WinterWet"
  HeaderSnow_Reqd(cs_OHMCode_WDry) = "OHMCode_WinterDry"
  HeaderSnow_Reqd(cs_OHMThresh_SW) = "OHMThresh_SW"
  HeaderSnow_Reqd(cs_OHMThresh_WD) = "OHMThresh_WD"
  HeaderSnow_Reqd(cs_ESTMCode)     = "ESTMCode"
  HeaderSnow_Reqd(cs_cpAnOHM)      = "AnOHM_Cp"    ! AnOHM TS
  HeaderSnow_Reqd(cs_kkAnOHM)      = "AnOHM_Kk"    ! AnOHM TS
  HeaderSnow_Reqd(cs_chAnOHM)      = "AnOHM_Ch"    ! AnOHM TS


  ! ========== SUEWS_Soil.txt ===================
  HeaderSoil_Reqd(cSo_Code)        = "Code"
  HeaderSoil_Reqd(cSo_SoilDepth)   = "SoilDepth"
  HeaderSoil_Reqd(cSo_SoilStCap)   = "SoilStoreCap"
  HeaderSoil_Reqd(cSo_KSat)        = "SatHydraulicCond"
  HeaderSoil_Reqd(cSo_SoilDens)    = "SoilDensity"
  HeaderSoil_Reqd(cSo_SoilInfRate) = "InfiltrationRate"
  HeaderSoil_Reqd(cSo_ObsSMDepth)  = "OBS_SMDepth"
  HeaderSoil_Reqd(cSo_ObsSMMax)    = "OBS_SMCap"
  HeaderSoil_Reqd(cSo_ObsSNRFrac)  = "OBS_SoilNotRocks"

  ! ========== SUEWS_Conductance.txt ============
  HeaderCond_Reqd(cc_Code)         = "Code"
  HeaderCond_Reqd(cc_GsG1)         = "G1"
  HeaderCond_Reqd(cc_GsG2)         = "G2"
  HeaderCond_Reqd(cc_GsG3)         = "G3"
  HeaderCond_Reqd(cc_GsG4)         = "G4"
  HeaderCond_Reqd(cc_GsG5)         = "G5"
  HeaderCond_Reqd(cc_GsG6)         = "G6"
  HeaderCond_Reqd(cc_GsTH)         = "TH"
  HeaderCond_Reqd(cc_GsTL)         = "TL"
  HeaderCond_Reqd(cc_GsS1)         = "S1"
  HeaderCond_Reqd(cc_GsS2)         = "S2"
  HeaderCond_Reqd(cc_GsKmax)       = "Kmax"
  HeaderCond_Reqd(cc_gsModel)       = "gsModel"

  ! ========== SUEWS_OHMCoefficients.txt ========
  HeaderOHMCoefficients_Reqd(cO_Code) = "Code"
  HeaderOHMCoefficients_Reqd(cO_a1)   = "a1"
  HeaderOHMCoefficients_Reqd(cO_a2)   = "a2"
  HeaderOHMCoefficients_Reqd(cO_a3)   = "a3"

  ! ========== SUEWS_ESTMCoefficients.txt ========
  HeaderESTMCoefficients_Reqd(cE_Code)       = "Code"
  HeaderESTMCoefficients_Reqd(cE_Surf_thick1)   = "Surf_thick1"
  HeaderESTMCoefficients_Reqd(cE_Surf_k1)       = "Surf_k1"
  HeaderESTMCoefficients_Reqd(cE_Surf_rhoCp1)   = "Surf_rhoCp1"
  HeaderESTMCoefficients_Reqd(cE_Surf_thick2)   = "Surf_thick2"
  HeaderESTMCoefficients_Reqd(cE_Surf_k2)       = "Surf_k2"
  HeaderESTMCoefficients_Reqd(cE_Surf_rhoCp2)   = "Surf_rhoCp2"
  HeaderESTMCoefficients_Reqd(cE_Surf_thick3)   = "Surf_thick3"
  HeaderESTMCoefficients_Reqd(cE_Surf_k3)       = "Surf_k3"
  HeaderESTMCoefficients_Reqd(cE_Surf_rhoCp3)   = "Surf_rhoCp3"
  HeaderESTMCoefficients_Reqd(cE_Surf_thick4)   = "Surf_thick4"
  HeaderESTMCoefficients_Reqd(cE_Surf_k4)       = "Surf_k4"
  HeaderESTMCoefficients_Reqd(cE_Surf_rhoCp4)   = "Surf_rhoCp4"
  HeaderESTMCoefficients_Reqd(cE_Surf_thick5)   = "Surf_thick5"
  HeaderESTMCoefficients_Reqd(cE_Surf_k5)       = "Surf_k5"
  HeaderESTMCoefficients_Reqd(cE_Surf_rhoCp5)   = "Surf_rhoCp5"
  HeaderESTMCoefficients_Reqd(cE_Wall_thick1)   = "Wall_thick1"
  HeaderESTMCoefficients_Reqd(cE_Wall_k1)       = "Wall_k1"
  HeaderESTMCoefficients_Reqd(cE_Wall_rhoCp1)   = "Wall_rhoCp1"
  HeaderESTMCoefficients_Reqd(cE_Wall_thick2)   = "Wall_thick2"
  HeaderESTMCoefficients_Reqd(cE_Wall_k2)       = "Wall_k2"
  HeaderESTMCoefficients_Reqd(cE_Wall_rhoCp2)   = "Wall_rhoCp2"
  HeaderESTMCoefficients_Reqd(cE_Wall_thick3)   = "Wall_thick3"
  HeaderESTMCoefficients_Reqd(cE_Wall_k3)       = "Wall_k3"
  HeaderESTMCoefficients_Reqd(cE_Wall_rhoCp3)   = "Wall_rhoCp3"
  HeaderESTMCoefficients_Reqd(cE_Wall_thick4)   = "Wall_thick4"
  HeaderESTMCoefficients_Reqd(cE_Wall_k4)       = "Wall_k4"
  HeaderESTMCoefficients_Reqd(cE_Wall_rhoCp4)   = "Wall_rhoCp4"
  HeaderESTMCoefficients_Reqd(cE_Wall_thick5)   = "Wall_thick5"
  HeaderESTMCoefficients_Reqd(cE_Wall_k5)       = "Wall_k5"
  HeaderESTMCoefficients_Reqd(cE_Wall_rhoCp5)   = "Wall_rhoCp5"
  HeaderESTMCoefficients_Reqd(cE_Internal_thick1)   = "Internal_thick1"
  HeaderESTMCoefficients_Reqd(cE_Internal_k1)       = "Internal_k1"
  HeaderESTMCoefficients_Reqd(cE_Internal_rhoCp1)   = "Internal_rhoCp1"
  HeaderESTMCoefficients_Reqd(cE_Internal_thick2)   = "Internal_thick2"
  HeaderESTMCoefficients_Reqd(cE_Internal_k2)       = "Internal_k2"
  HeaderESTMCoefficients_Reqd(cE_Internal_rhoCp2)   = "Internal_rhoCp2"
  HeaderESTMCoefficients_Reqd(cE_Internal_thick3)   = "Internal_thick3"
  HeaderESTMCoefficients_Reqd(cE_Internal_k3)       = "Internal_k3"
  HeaderESTMCoefficients_Reqd(cE_Internal_rhoCp3)   = "Internal_rhoCp3"
  HeaderESTMCoefficients_Reqd(cE_Internal_thick4)   = "Internal_thick4"
  HeaderESTMCoefficients_Reqd(cE_Internal_k4)       = "Internal_k4"
  HeaderESTMCoefficients_Reqd(cE_Internal_rhoCp4)   = "Internal_rhoCp4"
  HeaderESTMCoefficients_Reqd(cE_Internal_thick5)   = "Internal_thick5"
  HeaderESTMCoefficients_Reqd(cE_Internal_k5)       = "Internal_k5"
  HeaderESTMCoefficients_Reqd(cE_Internal_rhoCp5)   = "Internal_rhoCp5"
  HeaderESTMCoefficients_Reqd(cE_nroom)      = "nroom"
  HeaderESTMCoefficients_Reqd(cE_alb_ibld)   = "Internal_albedo"
  HeaderESTMCoefficients_Reqd(cE_em_ibld)    = "Internal_emissivity"
  HeaderESTMCoefficients_Reqd(cE_CH_iwall)   = "Internal_CHwall"
  HeaderESTMCoefficients_Reqd(cE_CH_iroof)   = "Internal_CHroof"
  HeaderESTMCoefficients_Reqd(cE_CH_ibld)    = "Internal_CHbld"

  ! ========== SUEWS_AnthropogenicHeat.txt ======
  HeaderAnthropogenic_Reqd(cA_Code)     = "Code"
  HeaderAnthropogenic_Reqd(cA_BaseTHDD) = "BaseTHDD"
  HeaderAnthropogenic_Reqd(cA_QF_A1)    = "QF_A_WD"
  HeaderAnthropogenic_Reqd(cA_QF_B1)    = "QF_B_WD"
  HeaderAnthropogenic_Reqd(cA_QF_C1)    = "QF_C_WD"
  HeaderAnthropogenic_Reqd(cA_QF_A2)    = "QF_A_WE"
  HeaderAnthropogenic_Reqd(cA_QF_B2)    = "QF_B_WE"
  HeaderAnthropogenic_Reqd(cA_QF_C2)    = "QF_C_WE"
  HeaderAnthropogenic_Reqd(cA_AHMin_WD)    = "AHMin_WD"
  HeaderAnthropogenic_Reqd(cA_AHMin_WE)    = "AHMin_WE"
  HeaderAnthropogenic_Reqd(cA_AHSlopeHeating_WD)  = "AHSlope_Heating_WD"
  HeaderAnthropogenic_Reqd(cA_AHSlopeHeating_WE)  = "AHSlope_Heating_WE"
  HeaderAnthropogenic_Reqd(cA_AHSlopeCooling_WD)  = "AHSlope_Cooling_WD"
  HeaderAnthropogenic_Reqd(cA_AHSlopeCooling_WE)  = "AHSlope_Cooling_WE"
  HeaderAnthropogenic_Reqd(cA_TCriticHeating_WD)  = "TCritic_Heating_WD"
  HeaderAnthropogenic_Reqd(cA_TCriticHeating_WE)  = "TCritic_Heating_WE"
  HeaderAnthropogenic_Reqd(cA_TCriticCooling_WD)  = "TCritic_Cooling_WD"
  HeaderAnthropogenic_Reqd(cA_TCriticCooling_WE)  = "TCritic_Cooling_WE"
  HeaderAnthropogenic_Reqd(cA_EnProfWD)     = "EnergyUseProfWD"
  HeaderAnthropogenic_Reqd(cA_ENProfWE)     = "EnergyUseProfWE"
  HeaderAnthropogenic_Reqd(cA_CO2mWD)       = "ActivityProfWD"
  HeaderAnthropogenic_Reqd(cA_CO2mWE)       = "ActivityProfWE"
  HeaderAnthropogenic_Reqd(cA_TraffProfWD)  = "TraffProfWD"
  HeaderAnthropogenic_Reqd(cA_TraffProfWE)  = "TraffProfWE"
  HeaderAnthropogenic_Reqd(cA_PopProfWD)    = "PopProfWD"
  HeaderAnthropogenic_Reqd(cA_PopProfWE)    = "PopProfWE"
  HeaderAnthropogenic_Reqd(cA_MinQFMetab)   = "MinQFMetab"
  HeaderAnthropogenic_Reqd(cA_MaxQFMetab)   = "MaxQFMetab"
  HeaderAnthropogenic_Reqd(cA_FrFossilFuel_Heat)    = "FrFossilFuel_Heat"
  HeaderAnthropogenic_Reqd(cA_FrFossilFuel_NonHeat) = "FrFossilFuel_NonHeat"
  HeaderAnthropogenic_Reqd(cA_EF_umolCO2perJ) = "EF_umolCO2perJ"
  HeaderAnthropogenic_Reqd(cA_EnEF_v_Jkm)     = "EnEF_v_Jkm"
  HeaderAnthropogenic_Reqd(cA_FcEF_v_kgkm)    = "FcEF_v_kgkm"
  HeaderAnthropogenic_Reqd(cA_TrafficUnits)   = "TrafficUnits"

  ! ========== SUEWS_Irrigation.txt =============
  HeaderIrrigation_Reqd(cIr_Code)         = "Code"
  HeaderIrrigation_Reqd(cIr_IeStart)      = "Ie_start"
  HeaderIrrigation_Reqd(cIr_IeEnd)        = "Ie_end"
  HeaderIrrigation_Reqd(cIr_IntWU)        = "InternalWaterUse"
  HeaderIrrigation_Reqd(cIr_Faut)         = "Faut"
  HeaderIrrigation_Reqd(cIr_Ie_a1)        = "Ie_a1"
  HeaderIrrigation_Reqd(cIr_Ie_a2)        = "Ie_a2"
  HeaderIrrigation_Reqd(cIr_Ie_a3)        = "Ie_a3"
  HeaderIrrigation_Reqd(cIr_Ie_m1)        = "Ie_m1"
  HeaderIrrigation_Reqd(cIr_Ie_m2)        = "Ie_m2"
  HeaderIrrigation_Reqd(cIr_Ie_m3)        = "Ie_m3"
  HeaderIrrigation_Reqd(cIr_DayWat1)      = "DayWat(1)"
  HeaderIrrigation_Reqd(cIr_DayWat2)      = "DayWat(2)"
  HeaderIrrigation_Reqd(cIr_DayWat3)      = "DayWat(3)"
  HeaderIrrigation_Reqd(cIr_DayWat4)      = "DayWat(4)"
  HeaderIrrigation_Reqd(cIr_DayWat5)      = "DayWat(5)"
  HeaderIrrigation_Reqd(cIr_DayWat6)      = "DayWat(6)"
  HeaderIrrigation_Reqd(cIr_DayWat7)      = "DayWat(7)"
  HeaderIrrigation_Reqd(cIr_DayWatPer1)   = "DayWatPer(1)"
  HeaderIrrigation_Reqd(cIr_DayWatPer2)   = "DayWatPer(2)"
  HeaderIrrigation_Reqd(cIr_DayWatPer3)   = "DayWatPer(3)"
  HeaderIrrigation_Reqd(cIr_DayWatPer4)   = "DayWatPer(4)"
  HeaderIrrigation_Reqd(cIr_DayWatPer5)   = "DayWatPer(5)"
  HeaderIrrigation_Reqd(cIr_DayWatPer6)   = "DayWatPer(6)"
  HeaderIrrigation_Reqd(cIr_DayWatPer7)   = "DayWatPer(7)"

  ! ========== SUEWS_Profiles.txt ===============
  HeaderProfiles_Reqd(cPr_Code)      = "Code"
  HeaderProfiles_Reqd(cPr_Hours( 1)) = "0"
  HeaderProfiles_Reqd(cPr_Hours( 2)) = "1"
  HeaderProfiles_Reqd(cPr_Hours( 3)) = "2"
  HeaderProfiles_Reqd(cPr_Hours( 4)) = "3"
  HeaderProfiles_Reqd(cPr_Hours( 5)) = "4"
  HeaderProfiles_Reqd(cPr_Hours( 6)) = "5"
  HeaderProfiles_Reqd(cPr_Hours( 7)) = "6"
  HeaderProfiles_Reqd(cPr_Hours( 8)) = "7"
  HeaderProfiles_Reqd(cPr_Hours( 9)) = "8"
  HeaderProfiles_Reqd(cPr_Hours(10)) = "9"
  HeaderProfiles_Reqd(cPr_Hours(11)) = "10"
  HeaderProfiles_Reqd(cPr_Hours(12)) = "11"
  HeaderProfiles_Reqd(cPr_Hours(13)) = "12"
  HeaderProfiles_Reqd(cPr_Hours(14)) = "13"
  HeaderProfiles_Reqd(cPr_Hours(15)) = "14"
  HeaderProfiles_Reqd(cPr_Hours(16)) = "15"
  HeaderProfiles_Reqd(cPr_Hours(17)) = "16"
  HeaderProfiles_Reqd(cPr_Hours(18)) = "17"
  HeaderProfiles_Reqd(cPr_Hours(19)) = "18"
  HeaderProfiles_Reqd(cPr_Hours(20)) = "19"
  HeaderProfiles_Reqd(cPr_Hours(21)) = "20"
  HeaderProfiles_Reqd(cPr_Hours(22)) = "21"
  HeaderProfiles_Reqd(cPr_Hours(23)) = "22"
  HeaderProfiles_Reqd(cPr_Hours(24)) = "23"

  ! ========== SUEWS_WithinGridWaterDist.txt ====
  HeaderWGWaterDist_Reqd(cWG_Code)        = "Code"
  HeaderWGWaterDist_Reqd(cWG_ToPaved)     = "ToPaved"
  HeaderWGWaterDist_Reqd(cWG_ToBldgs)     = "ToBldgs"
  HeaderWGWaterDist_Reqd(cWG_ToEveTr)     = "ToEveTr"
  HeaderWGWaterDist_Reqd(cWG_ToDecTr)     = "ToDecTr"
  HeaderWGWaterDist_Reqd(cWG_ToGrass)     = "ToGrass"
  HeaderWGWaterDist_Reqd(cWG_ToBSoil)     = "ToBSoil"
  HeaderWGWaterDist_Reqd(cWG_ToWater)     = "ToWater"
  HeaderWGWaterDist_Reqd(cWG_ToRunoff)    = "ToRunoff"
  HeaderWGWaterDist_Reqd(cWG_ToSoilStore) = "ToSoilStore"


  ! ========== SUEWS_BiogenCO2.txt ======
  HeaderBiogen_Reqd(cB_Code)            = "Code"
  HeaderBiogen_Reqd(cB_alpha)           = "alpha"
  HeaderBiogen_Reqd(cB_beta)            = "beta"
  HeaderBiogen_Reqd(cB_theta)           = "theta"
  HeaderBiogen_Reqd(cB_alpha_enh)       = "alpha_enh"
  HeaderBiogen_Reqd(cB_beta_enh)        = "beta_enh"
  HeaderBiogen_Reqd(cB_resp_a)          = "resp_a"
  HeaderBiogen_Reqd(cB_resp_b)          = "resp_b"
  HeaderBiogen_Reqd(cB_min_r)           = "min_respi"

  ! =======================================================


  !write(*,*) 'Checking header for ', FileName
  ! Check columns in input files match model code

  IF(FileName == 'SUEWS_NonVeg.txt') THEN
     IF(ANY(HeaderNonVeg_File /= HeaderNonVeg_Reqd)) THEN
        WRITE(*,*) HeaderNonVeg_File == HeaderNonVeg_Reqd
        WRITE(*,*) HeaderNonVeg_File
        WRITE(*,*) HeaderNonVeg_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_NonVeg.txt does not match model code.',notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_Veg.txt') THEN
     IF(ANY(HeaderVeg_File /= HeaderVeg_Reqd)) THEN
        WRITE(*,*) HeaderVeg_File == HeaderVeg_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_Veg.txt does not match model code.',notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_Water.txt') THEN
     IF(ANY(HeaderWater_File /= HeaderWater_Reqd)) THEN
        WRITE(*,*) HeaderWater_File == HeaderWater_Reqd
        WRITE(*,*) HeaderWater_File
        WRITE(*,*) HeaderWater_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_Water.txt does not match model code.',notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_Snow.txt') THEN
     IF(ANY(HeaderSnow_File /= HeaderSnow_Reqd)) THEN
        WRITE(*,*) HeaderSnow_File == HeaderSnow_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_Snow.txt does not match model code.',notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_Soil.txt') THEN
     IF(ANY(HeaderSoil_File /= HeaderSoil_Reqd)) THEN
        WRITE(*,*) HeaderSoil_File == HeaderSoil_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_Soil.txt does not match model code.',notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_Conductance.txt') THEN
     IF(ANY(HeaderCond_File /= HeaderCond_Reqd)) THEN
        WRITE(*,*) HeaderCond_File == HeaderCond_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_Cond.txt does not match model code.',notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_OHMCoefficients.txt') THEN
     IF(ANY(HeaderOHMCoefficients_File /= HeaderOHMCoefficients_Reqd)) THEN
        WRITE(*,*) HeaderOHMCoefficients_File == HeaderOHMCoefficients_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_OHMCoefficients.txt does not match model code.',&
             notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_ESTMCoefficients.txt') THEN
     IF(ANY(HeaderESTMCoefficients_File /= HeaderESTMCoefficients_Reqd)) THEN
        WRITE(*,*) HeaderESTMCoefficients_File == HeaderESTMCoefficients_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_ESTMCoefficients.txt does not match model code.',&
             notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_AnthropogenicHeat.txt') THEN
     IF(ANY(HeaderAnthropogenic_File /= HeaderAnthropogenic_Reqd)) THEN
        WRITE(*,*) HeaderAnthropogenic_File == HeaderAnthropogenic_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_AnthropogenicHeat.txt does not match model code.',&
             notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_Irrigation.txt') THEN
     IF(ANY(HeaderIrrigation_File /= HeaderIrrigation_Reqd)) THEN
        WRITE(*,*) HeaderIrrigation_File == HeaderIrrigation_Reqd
        WRITE(*,*) HeaderIrrigation_File
        WRITE(*,*) HeaderIrrigation_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_Irrigation.txt does not match model code.',&
             notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_Profiles.txt') THEN
     IF(ANY(HeaderProfiles_File /= HeaderProfiles_Reqd)) THEN
        WRITE(*,*) HeaderProfiles_File == HeaderProfiles_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_Profiles.txt does not match model code.',&
             notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_WithinGridWaterDist.txt') THEN
     IF(ANY(HeaderWGWaterDist_File /= HeaderWGWaterDist_Reqd)) THEN
        WRITE(*,*) HeaderWGWaterDist_File == HeaderWGWaterDist_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_WithinGridWaterDist.txt does not match model code.',&
             notUsed,notUsed,notUsedI)
     ENDIF

  ELSEIF(FileName == 'SUEWS_BiogenCO2.txt') THEN
     IF(ANY(HeaderBiogen_File /= HeaderBiogen_Reqd)) THEN
        WRITE(*,*) HeaderBiogen_File == HeaderBiogen_Reqd
        CALL ErrorHint(56,'Names or order of columns in SUEWS_BiogenCO2.txt does not match model code.',&
             notUsed,notUsed,notUsedI)
     ENDIF

  ELSE
     WRITE(*,*) 'Problem in subroutine InputHeaderCheck. File header not specified in model code for ',FileName
     CALL ErrorHint(58,FileName,notUsed,notUsed,notUsedI)

  ENDIF

ENDSUBROUTINE InputHeaderCheck

!-------------------------------------------------------------------------
!
! TS 05 Jul 2018: No longer needed as interpolation is done through specific subroutines at each required instant
!Interpolates hourly profiles provided in SUEWS_Profiles.txt
! to resolution of the model timestep
! HCW 06 Feb 2015
!===================================================================================
! SUBROUTINE SUEWS_InterpHourlyProfiles(Gridiv,TstepP_ID,SurfChar_HrProf)
!
!   USE allocateArray
!   USE ColNamesInputFiles
!   USE sues_data
!
!   IMPLICIT NONE
!
!   INTEGER:: i,j, ii   !Used to count over hours and sub-hourly timesteps
!   INTEGER:: Gridiv, TstepP_ID
!   INTEGER,DIMENSION(24):: SurfChar_HrProf
!   REAL(KIND(1d0)):: deltaProf   !Change in hourly profiles per model timestep
!
!   ! Copy value for first hour
!   TstepProfiles(Gridiv,TstepP_ID,1) = SurfaceChar(Gridiv,SurfChar_HrProf(1))
!   DO i=1,24
!      j = (i+1)
!      IF(i == 24) j = 1   !If last hour of day, loop round to first hour of day for interpolation
!      deltaProf = ((SurfaceChar(Gridiv,SurfChar_HrProf(j)) - SurfaceChar(Gridiv,SurfChar_HrProf(i))))/nsh_real
!      DO ii=1,nsh
!         IF((nsh*(i-1)+ii+1) < (23*nsh+nsh+1))  THEN
!            TstepProfiles(Gridiv,TstepP_ID,(nsh*(i-1)+ii+1)) = SurfaceChar(Gridiv,SurfChar_HrProf(i)) + deltaProf*ii
!         ENDIF
!      ENDDO
!   ENDDO
!
! endsubroutine SUEWS_InterpHourlyProfiles
!===================================================================================

!===================================================================================
! get interpolated profile values at specified time
! NO normalisation performed
FUNCTION get_Prof_SpecTime_inst(Hour, Min, Sec, Prof_24h) RESULT(Prof_CurrTime)

  IMPLICIT NONE

  INTEGER :: i, j   !Used to count over hours and sub-hourly timesteps
  INTEGER,INTENT(IN) :: Hour, Min, Sec
  INTEGER :: total_sec, SecPerHour
  REAL(KIND(1d0)),DIMENSION(0:23),INTENT(IN) :: Prof_24h
  REAL(KIND(1d0)):: deltaProf   !Change in hourly profiles per model timestep
  REAL(KIND(1d0)) :: Prof_CurrTime

  total_sec = Min * 60 + Sec
  SecPerHour = 3600

  i = hour
  j = i + 1
  IF (j == 24) j = 0

  deltaProf = (Prof_24h(j) - Prof_24h(i))/SecPerHour
  Prof_CurrTime = Prof_24h(hour) + deltaProf * total_sec

END FUNCTION get_Prof_SpecTime_inst

!===================================================================================
! get interpolated profile values at specified time
! normalise so the AVERAGE of the multipliers is equal to 1
FUNCTION get_Prof_SpecTime_mean(Hour, Min, Sec, Prof_24h) RESULT(Prof_CurrTime)

  IMPLICIT NONE

  INTEGER :: i, j   !Used to count over hours and sub-hourly timesteps
  INTEGER,INTENT(IN) :: Hour, Min, Sec
  INTEGER :: total_sec, SecPerHour
  REAL(KIND(1d0)),DIMENSION(0:23),INTENT(IN) :: Prof_24h
  REAL(KIND(1d0)),DIMENSION(0:23):: Prof_24h_mean
  REAL(KIND(1d0)):: deltaProf   !Change in hourly profiles per model timestep
  REAL(KIND(1d0)) :: Prof_CurrTime

  total_sec = Min * 60 + Sec
  SecPerHour = 3600

  Prof_24h_mean=MERGE(Prof_24h/(SUM(Prof_24h)), 0.d0, SUM(Prof_24h) /=0) ! prevent zero-division
  ! print*, Prof_24h_mean

  i = hour
  j = i + 1
  IF (j == 24) j = 0

  deltaProf = (Prof_24h_mean(j) - Prof_24h_mean(i))/SecPerHour

  ! print*, deltaProf,total_sec
  Prof_CurrTime = Prof_24h_mean(i) + deltaProf * total_sec

END FUNCTION get_Prof_SpecTime_mean

!===================================================================================
! get interpolated profile values at specified time
! normalise so the SUM of the multipliers is equal to 1
FUNCTION get_Prof_SpecTime_sum(Hour, Min, Sec, Prof_24h, dt) RESULT(Prof_CurrTime)

  IMPLICIT NONE

  INTEGER :: i, j   !Used to count over hours and sub-hourly timesteps
  INTEGER,INTENT(IN) :: Hour, Min, Sec, dt
  INTEGER :: total_sec, SecPerHour
  REAL(KIND(1d0)),DIMENSION(0:23),INTENT(IN) :: Prof_24h
  REAL(KIND(1d0)),DIMENSION(0:23):: Prof_24h_sum
  REAL(KIND(1d0)):: deltaProf   !Change in hourly profiles per model timestep
  REAL(KIND(1d0)) :: Prof_CurrTime

  total_sec = Min * 60 + Sec
  SecPerHour = 3600

  Prof_24h_sum=MERGE(Prof_24h/(SUM(Prof_24h)), 0.d0, SUM(Prof_24h) /=0) ! prevent zero-division

  i = hour
  j = i + 1
  IF (j == 24) j = 0

  deltaProf = (Prof_24h_sum(j) - Prof_24h_sum(i))/SecPerHour
  Prof_CurrTime = Prof_24h_sum(hour) + deltaProf * total_sec
  Prof_CurrTime = Prof_CurrTime * dt/SecPerHour

END FUNCTION get_Prof_SpecTime_sum
!===================================================================================

! Subroutines for matching codes in the input files
!  could re-write as a generic function later...

SUBROUTINE CodeMatchOHM(Gridiv,is,SWWD)
  ! Matches OHM coefficients a1, a2, a3 via OHM codes
  ! for summer/winter wet/dry conditions
  ! HCW 03 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: gridiv
  INTEGER:: is
  CHARACTER(len=4):: SWWD

  iv5=0 ! Reset iv5 to zero

  IF(SWWD == 'SWet') THEN

     DO iv5=1,nlinesOHMCoefficients
        IF (OHMCoefficients_Coeff(iv5,cO_Code)==SurfaceChar(gridiv,c_OHMCode_SWet(is))) THEN
           EXIT
        ELSEIF(iv5 == nlinesOHMCoefficients) THEN
           WRITE(*,*) 'Program stopped! OHM code (summer wet)',SurfaceChar(gridiv,c_OHMCode_SWet(is)),&
                'not found in OHM_Coefficients.txt for surface',is,'.'
           CALL ErrorHint(57,'Cannot find OHM code (summer wet)',SurfaceChar(gridiv,c_OHMCode_SWet(is)),notUsed,notUsedI)
        ENDIF
     ENDDO

  ELSEIF(SWWD == 'SDry') THEN

     DO iv5=1,nlinesOHMCoefficients
        IF (OHMCoefficients_Coeff(iv5,cO_Code)==SurfaceChar(gridiv,c_OHMCode_SDry(is))) THEN
           EXIT
        ELSEIF(iv5 == nlinesOHMCoefficients) THEN
           WRITE(*,*) 'Program stopped! OHM code (summer dry)',SurfaceChar(gridiv,c_OHMCode_SDry(is)),&
                'not found in OHM_Coefficients.txt for surface',is,'.'
           CALL ErrorHint(57,'Cannot find OHM code (summer dry)',SurfaceChar(gridiv,c_OHMCode_SDry(is)),notUsed,notUsedI)
        ENDIF
     ENDDO

  ELSEIF(SWWD == 'WWet') THEN

     DO iv5=1,nlinesOHMCoefficients
        IF (OHMCoefficients_Coeff(iv5,cO_Code)==SurfaceChar(gridiv,c_OHMCode_WWet(is))) THEN
           EXIT
        ELSEIF(iv5 == nlinesOHMCoefficients) THEN
           WRITE(*,*) 'Program stopped! OHM code (winter wet)',SurfaceChar(gridiv,c_OHMCode_WWet(is)),&
                'not found in OHM_Coefficients.txt for surface',is,'.'
           CALL ErrorHint(57,'Cannot find OHM code (winter wet)',SurfaceChar(gridiv,c_OHMCode_WWet(is)),notUsed,notUsedI)
        ENDIF
     ENDDO

  ELSEIF(SWWD == 'WDry') THEN

     DO iv5=1,nlinesOHMCoefficients
        IF (OHMCoefficients_Coeff(iv5,cO_Code)==SurfaceChar(gridiv,c_OHMCode_WDry(is))) THEN
           EXIT
        ELSEIF(iv5 == nlinesOHMCoefficients) THEN
           WRITE(*,*) 'Program stopped! OHM code (winter dry)',SurfaceChar(gridiv,c_OHMCode_WDry(is)),&
                'not found in OHM_Coefficients.txt for surface',is,'.'
           CALL ErrorHint(57,'Cannot find OHM code (winter dry)',SurfaceChar(gridiv,c_OHMCode_WDry(is)),notUsed,notUsedI)
        ENDIF
     ENDDO

  ELSE
     WRITE(*,*) 'Problem with CodeMatchOHM (in SUEWS_CodeMatch.f95). ',SWWD,' not recognised. Needs to be one of: ',&
          'SWet = Summer Wet, SDry = Summer Dry, WWet = WinterWet, WDry = Winter Dry. N.B. Case sensitive. '
     STOP
  ENDIF

  RETURN
ENDSUBROUTINE CodeMatchOHM
! ---------------------------------------------------------

SUBROUTINE CodeMatchESTM(Gridiv,is)
  ! Matches ESTM coefficients via ESTM code
  ! Modified HCW 16 Jun 2016 - for SUEWS surface types
  !                          - removed summer/winter wet/dry option
  ! S.O. 04 Feb 2016
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: gridiv
  INTEGER:: is

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesESTMCoefficients
     IF (ESTMCoefficients_Coeff(iv5,cE_Code)==SurfaceChar(gridiv,c_ESTMCode(is))) THEN
        EXIT
     ELSEIF(iv5 == nlinesESTMCoefficients) THEN
        WRITE(*,*) 'Program stopped! ESTM code',SurfaceChar(gridiv,c_ESTMCode(is)),&
             'not found in ESTM_Coefficients.txt for surface',is,'.'
        CALL ErrorHint(57,'Cannot find ESTM code',SurfaceChar(gridiv,c_ESTMCode(is)),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchESTM
! ---------------------------------------------------------

SUBROUTINE CodeMatchESTM_Class(Gridiv,is,ii)
  ! Matches ESTM coefficients via ESTM codes in SiteSelect for Paved and Bldgs ESTM classes
  ! HCW 16 Jun 2016
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: gridiv
  INTEGER:: is, ii

  iv5=0 ! Reset iv5 to zero

  IF(is == BldgSurf) THEN
     DO iv5=1,nlinesESTMCoefficients
        IF (ESTMCoefficients_Coeff(iv5,cE_Code)==SurfaceChar(gridiv,c_Code_ESTMClass_Bldgs(ii))) THEN
           EXIT
        ELSEIF(iv5 == nlinesESTMCoefficients) THEN
           WRITE(*,*) 'Program stopped! ESTM code',SurfaceChar(gridiv,c_Code_ESTMClass_Bldgs(ii)),&
                'not found in ESTM_Coefficients.txt for surface',is,'.'
           CALL ErrorHint(57,'Cannot find ESTM code',SurfaceChar(gridiv,c_Code_ESTMClass_Bldgs(ii)),notUsed,notUsedI)
        ENDIF
     ENDDO
  ELSEIF(is == PavSurf) THEN
     DO iv5=1,nlinesESTMCoefficients
        IF (ESTMCoefficients_Coeff(iv5,cE_Code)==SurfaceChar(gridiv,c_Code_ESTMClass_Paved(ii))) THEN
           EXIT
        ELSEIF(iv5 == nlinesESTMCoefficients) THEN
           WRITE(*,*) 'Program stopped! ESTM code',SurfaceChar(gridiv,c_Code_ESTMClass_Paved(ii)),&
                'not found in ESTM_Coefficients.txt for surface',is,'.'
           CALL ErrorHint(57,'Cannot find ESTM code',SurfaceChar(gridiv,c_Code_ESTMClass_Paved(ii)),notUsed,notUsedI)
        ENDIF
     ENDDO
  ELSE
     WRITE(*,*) 'Problem with CodeMatchESTM_Class (in SUEWS_CodeMatch.f95). ',is,' not correct. Needs to be either ',&
          '1 = Paved surfaced, 2 = Bldgs surfaces.'
     STOP
  ENDIF
  RETURN
ENDSUBROUTINE CodeMatchESTM_Class
! ---------------------------------------------------------

SUBROUTINE CodeMatchProf(Gridiv,SurfaceCharCodeCol)
  ! Matches Soil characteristics via codes in *SurfaceChar*
  ! for energy use/water use/snow clearing
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: Gridiv
  INTEGER:: SurfaceCharCodeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesProfiles
     IF (Profiles_Coeff(iv5,cPr_Code)==SurfaceChar(Gridiv,SurfaceCharCodeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesProfiles) THEN
        WRITE(*,*) 'Program stopped! Profile code ',SurfaceChar(Gridiv,SurfaceCharCodeCol),'not found in SUEWS_Profiles.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_Profiles.txt',SurfaceChar(Gridiv,SurfaceCharCodeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchProf
! ---------------------------------------------------------

SUBROUTINE CodeMatchDist(rr,CodeCol,codeColSameSurf)
  ! Matches within-grid water distribution via codes
  ! Checks water cannot flow from one surface to the same surface
  ! Checks water distribution fractions sum to 1.
  ! HCW 10 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol, codeColSameSurf

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesWGWaterDist
     IF (WGWaterDist_Coeff(iv5,cWG_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesWGWaterDist) THEN
        WRITE(*,*) 'Program stopped! Within-grid water distribution code ',SiteSelect(rr,codeCol),&
             'not found in SUEWS_WaterDistWithinGrid.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_WaterDistWithinGrid.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  ! Check water flow to same surface is zero (previously in RunControlByGridByYear in SUEWS_Initial.f95)
  IF(WGWaterDist_Coeff(iv5,codeColSameSurf) /= 0) THEN
     CALL ErrorHint(8,'Diagonal elements should be zero as water cannot move from one surface to the same surface.', &
          WGWaterDist_Coeff(iv5,codeColSameSurf),notUsed,notUsedI)
  ENDIF

  !! QUESTION: MODIFY THIS?
  ! Check water either moves to runoff or soilstore, but not to both
  ! Model returns an error if both ToRunoff and ToSoilStore are non-zero.
  !! - Probably should remove this...
  !! - Also look at SUEWS_translate, as the non-zero value goes into WaterDist
  IF(WGWaterDist_Coeff(iv5,cWG_ToRunoff)/=0.AND.WGWaterDist_Coeff(iv5,cWG_ToSoilStore)/=0) THEN
     CALL ErrorHint(9,'One of these (ToRunoff,ToSoilStore) should be zero.', &
          WGWaterDist_Coeff(iv5,cWG_ToRunoff),WGWaterDist_Coeff(iv5,cWG_ToSoilStore),notUsedI)
  ENDIF

  !! Also do for water surface once implemented
  IF(codeCol /= c_WGWaterCode) THEN   ! Except for Water surface
     ! Check total water distribution from each surface adds up to 1
     IF(SUM(WGWaterDist_Coeff(iv5,cWG_ToPaved:cWG_ToSoilStore)) > 1.0000001.OR.SUM(WGWaterDist_Coeff(iv5,&
          cWG_ToPaved:cWG_ToSoilStore)) < 0.9999999 ) THEN
        CALL ErrorHint(8,'Total water distribution from each surface should add up to 1.',&
             SUM(WGWaterDist_Coeff(iv5,cWG_ToPaved:cWG_ToSoilStore)),notUsed,notUsedI)
     ENDIF
  ENDIF

  RETURN
ENDSUBROUTINE CodeMatchDist
! ---------------------------------------------------------


SUBROUTINE CodeMatchNonVeg(rr,CodeCol)
  ! Matches Impervious characteristics via codes in SiteSelect
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesNonVeg
     IF (NonVeg_Coeff(iv5,ci_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesNonVeg) THEN
        WRITE(*,*) 'Program stopped! NonVeg code ',SiteSelect(rr,codeCol),'not found in SUEWS_NonVeg.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_NonVeg.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchNonVeg
! ---------------------------------------------------------


SUBROUTINE CodeMatchVeg(rr,CodeCol)
  ! Matches Pervious characteristics via codes in SiteSelect
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesVeg
     IF (Veg_Coeff(iv5,cp_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesVeg) THEN
        WRITE(*,*) 'Program stopped! Veg code ',SiteSelect(rr,codeCol),'not found in SUEWS_Vegs.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_Veg.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchVeg
! ---------------------------------------------------------


SUBROUTINE CodeMatchWater(rr,CodeCol)
  ! Matches Water characteristics via codes in SiteSelect
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesWater
     IF (Water_Coeff(iv5,cw_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesWater) THEN
        WRITE(*,*) 'Program stopped! Water code ',SiteSelect(rr,codeCol),'not found in SUEWS_Water.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_Water.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchWater
! ---------------------------------------------------------


SUBROUTINE CodeMatchSnow(rr,CodeCol)
  ! Matches Snow characteristics via codes in SiteSelect
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesSnow
     IF (Snow_Coeff(iv5,cs_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesSnow) THEN
        WRITE(*,*) 'Program stopped! Snow code ',SiteSelect(rr,codeCol),'not found in SUEWS_Snow.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_Snow.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchSnow
! ---------------------------------------------------------

SUBROUTINE CodeMatchConductance(rr,CodeCol)
  ! Matches Conductance characteristics via codes in SiteSelect
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesConductance
     IF (Conductance_Coeff(iv5,cc_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesConductance) THEN
        WRITE(*,*) 'Program stopped! Conductance code ',SiteSelect(rr,codeCol),'not found in SUEWS_Conductance.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_Conductance.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchConductance
! ---------------------------------------------------------


SUBROUTINE CodeMatchAnthropogenic(rr,CodeCol)
  ! Matches AnthropogenicHeat characteristics via codes in SiteSelect
  ! HCW 20 Nov 2014
  ! MH 21 Jun 2017
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesAnthropogenic
     IF (Anthropogenic_Coeff(iv5,cA_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesAnthropogenic) THEN
        WRITE(*,*) 'Program stopped! Anthropogenic code ',SiteSelect(rr,codeCol),'not found in SUEWS_AnthropogenicHeat.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_AnthropogenicHeat.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchAnthropogenic
! ---------------------------------------------------------


SUBROUTINE CodeMatchIrrigation(rr,CodeCol)
  ! Matches Irrigation characteristics via codes in SiteSelect
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: rr
  INTEGER:: codeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesIrrigation
     IF (Irrigation_Coeff(iv5,cIr_Code)==SiteSelect(rr,codeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesIrrigation) THEN
        WRITE(*,*) 'Program stopped! Irrigation code ',SiteSelect(rr,codeCol),'not found in SUEWS_Irrigation.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_Irrigation.txt',SiteSelect(rr,codeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchIrrigation
! ---------------------------------------------------------

SUBROUTINE CodeMatchSoil(Gridiv,SurfaceCharCodeCol)
  ! Matches Soil characteristics via codes in *SurfaceChar*
  ! HCW 20 Nov 2014
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: Gridiv
  INTEGER:: SurfaceCharCodeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesSoil
     IF (Soil_Coeff(iv5,cSo_Code)==SurfaceChar(Gridiv,SurfaceCharCodeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesSoil) THEN
        WRITE(*,*) 'Program stopped! Soil code ',SurfaceChar(Gridiv,SurfaceCharCodeCol),'not found in SUEWS_Soil.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_Soil.txt',SurfaceChar(Gridiv,SurfaceCharCodeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchSoil
! ---------------------------------------------------------

SUBROUTINE CodeMatchBiogen(Gridiv,SurfaceCharCodeCol)
  ! Matches Biogen characteristics via codes in *SuraceChar*
  ! MH 16 Jun 2017
  ! ---------------------------------------------------------

  USE allocateArray
  USE Initial
  USE ColNamesInputFiles
  USE defaultNotUsed

  IMPLICIT NONE

  INTEGER:: Gridiv
  INTEGER:: SurfaceCharCodeCol

  iv5=0 ! Reset iv5 to zero

  DO iv5=1,nlinesBiogen
     IF (Biogen_Coeff(iv5,cB_Code)==SurfaceChar(Gridiv,SurfaceCharCodeCol)) THEN
        EXIT
     ELSEIF(iv5 == nlinesBiogen) THEN
        WRITE(*,*) 'Program stopped! Biogen code ',SurfaceChar(Gridiv,SurfaceCharCodeCol),'not found in SUEWS_BiogenCO2.txt.'
        CALL ErrorHint(57,'Cannot find code in SUEWS_BiogenCO2.txt',SurfaceChar(Gridiv,SurfaceCharCodeCol),notUsed,notUsedI)
     ENDIF
  ENDDO

  RETURN
ENDSUBROUTINE CodeMatchBiogen
! ---------------------------------------------------------

MODULE MetDisagg
  !========================================================================================
  ! Disaggregation of meteorological forcing data
  !  Code to disaggregate met forcing data from resolution provided to the model time-step
  ! Created: HCW 10 Feb 2017
  !
  ! ---- Key for MetDisaggMethod settings ----
  !10  ->  linear disaggregation for timestamps representing the end of the averaging period
  !20  ->  linear disaggregation for instantaneous variables (e.g. air temperature, humidity, pressure, wind speed in WFDEI dataset)
  !100 -> evenly distribute rainfall among all subintervals in a rainy interval
  !101 -> evenly distribute rainfall among RainAmongN subintervals in a rainy interval
  !        - requires RainAmongN to be set in RunControl.nml
  ! If KdownZen = 1 -> include additional zenith check in kdown disaggregation
  !
  ! N.B. wdir downscaling is currently not implemented
  !
  !========================================================================================

  USE AllocateArray
  USE ColNamesInputFiles
  USE Data_In
  USE Initial
  USE NARP_MODULE,ONLY:NARP_cal_SunPosition

  IMPLICIT NONE

CONTAINS

  !======================================================================================
  SUBROUTINE DisaggregateMet(iBlock, igrid)
    ! Subroutine to disaggregate met forcing data to model time-step
    ! HCW 10 Feb 2017
    !======================================================================================

    USE Sues_Data
    USE DefaultNotUsed

    IMPLICIT NONE

    INTEGER:: lunit = 100
    INTEGER:: tdiff   !Time difference (in minutes) between first and second rows of original met forcing file
    INTEGER:: i,ii  !counter
    INTEGER:: iBlock, igrid
    INTEGER,DIMENSION(Nper):: seq1Nper
    INTEGER,DIMENSION(nsd):: seq1nsd
    INTEGER,DIMENSION(nColumnsMetForcingData):: MetDisaggMethod   ! Stores method to use for disaggregating met data
    REAL(KIND(1d0)),DIMENSION(nColumnsMetForcingData):: MetArrayOrig
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData*Nper,ncolumnsMetForcingData):: Met_tt
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData*Nper):: Met_tt_kdownAdj
    CHARACTER(LEN=9),DIMENSION(ncolumnsMetForcingData):: HeaderMet
    CHARACTER(LEN=10*ncolumnsMetForcingData):: HeaderMetOut
    ! REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData):: dectimeOrig
    ! REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData*Nper):: dectimeDscd, dectimeFast
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData*Nper):: dectimeFast
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData*Nper):: idectime ! sun position at middle of time-step before

    ! INTEGER, DIMENSION(Nper):: temp_iy, temp_id, temp_ih, temp_im, temp_ihm ! temorary varaibles for disaggragation
    ! REAL(KIND(1d0)), DIMENSION(Nper):: temp_dectime ! temorary varaibles for disaggragation
    ! INTEGER :: Days_of_Year
    ! INTEGER, DIMENSION(Nper)::ndays_iy ! number of days in iy

    ! Allocate and initialise arrays to receive original forcing data --------------------
    ALLOCATE(MetForDisagg(ReadLinesOrigMetData,nColumnsMetForcingData))
    ALLOCATE(MetForDisaggPrev(nColumnsMetForcingData))
    ALLOCATE(MetForDisaggNext(nColumnsMetForcingData))
    MetForDisagg(:,:) = -999
    MetForDisaggPrev(:) = -999
    MetForDisaggNext(:) = -999
    ! Initialise array to receive disaggregated data
    Met_tt = -999
    ! Intialise disaggregation method
    MetDisaggMethod = -999

    ! Generate useful sequences
    seq1Nper = (/(i, i=1,Nper, 1)/)
    seq1nsd = (/(i, i=1,nsd, 1)/)

    ! Get methods to use for disaggregation from RunControl
    IF(DiagnoseDisagg==1) WRITE(*,*) 'DisaggMethod: ',DisaggMethod, 'RainDisaggMethod:',RainDisaggMethod
    IF(DisaggMethod == 1) THEN
       MetDisaggMethod(:) = 10   !linear disaggregation of averages
    ELSEIF(DisaggMethod == 2) THEN
       MetDisaggMethod(:) = 20   !linear disaggregation of instantaneous values
    ELSEIF(DisaggMethod == 3) THEN   !WFDEI set up, where T, Q, pres, U are instantaneous
       MetDisaggMethod(:) = 10   !linear disaggregation of averages
       MetDisaggMethod(10:13) = 20   !linear disagg instantaneous values for U, RH, Tair, pres
    ELSE
       CALL errorHint(2,'Problem in SUEWS_MetDisagg: DisaggMethod value should be 1, 2, or 3', &
            NotUsed,NotUsed,DisaggMethod)
    ENDIF
    ! Set rainfall
    MetDisaggMethod(14) = RainDisaggMethod


    ! Read data ---------------------------------------------------------------------
    IF(DiagnoseDisagg==1) WRITE(*,*) 'Reading file: ', TRIM(FileOrigMet)
    OPEN(lunit,file=TRIM(FileOrigMet),status='old')
    ! CALL skipHeader(lunit,SkipHeaderMet)  !Skip header -> read header instead
    READ(lunit,*) HeaderMet
    !write(*,*) HeaderMet
    ! Skip over lines that have already been read and downscaled
    IF (SkippedLinesOrig>0) THEN
       DO i=1,skippedLinesOrig-1   ! minus 1 here because last line of last block needs to be read again
          READ(lunit,*)
       ENDDO
       ! Read in last line of previous block
       CALL MetRead(lunit,MetArrayOrig,InputmetFormat,ldown_option,NetRadiationMethod,&
            snowUse,SMDMethod,SoilDepthMeas,SoilRocks,SoilDensity,SmCap)
       MetForDisaggPrev(1:ncolumnsMetForcingData) = MetArrayOrig
    ENDIF
    ! print*, 'MetForDisagg',MetForDisagg(1:3,1:4)
    ! print*, 'ReadLinesOrigMetDataMax',ReadLinesOrigMetDataMax
    ! Read in current block
    DO i=1, ReadLinesOrigMetDataMax
       CALL MetRead(lunit,MetArrayOrig,InputmetFormat,ldown_option,NetRadiationMethod,&
            snowUse,SMDMethod,SoilDepthMeas,SoilRocks,SoilDensity,SmCap)
       MetForDisagg(i,1:ncolumnsMetForcingData) = MetArrayOrig
    ENDDO
    ! print*, 'MetForDisagg',MetForDisagg(1:3,1:4)
    ! Read in first line of next block (except for last block)
    IF(iBlock/=ReadBlocksOrigMetData) THEN
       CALL MetRead(lunit,MetArrayOrig,InputmetFormat,ldown_option,NetRadiationMethod,&
            snowUse,SMDMethod,SoilDepthMeas,SoilRocks,SoilDensity,SmCap)
       MetForDisaggNext(1:ncolumnsMetForcingData) = MetArrayOrig
    ENDIF
    CLOSE(lunit)

    ! Check resolution of original met forcing data -------------------------------------
    ! Find time difference (in minutes) between first and second row
    tdiff = INT(MetForDisagg(2,4)-MetForDisagg(1,4))   !Try using minutes
    IF(tdiff == 0) tdiff = INT(MetForDisagg(2,3)-MetForDisagg(1,3))*60   !If no difference in minutes, try using hours
    IF(tdiff < 0) THEN   !If time difference is negative (e.g. change of day), instead use second and third row
       tdiff = INT(MetForDisagg(3,4)-MetForDisagg(2,4))
       IF(tdiff == 0) tdiff = INT(MetForDisagg(3,3)-MetForDisagg(2,3))*60   !If no difference in minutes, try using hours
    ENDIF
    ! Check actual resolution matches specified input resolution
    IF(tdiff /= ResolutionFilesIn/60) THEN
       CALL errorHint(2,'Problem in SUEWS_MetDisagg: timestamps in met forcing file inconsistent with ResolutionFilesIn', &
            REAL(ResolutionFilesIn,KIND(1d0)),NotUsed,tdiff*60)
    ENDIF

    ! Check file only contains a single year --------------------------------------------
    ! Very last data point is allowed to be (should be) timestamped with following year
    IF(ANY(MetForDisagg(1:(ReadLinesOrigMetDataMax-1),1) /= MetForDisagg(1,1))) THEN
       CALL errorHint(3,'Problem in SUEWS_MetDisagg: multiple years found in original met forcing file.', &
            MetForDisagg(1,1),NotUsed,NotUsedI)
    ENDIF

    ! Disaggregate time columns ---------------------------------------------------------
    IF (Diagnose==1) WRITE(*,*) 'Disaggregating met forcing data (',TRIM(FileOrigMet),') to model time-step...'

    CALL DisaggregateDateTime(MetForDisagg(:,1:4),tstep,Nper,ReadLinesOrigMetDataMax,Met_tt(:,1:4))

    ! Disaggregate other columns --------------------------------------------------------
    DO ii=5,ncolumnsMetForcingData
       IF(ii == 14) THEN  !Do something different for rainfall and snowfall (if present)
          IF(MetDisaggMethod(14) == 100) THEN
             Met_tt(:,14) = DisaggP_amongN(MetForDisagg(:,14),Nper,Nper,ReadLinesOrigMetData,ReadLinesOrigMetDataMax)
             IF(ALL(MetForDisagg(:,16)==-999)) THEN
                Met_tt(:,16) = -999
             ELSE
                Met_tt(:,16) = DisaggP_amongN(MetForDisagg(:,16),Nper,Nper,ReadLinesOrigMetData,ReadLinesOrigMetDataMax)
             ENDIF
          ELSEIF(MetDisaggMethod(14) == 101) THEN
             IF(RainAmongN == -999) THEN
                CALL ErrorHint(2,'Problem in SUEWS_MetDisagg: RainDisaggMethod requires RainAmongN', &
                     REAL(RainAmongN,KIND(1d0)),NotUsed,RainDisaggMethod)
             ELSEIF(RainAmongN > Nper) THEN
                CALL ErrorHint(2,'Problem in SUEWS_MetDisagg: RainAmongN > Nper',REAL(Nper,KIND(1d0)),NotUsed,RainAmongN)
             ELSE
                Met_tt(:,14) = DisaggP_amongN(MetForDisagg(:,14),RainAmongN, Nper,ReadLinesOrigMetData,ReadLinesOrigMetDataMax)
                IF(ALL(MetForDisagg(:,16)==-999)) THEN
                   Met_tt(:,16) = -999
                ELSE
                   Met_tt(:,16) = DisaggP_amongN(MetForDisagg(:,16),RainAmongN,Nper,ReadLinesOrigMetData,ReadLinesOrigMetDataMax)
                ENDIF
             ENDIF
          ELSEIF(MetDisaggMethod(14) == 102) THEN
             IF(ALL(MultRainAmongN == -999)) THEN
                CALL ErrorHint(2,'Problem in SUEWS_MetDisagg: RainDisaggMethod requires MultRainAmongN', &
                     REAL(MultRainAmongN(1),KIND(1d0)),NotUsed,RainDisaggMethod)
             ELSEIF(ALL(MultRainAmongNUpperI == -999)) THEN
                CALL ErrorHint(2,'Problem in SUEWS_MetDisagg: RainDisaggMethod requires MultRainAmongNUpperI', &
                     MultRainAmongNUpperI(1),NotUsed,RainDisaggMethod)
             ELSEIF(ANY(MultRainAmongN > Nper)) THEN
                CALL ErrorHint(2,'Problem in SUEWS_MetDisagg: MultRainAmongN > Nper',REAL(Nper,KIND(1d0)),NotUsed, &
                     MAXVAL(MultRainAmongN))
             ELSE
                Met_tt(:,14) = DisaggP_amongNMult(MetForDisagg(:,14),MultRainAmongNUpperI,MultRainAmongN, Nper,&
                     ReadLinesOrigMetData,ReadLinesOrigMetDataMax)
                IF(ALL(MetForDisagg(:,16)==-999)) THEN
                   Met_tt(:,16) = -999
                ELSE
                   Met_tt(:,16) = DisaggP_amongNMult(MetForDisagg(:,16),MultRainAmongNUpperI,MultRainAmongN,Nper, &
                        ReadLinesOrigMetData,ReadLinesOrigMetDataMax)
                ENDIF
             ENDIF
          ELSE
             WRITE(*,*) 'Disaggregation code for rain not recognised'
          ENDIF
       ELSEIF(ii == 24) THEN  !wind direction disaggregation not coded yet...
          IF(ANY(MetForDisagg(:,ii)/=-999)) THEN
             WRITE(*,*) 'Disaggregation of wind direction not currently implemented!'
          ENDIF
       ELSE
          IF(ALL(MetForDisagg(:,ii)==-999)) THEN
             !IF(DiagnoseDisagg==1) write(*,*) 'No data for col.', ii
             Met_tt(:,ii) = -999
          ELSE
             Met_tt(:,ii) = Disagg_Lin(MetForDisagg(:,ii),MetForDisaggPrev(ii),MetForDisaggNext(ii),MetDisaggMethod(ii), &
                  Nper,ReadLinesOrigMetData,ReadLinesOrigMetDataMax,iBlock)
          ENDIF
       ENDIF
    ENDDO

    ! Adjust kdown disaggregation using zenith angle
    IF(KdownZen == 1) THEN
       IF(DiagnoseDisagg==1) WRITE(*,*) 'Adjusting disaggregated kdown using zenith angle'
       Met_tt_kdownAdj(:) = Met_tt(:,15)
       ! Translate location data from SurfaceChar to find solar angles
       lat = SurfaceChar(igrid,c_lat)
       lng = SurfaceChar(igrid,c_lng)
       timezone = SurfaceChar(igrid,c_tz)
       alt = SurfaceChar(igrid,c_Alt)
       ! Calculate dectime at downscaled time-step
       dectimeFast(:) = Met_tt(:,2) + Met_tt(:,3)/24.0 + Met_tt(:,4)/(60.0*24.0)
       idectime=dectimeFast-halftimestep! sun position at middle of timestep before
       DO i=1,(ReadLinesOrigMetDataMax*Nper)
          CALL NARP_cal_SunPosition(Met_tt(i,2),idectime(i),timezone,lat,lng,alt,azimuth,zenith_deg)
          ! If sun below horizon, set disaggregated kdown to zero
          IF(zenith_deg > 90) THEN
             !write(*,*) Met_tt(i,1:4)
             Met_tt_kdownAdj(i) = 0.0
          ENDIF
       ENDDO
       ! Redistribute kdown over each day
       DO i=1,(ReadLinesOrigMetDataMax*Nper/nsd) ! Loop over each day
          Met_tt_kdownAdj((i-1)*nsd+seq1nsd) = Met_tt_kdownAdj( (i-1)*nsd+seq1nsd) * &
               SUM(Met_tt((i-1)*nsd+seq1nsd,15 ))/SUM(Met_tt_kdownAdj((i-1)*nsd+seq1nsd))
       ENDDO
       ! Copy adjusted kdown back to Met_tt array
       Met_tt(:,15) = Met_tt_kdownAdj(:)
    ENDIF

    ! Copy disaggregated data to MetForcingDataArray
    MetForcingData(:,1:24,GridCounter) = Met_tt(:,1:24)

    ! If snow is -999, set to zero (also in LUMPS_metRead.f95)
    IF(ALL(MetForcingData(:,16,GridCounter) == -999)) MetForcingData(:,16,GridCounter)=0

    ! Undo pressure conversion again for writing out
    Met_tt(:,13) = Met_tt(:,13)/10.0

    ! Write out disaggregated file ------------------------------------------------------
    IF(KeepTstepFilesIn == 1) THEN
       IF (iBlock==1) THEN
          ! Prepare header
          DO i=1,ncolumnsMetForcingData
             IF(i==1) THEN
                HeaderMetOut=ADJUSTL(HeaderMet(i))
             ELSE
                HeaderMetOut=TRIM(HeaderMetOut)//' '//ADJUSTL(HeaderMet(i))
             ENDIF
          ENDDO
          ! Write out header
          OPEN(78,file=TRIM(FileDscdMet),err=112)
          WRITE(78,'(a)') HeaderMetOut
       ELSE
          OPEN(78,file=TRIM(FileDscdMet),position='append')!,err=112)
       ENDIF
       ! Write out data
       DO i=1,(ReadLinesOrigMetDataMax*Nper)
          WRITE(78,303) (INT(Met_tt(i,ii)), ii=1,4), Met_tt(i,5:ncolumnsMetForcingData)
       ENDDO
       !IF(iBlock == ReadBlocksOrigMetData) THEN
       !   WRITE(78,'(i2)') -9
       !   WRITE(78,'(i2)') -9
       !ENDIF
       CLOSE (78)   !Close output file
    ENDIF


303 FORMAT((i4,1X), 3(i3,1X), 9(f12.6,1X), (f9.4,1X), 10(f9.4,1X))  !Allows 4 dp for rainfall

    ! Deallocate arrays -----------------------------------------------------------------
    DEALLOCATE(MetForDisagg)
    DEALLOCATE(MetForDisaggPrev)
    DEALLOCATE(MetForDisaggNext)

    RETURN

112 CALL ErrorHint(52,TRIM(FileDscdMet),notUsed,notUsed,notUsedI)

  ENDSUBROUTINE DisaggregateMet
  !======================================================================================


  !======================================================================================
  SUBROUTINE DisaggregateESTM(iBlock)
    ! Subroutine to disaggregate met forcing data to model time-step
    ! HCW 10 Feb 2017
    !======================================================================================

    USE Sues_Data
    USE DefaultNotUsed

    IMPLICIT NONE

    INTEGER:: lunit = 101
    INTEGER:: tdiff   !Time difference (in minutes) between first and second rows of original met forcing file
    INTEGER:: i,ii  !counter
    INTEGER:: iBlock
    INTEGER,DIMENSION(NperESTM):: seq1NperESTM
    INTEGER,DIMENSION(nsd):: seq1nsd
    INTEGER,DIMENSION(ncolsESTMdata):: ESTMDisaggMethod   ! Stores method to use for disaggregating met data
    REAL(KIND(1d0)),DIMENSION(ncolsESTMdata):: ESTMArrayOrig
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigESTMData*NperESTM,ncolsESTMdata):: ESTM_tt
    CHARACTER(LEN=9),DIMENSION(ncolsESTMdata):: HeaderESTM
    CHARACTER(LEN=10*ncolsESTMdata):: HeaderESTMOut
    ! REAL(KIND(1d0)),DIMENSION(ReadLinesOrigESTMData):: dectimeOrig
    ! REAL(KIND(1d0)),DIMENSION(ReadLinesOrigESTMData*NperESTM):: dectimeDscd
    INTEGER::iostat_var

    ! INTEGER, DIMENSION(NperESTM):: temp_iy, temp_id, temp_ih, temp_im, temp_ihm

    ! Allocate and initialise arrays to receive original forcing data --------------------
    ALLOCATE(ESTMForDisagg(ReadLinesOrigESTMData,ncolsESTMdata))
    ALLOCATE(ESTMForDisaggPrev(ncolsESTMdata))
    ALLOCATE(ESTMForDisaggNext(ncolsESTMdata))
    ESTMForDisagg(:,:) = -999
    ESTMForDisaggPrev(:) = -999
    ESTMForDisaggNext(:) = -999
    ! Initialise array to receive disaggregated data
    ESTM_tt = -999
    ! Intialise disaggregation method
    ESTMDisaggMethod = -999

    ! Generate useful sequences
    seq1NperESTM = (/(i, i=1,NperESTM, 1)/)
    seq1nsd = (/(i, i=1,nsd, 1)/)

    ! Get methods to use for disaggregation from RunControl
    ! (N.B.DisaggMethodESTM is set as 1 or 2 in RunControl; ESTMDisaggMethod is array of ncolsESTMdata used here)
    IF(DisaggMethodESTM == 1) THEN
       ESTMDisaggMethod(:) = 10   !linear disaggregation of averages
    ELSEIF(DisaggMethodESTM == 2) THEN
       ESTMDisaggMethod(:) = 20   !linear disaggregation of instantaneous values
    ELSE
       CALL errorHint(2,'Problem in SUEWS_ESTMDisagg: DisaggMethodESTM value should be 1 or 2', &
            NotUsed,NotUsed,DisaggMethodESTM)
    ENDIF

    ! Read data ---------------------------------------------------------------------
    IF(DiagnoseDisaggESTM==1) WRITE(*,*) 'Reading file: ', TRIM(FileOrigESTM)
    OPEN(lunit,file=TRIM(FileOrigESTM),status='old')
    ! CALL skipHeader(lunit,SkipHeaderMet)  !Skip header -> read header instead
    READ(lunit,*) HeaderESTM
    !write(*,*) HeaderMet
    ! Skip over lines that have already been read and downscaled
    IF (SkippedLinesOrigESTM>0) THEN
       DO i=1,skippedLinesOrigESTM-1   ! minus 1 here because last line of last block needs to be read again
          READ(lunit,*)
       ENDDO
       ! Read in last line of previous block
       READ(lunit,*,iostat=iostat_var) ESTMArrayOrig
       ESTMForDisaggPrev(1:ncolsESTMdata) = ESTMArrayOrig
    ENDIF
    ! Read in current block
    DO i=1, ReadLinesOrigESTMDataMax
       READ(lunit,*,iostat=iostat_var) ESTMArrayOrig
       ESTMForDisagg(i,1:ncolsESTMdata) = ESTMArrayOrig
    ENDDO
    ! Read in first line of next block (except for last block)
    IF(iBlock/=ReadBlocksOrigMetData) THEN
       READ(lunit,*,iostat=iostat_var) ESTMArrayOrig
       ESTMForDisaggNext(1:ncolsESTMdata) = ESTMArrayOrig
    ENDIF
    CLOSE(lunit)

    ! Check resolution of original met forcing data -------------------------------------
    ! Find time difference (in minutes) between first and second row
    tdiff = INT(ESTMForDisagg(2,4)-ESTMForDisagg(1,4))   !Try using minutes
    IF(tdiff == 0) tdiff = INT(ESTMForDisagg(2,3)-ESTMForDisagg(1,3))*60   !If no difference in minutes, try using hours
    IF(tdiff < 0) THEN   !If time difference is negative (e.g. change of day), instead use second and third row
       tdiff = INT(ESTMForDisagg(3,4)-ESTMForDisagg(2,4))
       IF(tdiff == 0) tdiff = INT(ESTMForDisagg(3,3)-ESTMForDisagg(2,3))*60   !If no difference in minutes, try using hours
    ENDIF
    ! Check actual resolution matches specified input resolution
    IF(tdiff /= ResolutionFilesInESTM/60) THEN
       CALL errorHint(2,'Problem in SUEWS_ESTMDisagg: timestamps in ESTM forcing file inconsistent with ResolutionFilesInESTM', &
            REAL(ResolutionFilesInESTM,KIND(1d0)),NotUsed,tdiff*60)
    ENDIF

    ! Disaggregate time columns ---------------------------------------------------------
    IF ( Diagnose==1 ) THEN
       WRITE(*,*) 'Disaggregating ESTM forcing data (',TRIM(FileOrigESTM),') to model time-step...'
    END IF
    CALL DisaggregateDateTime(ESTMForDisagg(:,1:4),tstep,NperESTM,ReadLinesOrigMetDataMax,ESTM_tt(:,1:4))
    ! ! Convert to dectime
    ! dectimeOrig = ESTMForDisagg(:,2) + ESTMForDisagg(:,3)/24.0 + ESTMForDisagg(:,4)/(60.0*24.0)
    !
    ! DO i=1,ReadLinesOrigESTMDataMax
    !    ! Downscale dectime using dectimeOrig(i) [becomes timestamp of last subinterval]
    !    dectimeDscd(NperESTM*(i-1)+Seq1NperESTM) = dectimeOrig(i) - (tstep/60.0)/(60.0*24.0)*(/(ii, ii=(NperESTM-1),0, -1)/)
    !    ! Convert to required formats
    !    temp_iy   = INT(ESTMForDisagg(i,1))   !Copy year
    !    temp_id   = FLOOR(dectimeDscd(NperESTM*(i-1)+Seq1NperESTM))   !DOY
    !    ! To avoid precision errors, round here
    !    !  - this should not be a problem as a difference of 1 = 1 min, so a difference of 0.001 << 1 min
    !    temp_ihm  = NINT(((dectimeDscd(NperESTM*(i-1)+Seq1NperESTM) - temp_id/1.0)*60.0*24.0)*1000.0)/1000   !Minutes of the day (1440 max)
    !    temp_ih = (temp_ihm-MOD(temp_ihm,60))/60   !Hours
    !    temp_im = MOD(temp_ihm,60)   !Minutes
    !
    !    IF(dectimeOrig(i) == 1.0000 .AND. i > 1) THEN   !If year changes and it is not the beginning of the dataset
    !       WRITE(*,*) 'Year change encountered: ', dectimeOrig(i), dectimeOrig(i-1)
    !       ! Re-downscale dectime using dectimeOrig(i-1)
    !       dectimeDscd(NperESTM*(i-1)+Seq1NperESTM) = dectimeOrig(i-1) + (tstep/60.0)/(60.0*24.0)*Seq1NperESTM
    !       ! Convert to required formats
    !       temp_iy   = INT(ESTMForDisagg(i,1))   !Copy year
    !       temp_id   = FLOOR(dectimeDscd(NperESTM*(i-1)+Seq1NperESTM))   !DOY
    !       temp_ihm  = NINT(((dectimeDscd(NperESTM*(i-1)+Seq1NperESTM) - temp_id/1.0)*60.0*24.0)*1000.0)/1000   !Mins of the day (1440 max)
    !       temp_ih = (temp_ihm-MOD(temp_ihm,60))/60   !Hours
    !       temp_im = MOD(temp_ihm,60)   !Minutes
    !       ! Adjust year and DOY to account for year change
    !       temp_iy(1:(NperESTM-1)) = temp_iy(1:(NperESTM-1)) - 1  !Subtract 1 from year for all except final timestamp
    !       temp_id(NperESTM) = 1  !Set day for final timestamp to 1
    !    ENDIF
    !
    !    !IF(i==1 .or. i== ReadlinesOrigESTMDataMax) THEN
    !    !   write(*,*) temp_iy
    !    !   write(*,*) temp_id
    !    !   !write(*,*) temp_ihm
    !    !   write(*,*) temp_ih
    !    !   write(*,*) temp_im
    !    !ENDIF
    !
    !    ! Copy to ESTM_tt array
    !    ESTM_tt(NperESTM*(i-1)+Seq1NperESTM,1) = temp_iy
    !    ESTM_tt(NperESTM*(i-1)+Seq1NperESTM,2) = temp_id
    !    ESTM_tt(NperESTM*(i-1)+Seq1NperESTM,3) = temp_ih
    !    ESTM_tt(NperESTM*(i-1)+Seq1NperESTM,4) = temp_im
    !
    ! ENDDO


    ! Disaggregate other columns --------------------------------------------------------
    ! All other columns are temperatures
    DO ii=5,ncolsESTMdata
       IF(ALL(ESTMForDisagg(:,ii)==-999)) THEN
          !IF(DiagnoseDisaggESTM==1) write(*,*) 'No data for col.', ii
          ESTM_tt(:,ii) = -999
       ELSE
          ESTM_tt(:,ii) = Disagg_Lin(ESTMForDisagg(:,ii),ESTMForDisaggPrev(ii),ESTMForDisaggNext(ii),ESTMDisaggMethod(ii), &
               NperESTM,ReadLinesOrigESTMData,ReadLinesOrigESTMDataMax,iBlock)
       ENDIF
    ENDDO

    ! Copy disaggregated data to MetForcingDataArray
    ESTMForcingData(:,1:ncolsESTMdata,GridCounter) = ESTM_tt(:,1:ncolsESTMdata)

    ! Write out disaggregated file ------------------------------------------------------
    IF(KeepTstepFilesIn == 1) THEN
       IF (iBlock==1) THEN
          ! Prepare header
          DO i=1,ncolsESTMdata
             IF(i==1) THEN
                HeaderESTMOut=ADJUSTL(HeaderESTM(i))
             ELSE
                HeaderESTMOut=TRIM(HeaderESTMOut)//' '//ADJUSTL(HeaderESTM(i))
             ENDIF
          ENDDO
          ! Write out header
          OPEN(78,file=TRIM(FileDscdESTM),err=113)
          WRITE(78,'(a)') HeaderESTMOut
       ELSE
          OPEN(78,file=TRIM(FileDscdESTM),position='append')!,err=113)
       ENDIF
       ! Write out data
       DO i=1,(ReadLinesOrigESTMDataMax*NperESTM)
          WRITE(78,304) (INT(ESTM_tt(i,ii)), ii=1,4), ESTM_tt(i,5:ncolsESTMdata)
       ENDDO
       !IF(iBlock == ReadBlocksOrigMetData) THEN
       !   WRITE(78,'(i2)') -9
       !   WRITE(78,'(i2)') -9
       !ENDIF
       CLOSE (78)   !Close output file
    ENDIF


304 FORMAT((i4,1X), 3(i3,1X), 9(f9.4,1X))

    ! Deallocate arrays -----------------------------------------------------------------
    DEALLOCATE(ESTMForDisagg)
    DEALLOCATE(ESTMForDisaggPrev)
    DEALLOCATE(ESTMForDisaggNext)

    RETURN

113 CALL ErrorHint(52,TRIM(FileDscdESTM),notUsed,notUsed,notUsedI)

  ENDSUBROUTINE DisaggregateESTM
  !======================================================================================

  !======================================================================================
  SUBROUTINE DisaggregateDateTime(DateTimeForDisagg,tstep,Nper,ReadLinesOrigMetDataMax,DateTimeDscd)
    USE datetime_module,ONLY:daysInYear
    IMPLICIT NONE
    INTEGER,INTENT(in) :: tstep,Nper,ReadLinesOrigMetDataMax
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData,4),INTENT(in):: DateTimeForDisagg
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData*Nper,4),INTENT(out):: DateTimeDscd


    REAL(KIND(1d0)),DIMENSION(ReadLinesOrigMetData):: dectimeOrig
    REAL(KIND(1d0)), DIMENSION(Nper) :: temp_dectime  !temorary varaibles for disaggragation
    INTEGER, DIMENSION(Nper):: temp_iy, temp_id, temp_ih, temp_im, temp_ihm ! temorary varaibles for disaggragation
    INTEGER, DIMENSION(Nper)::ndays_iy ! number of days in iy

    INTEGER :: i,ii
    INTEGER,DIMENSION(Nper):: seq1Nper

    ! Generate useful sequences
    seq1Nper = (/(i, i=1,Nper, 1)/)
    ! Convert to dectime
    ! dectimeOrig = MetForDisagg(:,2) + MetForDisagg(:,3)/24.0 + MetForDisagg(:,4)/(60.0*24.0)
    ! correct to dectime(year_start)=0 and dectime(year_end)=days of year (i.e., 365 or 366 if leap year) ! TS 09 May 2018
    dectimeOrig = (DateTimeForDisagg(:,2)-1) + DateTimeForDisagg(:,3)/24.0 + DateTimeForDisagg(:,4)/(60.0*24.0)

    DO i=1,ReadLinesOrigMetDataMax

       ! Downscale dectime using dectimeOrig(i) [becomes timestamp of last subinterval]
       temp_dectime = dectimeOrig(i) - (tstep/60.0)/(60.0*24.0)*(/(ii, ii=(Nper-1),0, -1)/)
       temp_dectime = NINT(temp_dectime*60*60*24)/(60*60*24*1.)

       ! Convert to required formats
       ! get year: year-1 if dectime <0, copy `year` from metforcing otherwise
       temp_iy  = MERGE(INT(DateTimeForDisagg(i,1))-1,INT(DateTimeForDisagg(i,1)),temp_dectime < 0)

       ! get day of year:
       ndays_iy = daysInYear(temp_iy) ! get days of year for DOY correction when temp_dectime<0 during year-crossing
       temp_dectime=MERGE(temp_dectime+ndays_iy,temp_dectime,temp_dectime<0) ! correct minus temp_dectime to positive values
       temp_id  = FLOOR(temp_dectime)+1 !DOY

       temp_ihm  = NINT((temp_dectime+1 - temp_id/1.0)*60.0*24.0)  !Minutes of the day (1440 max)
       temp_ih = (temp_ihm-MOD(temp_ihm,60))/60   !Hours
       temp_ih = MERGE(temp_ih, 0, mask=(temp_ih<24))
       temp_im = MOD(temp_ihm,60)   !Minutes

       ! Copy to Met_tt array
       DateTimeDscd(Nper*(i-1)+Seq1Nper,1) = temp_iy
       DateTimeDscd(Nper*(i-1)+Seq1Nper,2) = temp_id
       DateTimeDscd(Nper*(i-1)+Seq1Nper,3) = temp_ih
       DateTimeDscd(Nper*(i-1)+Seq1Nper,4) = temp_im

    ENDDO

  END SUBROUTINE DisaggregateDateTime
  !======================================================================================

  ! Define functions here:
  FUNCTION Disagg_Lin(Slow,SlowPrev,SlowNext,DisaggType,Nper_loc,ReadLinesOrig_loc,ReadLinesOrigMax_loc,iBlock) RESULT(Fast)

    USE DefaultNotUsed
    USE sues_data

    IMPLICIT NONE

    INTEGER:: DisaggType   !Type of disaggregation: 10 for averaged variables; 20 for instantaneous variables
    INTEGER:: Nper_loc     !Number of subintervals per interval (local Nper)
    INTEGER:: ReadLinesOrig_loc,ReadLinesOrigMax_loc   !Number of lines to read in original file (local)
    INTEGER:: iBlock
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrig_loc*Nper_loc):: Fast  !Array to receive disaggregated data
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrig_loc):: Slow   !Array to disaggregate
    REAL(KIND(1d0)):: SlowPrev, SlowNext
    INTEGER,DIMENSION(Nper_loc):: FastRows   !Group of rows that are filled with each iteration
    INTEGER,DIMENSION(FLOOR(Nper_loc/2.0)):: FirstRows10   !Rows at the beginning that are not filled during iteration (for averages)
    INTEGER,DIMENSION(Nper_loc-FLOOR(Nper_loc/2.0)):: LastRows10    !Rows at the end that are not filled during iteration
    INTEGER,DIMENSION(Nper_loc):: FirstRows20   !Rows at the beginning that are not filled during iteration (for instantaneous)
    INTEGER,DIMENSION(Nper_loc):: seq1Nper_loc   !1 to Nper_loc
    INTEGER:: XNper_loc   !XNper_loc = 2 for even Nper_loc; XNper_loc=1 for odd Nper_loc
    INTEGER:: i,ii   !counters

    ! Calculate XNper_loc (differentiates between disaggregations with odd and even Nper_loc)
    IF(MOD(Nper_loc,2)==0) XNper_loc=2
    IF(MOD(Nper_loc,2)==1) XNper_loc=1

    seq1Nper_loc = (/(i, i=1,Nper_loc, 1)/)

    ! Setup counters for iteration
    IF(DisaggType==10) THEN
       FastRows = FLOOR(Nper_loc/2.0) + seq1Nper_loc  ! Rows to create at model time-step
       FirstRows10 = (/(i, i=1,(FastRows(1)-1), 1)/)   !For start of dataset
       LastRows10 =  (/(i, i=Nper_loc*(ReadLinesOrigMax_loc-1-1)+FastRows(Nper_loc)+1,(ReadLinesOrigMax_loc*Nper_loc),1)/)  ! For end of dataset
    ELSEIF(DisaggType==20) THEN
       FastRows = Nper_loc + seq1Nper_loc   !Rows to create at model time-step
       FirstRows20 = (/(i, i=1,(FastRows(1)-1), 1)/)   !For start of dataset
    ENDIF

    ! Initialise fast array to -999
    Fast = -999
    ! Linearly disaggregate
    IF(DisaggType==10) THEN   !Averaged variables
       IF(DiagnoseDisagg==1) WRITE(*,*) 'Linearly disaggregating averaged variable'
       DO i=1,(ReadLinesOrigMax_loc-1)
          Fast(Nper_loc*(i-1)+FastRows) = Slow(i) - &
               (Slow(i+1)-Slow(i))/(XNper_loc*Nper_loc) + &
               (Slow(i+1)-Slow(i))/Nper_loc*(/(ii, ii=1,Nper_loc, 1)/)
       ENDDO

       ! For first few rows, use previous met block
       IF(iBlock==1) THEN
          Fast(FirstRows10) = Fast(FastRows(1))   !Use repeat values at the start of the year
       ELSE
          Fast(FirstRows10) = SlowPrev - &
               (Slow(1)-SlowPrev)/(XNper_loc*Nper_loc) + &
               (Slow(1)-SlowPrev)/Nper_loc * &
               (/(ii, ii=(Nper_loc-SIZE(FirstRows10)+1),Nper_loc, 1)/)
       ENDIF
       ! For last few rows, use next met block
       IF(iBlock==ReadBlocksOrigMetData) THEN
          Fast(LastRows10) = Fast(Nper_loc*(ReadLinesOrigMax_loc-1-1)+FastRows(Nper_loc))   !Use repeat values at the end of the year
       ELSE
          Fast(LastRows10) = Slow(ReadLinesOrigMax_loc) - &
               (SlowNext-Slow(ReadLinesOrigMax_loc))/(XNper_loc*Nper_loc) + &
               (SlowNext-Slow(ReadLinesOrigMax_loc))/Nper_loc * &
               (/(ii, ii=1,SIZE(LastRows10), 1)/)
       ENDIF
    ELSEIF(DisaggType==20) THEN   !Instantaneous variables
       IF(DiagnoseDisagg==1) WRITE(*,*) 'Linearly disaggregating instantaneous variable'
       DO i=1,(ReadLinesOrigMax_loc-1)
          Fast(Nper_loc*(i-1)+FastRows) = (Slow(i) + &
               (Slow(i+1)-Slow(i))/Nper_loc*2*(seq1Nper_loc-1) + &
               Slow(i))/2
       ENDDO
       ! For first few rows, use previous met block
       IF(iBlock==1) THEN
          Fast(FirstRows20) = Fast(FastRows(1))   !Use repeat values at the start of the year
       ELSE
          Fast(FirstRows20) = (SlowPrev + &
               (Slow(1)-SlowPrev)/Nper_loc*2 * &
               ((/(ii, ii=(Nper_loc-SIZE(FirstRows20)+1),Nper_loc, 1)/)-1) + &
               SlowPrev)/2
       ENDIF
       !! Last few rows are already filled for the instantaneous value disaggregation
       !IF(iBlock==ReadBlocksOrigMetData) THEN
       !   Fast(LastRows20) = Fast(Nper_loc*(ReadLinesOrigMax_loc-1-1)+FastRows(Nper_loc))   !Use repeat values at the end of the year
       !ELSE
       !   Fast(LastRows20) = (Slow(ReadLinesOrigMax_loc) + &
       !                     (SlowNext-Slow(ReadLinesOrigMax_loc))/Nper_loc*2 * &
       !                        ((/(ii, ii=1,SIZE(LastRows20), 1)/)-1) + &
       !                       Slow(ReadLinesOrigMax_loc))/2
       !ENDIF
    ENDIF

    IF(ANY(Fast(1:ReadLinesOrigMax_loc*Nper_loc) == -999)) THEN
       WRITE(*,*) 'Problem: -999s (',COUNT(Fast(1:ReadLinesOrigMax_loc*Nper_loc)==-999),') in disaggregated data.'
       CALL errorHint(13,'Problem in SUEWS_MetDisagg: -999 values in disaggregated data.',NotUsed,NotUsed,NotUsedI)
    ENDIF

  ENDFUNCTION Disagg_Lin
  !======================================================================================

  !======================================================================================
  FUNCTION DisaggP_amongN(Slow,amongN, Nper_loc, ReadLinesOrig_loc, ReadLinesOrigMax_loc) RESULT(Fast)
    ! Subroutine to disaggregate precipitation by evenly distributing among N subintervals
    !  (i.e. equal intensity in N subintervals)
    ! See Ward et al. (in review), meanN, 0.5N or 0.25N approach
    ! HCW 10 Feb 2017
    !======================================================================================

    USE DefaultNotUsed
    USE sues_data

    IMPLICIT NONE

    INTEGER:: amongN       !Number of subintervals over which rain will be distributed
    INTEGER:: Nper_loc     !Number of subintervals per interval (local Nper)
    INTEGER:: ReadLinesOrig_loc,ReadLinesOrigMax_loc   !Number of lines to read in original file (local)
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrig_loc*Nper_loc):: Fast  !Array to receive disaggregated data
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrig_loc):: Slow   !Array to disaggregate
    INTEGER,DIMENSION(:),ALLOCATABLE:: Subintervals  !Array of subintervals that contain rain
    INTEGER,DIMENSION(Nper_loc):: seq1Nper_loc   !1 to Nper_loc
    INTEGER:: i

    ! For each averaging period, get subintervals which will receive rain
    ALLOCATE(Subintervals(amongN))
    Subintervals(:) = -999

    seq1Nper_loc = (/(i, i=1,Nper_loc, 1)/)

    IF(DiagnoseDisagg==1) WRITE(*,*) 'Distributing over ',amongN,' subintervals for variable'
    ! If all subintervals are to contain rain, don't need to generate random numbers
    IF(amongN == Nper_loc) THEN
       Subintervals(:) = seq1Nper_loc
    ENDIF
    IF(amongN > Nper_loc) &
         CALL errorHint(2,'Problem in SUEWS_MetDisagg: no. of rainy periods cannot exceed number of subintervals', &
         REAL(Nper_loc,KIND(1d0)),NotUsed,amongN)


    ! Initialise fast array to -999
    Fast = -999
    DO i=1,ReadLinesOrigMax_loc
       Fast(Nper_loc*(i-1)+seq1Nper_loc) = 0   !Fill all subintervals with zeros initially
       IF(Slow(i) > 0) THEN   !If there is some rainfall during this interval...
          IF(amongN < Nper_loc) THEN
             Subintervals(:) = -999
             Subintervals = RandomSamples(amongN,Nper_loc)
          ENDIF
          Fast(Nper_loc*(i-1)+SubIntervals) = Slow(i)/amongN
       ENDIF
    ENDDO

    IF(ANY(Fast(1:ReadLinesOrigMax_loc*Nper_loc) == -999)) THEN
       WRITE(*,*) 'Problem: -999s (',COUNT(Fast(1:ReadLinesOrigMax_loc*Nper_loc) == -999),') in disaggregated data'
       CALL errorHint(13,'Problem in SUEWS_MetDisagg: -999 values in disaggregated data.',NotUsed,NotUsed,NotUsedI)
    ENDIF

  ENDFUNCTION DisaggP_amongN
  !======================================================================================

  !======================================================================================
  FUNCTION DisaggP_amongNMult(Slow,multupperI, multamongN, Nper_loc, ReadLinesOrig_loc, ReadLinesOrigMax_loc) RESULT(Fast)
    ! Subroutine to disaggregate precipitation by evenly distributing among N subintervals
    !  (i.e. equal intensity in N subintervals) for different intensity bins
    ! Based on analsysis by Wen Gu
    ! HCW 21 Apr 2017
    !======================================================================================

    USE DefaultNotUsed
    USE sues_data

    IMPLICIT NONE

    REAL(KIND(1d0)),DIMENSION(5):: multupperI     !Upper bound of intensity bin
    INTEGER,DIMENSION(5):: multamongN       !Number of subintervals over which rain will be distributed (array)
    INTEGER:: thisamongN       !Number of subintervals over which rain will be distributed
    INTEGER:: Nper_loc     !Number of subintervals per interval (local Nper)
    INTEGER:: ReadLinesOrig_loc,ReadLinesOrigMax_loc   !Number of lines to read in original file (local)
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrig_loc*Nper_loc):: Fast  !Array to receive disaggregated data
    REAL(KIND(1d0)),DIMENSION(ReadLinesOrig_loc):: Slow   !Array to disaggregate
    INTEGER,DIMENSION(:),ALLOCATABLE:: Subintervals  !Array of subintervals that contain rain
    INTEGER,DIMENSION(Nper_loc):: seq1Nper_loc   !1 to Nper_loc
    INTEGER:: i

    seq1Nper_loc = (/(i, i=1,Nper_loc, 1)/)

    IF(DiagnoseDisagg==1) WRITE(*,*) 'Distributing over variable subintervals depending on intensity for variable'

    ! Initialise fast array to -999
    Fast = -999
    DO i=1,ReadLinesOrigMax_loc
       Fast(Nper_loc*(i-1)+seq1Nper_loc) = 0   !Fill all subintervals with zeros initially
       IF(Slow(i) > 0) THEN   !If there is some rainfall during this interval...
          !Use intensity in this interval to decide number of subintervals to fill with rain
          IF(Slow(i) <= multupperI(1)) THEN
             thisamongN = multamongN(1)
          ELSEIF(Slow(i) > multupperI(1) .AND. Slow(i) <= multupperI(2)) THEN
             thisamongN = multamongN(2)
          ELSEIF(Slow(i) > multupperI(2) .AND. Slow(i) <= multupperI(3)) THEN
             thisamongN = multamongN(3)
          ELSEIF(Slow(i) > multupperI(3) .AND. Slow(i) <= multupperI(4)) THEN
             thisamongN = multamongN(4)
          ELSEIF(Slow(i) > multupperI(4) .AND. Slow(i) <= multupperI(5)) THEN
             thisamongN = multamongN(5)
          ELSEIF(Slow(i) > multupperI(5)) THEN
             thisamongN = multamongN(5)
             CALL errorHint(4,'Precip in met forcing file exceeds maxiumum MultRainAmongNUpperI',&
                  Slow(i),MultRainAmongNUpperI(5),notUsedI)
          ENDIF

          ! For each averaging period, get subintervals which will receive rain
          ALLOCATE(Subintervals(thisamongN))
          Subintervals(:) = -999

          IF(thisamongN > Nper_loc) CALL errorHint(2,'Problem in SUEWS_MetDisagg: no. of rainy periods cannot exceed '//&
               'number of subintervals', REAL(Nper_loc,KIND(1d0)),NotUsed,thisamongN)

          IF(thisamongN == Nper_loc) THEN   ! If all subintervals are to contain rain, don't need to generate random numbers
             Subintervals(:) = seq1Nper_loc
          ELSEIF(thisamongN < Nper_loc) THEN
             Subintervals = RandomSamples(thisamongN,Nper_loc)
          ENDIF
          Fast(Nper_loc*(i-1)+SubIntervals) = Slow(i)/thisamongN
          !write(*,*) Slow(i), thisamongN
          DEALLOCATE(Subintervals)
       ENDIF
    ENDDO

    IF(ANY(Fast(1:ReadLinesOrigMax_loc*Nper_loc) == -999)) THEN
       WRITE(*,*) 'Problem: -999s (',COUNT(Fast(1:ReadLinesOrigMax_loc*Nper_loc) == -999),') in disaggregated data'
       CALL errorHint(13,'Problem in SUEWS_MetDisagg: -999 values in disaggregated data.',NotUsed,NotUsed,NotUsedI)
    ENDIF

  ENDFUNCTION DisaggP_amongNMult
  !======================================================================================

  !======================================================================================
  FUNCTION RandomSamples(N,OutOf) RESULT(Samples)
    ! Generates N/OutOf random samples without repeats
    !   e.g. for N = 3 and OutOf = 12, a possibility for Samples = 7,3,11
    ! HCW 10 Feb 2017
    !======================================================================================

    IMPLICIT NONE

    INTEGER:: i   !counter
    INTEGER:: N   !number of samples to return
    INTEGER:: OutOf   !number to sample from
    INTEGER:: X   !next sample to be added
    REAL(KIND(1D0)):: r   !random number
    INTEGER,DIMENSION(:),ALLOCATABLE:: Samples   !Array to receive random samples

    ! Allocate and initialise Samples
    ALLOCATE(Samples(N))
    Samples(:) = -999

    ! Generate random sample (no repeats)
    i=0 !Set counter to zero initially
    DO WHILE (ANY(Samples == -999))
       CALL RANDOM_NUMBER(r)
       X = INT(r*OutOf)+1
       !write(*,*) X
       !write(*,*) COUNT(Samples == X)
       IF(COUNT(Samples == X) == 0) THEN
          ! Only keep if this subinterval has not already been selected
          i=i+1
          Samples(i)=X
       ENDIF
       !write(*,*) Samples
    ENDDO

  ENDFUNCTION RandomSamples
  !======================================================================================

ENDMODULE MetDisagg
!========================================================================================

MODULE AtmMoistStab_module
  IMPLICIT NONE

CONTAINS
  !.c!! For Lumps Version 2 - no stability calculations
  ! Latent heat of sublimation when air temperature below zero added. LJ Nov 2012
  ! explict interface added to all subroutines, TS 08 Aug 2017
  SUBROUTINE LUMPS_cal_AtmMoist(&
       Temp_C,Press_hPa,avRh,dectime,&! input:
       lv_J_kg,lvS_J_kg,&! output:
       es_hPa,Ea_hPa,VPd_hpa,VPD_Pa,dq,dens_dry,avcp,air_dens)

    USE meteo,ONLY:&
         sat_vap_press_x,spec_heat_beer,&
         lat_vap,lat_vapSublim,spec_hum_def

    IMPLICIT NONE
    REAL(KIND(1d0))::vap_dens

    REAL(KIND(1d0)),INTENT(in)::&
         Temp_C,&
         Press_hPa,&
         avRh,dectime
    REAL(KIND(1d0)),INTENT(out)::&
         lv_J_kg,&!Latent heat of vaporization in [J kg-1]
         lvS_J_kg,&!Latent heat of sublimation in J/kg
         es_hPa,&!Saturation vapour pressure over water in hPa
         Ea_hPa,&!Vapour pressure of water in hPa
         VPd_hpa,& !vapour pressure deficit in hPa
         VPD_Pa,& !vapour pressure deficit in Pa
         dq,&!Specific humidity deficit in g/kg
         dens_dry,& !Vap density or absolute humidity	 (kg/m3)
         avcp,&!specific heat capacity in J kg-1 K-1
         air_dens!Air density in kg/m3


    REAL (KIND(1d0)),PARAMETER:: &
                                !  comp          = 0.9995, &
                                !  epsil         = 0.62197,&           !ratio molecular weight of water vapor/dry air (kg/mol/kg/mol)
                                !  epsil_gkg     = 621.97, &           !ratio molecular weight of water vapor/dry air in g/kg
                                !  dry_gas       = 8.31451,&           !Dry gas constant (J/k/mol)
                                !  gas_ct_wat    = 461.05,&            !Gas constant for water (J/kg/K)
                                !  molar         = 0.028965,&          !Dry air molar fraction in kg/mol
                                !  molar_wat_vap = 0.0180153,&         !Molar fraction of water vapor in kg/mol
         gas_ct_dry    = 8.31451/0.028965,&  !j/kg/k=dry_gas/molar
         gas_ct_wv     = 8.31451/0.0180153 !j/kg/kdry_gas/molar_wat_vap
    !  waterDens     = 999.8395            !Density of water in 0 cel deg
    INTEGER::from=1

    !Saturation vapour pressure over water in hPa
    es_hPa = sat_vap_press_x(Temp_C,Press_hPa,from,dectime) ! dectime is more or less unnecessary here

    !Vapour pressure of water in hPa
    Ea_hPa=avRh/100*es_hPa

    ! if(debug.and.dectime>55.13.and.dectime<55.2)write(35,*)'%',Temp_C

    VPd_hpa=es_hPa-ea_hpa           !vapour pressure deficit in hPa
    VPD_Pa=(es_hPa*100)-(Ea_hPa*100)!vapour pressure deficit in Pa

    dq=spec_hum_def(vpd_hPa,Press_hPa) !Specific humidity deficit in g/kg

    !Vap density or absolute humidity	 (kg/m3)
    vap_dens=(Ea_hPa*100/((Temp_C+273.16)*gas_ct_wv))

    !density Dry Air Beer(1990)	kg/m3
    dens_dry=((Press_hPa-Ea_hPa)*100)/(gas_ct_dry*(273.16+Temp_C))

    !Air density in kg/m3
    air_dens=(Press_hPa*100)/(gas_ct_dry*(Temp_C+273.16))

    !Calculate specific heat capacity in J kg-1 K-1
    avcp=spec_heat_beer(Temp_C,avRh,vap_dens,dens_dry)

    !Latent heat of vaporization in [J kg-1]
    lv_J_kg=lat_vap(Temp_C,Ea_hPa,Press_hPa,avcp,dectime)

    !Latent heat of sublimation in J/kg
    IF(Temp_C<0.000) THEN
       lvS_J_kg=lat_vapSublim(Temp_C,Ea_hPa,Press_hPa,avcp)
    ELSE
       lvS_J_kg = 2834000
    ENDIF
    !if(debug)write(*,*)lv_J_kg,Temp_C,'lv2'
    IF(press_hPa<900) THEN
       CALL ErrorHint(46, 'Function LUMPS_cal_AtmMoist',press_hPa,-55.55d0, -55)
    ENDIF
    RETURN
  END SUBROUTINE LUMPS_cal_AtmMoist






  !.c!! For Lumps Version 2 - no stability calculations
  !==========================================================
  !     Last change:
  !     TS   08 Aug 2017: added explicit interface
  !     TS   13 Jun 2017: corrections to the integral of stability functions
  !     MH   12 Apr 2017: Stable limit to exit do-loop
  !     LJ   25 Nov 2014: Limits for L
  !     LJ   19 Feb 2010
  !     SG   27 Mar 2000    4:44 pm
  !     ust - friction velocity
  !     L - monin obukhov stability length
  !       Van Ulden & Holtslag (1985) JCAM: 24: 1196-1207

  SUBROUTINE STAB_lumps(&

                                ! input
       StabilityMethod,&
       dectime,& !Decimal time
       zzd,&     !Active measurement height (meas. height-displac. height)
       z0m,&     !Aerodynamic roughness length
       zdm,&     !Displacement height
       avU1,&    !Average wind speed
       Temp_C,&  !Air temperature
       H_init,    & !Kinematic sensible heat flux [K m s-1] used to calculate friction velocity
                                ! output:
       L_MOD,& !Obukhov length
       TStar,& !T*
       UStar,& !Friction velocity
       zL)!Stability scale

    IMPLICIT NONE
    INTEGER,INTENT(in):: StabilityMethod


    REAL(KIND(1d0)),INTENT(in)::dectime !Decimal time
    REAL(KIND(1d0)),INTENT(in)::zzd     !Active measurement height (meas. height-displac. height)
    REAL(KIND(1d0)),INTENT(in)::z0m     !Aerodynamic roughness length
    REAL(KIND(1d0)),INTENT(in)::zdm     !Displacement height
    REAL(KIND(1d0)),INTENT(in)::avU1    !Average wind speed
    REAL(KIND(1d0)),INTENT(in)::Temp_C    !Air temperature
    REAL(KIND(1d0)),INTENT(in)::H_init    !Kinematic sensible heat flux [K m s-1] used to calculate friction velocity


    REAL(KIND(1d0)),INTENT(out)::L_MOD!Obukhov length
    REAL(KIND(1d0)),INTENT(out)::TStar!T*
    REAL(KIND(1d0)),INTENT(out)::UStar!Friction velocity
    REAL(KIND(1d0)),INTENT(out)::zL ! Stability scale
    ! REAL(KIND(1d0)),INTENT(out)::psim   !Stability function of momentum

    REAL(KIND(1d0))::G_T_K,&
         KUZ,&
         LOLD,&
         psim,&
         z0l,&
         psimz0,&
         h
    REAL(KIND(1d0)),PARAMETER :: &
         k=0.4,&             !Von Karman's contant
         grav=9.80665  !g - gravity - physics today august 1987
    INTEGER,PARAMETER ::   notUsedI=-55

    INTEGER :: i

    LOGICAL :: debug=.FALSE.

    IF(debug) WRITE(*,*)StabilityMethod,z0m,avU1,H_init,UStar,L_MOD
    G_T_K=(Grav/(Temp_C+273.16))*k !gravity constant/(Temperature*Von Karman Constant)
    KUZ=k*AvU1                     !Von Karman constant*mean wind speed
    IF(zzd<0) CALL ErrorHint(32,'Windspeed Ht too low relative to zdm [Stability calc]- values [z-zdm, zdm]',Zzd,zdm,notUsedI)

    UStar=KUZ/LOG(Zzd/z0m)      !Initial setting of u* and calc. of L_MOD (neutral situation)
    IF ( ABS(H_init)<0.001 ) THEN    ! prevent zero TStar
       h=0.001
    ELSE
       h=H_init
    END IF
    TStar=(-H/UStar)
    L_MOD=(UStar**2)/(G_T_K*TStar)


    IF(LOG(zzd/z0m)<0.001000) THEN
       ! PRINT*, 1/(z0m-z0m)
       CALL ErrorHint(17,'In stability subroutine, (z-zd) < z0.',zzd,z0m,notUsedI)
    ENDIF
    DO i=1,330 !Iteration starts
       LOLD=L_MOD
       zL=zzd/L_MOD
       z0L=z0m/L_MOD  !z0m roughness length

       ! IF (z  L>2)THEN
       !    CALL ErrorHint(73,'LUMPS_atmos_functions_stab.f95: stability scale (z/L), UStar',zL,UStar,notUsedI)
       !    RETURN !MO-theory not necessarily valid above zL>2. Still causes problematic UStar values and correct limit might be 0.3.
       !    !Needs more investigations.
       ! END IF


       psim=stab_fn_mom(StabilityMethod,zL,zL)
       psimz0=stab_fn_mom(StabilityMethod,zL,z0L)


       UStar=KUZ/(LOG(Zzd/z0m)-psim+psimz0) !Friction velocity in non-neutral situation



       TStar=(-H/UStar)
       L_MOD=(UStar**2)/(G_T_K*TStar)

       ! IF(UStar<0.001000)THEN       !If u* too small
       !    UStar=KUZ/(LOG(Zzd/z0m))
       !    PRINT*, 'UStar info',UStar,KUZ,(LOG(Zzd/z0m)),Zzd,z0m
       !    CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.001] zl,dectime',zl,dectime,notUsedI)
       !    CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.001] z0l,UStar',z0l,UStar,notUsedI)
       !    CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.001] psim,psimz0',psim,psimz0,notUsedI)
       !    CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.001] AVU1,log(zzd/z0m)',AVU1,LOG(zzd/z0m),notUsedI)
       !
       !    ! RETURN
       ! ENDIF

       IF(ABS(LOLD-L_MOD)<0.01)THEN
          IF (ABS(L_MOD)>1e6) L_MOD = L_MOD/ABS(L_MOD)*1e6
          ! RETURN
          CONTINUE
       ENDIF
    ENDDO

    ! limit zL to be within [-5,2]
    IF ( zL<-5 .OR. zL>2 ) THEN
       zL=MIN(2.,MAX(-5.,zL))
       ! limit other output varialbes as well as z/L
       L_MOD=zzd/zL
       z0L=z0m/L_MOD
       psim=stab_fn_mom(StabilityMethod,zL,zL)
       psimz0=stab_fn_mom(StabilityMethod,zL,z0L)
       ! TS 01 Aug 2018: set a low limit at 0.15 m/s (Schumann 1987, BLM)
       ! to prevent potential issues in other stability-related calcualtions
       UStar=MAX(0.15, KUZ/(LOG(Zzd/z0m)-psim+psimz0))
       TStar=(-H/UStar)
    END IF

    ! TS: limit UStar and TStar to reasonable values
    ! 02 Aug 2018: set a low limit at 0.15 m/s (Schumann 1987, BLM)
    UStar=MAX(0.15, UStar)
    TStar=(-H/UStar)

    IF(UStar<0.0001)THEN       !If u* still too small after iteration, then force quit simulation and write out error info
       ! UStar=KUZ/(LOG(Zzd/z0m))
       PRINT*, 'UStar',UStar,KUZ,(LOG(Zzd/z0m)),Zzd,z0m
       CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.0001] zl,dectime',zl,dectime,notUsedI)
       CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.0001] z0l,UStar',z0l,UStar,notUsedI)
       CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.0001] psim,psimz0',psim,psimz0,notUsedI)
       CALL ErrorHint(30,'SUBROUTINE STAB_lumps:[ u*< 0.0001] AVU1,log(zzd/z0m)',AVU1,LOG(zzd/z0m),notUsedI)

       ! RETURN
    ENDIF

    ! if ( L_MOD<-990 ) then
    !   print*, 'L_MOD too low',L_MOD
    !   print*, 1/(L_MOD-L_MOD)
    !
    ! end if


  END SUBROUTINE STAB_lumps

  !==================================================================

  FUNCTION stab_fn_mom(StabilityMethod,ZL,zl_f) RESULT(psym)
    !     StabilityMethod = 1-4 -
    !     PSYM - stability FUNCTION for momentum
    !Modified by LJ Mar 2010
    !Input:Used stability method, stability (z-d)/L, zeta (either (z-d)/L or z0/L)

    ! USE mod_z
    ! USE mod_k

    IMPLICIT NONE
    REAL(KIND(1d0)),PARAMETER :: &
                                !  k=0.4,&             !Von Karman's contant
                                !  k2=0.16,&           !Power of Van Karman's contant
         neut_limit=0.001000 !Limit for neutral stability
    !  notUsedI=-55

    REAL (KIND(1d0)):: piover2,psym,zl,zl_f,x,x2
    INTEGER ::StabilityMethod

    PIOVER2=ACOS(-1.)/2.
    !PRINT*,StabilityMethod,zl,"stab_fn_mom:"
    IF(ABS(zL)<neut_limit) THEN
       psym=0
    ELSEIF(zL<-neut_limit) THEN    !Unstable

       IF(StabilityMethod==1)THEN     !    Jensen et al 1984 - Van Ulden & Holtslag (1985) p 1206&
          psym=((1.-16.*zl_f)**0.25)-1
       ELSEIF(StabilityMethod==2) THEN !Dyer (1974)(1-16z/L)**.25' k=0.41  mod. Hogstrom (1988)v15.2
          X=(1.-(15.2*zl_f))**0.25
          X2=LOG((1+(X**2.))/2.)
          PSYM=(2.*LOG((1+X)/2.))+X2-(2.*ATAN(X))+PIOVER2
       ELSEIF(StabilityMethod==3)THEN !     campbell & norman eqn 7.26
          psym=0.6*(2)*LOG((1+(1-16*zl_f)**0.5)/2)
       ELSEIF(StabilityMethod==4) THEN !Businger et al (1971) modifed  Hogstrom (1988)
          x=(1-19.3*zl_f)**(-0.25)
          X2=LOG((1+(X**2.))/2.)
          PSYM=(2.*LOG((1+X)/2.))+X2-(2.*ATAN(X))+PIOVER2
       ELSEIF(StabilityMethod==7) THEN ! Dyer & Bradley (1982) (1-28z/L)**.25' k=0.4
          X=(1+(28.*zl_f))**0.25
          X2=LOG((1+X**2.)/2.)
          PSYM=(2.*LOG((1+X)/2.))+X2-(2.*ATAN(X))+PIOVER2
       ELSEIF(StabilityMethod==5)THEN ! Zilitinkevich & Chalikov (1968) modified Hogstrom (1988)
          IF(zl_f>=-0.16)THEN
             x=1+1.38*zl_f
          ELSE
             x=0.42*(-1)*zl_f**0.333
          ENDIF
          X2=LOG((1+(X**2.))/2.)
          PSYM=(2.*LOG((1+X)/2.))+X2-(2.*ATAN(X))+PIOVER2

       ELSEIF(StabilityMethod==6)THEN !     Foken and Skeib (1983)
          IF(zl_f>=0.06)THEN
             x=1
          ELSE
             x=((-1)*zl_f/0.06)**0.25
          ENDIF
          X2=LOG((1+(X**2.))/2.)
          PSYM=(2.*LOG((1+X)/2.))+X2-(2.*ATAN(X))+PIOVER2
       ENDIF

    ELSEIF(zL>neut_limit) THEN            !Stable

       IF(StabilityMethod==1)THEN         !Dyer (1974) k=0.35 x=1+5*zl Mod. Hogstrom (1988)
          psym=(-4.8)*zl_f
       ELSEIF(StabilityMethod==2)THEN     !Van Ulden & Holtslag (1985) p 1206
          IF ( zl_f >1000. ) THEN
             zl_f=1000.
          END IF
          PSYM=(-17.*(1.-EXP(-0.29*zl_f)))
       ELSEIF(StabilityMethod==4)THEN ! Businger et al (1971) modifed  Hogstrom (1988)
          ! psym=1+6*zl_f  ! this is NOT the integral form but the stability function, TS 13 Jun 2017
          psym=(-6)*zl_f   ! this is the integral form, TS 13 Jun 2017
       ELSEIF(StabilityMethod==3)THEN ! campbell & norman eqn 7.27 p 97
          psym=(-6)*LOG(1+zl_f)

       ENDIF
    ENDIF
    RETURN
  END FUNCTION stab_fn_mom

  !_______________________________________________________________
  !
  ! PSYH - stability function for heat
  FUNCTION stab_fn_heat(StabilityMethod,ZL,zl_f) RESULT (psyh)
    ! USE mod_k
    IMPLICIT NONE
    REAL(KIND(1d0)),PARAMETER :: &
                                !  k=0.4,&             !Von Karman's contant
                                !  k2=0.16,&           !Power of Van Karman's contant
         neut_limit=0.001000 !Limit for neutral stability
    !  notUsedI=-55

    REAL (KIND(1d0)):: zl,zl_f,psyh,x
    INTEGER :: StabilityMethod

    IF(ABS(zl)<neut_limit)THEN      !Neutral
       psyh=0
    ELSEIF(zL<-neut_limit) THEN     ! Unstable
       IF(StabilityMethod==3)THEN
          !campbell & norman eqn 7.26
          psyh=0.6*(2)*LOG((1+(1-16*zl_f)**0.5)/2)
       ELSE

          IF(StabilityMethod==4)THEN ! Businger et al (1971) modifed  Hogstrom (1988)
             x=0.95*(1.-11.6*zl_f)**(-0.5)
          ELSEIF(StabilityMethod==7) THEN
             x=(1-(28.*ZL))**0.25
          ELSEIF(StabilityMethod==2)THEN ! Dyer 1974 X=(1.-(16.*ZL))**(0.5)modified Hosgstrom
             x=0.95*(1.-15.2*zl_f)**0.5
          ENDIF
          PSYH=2*LOG((1+x**2)/2)
       ENDIF

    ELSE IF (zL>neut_limit) THEN    !Stable
       IF ( zL<=1 ) THEN ! weak/moderate stable
          IF(StabilityMethod==4)THEN !Businger et al (1971) modifed  Hogstrom (1988)
             ! psyh=0.95+(7.8*zl_f) ! this is NOT the integral form but the stability function, TS 13 Jun 2017
             psyh=(-7.8)*zl_f   ! this is the integral form, TS 13 Jun 2017
          ELSE !Dyer (1974)  PSYH=(-5)*ZL	modifed  Hogstrom (1988)
             PSYH=(-4.5)*Zl_f
          ENDIF
       ELSE !zL>1, very stable. otherwise psyh would be too large. TS 13 Jun 2017
          ! adopt the form as Brutasert (1982) eqn 4.58. but following the coeffs. of the above eqns
          IF(StabilityMethod==4)THEN !Businger et al (1971) modifed  Hogstrom (1988)
             psyh=(-7.8)*(1+LOG(zl_f))
          ELSE !Dyer (1974)  PSYH=(-5)*ZL	modifed  Hogstrom (1988)
             PSYH=(-4.5)*(1+LOG(zl_f))
          ENDIF
       END IF

    ENDIF

    RETURN
  END FUNCTION stab_fn_heat
  !--------------------------------------------------------------------------------
  ! psys - roughness sublayer correction psi_*
  !
  !     Garratt (1980) QJRMS Appendix 1 p 815/816

  FUNCTION stab_fn_rou(z,zstar) RESULT (psys)
    IMPLICIT NONE
    REAL(KIND(1d0))::alpha,zeta,z,psys,zstar,alpha1
    !     z wind speed height - z_d
    !     zstar height of the roughness sublayer
    !     eqn (a4) using alpha=0.5 alpha1=0.7
    alpha=0.5
    alpha1=0.7
    zeta=z/zstar
    psys=(alpha-1)* LOG(zeta)-(alpha*alpha1)*(1-zeta)-(alpha*alpha1**2) &
         *(1-zeta**2)/6.-(alpha*alpha1**3)*(1-zeta**3)/24.
    RETURN
  END FUNCTION stab_fn_rou


END MODULE AtmMoistStab_module

MODULE BLUEWS_module
  USE meteo,ONLY:qsatf

  IMPLICIT NONE
CONTAINS
  ! Note: INTERVAL is now set to 3600 s in Initial (it is no longer set in RunControl) HCW 29 Jan 2015
  ! Last modified:
  !  HCW 29 Mar 2017 - Changed third dimension of dataOutBL to Gridiv (was previously iMB which seems incorrect)
  !  NT 6 Apr 2017 - include top of the CBL variables in RKUTTA scheme + add flag to include or exclude subsidence
  !  LJ 27 Jan 2016 - Removal of tabs


  SUBROUTINE CBL(ifirst,Gridiv)

    USE mod_z
    USE mod_k
    USE gas
    USE time
    USE data_in
    USE sues_data
    USE moist
    USE allocateArray
    USE defaultNotUsed
    USE cbl_module
    USE gis_data
    USE WhereWhen
    USE meteo,ONLY:sat_vap_press_x

    IMPLICIT NONE

    ! REAL(KIND(1d0))::sat_vap_press_x
    REAL(KIND(1d0))::qh_use,qe_use,tm_K_zm,qm_gkg_zm
    REAL(KIND(1d0))::Temp_C1,avrh1,es_hPa1
    REAL(KIND(1d0))::secs0,secs1,Lv
    INTEGER::idoy,ifirst,Gridiv,startflag,iNBL

    ! initialise startflag
    startflag=0

    ! Reset iCBLcount at start of each metblock (HCW added 29/03/2017)
    IF(ifirst == 1) THEN
       iCBLcount = 0
    ENDIF

    !write(*,*) DateTIme
    !Skip first loop and unspecified days
    !IF((ifirst==1 .AND. iMB==1) .OR. CBLday(id)==0) THEN   !HCW modified condition to check for first timestep of the model run
    IF(ifirst==1 .OR. IniCBLdata(id,2)==-999) THEN   !TS modified to adapt the format of the new CBL_initial file
       iCBLcount=iCBLcount+1
       !write(*,*) 'ifirst or nonCBLday', DateTime, iCBLcount
       dataOutBL(iCBLcount,1:ncolumnsdataOutBL,Gridiv)=(/REAL(iy,8),REAL(id,8),REAL(it,8),REAL(imin,8),dectime, &
            (NAN,is=6,ncolumnsdataOutBL)/)
       RETURN
    ELSEIF(avkdn<5)THEN
       iNBL=1
       IF (iNBL==-9) THEN
          CALL CBL_initial(qh_use,qe_use,tm_K_zm,qm_gkg_zm,startflag, Gridiv)
          RETURN
       ELSE
          !ADD NBL for Night:(1)Fixed input/output NBL; (2) Input Fixed Theta,Q to SUEWS; (3) Currently NBL eq 200 m
          CALL NBL(qh_use,qe_use,tm_K_zm,qm_gkg_zm,startflag, Gridiv)
          RETURN
       ENDIF
    ENDIF

    IF(startflag==0)THEN !write down initial values in previous time step
       !write(*,*) 'startflag', DateTime, iCBLcount
       dataOutBL(iCBLcount,1:ncolumnsdataOutBL,Gridiv)=(/REAL(iy,8),REAL(id,8),REAL(it,8),REAL(imin,8),dectime,blh_m,tm_K, &
            qm_kgkg*1000,tp_K,qp_kgkg*1000,(NAN,is=11,20),gamt_Km,gamq_kgkgm/)
       startflag=1
    ENDIF

    qh_use=qhforCBL(Gridiv)   !HCW 21 Mar 2017
    qe_use=qeforCBL(Gridiv)
    IF(qh_use<-900.OR.qe_use<-900)THEN  ! observed data has a problem
       CALL ErrorHint(22,'Unrealistic qh or qe_value for CBL.',qh_use,qe_use,qh_choice)
    ENDIF
    !!Heat flux choices - these are now made in SUEWS_Calculations for qhforCBL and qeCBL, rather than here
    !IF(Qh_choice==1) THEN   !from SUEWS
    !  !qh_use=qh
    !   !qe_use=qeph
    !   qh_use=qhforCBL(Gridiv)   !HCW 21 Mar 2017
    !   qe_use=qeforCBL(Gridiv)
    !ELSEIF(qh_choice==2)THEN !from LUMPS
    !   qh_use=H_mod
    !   qe_use=E_mod
    !ELSEIF(qh_choice==3)THEN  !from OBS
    !   IF(qh_obs<-900.OR.qe_obs<-900)THEN  ! observed data has a problem
    !      CALL ErrorHint(22,'Unrealistic observed qh or qe_value.',qh_obs,qe_obs,qh_choice)
    !   ENDIF
    !   qh_use=qh_obs
    !   qe_use=qe_obs
    !ENDIF

    !-------Main loop of CBL calculation--------------------------------------
    !-------------------------------------------------------------------------

    !write(*,*) 'Main CBL loop'

    cbldata(1)=float(it)+float(imin)/60.
    cbldata(2)=qh_use
    cbldata(3)=qe_use
    cbldata(4)=avdens
    cbldata(5)=lv_J_kg
    cbldata(6)=avcp
    cbldata(7)=avu1
    cbldata(8)=UStar
    cbldata(9)=Press_hPa
    cbldata(10)=psyh

    secs0=cbldata(1)*3600.
    secs1=secs0+float(tstep) ! time in seconds
    ! Kinematic fluxes
    fhbl_Kms    = cbldata(2)/ (cbldata(4)*cbldata(6))  !qh_use/(avdens*avcp)      ! units: degK * m/s
    febl_kgkgms = cbldata(3)/ (cbldata(4)*cbldata(5))  !qe_use/(avdens*lv_J_kg)   ! units: kg/kg * m/s
    IF(CO2_included==1)THEN
       fcbl = 0!fc(i)/(rmco2/volm)      ! units: mol/mol * m/s
    ELSE
       cm=NAN
    ENDIF

    !   tpp_K=tp_K
    !   qpp_kgkg=qp_kgkg

    IF(sondeflag==1) THEN
       CALL gamma_sonde
    ENDIF
    !     	set up array for Runge-Kutta call
    blh1_m=blh_m
    y(1)=blh_m ! integrate h, t, q, c from time s(i-1)
    y(2)=tm_K  ! to time s(i) using runge-kutta solution
    y(3)=qm_kgkg   ! of slab CBL equations
    y(4)=cm
    y(5)=tp_K
    y(6)=qp_kgkg

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++
    CALL rkutta(neqn,secs0,secs1,y,1)
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++
    blh_m   =y(1)
    tm_K    =y(2)  ! potential temperature, units: K
    qm_kgkg =y(3)  ! specific humidity, units: kg/kg
    cm      =y(4)  ! co2 concentration,units: mol/mol
    tp_K    =y(5)  ! potential temperature top of CBL: K
    qp_kgkg =y(6)  ! specific humidity top of CBL: kg/kg
    !     	compute derived quantities for this time step

    !NT: now included in rkutta
    !   tp_K   = tpp_K     + (gamt_Km*(blh_m-blh1_m))
    !   qp_kgkg = qpp_kgkg + (gamq_kgkgm*(blh_m-blh1_m))

    !   IF (tp_K.LT.tm_K) THEN
    !      tp_K = tm_K
    !   ENDIF

    !		th = tm_K - (grav/cbldata(5))*blh_m			 ! actual temp just below z=h
    !		dh = qsatf(th,cbldata(8)) - qm_kgkg           ! deficit just below z=h

    tp_C=tp_K-C2K
    tm_C=tm_K-C2K

    !	 delt = tp_K - tm_K ! temp
    !	 delq = qp_kgkg - qm_kgkg ! humidity
    !deltv = (tp_K - tm_K) + 0.61*tm_k*(qp_kgkg - qm_kgkg)  ! pot virtual temp

    qm_gkg=qm_kgkg*1000 !humidities: kg/kg -> g/kg

    !Output time correction
    idoy=id
    !If(it==0 .and. imin==55) idoy=id-1
    IF(it==0 .AND. imin==(nsh_real-1)/nsh_real*60) idoy=id-1  !Modified by HCW 04 Mar 2015 in case model timestep is not 5-min


    ! QUESTION: any difference between the two options? code looks the same in the two branches.
    IF((qh_choice==1).OR.(qh_choice==2))THEN !BLUEWS or BLUMPS
       !Stability correction
       !tm_K_zm=tm_K+cbldata(10)*cbldata(2)/(k*cbldata(8)*cbldata(6)*cbldata(4))
       Temp_C=tm_K/((1000/cbldata(9))**(gas_ct_dry/cbldata(6)))-C2K
       es_hPa=sat_vap_press_x(Temp_C,cbldata(9),1,dectime)
       lv=(2500.25-2.365*Temp_C)*1000
       !qm_gkg_zm=qm_gkg+cbldata(10)*cbldata(3)/(k*cbldata(8)*cbldata(4)*lv)
       avrh=100*((qm_gkg*cbldata(9)/(622+qm_gkg))/es_hPa) !check pressure
       IF(avrh>100)THEN
          CALL errorHint(34,'subroutine CBL dectime, relative humidity',idoy+cbldata(1)/24.0,avrh,100)
          avrh=100
       ENDIF
       iCBLcount=iCBLcount+1
       !write(*,*) 'qh1or2', DateTIme, iCBLcount
       dataOutBL(iCBLcount,1:ncolumnsdataOutBL,Gridiv)=(/REAL(iy,8),REAL(id,8),REAL(it,8),REAL(imin,8),dectime,blh_m,tm_K, &
            qm_kgkg*1000, tp_K,qp_kgkg*1000,&
            Temp_C,avrh,cbldata([2,3,9,7,8,4,5,6]),&
            gamt_Km,gamq_kgkgm/)
    ELSEIF(qh_choice==3)THEN ! CBL
       !tm_K_zm=tm_K+cbldata(10)*cbldata(2)/(k*cbldata(8)*cbldata(6)*cbldata(4))
       Temp_C1=tm_K/((1000/cbldata(9))**(gas_ct_dry/cbldata(6)))-C2K
       es_hPa1=sat_vap_press_x(Temp_C1,cbldata(9),1,dectime)
       lv=(2500.25-2.365*Temp_C1)*1000
       !qm_gkg_zm=qm_gkg+cbldata(10)*cbldata(3)/(k*cbldata(8)*cbldata(4)*lv)
       avrh1=100*((qm_gkg*cbldata(9)/(622+qm_gkg))/es_hPa1) ! should be cbldata(9), i.e., Press_hPa
       IF(avrh1>100)THEN
          CALL errorHint(34,'subroutine CBL dectime, relative humidity',idoy+cbldata(1)/24.0,avrh1,100)
          avrh1=100
       ENDIF
       iCBLcount=iCBLcount+1
       !write(*,*) 'qh3', DateTIme, iCBLcount
       dataOutBL(iCBLcount,1:ncolumnsdataOutBL,Gridiv)=(/REAL(iy,8),REAL(id,8),REAL(it,8),REAL(imin,8),dectime,blh_m,tm_K, &
            qm_kgkg*1000,tp_K,qp_kgkg*1000,&
            Temp_C1,avrh1,cbldata([2,3,9,7,8,4,5,6]),&
            gamt_Km,gamq_kgkgm/)
    ENDIF

    RETURN

  END SUBROUTINE CBL

  !-----------------------------------------------------------------------
  !-----------------------------------------------------------------------
  SUBROUTINE CBL_ReadInputData
    USE allocateArray
    USE data_in
    USE sues_data
    USE cbl_module
    USE initial
    USE WhereWhen

    IMPLICIT NONE

    INTEGER::i, ios
    REAL(KIND(1d0))::l

    NAMELIST/CBLInput/EntrainmentType,&
         QH_choice,&
         isubs,&
         CO2_included,&
         cblday,&
         wsb,&
         InitialData_use,&
         InitialDataFileName,&
         sondeflag,&
         FileSonde


    OPEN(51,file=TRIM(FileInputPath)//'CBLInput.nml',status='old', err=24)
    READ(51,nml=CBLInput,err=24)
    CLOSE(51)

    !Read initial values if it's needed
    IF(InitialData_use==1 .OR. InitialData_use==2)THEN
       OPEN(52,file=TRIM(FileInputPath)//TRIM(InitialDataFileName),status='old', err=25)
       READ(52,*)
       nlineInData = 0   !Initialise nlines
       DO
          READ(52,*, iostat=ios) l
          IF(ios<0 .OR. l == -9) EXIT   !IF (l == -9) EXIT
          nlineInData = nlineInData + 1
       ENDDO
       CLOSE(52)

       ALLOCATE(IniCBLdata(1:nlineInData,1:8))
       OPEN(52,file=TRIM(FileInputPath)//TRIM(InitialDataFileName),status='old', err=25)
       READ(52,*)
       DO i=1,nlineInData
          READ(52,*)IniCBLdata(i,1:8)
       ENDDO
       CLOSE(52)
    ENDIF

    IF(CO2_included==0)THEN
       fcbl=0       ! hard-wire no CO2
    ENDIF

    iCBLcount=0

    RETURN

24  CALL ErrorHint(24,'CBLInput.nml',0.00D0,0.000D0,0)
25  CALL ErrorHint(24,TRIM(FileInputPath)//TRIM(InitialDataFileName),0.00D0,0.00D0,0)

  END SUBROUTINE CBL_ReadInputData

  !----------------------------------------------------------------------
  !-----------------------------------------------------------------------
  SUBROUTINE CBL_initial(qh_use,qe_use,tm_K_zm,qm_gkg_zm,startflag,Gridiv)

    USE mod_z
    USE mod_k
    USE gas
    USE time
    USE data_in
    USE sues_data
    USE moist
    USE allocateArray
    USE defaultNotUsed
    USE cbl_module
    USE gis_data
    USE WhereWhen
    USE meteo,ONLY:sat_vap_press_x

    IMPLICIT NONE

    REAL(KIND(1d0))::qh_use,qe_use,tm_K_zm,qm_gkg_zm
    REAL(KIND(1d0))::lv
    INTEGER::i,nLineDay,Gridiv,startflag


    qh_use=qhforCBL(Gridiv)   !HCW 21 Mar 2017
    qe_use=qeforCBL(Gridiv)
    IF(qh_use<-900.OR.qe_use<-900)THEN  ! observed data has a problem
       CALL ErrorHint(22,'Unrealistic qh or qe_value for CBL.',qh_use,qe_use,qh_choice)
    ENDIF
    !!Heat flux choices - these are now made in SUEWS_Calculations for qhforCBL and qeCBL, rather than here
    !IF(Qh_choice==1) THEN   !from SUEWS
    !   !qh_use=qh
    !   !qe_use=qeph
    !   qh_use=qhforCBL(Gridiv)   !HCW 21 Mar 2017
    !   qe_use=qeforCBL(Gridiv)
    !ELSEIF(qh_choice==2)THEN !from LUMPS
    !   qh_use=H_mod
    !   qe_use=E_mod
    !ELSEIF(qh_choice==3)THEN  !from OBS
    !   IF(qh_obs<-900.OR.qe_obs<-900)THEN  ! observed data has a problem
    !      CALL ErrorHint(22,'Unrealistic observed qh or qe_value.',qh_obs,qe_obs,qh_choice)
    !   ENDIF
    !   qh_use=qh_obs
    !   qe_use=qe_obs
    !ENDIF


    blh_m=NAN
    iCBLcount=iCBLcount+1
    !write(*,*) 'cblinitial', DateTIme, iCBLcount
    dataOutBL(iCBLcount,1:ncolumnsdataOutBL,Gridiv)=(/REAL(iy,8),REAL(id,8),REAL(it,8),REAL(imin,8),dectime, &
         (NAN,is=6,ncolumnsdataOutBL)/)

    nLineDay=0
    DO i=1,nlineInData
       IF (INT(IniCBLdata(i,1))<=id)THEN
          nLineDay=nLineDay+1
       ENDIF
    ENDDO


    IF(InitialData_use==2) THEN
       blh_m=IniCBLdata(nLineDay,2)
       gamt_Km=IniCBLdata(nLineDay,3)
       gamq_gkgm=IniCBLdata(nLineDay,4)
       tp_K=IniCBLdata(nLineDay,5)
       qp_gkg=IniCBLdata(nLineDay,6)
       tm_K=IniCBLdata(nLineDay,7)
       qm_gkg=IniCBLdata(nLineDay,8)
    ELSEIF(InitialData_use==1 .AND. IniCBLdata(nlineDay,1)==id)THEN   ! Changed from i to nlineDay, HCW 29 March 2017
       blh_m=IniCBLdata(nLineDay,2)
       gamt_Km=IniCBLdata(nLineDay,3)
       gamq_gkgm=IniCBLdata(nLineDay,4)
       tm_K_zm=(Temp_C+C2K)*((1000/Press_hPa)**(gas_ct_dry/avcp))
       tm_K=tm_K_zm-psyh*qh_use/(k*UStar*avcp*avdens)
       es_hPa=sat_vap_press_x(Temp_C,Press_hPa,1,dectime)
       qm_gkg_zm=622*avrh/(100*Press_hPa/es_hPa-avrh)
       lv=(2500.25-2.365*temp_C)*1000
       qm_gkg=qm_gkg_zm-psyh*qe_use/(k*UStar*avdens*lv)
       tp_K=tm_K
       qp_gkg=qm_gkg
    ELSEIF(InitialData_use==0)THEN
       blh_m=241.5
       gamt_Km=0.043
       gamq_gkgm=0.0092
       tm_K_zm=(Temp_C+C2K)*((1000/Press_hPa)**(gas_ct_dry/avcp))
       tm_K=tm_K_zm-psyh*qh_use/(k*UStar*avcp*avdens)
       es_hPa=sat_vap_press_x(Temp_C,Press_hPa,1,dectime)
       qm_gkg_zm=622*avrh/(100*Press_hPa/es_hPa-avrh)
       lv=(2500.25-2.365*temp_C)*1000
       qm_gkg=es_hPa-psyh*qe_use/(k*UStar*avdens*lv)
       tp_K=tm_K
       qp_gkg=qm_gkg
    ENDIF

    gamq_kgkgm=gamq_gkgm/1000.
    qp_kgkg=qp_gkg/1000    !humidities: g/kg -> kg/kg   q+
    qm_kgkg=qm_gkg/1000    !conc at mixing layer height h
    tp_C=tp_K-C2K
    tm_C=tm_K-C2K

    ! IF(sondeflag==1 .AND. cblday(id)==1) THEN
    IF(sondeflag==1 .AND. IniCBLdata(id,2)/=-999) THEN
       !if gamma theta varies with z (selected by setting gthetaflag=1)
       !if gamma q varies with z (selected by setting ghumflag=1)
       CALL sonde(id)
       gamt_Km=0
       gamq_kgkgm=0
    ENDIF

    !adjusting qp and pm in case of saturation
    IF(qp_kgkg>qsatf(tp_C,Press_hPa).OR.qp_kgkg<0)THEN
       qp_kgkg = qsatf(tp_C,Press_hPa)
    ENDIF
    IF(qm_kgkg>qsatf(tm_C,Press_hPa).OR.qm_kgkg<0) THEN
       qm_kgkg = qsatf(tm_C,Press_hPa)
    ENDIF

    !    if((CBLuse==2).and.(zenith_deg>=90))then
    !    blh_m=188
    !    endif
    startflag=0


  END SUBROUTINE CBL_initial

  SUBROUTINE NBL(qh_use,qe_use,tm_K_zm,qm_gkg_zm,startflag,Gridiv)

    USE mod_z
    USE mod_k
    USE gas
    USE time
    USE data_in
    USE sues_data
    USE moist
    USE allocateArray
    USE defaultNotUsed
    USE cbl_module
    USE gis_data
    USE WhereWhen
    USE meteo,ONLY:sat_vap_press_x

    IMPLICIT NONE
    REAL(KIND(1d0))::qh_use,qe_use,tm_K_zm,qm_gkg_zm
    REAL(KIND(1d0))::lv
    INTEGER::i,nLineDay,Gridiv,startflag

    qh_use=qhforCBL(Gridiv)   !HCW 21 Mar 2017
    qe_use=qeforCBL(Gridiv)
    IF(qh_use<-900.OR.qe_use<-900)THEN  ! observed data has a problem
       CALL ErrorHint(22,'Unrealistic qh or qe_value for CBL.',qh_use,qe_use,qh_choice)
    ENDIF

    nLineDay=0
    DO i=1,nlineInData
       IF (INT(IniCBLdata(i,1))<=id)THEN
          nLineDay=nLineDay+1
       ENDIF
    ENDDO

    !Assume Theta and Q in the night constantly Equal to the ones in the morning for CBL to run
    ! seems incorrect initialisation
    ! tm_K=IniCBLdata(nLineDay,7)*1000
    ! qm_gkg=IniCBLdata(nLineDay,8)*1000

    ! corrected to the following, TS 20170609:
    tm_K=IniCBLdata(nLineDay,7)
    qm_gkg=IniCBLdata(nLineDay,8)

    !NBL currently fixed to 200 m
    blh_m=200

    ! also fill in other variables
    gamt_Km=IniCBLdata(nLineDay,3)
    gamq_gkgm=IniCBLdata(nLineDay,4)
    tp_K=IniCBLdata(nLineDay,5)
    qp_gkg=IniCBLdata(nLineDay,6)
    tm_K=IniCBLdata(nLineDay,7)
    qm_gkg=IniCBLdata(nLineDay,8)

    iCBLcount=iCBLcount+1
    ! dataOutBL(iCBLcount,1:ncolumnsdataOutBL,Gridiv)=(/REAL(iy,8),REAL(id,8),REAL(it,8),REAL(imin,8),&
    ! dectime,blh_m,tm_K,qm_gkg,&
    ! (NAN,is=9,ncolumnsdataOutBL)/)

    Temp_C=tm_K/((1000/Press_hPa)**(gas_ct_dry/avcp))-C2K
    es_hPa=sat_vap_press_x(Temp_C,Press_hPa,1,dectime)
    lv=(2500.25-2.365*Temp_C)*1000
    !qm_gkg_zm=qm_gkg+cbldata(10)*cbldata(3)/(k*cbldata(8)*cbldata(4)*lv)
    avrh=100*((qm_gkg*Press_hPa/(622+qm_gkg))/es_hPa) !check pressure
    IF(avrh>100)THEN
       CALL errorHint(34,'subroutine CBL dectime, relative humidity',dectime,avrh,100)
       avrh=100
    ENDIF

    dataOutBL(iCBLcount,1:ncolumnsdataOutBL,Gridiv)=&
         (/REAL(iy,8),REAL(id,8),REAL(it,8),REAL(imin,8),dectime,&
         blh_m,tm_K,qm_gkg,&
         tp_K,qp_gkg,&
         Temp_C,avrh,qh_use,qe_use,Press_hPa,avu1,UStar,avdens,lv_J_kg,avcp,&
         gamt_Km,gamq_kgkgm/)

    IF(InitialData_use==2) THEN
       blh_m=IniCBLdata(nLineDay,2)
       gamt_Km=IniCBLdata(nLineDay,3)
       gamq_gkgm=IniCBLdata(nLineDay,4)
       tp_K=IniCBLdata(nLineDay,5)
       qp_gkg=IniCBLdata(nLineDay,6)
       tm_K=IniCBLdata(nLineDay,7)
       qm_gkg=IniCBLdata(nLineDay,8)
    ELSEIF(InitialData_use==1 .AND. IniCBLdata(nlineDay,1)==id)THEN   ! Changed from i to nlineDay, HCW 29 March 2017
       blh_m=IniCBLdata(nLineDay,2)
       gamt_Km=IniCBLdata(nLineDay,3)
       gamq_gkgm=IniCBLdata(nLineDay,4)
       tm_K_zm=(Temp_C+C2K)*((1000/Press_hPa)**(gas_ct_dry/avcp))
       tm_K=tm_K_zm-psyh*qh_use/(k*UStar*avcp*avdens)
       es_hPa=sat_vap_press_x(Temp_C,Press_hPa,1,dectime)
       qm_gkg_zm=622*avrh/(100*Press_hPa/es_hPa-avrh)
       lv=(2500.25-2.365*temp_C)*1000
       qm_gkg=qm_gkg_zm-psyh*qe_use/(k*UStar*avdens*lv)
       tp_K=tm_K
       qp_gkg=qm_gkg
    ELSEIF(InitialData_use==0)THEN
       blh_m=241.5
       gamt_Km=0.043
       gamq_gkgm=0.0092
       tm_K_zm=(Temp_C+C2K)*((1000/Press_hPa)**(gas_ct_dry/avcp))
       tm_K=tm_K_zm-psyh*qh_use/(k*UStar*avcp*avdens)
       es_hPa=sat_vap_press_x(Temp_C,Press_hPa,1,dectime)
       qm_gkg_zm=622*avrh/(100*Press_hPa/es_hPa-avrh)
       lv=(2500.25-2.365*temp_C)*1000
       qm_gkg=es_hPa-psyh*qe_use/(k*UStar*avdens*lv)
       tp_K=tm_K
       qp_gkg=qm_gkg
    ENDIF

    gamq_kgkgm=gamq_gkgm/1000.
    qp_kgkg=qp_gkg/1000    !humidities: g/kg -> kg/kg   q+
    qm_kgkg=qm_gkg/1000    !conc at mixing layer height h
    tp_C=tp_K-C2K
    tm_C=tm_K-C2K

    ! IF(sondeflag==1 .AND. cblday(id)==1) THEN
    IF(sondeflag==1 .AND. IniCBLdata(id,2)/=-999) THEN
       !if gamma theta varies with z (selected by setting gthetaflag=1)
       !if gamma q varies with z (selected by setting ghumflag=1)
       CALL sonde(id)
       gamt_Km=0
       gamq_kgkgm=0
    ENDIF

    !adjusting qp and pm in case of saturation
    IF(qp_kgkg>qsatf(tp_C,Press_hPa).OR.qp_kgkg<0)THEN
       qp_kgkg = qsatf(tp_C,Press_hPa)
    ENDIF
    IF(qm_kgkg>qsatf(tm_C,Press_hPa).OR.qm_kgkg<0) THEN
       qm_kgkg = qsatf(tm_C,Press_hPa)
    ENDIF

    startflag=0
  END SUBROUTINE NBL

  !------------------------------------------------------------------------


  !-----------------------------------------------------------------------
  ! from CBL modelling Cleugh and Grimmond (2000) BLM
  ! NT 6 Apr 2017: include iteration over top of CBL scalars and include subsidence flag
  ! Last modified: LJ 27 Jan 2016 - Removal of tabs
  !-----------------------------------------------------------------------
  SUBROUTINE RKUTTA(neqn,XA,XB,Y,NSTEPS)
    !       XA=s0
    !       XB=s1
    !       Y(1)=blh_m
    !       Y(2)=tm_K
    !       Y(3)=qm_kgkg
    !       Y(4)=cm
    !       Y(5)=tp_K
    !       Y(6)=qp_kgkg
    !       JOHN KNIGHT, 1985 (AMENDED BY MRR, 23-SEP-85)
    !       EXPLICIT FOURTH-ORDER RUNGE-KUTTA METHOD FOR FIRST-ORDER ODE SYSTEM
    !       OF NE EQUATIONS, WITH INITIAL VALUES SUPPLIED.
    !       MEANING OF PARAMETERS:
    !       NE     = NUMBER OF EQUATIONS (MAX 21)
    !       XA     = VALUE OF INDEPENDENT VARIABLE ON ENTRY
    !       XB     = VALUE OF INDEPENDENT VARIABLE AT END OF INTERVAL
    !       Y(NE)  = ON ENTRY: INITIAL VALUES OF DEPENDENT VARIABLES AT XA
    !       ON EXIT:  CALCULATED VALUES OF DEPENDENT VARIABLES AT XB
    !       NSTEPS = NUMBER OF INTEGRATION STEPS OVER INTERVAL (XA,XB)
    !       DIFF  = NAME OF USER-SUPPLIED SUBROUTINE TO CALCULATE DERIVATIVES
    !       DYDX (DIFF MUST BE DECLARED EXTERNAL IN CALLING PROGRAM).
    !       PARAMETERS IN SUBROUTINE DIFF(NE,X,Y,DYDX):
    !       NEqn = NUMBER OF EQUATIONS
    !       X = INDEPENDENT VARIABLE
    !       Y = ARRAY (LENGTH NE) OF VALUES OF DEPENDENT VARIABLES
    !       DYDX = ON EXIT, ARRAY (LENGTH NE) OF VALUES OF DERIVATIVES
    !	IMPLICIT real*8 (A-H,O-Z)
    IMPLICIT NONE
    INTEGER::ns,nsteps, nj,n,neqn
    REAL(KIND(1D0)), DIMENSION (neqn):: y
    REAL(KIND(1D0)), DIMENSION (21):: dydx,arg
    REAL(KIND(1D0)), DIMENSION (21,5):: rk
    REAL(KIND(1D0)), DIMENSION (4):: coef
    REAL (KIND(1D0)):: XA,XB,step,X,xx

    coef(1)=1.0
    coef(2)=0.5
    coef(3)=0.5
    coef(4)=1.0
    !	print*,"rk1: ",xa,xb,y
    STEP = (XB-XA)/NSTEPS

    DO NS = 1,NSTEPS
       DO  NJ = 1,nEqn
          RK(NJ,1) = 0
       ENDDO
       X = XA+(NS-1)*STEP
       DO N = 1,4
          IF (N==1)THEN
             XX = X
          ELSEIF (N>1)THEN
             XX = X + COEF(N)*STEP
          ENDIF

          DO NJ = 1,nEqn
             ARG(NJ) = Y(NJ) + COEF(N)*RK(NJ,N)
          ENDDO

          CALL DIFF(xx,ARG,DYDX)

          DO NJ = 1,nEqn
             RK(NJ,N+1) = STEP*DYDX(NJ)
          ENDDO
       ENDDO

       DO  NJ = 1,nEqn
          DO  N = 1,4
             Y(NJ) = Y(NJ) + RK(NJ,N+1)/(6*COEF(N))
          ENDDO
       ENDDO
    ENDDO

    RETURN
  END SUBROUTINE RKUTTA
  !---------------------------------------------------------------------
  !---------------------------------------------------------------------

  SUBROUTINE diff(s,y1,dyds)
    ! in y1,neqn
    ! out dyds

    !       calculates derivatives for cbl slab model
    !       y(1) = h = cbl depth(m)
    !       y(2) = t = potential temp(K)
    !       y(3) = q = specific humidity(kg/kg)
    !       y(4) = c = CO2 concentration
    USE data_in
    USE sues_data
    !    use allocateArray
    USE time
    USE CBL_MODULE
    USE defaultnotUsed
    USE mod_grav

    IMPLICIT NONE
    REAL(KIND(1D0)), DIMENSION(neqn)::dyds,y1
    REAL(KIND(1d0)) :: zero=0.0
    REAL(KIND(1d0)) :: h1,t_K,q_kgkg,c,cp,ws,s,foo
    !     real(kind(1D0)) :: tp_K,qp_kgkg
    REAL(KIND(1D0)):: delt_K,delq_kgkg,delc
    REAL(KIND(1D0)):: gamtv_Km,deltv_K,ftv_Kms
    REAL(KIND(1D0)):: ftva_Kms,delb,qs2,qs3
    REAL(KIND(1D0)):: dhds,dtds,dqds,dcds,dtpds,dqpds
    REAL(KIND(1D0)):: conk,conn,cona,conc,cont

    !    print*,"diff: timestamp:",s
    foo=s
    !    pause
    h1     = y1(1)!m
    t_K    = y1(2)!K
    q_kgkg = y1(3)!kg/kg
    c      = y1(4)
    tp_K   = y1(5)!K
    qp_kgkg= y1(6)!kg/kg

    !       find t, q, c above inversion, and jumps across inversion
    !       tp = tp + gamt*h
    !       qp = qp0 + gamq*h

    cp        = 0 ! cp0 + gamc* h1   ! todo

    delt_K    = tp_K    - t_K
    delq_kgkg = qp_kgkg - q_kgkg
    delc      = cp - c

    !       find potential virtual temperature flux, gradient and jump
    ftv_Kms  = fhbl_Kms + 0.61 * tm_K * febl_kgkgms
    gamtv_Km = gamt_Km  + 0.61 * tm_K * gamq_kgkgm!/1000
    deltv_K  = delt_K   + 0.61 * tm_K * delq_kgkg

    !       find velocity scale ws
    ftva_Kms = MAX(ftv_Kms,zero) ! virtual heat flux
    ws = (h1*ftva_Kms*grav/tm_K)**0.3333333333

    !       find dhds using one of 4 alternative schemes chosen by ient:
    IF (EntrainmentType==2) THEN
       !       EntrainmentType=1: encroachment (as in McN and S 1986 eq 16))
       dhds = ftva_Kms/(h1*gamtv_Km)

    ELSE IF (EntrainmentType==1) THEN
       !       EntrainmentType=2: Driedonks 1981 (as in McN and S 1986 eq 13)
       IF (deltv_K<=0.01) THEN
          dhds = ftva_Kms/(h1*gamtv_Km)
          CALL errorHint(30,"subroutine diff [CBL: Deltv_K<0.01 EntrainmentType=1], deltv_K,delt_K,",deltv_K,delt_K,notUsedI)
          CALL errorHint(30,"subroutine diff [CBL: Deltv_K<0.01 EntrainmentType=1], tm_K,TPP_K,y1",tm_K,TPP_K, notUsedI)
          ! call errorHint(31,"subroutine diff [CBL: Deltv_K<0.01 EntrainmentType=1], y1",real(y1(1),kind(1d0)),notUsed,notUsedI)
       ELSE
          delb = grav*deltv_K/tm_K
          conc = 0.2
          cona = 5.0
          dhds = (conc*ws**3 + cona*cbldata(8)**3)/(h1*delb)
       END IF

    ELSE IF (EntrainmentType==4) THEN
       !       EntrainmentType=3: Tennekes 1973 (as in R 1991 eqs 3,4)
       alpha3=0.2   ! alpha changed back to original Tennekes 1973 value
       IF (deltv_K<=0.01) THEN
          dhds = ftva_Kms/(h1*gamtv_Km)
          CALL ErrorHint(31, 'subroutine difflfnout: [CBL: deltv_K<0.01 EntrainmentType=4],deltv_K',&
               deltv_K,notUsed,notUsedI)
       ELSE
          ! include the option whether or not to include subsidence
          IF (isubs==1) THEN
             dhds = alpha3*ftva_Kms/deltv_k + wsb
          ELSE
             dhds = alpha3*ftva_Kms/deltv_K
          END IF
       END IF

       !       write (4,*) tpp, gamq, dhds, deltv

    ELSE IF (EntrainmentType==3) THEN
       !       EntrainmentType=4: Rayner and Watson 1991 eq 21
       conn = 1.33
       conk = 0.18
       cont = 0.80
       qs3 = ws**3 + (conn*cbldata(8))**3
       qs2 = qs3**(0.6666666667)

       IF (deltv_K<=0.01) THEN
          dhds = ftva_Kms/(h1*gamtv_Km)
          CALL ErrorHint(31, 'subroutine difflfnout: [CBL: deltv_K<0.01 EntrainmentType=3],deltv_K',&
               deltv_K,notUsed,notUsedI)

       ELSE
          delb = grav*deltv_K/tm_K
          dhds = (conk*qs3) / (cont*qs2 + h1*delb)
       END IF

    ELSE
       CALL ErrorHint(24, 'BLUEWS_DIff- CBL- illegal alpha',notUsed,notUsed,notUsedI)
    END IF
    ! find dtds, dqds, dc/ds:
    !	wsb is the subsidence velocity. Try using: -0.01, -0.05, -0.1.
    IF (isubs==1) THEN
       dtds = fhbl_Kms/h1    + delt_K    *(dhds-wsb)/h1
       dqds = febl_kgkgms/h1 + delq_kgkg *(dhds-wsb)/h1
       dcds = fcbl/h1        + delc      *(dhds-wsb)/h1
       ! also iterate the top of CBL scalars
       dtpds = gamt_Km * (dhds-wsb)
       dqpds = gamq_kgkgm * (dhds-wsb)
    ELSE
       dtds = fhbl_Kms/h1    + delt_K    *(dhds)/h1
       dqds = febl_kgkgms/h1 + delq_kgkg *(dhds)/h1
       dcds = fcbl/h1        + delc      *(dhds)/h1
       ! also iterate the top of CBL scalars
       dtpds = gamt_Km * (dhds)
       dqpds = gamq_kgkgm * (dhds)
    END IF

    dyds(1) = dhds
    dyds(2) = dtds
    dyds(3) = dqds
    dyds(4) = dcds
    dyds(5) = dtpds
    dyds(6) = dqpds


    RETURN
  END SUBROUTINE diff

  !--------------------------------------------------------------------------
  !--------------------------------------------------------------------------
  SUBROUTINE sonde(id)
    ! read sonde or vertical profile data - when available
    !use allocateArray
    USE data_in
    USE cbl_module
    IMPLICIT NONE
    INTEGER::i,fn=101,izm=500,notUsedI=-9999,id
    CHARACTER (len=200)::FileN
    REAL (KIND(1d0)):: dxx
    REAL (KIND(1d0)),PARAMETER::notUsed=-9999.99

    FileN=TRIM(FileInputPath)//TRIM(FileSonde(id))
    OPEN(fn,file=FileN,status="old",err=24)
    ! todo gneric skip header
    READ(fn,*)
    READ(fn,*)
    READ(fn,*)

    DO i=1,1000
       READ(fn,*,END=900,err=25)gtheta(i,1),dxx,gtheta(i,2),ghum(i,1),dxx,ghum(i,2)
       ghum(i,2) = ghum(i,2)
    ENDDO
900 zmax=i-1
    IF(zmax>izm)THEN
       CALL ErrorHint(23,FileN,REAL(zmax,KIND(1D0)),notUsed,izm)
    ENDIF
    CLOSE(fn)
    RETURN
24  CALL ErrorHint(24,FileN,notUsed,notUsed, notUsedI)
25  CALL ErrorHint(25,FileN,notUsed,notUsed,i)
    RETURN
  END SUBROUTINE sonde
  !------------------------------------------------------------------------------
  !------------------------------------------------------------------------------
  SUBROUTINE gamma_sonde
    USE cbl_module
    !use allocateArray

    IMPLICIT NONE
    REAL(KIND(1D0))::gamtt,gamqq
    INTEGER::j
    ! gtheta(i,1),dxx,gtheta(i,2),ghum(i,1),dxx,ghum(i,2)
    !search for correct gamma theta, depends on h(i-1),
    !               ie current value for mixed layer depth
    IF (sondeflag==1) THEN
       DO j=2,zmax
          IF (blh_m>=gtheta(j-1,1)) THEN
             gamtt = gtheta(j-1,2)
          ENDIF
          gamt_Km = gamtt
       ENDDO

       DO j=2,zmax
          IF (blh_m>=ghum(j-1,1)) THEN
             gamqq = ghum(j-1,2)
          ENDIF
          gamq_kgkgm = gamqq/1000.
       ENDDO
    ENDIF
    RETURN

  END SUBROUTINE gamma_sonde




END MODULE BLUEWS_module

MODULE WaterDist_module

  IMPLICIT NONE
CONTAINS

  SUBROUTINE drainage(&
       is,& !input
       state_is,&
       StorCap,&
       DrainEq,&
       DrainCoef1,&
       DrainCoef2,&
       nsh_real,&
       drain_is)!output

    !Calculation of drainage for each land surface.
    !INPUT: Storage capacity, type of drainage equation used, drainage coefficients
    !       used in the equation
    !Modified by HCW 16 Feb 2015
    !  Removed option of Eq 4 (calculation needs to be checked before re-implementing).
    !  Code writes an error if calculated drainage exceeds surface state_id (but code continues).
    !  This may indicate inappropriate drainage equation, storage capacities or model tstep.
    !Modified by LJ in Aug 2011. Drainage cannot exceed the surface storage.
    !Modified LJ in 10/2010
    !------------------------------------------------------------------------------

    ! use allocateArray
    ! use gis_data
    ! use sues_data
    ! use time

    IMPLICIT NONE
    INTEGER,INTENT(in)::&
         is ! surface type number
    REAL (KIND(1d0)),INTENT(in)::&
         state_is,  &!Wetness status of surface type "is" [mm]
         StorCap,   &!current storage capacity [mm]
         DrainCoef1,&!Drainage coeff 1 [units depend on choice of eqn]
         DrainCoef2,&!Drainage coeff 2 [units depend on choice of eqn]
         DrainEq,   &!Drainage equation to use
         nsh_real    !nsh cast as a real for use in calculations
    REAL (KIND(1d0)),INTENT(out)::&
         drain_is!Drainage of surface type "is" [mm]


    !If surface is dry, no drainage occurs
    IF(state_is<0.000000001) THEN
       drain_is=0.0
    ELSE
       IF(INT(DrainEq)==1) THEN   !Falk and Niemczynowicz (1978): Drainage equation for paved, buildings and irrigated grass

          IF (state_is<StorCap) THEN
             drain_is=0   !No drainage if state_id is less than storage capacity
          ELSE
             drain_is=(DrainCoef1*(state_is-StorCap)**DrainCoef2)/nsh_real
          ENDIF

       ELSEIF(INT(DrainEq)==2) THEN   !Rutter eqn corrected for c=0, see Eq 9 of Calder & Wright 1986
          drain_is=(DrainCoef1*(EXP(DrainCoef2*state_is)-1))/nsh_real
          ! N.B. -1 is correct here but brackets are wrong in G&O 1991 Eq 5 & Ja11 Eq 18.

       ELSEIF(INT(DrainEq)==3) THEN   !Falk and Niemczynowicz (1978)
          drain_is=(DrainCoef1*(state_is**DrainCoef2))/nsh_real

       ENDIF

       ! Check value obtained is physically reasonable
       ! More water cannot drain than is in the surface state_id
       ! although high initial rate of drainage tries to drain more water than is in state_id within tstep
       ! May indicate shorter tstep needed, or a more suitable equation
       IF (drain_is>state_is) THEN
          !write(*,*) 'Drainage:', is, drain(is), state_id(is), drain(is)-state_id(is), DrainEq, DrainCoef1, DrainCoef2, nsh_real
          CALL ErrorHint(61,'SUEWS_drain: drain_is > state_is for surface is ',drain_is,state_is,is)
          drain_is=state_is   !All water in state_id is drained (but no more)
       ELSEIF(drain_is<0.0001) THEN
          drain_is=0
       ENDIF
    ENDIF

    RETURN

  END SUBROUTINE drainage
  !------------------------------------------------------------------------------

  SUBROUTINE soilstore(&
       is,& ! input: ! surface type
       sfr,&! surface fractions
       PipeCapacity,&!Capacity of pipes to transfer water
       RunoffToWater,&!Fraction of surface runoff going to water body
       pin,&!Rain per time interval
       wu_EveTr,&!Water use for evergreen trees/shrubs [mm]
       wu_DecTr,&!Water use for deciduous trees/shrubs [mm]
       wu_Grass,&!Water use for grass [mm]
       drain,&!Drainage of each surface type [mm]
       AddWater,&!Water from other surfaces (WGWaterDist in SUEWS_ReDistributeWater.f95) [mm]
       addImpervious,&!Water from impervious surfaces of other grids [mm] for whole surface area
       nsh_real,&!nsh cast as a real for use in calculations
       stateOld,&!Wetness status of each surface type from previous timestep [mm]
       AddWaterRunoff,&!Fraction of water going to runoff/sub-surface soil (WGWaterDist) [-]
       PervFraction,&! sum of surface cover fractions for impervious surfaces
       addVeg,&!Water from vegetated surfaces of other grids [mm] for whole surface area
       soilstoreCap,&!Capacity of soil store for each surface [mm]
       addWaterBody,&!Water from water surface of other grids [mm] for whole surface area
       FlowChange,&!Difference between the input and output flow in the water body
       StateLimit,&!Limit for state_id of each surface type [mm] (specified in input files)
       runoffAGimpervious,&!  inout:!Above ground runoff from impervious surface [mm] for whole surface area
       surplusWaterBody,&!Extra runoff that goes to water body [mm] as specified by RunoffToWater
       runoffAGveg,&!Above ground runoff from vegetated surfaces [mm] for whole surface area
       runoffPipes,&!Runoff in pipes [mm] for whole surface area
       ev,&!Evaporation
       soilmoist_id,&!Soil moisture of each surface type [mm]
       SurplusEvap,&!Surplus for evaporation in 5 min timestep
       runoffWaterBody,&!Above ground runoff from water surface [mm] for whole surface area
       runoff_per_interval,&! Total water transported to each grid for grid-to-grid connectivity
       p_mm,&!output: !Inputs to surface water balance
       chang,&!Change in state_id [mm]
       runoff,&!Runoff from each surface type [mm]
       state_id&!Wetness status of each surface type [mm]
       )
    !------------------------------------------------------------------------------
    !Calculation of storage change
    ! LJ 27 Jan 2016
    !   -Removed tabs and cleaned the code
    ! HCW 08 Dec 2015
    !   -Added if-loop check for no Paved surfaces
    ! LJ 6 May 2015
    !   - Calculations of the piperunoff exceedings moved to separate subroutine updateFlood.
    !   - Now also called from snow subroutine
    !   - Evaporation is modified using EvapPart
    !   - when no water on impervious surfaces, evap occurs above pervious surfaces instead
    ! Rewritten by HCW 12 Feb 2015
    !   - Old variable 'p' for water input to the surface renamed to 'p_mm'
    !   - All water now added to p_mm first, before threshold checks or other calculations
    !   - Water from other grids now added to p_mm (instead of state_id for impervious surfaces)
    !   - Removed division of runoff by nsh, as whole model now runs at the same timestep
    !   - Adjusted transfer of ev between surfaces to conserve mass (not depth)
    !   - Volumes used for water transport between grids to account for SurfaceArea changing between grids
    !   - Added threshold check for state_id(WaterSurf) - was going negative
    ! Last modified HCW 09 Feb 2015
    !   - Removed StorCap input because it is provided by module allocateArray
    !   - Tidied and commented code
    ! Modified by LJ in November 2012:
    !   - P>10 was not taken into account for impervious surfaces - Was fixed.
    !   - Above impervious surfaces possibility of the state_id to exceed max capacity was limited
    !     although this should be possible - was fixed
    ! Modified by LJ 10/2010
    ! Rewritten mostly by LJ in 2010
    ! To do:
    !   - Finish area normalisation for RG2G & finish coding GridConnections
    !   - What is the 10 mm hr-1 threshold for?
    !  - Decide upon and correct storage capacities here & in evap subroutine
    !  - FlowChange units should be mm hr-1 - need to update everywhere
    !   - Add SurfaceFlood(is)?
    !   - What happens if sfr(is) = 0 or 1?
    !   - Consider how irrigated trees actually works...
    !------------------------------------------------------------------------------


    IMPLICIT NONE

    !Stores flood water when surface state_id exceeds storage capacity [mm]
    INTEGER, PARAMETER:: nsurf=7                !Total number of surfaces

    INTEGER, PARAMETER:: PavSurf   = 1,&   !When all surfaces considered together (1-7)
         BldgSurf  = 2,&
         ConifSurf = 3,&
         DecidSurf = 4,&
         GrassSurf = 5,&   !New surface classes: Grass = 5th/7 surfaces
         BSoilSurf = 6,&   !New surface classes: Bare soil = 6th/7 surfaces
         WaterSurf = 7
    !  ExcessSurf= 8,&   !Runoff or subsurface soil in WGWaterDist
    !  NSurfDoNotReceiveDrainage=0,&   !Number of surfaces that do not receive drainage water (green roof)
    !  ivConif = 1,&     !When only vegetated surfaces considered (1-3)
    !  ivDecid = 2,&
    !  ivGrass = 3

    INTEGER,INTENT(in)::is ! surface type


    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr! surface fractions
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::AddWater!Water from other surfaces (WGWaterDist in SUEWS_ReDistributeWater.f95) [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::stateOld!Wetness status of each surface type from previous timestep [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::AddWaterRunoff!Fraction of water going to runoff/sub-surface soil (WGWaterDist) [-]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::soilstoreCap!Capacity of soil store for each surface [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::StateLimit!Limit for state_id of each surface type [mm] (specified in input files)

    REAL(KIND(1d0)),INTENT(in)::PipeCapacity!Capacity of pipes to transfer water
    REAL(KIND(1d0)),INTENT(in)::RunoffToWater!Fraction of surface runoff going to water body
    REAL(KIND(1d0)),INTENT(in)::pin!Rain per time interval
    REAL(KIND(1d0)),INTENT(in)::wu_EveTr!Water use for evergreen trees/shrubs [mm]
    REAL(KIND(1d0)),INTENT(in)::wu_DecTr!Water use for deciduous trees/shrubs [mm]
    REAL(KIND(1d0)),INTENT(in)::wu_Grass!Water use for grass [mm]
    REAL(KIND(1d0)),INTENT(in)::addImpervious!Water from impervious surfaces of other grids [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(in)::nsh_real!nsh cast as a real for use in calculations
    REAL(KIND(1d0)),INTENT(in)::PervFraction! sum of surface cover fractions for impervious surfaces
    REAL(KIND(1d0)),INTENT(in)::addVeg!Water from vegetated surfaces of other grids [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(in)::addWaterBody!Water from water surface of other grids [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(in)::FlowChange!Difference between the input and output flow in the water body


    REAL(KIND(1d0)),INTENT(inout)::runoffAGimpervious!Above ground runoff from impervious surface [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(inout)::surplusWaterBody!Extra runoff that goes to water body [mm] as specified by RunoffToWater
    REAL(KIND(1d0)),INTENT(inout)::runoffAGveg!Above ground runoff from vegetated surfaces [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(inout)::runoffPipes!Runoff in pipes [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(inout)::ev!Evaporation
    REAL(KIND(1d0)),INTENT(inout)::runoffWaterBody!Above ground runoff from water surface [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(inout)::runoff_per_interval! Total water transported to each grid for grid-to-grid connectivity

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::soilmoist_id  !Soil moisture of each surface type [mm]
    REAL(KIND(1d0)),DIMENSION(2),INTENT(inout)    ::SurplusEvap!Surplus for evaporation in 5 min timestep

    REAL(KIND(1d0)),INTENT(out)::p_mm!Inputs to surface water balance

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::chang !Change in state_id [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::runoff!Runoff from each surface type [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in) ::drain !Drainage of each surface type [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::state_id !Wetness status of each surface type [mm]

    !Extra evaporation [mm] from impervious surfaces which cannot happen due to lack of water
    REAL(KIND(1d0)):: EvPart
    REAL(KIND(1d0)),PARAMETER:: NotUsed=-55.5
    REAL(KIND(1d0)),PARAMETER:: IPThreshold_mmhr=10 ! NB:this should be an input and can be specified. SG 25 Apr 2018

    !Initialise extra evaporation to zero
    EvPart=0

    !SurfaceFlood(is) = 0 !!This probably needs to be carried over between timesteps, but reset for now

    !==================================================================
    ! Combine water inputs to the current surface
    ! Add external water use for each surface type
    IF(is==ConifSurf) THEN
       p_mm=pin+wu_EveTr
    ELSEIF(is==DecidSurf) THEN
       p_mm=pin+wu_DecTr
    ELSEIF(is==GrassSurf) THEN
       p_mm=pin+wu_Grass
    ELSE
       p_mm=pin
    ENDIF

    ! Add water from other surfaces within the same grid (RS2S) ----
    ! AddWater is the water supplied to the current surface from other surfaces
    !  i.e. drain*WaterDist (see SUEWS_ReDistributeWater)
    p_mm=p_mm+AddWater(is)

    !==== Impervious surfaces (Paved, Buildings) ======================
    IF(is==PavSurf.OR.is==BldgSurf) THEN

       ! Add water from neighbouring grids (RG2G)
       ! Add to PavSurf only, as water cannot flow onto buildings
       IF (is==PavSurf) THEN
          IF(sfr(PavSurf)/=0) THEN   ! If loop added HCW 08 Dec 2015
             p_mm=p_mm+addImpervious/sfr(PavSurf)
          ENDIF
       ENDIF

       ! Calculate change in surface state_id (inputs - outputs)
       chang(is)=p_mm-(drain(is)+ev)

       ! If p_mm is too large, excess goes to runoff (i.e. the rate of water supply is too fast)
       ! and does not affect state_id
       IF(p_mm>IPThreshold_mmhr/nsh_real) THEN
          runoff(is)=runoff(is)+(p_mm-IPThreshold_mmhr/nsh_real)
          chang(is)=IPThreshold_mmhr/nsh_real-(drain(is)+ev)
       ENDIF

       ! Calculate updated state_id using chang
       ! state_id(is)=state_id(is)+chang(is)
       state_id(is)=stateOld(is)+chang(is)

       ! Check state_id is within physical limits between zero (dry) and max. storage capacity
       IF(state_id(is)<0.0) THEN   ! Cannot have a negative surface state_id
          ! If there is not sufficient water on the surface, then don't allow this evaporation to happen
          ! Allow evaporation only until surface is dry (state_id(is)=0); additional evaporation -> evaporation surplus
          SurplusEvap(is)=ABS(state_id(is))   !Surplus evaporation is that which tries to evaporate non-existent water
          ev = ev-SurplusEvap(is)          !Limit evaporation according to water availability
          state_id(is)=0.0                    !Now surface is dry
          ! elseif (state_id(is)>StoreDrainPrm(6,is)) then   !!This should perhaps be StateLimit(is)
          !    !! If state_id exceeds the storage capacity, then the excess goes to surface flooding
          !    !SurfaceFlood(is)=SurfaceFlood(is)+(state_id(is)-StoreDrainPrm(6,is))   !!Need to deal with this properly
          !    runoff(is)=runoff(is)+(state_id(is)-StoreDrainPrm(6,is))   !!needs to go to flooding
          !    state_id(is)=StoreDrainPrm(6,is)              !Now surface state_id is at max (storage) capacity
       ENDIF

       ! Recalculate change in surface state_id from difference with previous timestep
       chang(is) = state_id(is)-stateOld(is)

       ! Runoff -------------------------------------------------------
       ! For impervious surfaces, some of drain(is) becomes runoff
       runoff(is)=runoff(is)+drain(is)*AddWaterRunoff(is)   !Drainage (that is not flowing to other surfaces) goes to runoff

       !So, up to this point, runoff(is) can have contributions if
       ! p_mm > ipthreshold (water input too fast)
       ! state_id > StoreDrainPrm(6,is) (net water exceeds storage capacity)
       ! WaterDist specifies some fraction of drain(is) -> runoff

       !==== Pervious surfaces (Conif, Decid, Grass, BSoil, Water) =======
    ELSEIF(is>=3) THEN

       ! Transfer evaporation surplus from impervious surfaces to pervious surfaces
       IF(PervFraction/=0) THEN   !If pervious surfaces exist
          EvPart=(SurplusEvap(PavSurf)*sfr(PavSurf)+SurplusEvap(BldgSurf)*sfr(BldgSurf))/PervFraction
       ELSE         !If no pervious surface, SurplusEvap cannot be transferred and this evap cannot
          EvPart=0  !happen (will increase QHinstead)
       ENDIF

       ! Add surplus evaporation to ev for pervious surfaces
       ev=ev+EvPart

       !==== For Conif, Decid, Grass, BSoil surfaces ==================
       IF (is/=WaterSurf) THEN

          ! ---- Add water from neighbouring grids (RG2G) ----
          ! Add to Grass and BSoil only, as water cannot flow onto trees
          IF (is==GrassSurf.OR.is==BSoilSurf) THEN
             IF ((sfr(GrassSurf)+sfr(BSoilSurf))/=0) THEN
                p_mm=p_mm+addVeg/(sfr(GrassSurf)+sfr(BSoilSurf))
             ENDIF
          ENDIF

          ! Calculate change in surface state_id (inputs - outputs)
          chang(is)=p_mm-(drain(is)+ev)

          ! If p_mm is too large, excess goes to runoff (i.e. the rate of water supply is too fast)
          !  and does not affect state_id
          IF (p_mm>IPThreshold_mmhr/nsh_real) THEN
             runoff(is)=runoff(is)+(p_mm-IPThreshold_mmhr/nsh_real)
             chang(is)=IPThreshold_mmhr/nsh_real-(drain(is)+ev)
          ENDIF

          ! Calculate updated state_id using chang
          ! state_id(is)=state_id(is)+chang(is)
          state_id(is)=stateOld(is)+chang(is)

          ! Check state_id is within physical limits between zero (dry) and max. storage capacity
          IF(state_id(is)<0.0) THEN   ! Cannot have a negative surface state_id
             ! If there is not sufficient water on the surface, then remove water from soilstore
             ! Allow evaporation until soilmoist_id is depleted and surface is dry
             IF((soilmoist_id(is)+state_id(is))>=0) THEN
                soilmoist_id(is)=soilmoist_id(is)+state_id(is)
                state_id(is)=0.0
                ! If there is not sufficient water on the surface or soilstore, then don't allow this evaporation to happen
             ELSE
                ev=ev-ABS(state_id(is))   !Limit evaporation according to water availability
                state_id(is)=0.0          !Now surface is dry
             ENDIF

             !elseif (state_id(is)>StoreDrainPrm(6,is)) then   !!This should perhaps be StateLimit(is)
             !   !! If state_id exceeds the storage capacity, then the excess goes to surface flooding
             !   !SurfaceFlood(is)=SurfaceFlood(is)+(state_id(is)-StoreDrainPrm(6,is))   !!Need to deal with this properly
             !   runoff(is)=runoff(is)+(state_id(is)-StoreDrainPrm(6,is))   !!needs to go to flooding
             !   state_id(is)=StoreDrainPrm(6,is)              !Now surface state_id is at max (storage) capacity
          ENDIF

          ! Recalculate change in surface state_id from difference with previous timestep
          chang(is) = state_id(is)-stateOld(is)

          !Where should this go? Used to be before previous part!!
          ! soilmoist_id -------------------------------------------------
          ! For pervious surfaces (not water), some of drain(is) goes to soil storage
          ! Drainage (that is not flowing to other surfaces) goes to soil storages
          soilmoist_id(is)=soilmoist_id(is)+drain(is)*AddWaterRunoff(is)

          ! If soilstore is full, the excess will go to runoff
          IF(soilmoist_id(is)>soilstoreCap(is)) THEN  ! TODO: this should also go to flooding of some sort
             runoff(is)=runoff(is)+(soilmoist_id(is)-soilstoreCap(is))
             soilmoist_id(is)=soilstoreCap(is)
          ELSEIF (soilmoist_id(is)<0) THEN   !! QUESTION: But where does this lack of water go? !!Can this really happen here?
             CALL ErrorHint(62,'SUEWS_store: soilmoist_id(is) < 0 ',soilmoist_id(is),NotUsed,is)
             ! Code this properly - soilmoist_id(is) < 0 shouldn't happen given the above loops
             !soilmoist_id(is)=0   !Groundwater / deeper soil should kick in
          ENDIF

          !==== Water surface ========================================
       ELSEIF (is==WaterSurf) THEN

          IF(sfr(WaterSurf)/=0)THEN

             ! ---- Add water from neighbouring grids (RG2G) ----
             p_mm=p_mm+addWaterBody/sfr(WaterSurf)

             ! Calculate change in surface state_id (inputs - outputs)
             ! No drainage for water surface
             ! FlowChange is the difference in input and output flows [mm hr-1]
             chang(is)=p_mm+FlowChange/nsh_real-ev

             ! Calculate updated state_id using chang
             ! state_id(is)=state_id(is)+chang(is)
             state_id(is)=stateOld(is)+chang(is)

             ! Check state_id is within physical limits between zero (dry) and max. storage capacity
             IF(state_id(is)<0.0) THEN   ! Cannot have a negative surface state_id
                ! If there is not sufficient water on the surface, then don't allow this evaporation to happen
                ev=ev-ABS(state_id(is))   !Limit evaporation according to water availability
                state_id(is)=0.0          !Now surface is dry
                !elseif (state_id(is)>StoreDrainPrm(6,is)) then   !!This should perhaps be StateLimit(is)
                !   !! If state_id exceeds the storage capacity, then the excess goes to surface flooding
                !   !SurfaceFlood(is)=SurfaceFlood(is)+(state_id(is)-StoreDrainPrm(6,is))   !!Need to deal with this properly
                !   runoff(is)=runoff(is)+(state_id(is)-StoreDrainPrm(6,is))   !!needs to go to flooding
                !   state_id(is)=StoreDrainPrm(6,is)              !Now surface state_id is at max (storage) capacity
             ENDIF

             ! Recalculate change in surface state_id from difference with previous timestep
             chang(is) = state_id(is)-stateOld(is)

             ! If state_id exceeds limit, then excess goes to runoff (currently applies to water StoreDrainPrm only)
             IF (state_id(WaterSurf)>StateLimit(WaterSurf)) THEN
                runoff(WaterSurf)=runoff(WaterSurf)+(state_id(WaterSurf)-StateLimit(WaterSurf))
                state_id(WaterSurf)=StateLimit(WaterSurf)
                runoffWaterBody=runoffWaterBody+runoff(WaterSurf)*sfr(WaterSurf)
             ELSE
                state_id(WaterSurf)=state_id(WaterSurf)+surplusWaterBody
                IF (state_id(WaterSurf)>StateLimit(WaterSurf)) THEN
                   runoffWaterBody=runoffWaterBody+(state_id(WaterSurf)-StateLimit(WaterSurf))*sfr(WaterSurf)
                   state_id(WaterSurf)=StateLimit(WaterSurf)
                ENDIF
             ENDIF

             ! Recalculate change in surface state_id from difference with previous timestep
             chang(is) = state_id(is)-stateOld(is)
          ENDIF

       ENDIF   !end of WaterSurf

    ENDIF   !end of different surfaces

    !==================================================================
    !==== RUNOFF ======================================================

    ! TODO: to consider areas here - SurfaceArea may vary between grids too
    ! - also implement where water for next surface is calculated (RunoffFromGrid subroutine)
    ! Calculations of the piperunoff exceedensances moved to separate subroutine so that from snow same
    ! calculations can be made. LJ in May 2015

    IF(is<WaterSurf) THEN   !Not for water body

       ! Add runoff to pipes
       runoffPipes=runoffPipes+(runoff(is)*sfr(is))
       !  CALL updateFlood
       CALL updateFlood(&
                                ! input:
            nsurf,is,PavSurf,BldgSurf,WaterSurf,ConifSurf,BSoilSurf,&
            sfr,PipeCapacity,RunoffToWater,&
                                ! inout:
            runoffAGimpervious,surplusWaterBody,runoffAGveg,runoffPipes&
            )
    ENDIF

    runoff_per_interval=runoff_per_interval+(runoff(is)*sfr(is)) !The total runoff from the area !!Check (HCW)

  END SUBROUTINE soilstore
  !------------------------------------------------------------------------------
  !------------------------------------------------------------------------------
  SUBROUTINE updateFlood(&

                                ! input:
       nsurf,is,PavSurf,BldgSurf,WaterSurf,ConifSurf,BSoilSurf,&
       sfr,PipeCapacity,RunoffToWater,&
                                ! inout:
       runoffAGimpervious,surplusWaterBody,runoffAGveg,runoffPipes&
       )

    ! USE allocateArray
    ! USE sues_data

    IMPLICIT NONE
    INTEGER, INTENT(in) :: nsurf,is,PavSurf,BldgSurf,WaterSurf,ConifSurf,BSoilSurf
    REAL(KIND(1d0)), INTENT(in) :: sfr(nsurf),PipeCapacity,RunoffToWater
    REAL(KIND(1d0)), INTENT(inout) :: runoffAGimpervious,surplusWaterBody,runoffAGveg,runoffPipes

    ! If pipe capacity is full, surface runoff occurs
    ! N.B. this will happen each loop (replicates pipes filling up)
    IF(runoffPipes>PipeCapacity) THEN

       !------Paved and building surface
       IF(is==PavSurf.OR.is==BldgSurf) THEN
          IF(sfr(WaterSurf)>0.0000001) THEN
             ! If there is some water present, the water surface will take some of the flood water (fraction RunoffToWater)
             ! RunoffToWater is specified in SUEWS_SiteSelect.txt
             runoffAGimpervious=runoffAGimpervious+(runoffPipes-PipeCapacity)*(1-RunoffToWater)
             surplusWaterBody=surplusWaterBody+(runoffPipes-PipeCapacity)*RunoffToWater
          ELSE
             ! Otherwise, all flood water must go to runoff
             runoffAGimpervious=runoffAGimpervious+(runoffPipes-PipeCapacity)
          ENDIF
          !------other surfaces
       ELSEIF(is>=ConifSurf.AND.is<=BSoilSurf) THEN
          IF(sfr(WaterSurf)>0.0000001) THEN
             ! If there is some water present, the water surface will take some of the flood water (fraction RunoffToWater)
             runoffAGveg=runoffAGveg+(runoffPipes-PipeCapacity)*(1-RunoffToWater)
             surplusWaterBody=surplusWaterBody+(runoffPipes-PipeCapacity)*RunoffToWater
          ELSE
             ! Otherwise, all flood water must go to runoff
             runoffAGveg=runoffAGveg+(runoffPipes-PipeCapacity)
          ENDIF
       ENDIF

       runoffPipes=PipeCapacity   !Pipes are at their max capacity

    ENDIF   !If runoff exceed pipe capacity

  END SUBROUTINE updateFlood

  SUBROUTINE ReDistributeWater(&
                                ! input:
       nsurf,& ! surface type number
       WaterSurf,&
       snowUse,&
       WaterDist,  &
       sfr,   &!
       Drain,&
                                ! output:
       AddWaterRunoff,&
       AddWater&
       )
    !Drainage moves into different parts defined by WaterDistSS_YYYY.txt. LJ 2010
    !AddWater(is) is that amount of water that is gained for each surface
    !Latest update takes snow into account. 22/03/2013 LJ
    !-------------------------------------------------------------------

    ! use allocateArray
    ! use data_in
    ! use gis_data
    ! use sues_data

    IMPLICIT NONE

    INTEGER,INTENT(in)::nsurf ! number of surface types
    INTEGER,INTENT(in)::WaterSurf!=7, water surface code
    INTEGER,INTENT(in)::snowUse!Snow part used (1) or not used (0)

    REAL (KIND(1d0)),INTENT(in)::WaterDist(nsurf+1,nsurf-1) !Within-grid water distribution to other surfaces and runoff/soil store [-]
    REAL (KIND(1d0)),INTENT(in)::sfr(nsurf)                !Surface fractions [-]
    REAL (KIND(1d0)),INTENT(in)::Drain(nsurf)               !Drainage of each surface type [mm]

    REAL (KIND(1d0)),INTENT(out)::AddWaterRunoff(nsurf)!Fraction of water going to runoff/sub-surface soil (WGWaterDist) [-]
    REAL (KIND(1d0)),INTENT(out)::AddWater(nsurf)        !Water from other surfaces (WGWaterDist in SUEWS_ReDistributeWater.f95) [mm]

    INTEGER::ii,jj,&
         NSurfDoNotReceiveDrainage=0!Number of surfaces that do not receive drainage water (green roof)

    !Fractions that go to runoff from each surface
    DO ii=1,nsurf-1   !not water in the calculation
       AddWaterRunoff(ii)=WaterDist(8,ii)
    ENDDO
    AddWaterRunoff(WaterSurf)=0
    AddWater=0

    DO ii=1,nsurf-NSurfDoNotReceiveDrainage !go through surfaces from 1 to 7. These gain water through drainage
       DO jj=1,nsurf-(NSurfDoNotReceiveDrainage+1) !From where surface ii can gain water - can't gain water from itself

          IF (sfr(ii)/=0) THEN !Water movement takes place only if surface fraction exists

             !No snow calculations!
             IF (snowUse==0) THEN
                AddWater(ii)=AddWater(ii)+(Drain(jj)*sfr(jj)/sfr(ii))*WaterDist(ii,jj) !Original

                !Snow included, This needs to be fixed at some point. LJ Mar 2013
             ELSE
                AddWaterRunoff(jj)=AddWaterRunoff(jj)+WaterDist(ii,jj) !No receiving surface -> runoff
             ENDIF

          ELSE
             AddWaterRunoff(jj)=AddWaterRunoff(jj)+WaterDist(ii,jj) !If no receiving surface exists,
             !water fraction goes to AddWaterRunoff
          ENDIF
       ENDDO
    ENDDO
  END SUBROUTINE ReDistributeWater


  SUBROUTINE SUEWS_update_SoilMoist(&
       NonWaterFraction,&!input
       soilstoreCap,sfr,soilmoist_id,&
       SoilMoistCap,SoilState,&!output
       vsmd,smd)
    IMPLICIT NONE
    INTEGER,PARAMETER ::nsurf     = 7 ! number of surface types
    INTEGER,PARAMETER ::ConifSurf = 3 !New surface classes: Grass = 5th/7 surfaces
    INTEGER,PARAMETER ::DecidSurf = 4 !New surface classes: Grass = 5th/7 surfaces
    INTEGER,PARAMETER ::GrassSurf = 5

    ! INTEGER,INTENT(in)::nsurf,ConifSurf,DecidSurf,GrassSurf
    REAL(KIND(1d0)),INTENT(in)::NonWaterFraction
    REAL(KIND(1d0)),INTENT(in),DIMENSION(nsurf)::soilstoreCap,sfr,soilmoist_id

    REAL(KIND(1d0)),INTENT(out)::SoilMoistCap,SoilState
    REAL(KIND(1d0)),INTENT(out)::vsmd,smd

    INTEGER :: is


    SoilMoistCap=0   !Maximum capacity of soil store [mm] for whole surface
    SoilState=0      !Area-averaged soil moisture [mm] for whole surface

    IF (NonWaterFraction/=0) THEN !Soil states only calculated if soil exists. LJ June 2017
       DO is=1,nsurf-1   !No water body included
          SoilMoistCap=SoilMoistCap+(soilstoreCap(is)*sfr(is)/NonWaterFraction)
          SoilState=SoilState+(soilmoist_id(is)*sfr(is)/NonWaterFraction)
       ENDDO
    ENDIF

    !If loop removed HCW 26 Feb 2015
    !if (ir==1) then  !Calculate initial smd
    smd=SoilMoistCap-SoilState
    !endif

    ! Calculate soil moisture for vegetated surfaces only (for use in surface conductance)
    vsmd=0
    DO is=ConifSurf,GrassSurf  !Vegetated surfaces only
       IF ( sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf) ==0 ) THEN
          vsmd=0
       ELSE
          vsmd=vsmd+(soilstoreCap(is) - soilmoist_id(is))*sfr(is)/(sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf))
       END IF
       !write(*,*) is, vsmd, smd
    ENDDO

  END SUBROUTINE SUEWS_update_SoilMoist


  !========== Calculate soil moisture ============
  SUBROUTINE SUEWS_cal_SoilMoist(&
       SMDMethod,xsmd,NonWaterFraction,SoilMoistCap,&!input
       SoilStoreCap,surf_chang_per_tstep,&
       soilmoist_id,soilmoistOld,sfr,&
       smd,smd_nsurf,tot_chang_per_tstep,SoilState)!output

    IMPLICIT NONE
    INTEGER,PARAMETER::nsurf=7


    INTEGER,INTENT(in) ::SMDMethod
    REAL(KIND(1d0)),INTENT(in)::xsmd
    REAL(KIND(1d0)),INTENT(in)::NonWaterFraction
    REAL(KIND(1d0)),INTENT(in)::SoilMoistCap

    REAL(KIND(1d0)),INTENT(in)::surf_chang_per_tstep
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::soilmoist_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::soilmoistOld
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::SoilStoreCap        !Capacity of soil store for each surface [mm]

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::smd_nsurf
    REAL(KIND(1d0)),INTENT(out)::SoilState
    REAL(KIND(1d0)),INTENT(out)::smd
    REAL(KIND(1d0)),INTENT(out)::tot_chang_per_tstep

    REAL(KIND(1d0)),PARAMETER::NotUsed=-999
    REAL(KIND(1d0)),PARAMETER::NAN=-999
    INTEGER :: is

    SoilState=0       !Area-averaged soil moisture [mm] for whole surface
    IF (NonWaterFraction/=0) THEN !Fixed for water surfaces only
       DO is=1,nsurf-1   !No water body included
          SoilState=SoilState+(soilmoist_id(is)*sfr(is)/NonWaterFraction)
          IF (SoilState<0) THEN
             CALL ErrorHint(62,'SUEWS_Calculations: total SoilState < 0 (just added surface is) ',SoilState,NotUsed,is)
          ELSEIF (SoilState>SoilMoistCap) THEN
             CALL ErrorHint(62,'SUEWS_Calculations: total SoilState > capacity (just added surface is) ',SoilState,NotUsed,is)
             !SoilMoist_state=SoilMoistCap !What is this LJ 10/2010 - QUESTION: SM exceeds capacity, but where does extra go?HCW 11/2014
          ENDIF
       ENDDO  !end loop over surfaces
    ENDIF

    ! Calculate soil moisture deficit
    smd=SoilMoistCap-SoilState   !One value for whole surface
    smd_nsurf=SoilstoreCap-soilmoist_id   !smd for each surface

    ! Soil stores can change after horizontal water movements
    ! Calculate total change in surface and soil state_id
    tot_chang_per_tstep = surf_chang_per_tstep   !Change in surface state_id
    DO is=1,(nsurf-1)   !No soil for water surface (so change in soil moisture is zero)
       tot_chang_per_tstep = tot_chang_per_tstep + ((soilmoist_id(is)-soilmoistOld(is))*sfr(is))   !Add change in soil state_id
    ENDDO

    IF (SMDMethod>0) THEN
       !  smd_nsurf=NAN
       smd_nsurf=NAN
       smd=xsmd
    ENDIF


  END SUBROUTINE SUEWS_cal_SoilMoist

  SUBROUTINE SUEWS_cal_HorizontalSoilWater(&
       sfr,&! input: ! surface fractions
       SoilStoreCap,&!Capacity of soil store for each surface [mm]
       SoilDepth,&!Depth of sub-surface soil store for each surface [mm]
       SatHydraulicConduct,&!Saturated hydraulic conductivity for each soil subsurface [mm s-1]
       SurfaceArea,&!Surface area of the study area [m2]
       NonWaterFraction,&! sum of surface cover fractions for all except water surfaces
       tstep_real,& !tstep cast as a real for use in calculations
       soilmoist_id,&! inout: !Soil moisture of each surface type [mm]
       runoffSoil,&!Soil runoff from each soil sub-surface [mm]
       runoffSoil_per_tstep&!  output:!Runoff to deep soil per timestep [mm] (for whole surface, excluding water body)
       )
    !Transfers water in soil stores of land surfaces LJ (2010)
    !Change the model to use varying hydraulic conductivity instead of constant value LJ (7/2011)
    !If one of the surface's soildepth is zero, no water movement is considered
    ! LJ  15/06/2017 Modification:   - Moved location of runoffSoil_per_tstep within previous if-loop to avoid dividing with zero with 100% water surface
    ! HCW 22/02/2017 Modifications:  - Minor bug fixed in VWC1/B_r1 comparison - if statements reversed
    ! HCW 13/08/2014 Modifications:  - Order of surfaces reversed (for both is and jj loops)
    !                                - Number of units (e.g. properties) added to distance calculation
    ! HCW 12/08/2014 Modifications:  - Distance changed from m to mm in dI_dt calculation
    !                                - dI_dt [mm s-1] multiplied by no. seconds in timestep -> dI [mm]
    !                                - if MatPot is set to max. value (100000 mm), Km set to 0 mm s-1
    !                                - Provide parameters for residual volumetric soil moisture [m3 m-3]
    !                                   (currently hard coded as 0.1 m3 m-3 for testing)
    !
    !------------------------------------------------------
    ! use SUES_data
    ! use gis_data
    ! use time
    ! use allocateArray

    IMPLICIT NONE
    INTEGER , PARAMETER :: nsurf=7! number of surface types

    REAL(KIND(1d0)), INTENT(in) ::sfr(nsurf)! surface fractions
    REAL(KIND(1d0)), INTENT(in) ::SoilStoreCap(nsurf)!Capacity of soil store for each surface [mm]
    REAL(KIND(1d0)), INTENT(in) ::SoilDepth(nsurf)!Depth of sub-surface soil store for each surface [mm]
    REAL(KIND(1d0)), INTENT(in) ::SatHydraulicConduct(nsurf)!Saturated hydraulic conductivity for each soil subsurface [mm s-1]
    REAL(KIND(1d0)), INTENT(in) ::SurfaceArea!Surface area of the study area [m2]
    REAL(KIND(1d0)), INTENT(in) ::NonWaterFraction! sum of surface cover fractions for all except water surfaces
    REAL(KIND(1d0)), INTENT(in) ::tstep_real !tstep cast as a real for use in calculations

    REAL(KIND(1d0)),DIMENSION(nsurf), INTENT(inout) ::soilmoist_id!Soil moisture of each surface type [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf), INTENT(inout) ::runoffSoil!Soil runoff from each soil sub-surface [mm]

    REAL(KIND(1d0)), INTENT(out) :: runoffSoil_per_tstep!Runoff to deep soil per timestep [mm] (for whole surface, excluding water body)



    INTEGER::jj,is
    REAL(KIND(1d0))::&
         DimenWaterCon1,DimenWaterCon2,&
         SoilMoistCap_Vol1,&
         SoilMoist_vol1,&
         SoilMoistCap_Vol2,&
         SoilMoist_vol2,&
         B_r1,MatPot1,Km1,&
         B_r2,MatPot2,Km2,&
         Distance,KmWeight,dI,&
         dI_dt!Water flow between two stores

    REAL(KIND(1d0)), PARAMETER::&
         alphavG=0.0005,&  !Set alphavG to match value in van Genuchten (1980) [mm-1]
         NUnits = 1   !Can change to represent plot/base unit size


    ! SoilMoist_vol1,2     = Volumetric soil moisture [m3 m-3]
    ! SoilMoistCap_vol1,2  = Volumetric soil moisture capacity [m3 m-3] (from FunctionalTypes)
    ! MatPot1,2            = Water potential (i.e. pressure head) of store [mm]
    ! DimenWaterCon1,2     = Dimensionless water content, or relative saturation [-]
    ! Distance             = Distance between two stores [m]
    ! B_r1,2               = Residual volumetric soil moisture [m3 m-3]
    ! Km1,2                = Hydraulic conductivity of store [mm s-1]
    ! KmWeight             = Weighted hydraulic conductivity [mm s-1]
    ! alphavG              = Parameter (could depend on soil texture) [mm-1]
    ! dI                   = Water flow between stores [mm] dI = dI_dt * no. secs in each timestep
    !                         if dI > 0, first surface gains water, second surface loses water
    ! NUnits               = Number of repeating units (e.g. properties, blocks) for distance calculation [-]


    runoffSoil_per_tstep=0


    DO is=1,nsurf-1 !nsurf-1,1,-1  !Loop through each surface, excluding water surface (runs backwards as of 13/08/2014, HCW)

       IF (sfr(is)/=0.AND.SoilStoreCap(is)>0) THEN  !If particular surface area exists
          ! and is capable of storing water (SoilStoreCap [mm])
          DO jj=is+1,nsurf-1 !is-1,1,-1  !Sub-loop through remaining surfaces (runs backwards as of 13/08/2014, HCW)

             IF (sfr(jj)/=0.AND.SoilStoreCap(jj)>0) THEN  !If other surface area exists
                ! and is capable of storing water

                ! ---- For surface 1 -----------------------------------------------------
                ! Calculate non-saturated VWC
                SoilMoistCap_Vol1=SoilStoreCap(is)/SoilDepth(is) !Volumetric soil moisture capacity [m3 m-3] (i.e. saturated VWC)
                SoilMoist_vol1=soilmoist_id(is)/SoilDepth(is) !Volumetric soil moisture [m3 m-3]

                !B_r1=SoilMoistCap_Vol1-SoilMoist_vol1  !Residual soil moisture content [m3 m-3]
                B_r1=0.1 !HCW 12/08/2014 Temporary fix
                ! Need to add residual soil moisture values to FunctionalTypes
                !B_r1=VolSoilMoistRes(is) !Residual soil moisture content [m3 m-3]

                !Order of if statements reversed HCW 22 Feb 2017
                !If soil moisture less than or equal to residual value, set MatPot to max and Km to 0 to suppress water movement
                IF(B_r1 >= SoilMoist_vol1) THEN
                   MatPot1 = 100000
                   Km1 = 0 !Added by LJ in Nov 2013
                   ! Otherwise, there should be enough water in the soil to allow horizontal transfer
                ELSE
                   DimenWaterCon1=(SoilMoist_vol1-B_r1)/(SoilMoistCap_Vol1-B_r1) !Dimensionless water content [-]

                   ! If very large or very small, adjust for calculation of MatPot and Km
                   IF(DimenWaterCon1>0.99999) THEN
                      DimenWaterCon1=DimenWaterCon1-0.0001 !This cannot equal 1
                   ENDIF

                   IF(DimenWaterCon1<0.00000005) THEN
                      DimenWaterCon1=DimenWaterCon1+0.0000001   !Added HCW 22 Feb 2017
                   ENDIF

                   !van Genuchten (1980), with n=2 and m = 1-1/n = 1/2
                   !Water potential of first store [mm] (van Genuchten 1980, Eq 3 rearranged)
                   MatPot1=SQRT(1/DimenWaterCon1**2-1)/alphavG

                   !Hydraulic conductivity of first store [mm s-1] (van Genuchten 1980, Eq 8)
                   Km1=SatHydraulicConduct(is)*SQRT(DimenWaterCon1)*(1-(1-DimenWaterCon1**2)**0.5)**2

                   !Check this value (HCW 12/08/2014)
                   IF(MatPot1>100000) THEN
                      MatPot1 = 100000  !Max. potential is 100000 mm (van Genuchten 1980)
                      Km1 = 0   !Added by HCW 12/08/2014
                   ENDIF

                ENDIF

                ! ---- For surface 2 -----------------------------------------------------
                ! Calculate non-saturated VWC
                SoilMoistCap_Vol2=SoilStoreCap(jj)/SoilDepth(jj) !Volumetric soil moisture capacity [m3 m-3] (i.e. saturated VWC)
                SoilMoist_vol2=soilmoist_id(jj)/SoilDepth(jj) !Volumetric soil moisture [m3 m-3]

                !B_r2=SoilMoistCap_Vol2-SoilMoist_vol2  !Residual soil moisture content [m3 m-3]
                B_r2=0.1 !HCW 12/08/2014 Temporary fix
                ! Need to add residual soil moisture values to FunctionalTypes
                !B_r2=VolSoilMoistRes(jj) !Residual soil moisture content [m3 m-3]

                !If soil moisture below residual value, set MatPot to maximum
                IF(B_r2>=SoilMoist_vol2) THEN
                   MatPot2=100000
                   Km2 = 0 !Added by LJ in Nov 2013
                ELSE
                   DimenWaterCon2=(SoilMoist_vol2-B_r2)/(SoilMoistCap_Vol2-B_r2) !Dimensionless water content [-]

                   IF(DimenWaterCon2>0.99999) THEN
                      DimenWaterCon2=DimenWaterCon2-0.0001 !This cannot equal 1
                   ENDIF

                   IF(DimenWaterCon2<0.00000005) THEN
                      DimenWaterCon2=DimenWaterCon2+0.0000001   !Added HCW 22 Feb 2017
                   ENDIF

                   !van Genuchten (1980), with n=2 and m = 1-1/n = 1/2
                   !Water potential of second store [mm] (van Genuchten 1980, Eq 3 rearranged)
                   MatPot2=SQRT(1/DimenWaterCon2**2-1)/alphavG

                   !Hydraulic conductivity of second store [mm s-1] (van Genuchten 1980, Eq 8)
                   Km2=SatHydraulicConduct(jj)*SQRT(DimenWaterCon2)*(1-(1-DimenWaterCon2**2)**0.5)**2

                   IF((MatPot2)>100000) THEN
                      MatPot2=100000 !Max. potential is 100000 mm (van Genuchten 1980)
                      Km2 = 0   !Added by HCW 12/08/2014
                   ENDIF

                ENDIF

                ! ------------------------------------------------------------------------

                !Find distance between the two stores (see Jarvi et al. 2011)
                !SurfaceArea in m2 (changed from ha to m2 n SUEWS_Initial), so Distance in m
                Distance=(SQRT(sfr(is)*SurfaceArea/NUnits)+SQRT(sfr(jj)*SurfaceArea/NUnits))/2

                !Calculate areally-weighted hydraulic conductivity [mm s-1]
                KmWeight=(sfr(is)*Km1+sfr(jj)*Km2)/(sfr(is)+sfr(jj))

                !Find water flow between the two stores [mm s-1] (Green-Ampt equation, Hillel 1971)
                !Multiply Distance by 1000 to convert m to mm (HCW 12/08/2014)
                dI_dt=-(KmWeight)*(-MatPot1+MatPot2)/(Distance*1000)

                !Multiply dI_dt by number of seconds in timestep to convert mm s-1 to mm
                !Added by HCW 12/08/2014
                dI=dI_dt*tstep_real  !Use dI instead of dI_dt in the following calculations

                !Move water (in mm) ------------------------------------------------------
                !Water moves only if (i) there is sufficient water to move and (ii) there is space to move it

                ! If there is sufficient water in both surfaces, allow movement of dI to occur
                IF ((soilmoist_id(jj)>=dI*sfr(is)/sfr(jj)).AND.((soilmoist_id(is)+dI)>=0)) THEN
                   soilmoist_id(is)=soilmoist_id(is)+dI
                   soilmoist_id(jj)=soilmoist_id(jj)-dI*sfr(is)/sfr(jj)  !Check (HCW 13/08/2014) - QUESTION: why adjust for jj and not is?

                   ! If insufficient water in first surface to move dI, instead move as much as possible
                ELSEIF ((soilmoist_id(is)+dI)<0) THEN
                   soilmoist_id(jj)=soilmoist_id(jj)+soilmoist_id(is)*sfr(is)/sfr(jj) !HCW 12/08/2014 switched order of these two lines
                   soilmoist_id(is)=0    !Check (HCW 13/08/2014) - QUESTION: can SM actually go to zero, or is this inconsistent with SMres?

                   ! If insufficient water in second surface to move dI, instead move as much as possible
                ELSE
                   soilmoist_id(is)=soilmoist_id(is)+soilmoist_id(jj)*sfr(jj)/sfr(is)
                   soilmoist_id(jj)=0
                ENDIF

                !If soil moisture exceeds capacity, excess goes to soil runoff (first surface)
                IF (soilmoist_id(is)>SoilStoreCap(is)) THEN
                   runoffSoil(is)=runoffSoil(is)+(soilmoist_id(is)-SoilStoreCap(is))
                   soilmoist_id(is)=SoilStoreCap(is)
                   !elseif (soilmoist_id(is)<0) then  !HCW 13/08/2014 commented out as should never be true here anyway...
                   !   soilmoist_id(is)=0             ! ... and if so, need to do more here (i.e. account for other water too)
                ENDIF

                !If soil moisture exceeds capacity, excess goes to soil runoff (second surface)
                IF (soilmoist_id(jj)>SoilStoreCap(jj)) THEN
                   runoffSoil(jj)=runoffSoil(jj)+(soilmoist_id(jj)-SoilStoreCap(jj))
                   soilmoist_id(jj)=SoilStoreCap(jj)
                   !elseif (soilmoist_id(jj)<0) then  !HCW 13/08/2014 commented out (as above)
                   !	 soilmoist_id(jj)=0
                ENDIF

             ENDIF  !end if second surface exists and is capable of storing water

          ENDDO  !end jj loop over second surface

          runoffSoil_per_tstep=runoffSoil_per_tstep+(runoffSoil(is)*sfr(is)/NonWaterFraction)  !Excludes water body. Moved here as otherwise code crashed when NonWaterFraction=0

       ENDIF  !end if first surface exists and is capable of storing water

       !runoffSoil_per_tstep=runoffSoil_per_tstep+(runoffSoil(is)*sfr(is)/NonWaterFraction)  !Excludes water body

    ENDDO !is loop over first surface

  END SUBROUTINE SUEWS_cal_HorizontalSoilWater

  ! Conversion of water use (irrigation)
  ! Last modified:
  !  TS 08 Aug 2017  - addded explicit interface
  !  LJ  6 Apr 2017  - WUchoice changed to WaterUseMethod
  !  TK 14 Mar 2017  - Corrected the variable name WUAreaEveTr_m2 -> WUAreaGrass_m2 (row 35)
  !                    Corrected conversion from m to mm /1000 -> *1000 (row 47 and 60)
  !  LJ 27 Jan 2016  - Removing Tab:s and cleaning the code
  !  HCW 12 Feb 2015 - Water use [mm] now inidcates the amount of water supplied for each surface
  !  HCW 26 Jan 2015 - Water use [mm] is the same for each surface at the moment and indicates the
  !                    amount of water supplied for each irrigated area
  !
  ! To Do:
  !	- Add functionality for water on paved surfaces (street cleaning, fountains)
  !===================================================================================
  SUBROUTINE SUEWS_cal_WaterUse(&
       nsh_real,& ! input:
       SurfaceArea,sfr,&
       IrrFracConif,IrrFracDecid,IrrFracGrass,&
       DayofWeek_id,WUProfA_24hr,WUProfM_24hr,&
       InternalWaterUse_h,HDD_id,WUDay_id,&
       WaterUseMethod,NSH,it,imin,DLS,&
       WUAreaEveTr_m2,WUAreaDecTr_m2,& ! output:
       WUAreaGrass_m2,WUAreaTotal_m2,&
       wu_EveTr,wu_DecTr,wu_Grass,wu_m3,int_wu,ext_wu)


    IMPLICIT NONE
    INTEGER,PARAMETER:: nsurf   = 7
    ! INTEGER,PARAMETER:: PavSurf   = 1  !When all surfaces considered together (1-7)
    ! INTEGER,PARAMETER::BldgSurf  = 2
    INTEGER,PARAMETER::ConifSurf = 3
    INTEGER,PARAMETER::DecidSurf = 4
    INTEGER,PARAMETER::GrassSurf = 5 !New surface classes: Grass = 5th/7 surfaces
    ! INTEGER,PARAMETER::BSoilSurf = 6 !New surface classes: Bare soil = 6th/7 surfaces
    ! INTEGER,PARAMETER::WaterSurf = 7
    ! INTEGER,PARAMETER::ExcessSurf= 8   !Runoff or subsurface soil in WGWaterDist
    ! INTEGER,PARAMETER::NSurfDoNotReceiveDrainage=0  !Number of surfaces that do not receive drainage water (green roof)
    ! INTEGER,PARAMETER::ivConif = 1!When only vegetated surfaces considered (1-3)
    ! INTEGER,PARAMETER::ivDecid = 2
    ! INTEGER,PARAMETER::ivGrass = 3


    REAL(KIND(1d0)),INTENT(in)::nsh_real
    REAL(KIND(1d0)),INTENT(in)::SurfaceArea !Surface area of the study area [m2]
    REAL(KIND(1d0)),INTENT(in)::sfr(nsurf)!Surface fractions [-]
    REAL(KIND(1d0)),INTENT(in)::IrrFracConif!Fraction of evergreen trees which are irrigated
    REAL(KIND(1d0)),INTENT(in)::IrrFracDecid!Fraction of deciduous trees which are irrigated
    REAL(KIND(1d0)),INTENT(in)::IrrFracGrass!Fraction of grass which is irrigated
    REAL(KIND(1d0)),INTENT(in)::InternalWaterUse_h !Internal water use [mm h-1]
    ! WUProfA_tstep(24*NSH,2),& !Automatic water use profiles at model timestep
    ! WUProfM_tstep(24*NSH,2),& !Manual water use profiles at model timestep
    REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in)::WUProfA_24hr !Automatic water use profiles at hourly scales
    REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in)::WUProfM_24hr !Manual water use profiles at hourly scales

    REAL(KIND(1d0)),DIMENSION(12),INTENT(in)::HDD_id !HDD(id-1), Heating Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(9),INTENT(in)::WUDay_id!WUDay(id-1), Daily water use for EveTr, DecTr, Grass [mm] (see SUEWS_DailyState.f95)

    INTEGER,INTENT(in):: &
         DayofWeek_id(3),& !DayofWeek(id) 1 - day of week; 2 - month; 3 - season
         WaterUseMethod,& !Use modelled (0) or observed (1) water use
                                !  ConifSurf,& !surface code
                                !  DecidSurf,& !surface code
                                !  GrassSurf,& !surface code
         NSH,&!Number of timesteps per hour
         it,& !Hour
         imin,& !Minutes
         DLS !day lightsavings =1 + 1h) =0
    !  nsurf


    REAL(KIND(1d0)),INTENT(out):: &
         WUAreaEveTr_m2,&
         WUAreaDecTr_m2,&
         WUAreaGrass_m2,&
         WUAreaTotal_m2,&
         wu_EveTr,&
         wu_DecTr,&
         wu_Grass,&
         wu_m3,&
         int_wu,&
         ext_wu


    REAL(KIND(1d0)):: &
         InternalWaterUse,&    !Internal water use for the model timestep [mm]
         WuFr=1,&
         wu!Water use for the model timestep [mm]
    INTEGER:: ih   !Hour corrected for Daylight savings
    INTEGER:: iu   !1=weekday OR 2=weekend
    INTEGER :: tstep ! timestep in second
    REAL(KIND(1d0)),PARAMETER::NAN=-999.
    REAL(KIND(1d0)):: OverUse
    REAL(KIND(1d0)):: rain_cum_daily ! accumulated daily rainfall

    REAL(KIND(1d0)):: get_Prof_SpecTime_sum

    ! NB: set OverUse as 0 as done module_constants, TS 22 Oct 2017
    ! and the logic for calculating OverUse to be determined
    OverUse=0

    ! timestep in second
    tstep=INT(3600/NSH)

    ! accumulated daily rainfall
    rain_cum_daily=HDD_id(11)

    ! --------------------------------------------------------------------------------
    ! If water used is observed and provided in the met forcing file, units are m3
    ! Divide observed water use (in m3) by water use area to find water use (in mm)
    IF (WaterUseMethod==1) THEN   !If water use is observed
       ! Calculate water use area [m2] for each surface type
       WUAreaEveTr_m2 = IrrFracConif*sfr(ConifSurf)*SurfaceArea
       WUAreaDecTr_m2 = IrrFracDecid*sfr(DecidSurf)*SurfaceArea
       WUAreaGrass_m2 = IrrFracGrass*sfr(GrassSurf)*SurfaceArea
       WUAreaTotal_m2 = WUAreaEveTr_m2 + WUAreaDecTr_m2 + WUAreaGrass_m2

       !Set water use [mm] for each surface type to zero initially
       wu_EveTr=0
       wu_DecTr=0
       wu_Grass=0
       IF(wu_m3==NAN.OR.wu_m3==0) THEN !If no water use
          wu_m3=0
          wu=wu_m3
       ELSE                            !If water use
          IF (WUAreaTotal_m2>0) THEN
             wu = (wu_m3/WUAreaTotal_m2*1000)  !Water use in mm for the whole irrigated area
             IF (WUAreaEveTr_m2>0) THEN
                wu_EveTr=wu                    !Water use for Irr EveTr in mm - these are all the same at the moment
                wu_EveTr=wu_EveTr*IrrFracConif !Water use for EveTr in mm
             ENDIF
             IF (WUAreaDecTr_m2>0) THEN
                wu_DecTr=wu                        !Water use for Irr DecTr in mm - these are all the same at the moment
                wu_DecTr=wu_DecTr*IrrFracDecid     !Water use for DecTr in mm
             ENDIF
             IF (WUAreaGrass_m2>0) THEN
                wu_Grass=wu                    !Water use for Irr Grass in mm - these are all the same at the moment
                wu_Grass=wu_Grass*IrrFracGrass !Water use for Grass in mm
             ENDIF
             wu = (wu_m3/SurfaceArea*1000)     !Water use for the whole study area in mm
          ENDIF
       ENDIF

       ! --------------------------------------------------------------------------------
       ! If water use is modelled, calculate at timestep of model resolution [mm]
    ELSEIF (WaterUseMethod==0) THEN   !If water use is modelled

       ! Account for Daylight saving
       ih=it-DLS
       IF (ih<0) ih=23

       ! Weekday or weekend profile
       iu=1     !Set to 1=weekday
       !  IF(DayofWeek(id,1)==1.OR.DayofWeek(id,1)==7) THEN
       IF(DayofWeek_id(1)==1.OR.DayofWeek_id(1)==7) THEN
          iu=2  !Set to 2=weekend
       ENDIF

       !write(*,*) (NSH*(ih+1-1)+imin*NSH/60+1)

       ! ---- Automatic irrigation ----
       ! wu_EveTr = WUProfA_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)*WUDay_id(2)   !Automatic evergreen trees
       ! wu_DecTr = WUProfA_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)*WUDay_id(5)   !Automatic deciduous trees
       ! wu_Grass = WUProfA_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)*WUDay_id(8)   !Automatic grass
       wu_EveTr = get_Prof_SpecTime_sum(ih,imin,0,WUProfA_24hr(:,iu),tstep)*WUDay_id(2)   !Automatic evergreen trees
       wu_DecTr = get_Prof_SpecTime_sum(ih,imin,0,WUProfA_24hr(:,iu),tstep)*WUDay_id(5)   !Automatic deciduous trees
       wu_Grass = get_Prof_SpecTime_sum(ih,imin,0,WUProfA_24hr(:,iu),tstep)*WUDay_id(8)   !Automatic grass

       ! ---- Manual irrigation ----
       WuFr=1 !Initialize WuFr to 1, but if raining, reduce manual fraction of water use
       ! If cumulative daily precipitation exceeds 2 mm
       IF(rain_cum_daily>2) THEN    !.and.WUDay(id-1,3)>0) then !Commented out HCW 23/01/2015
          WuFr=0   ! 0 -> No manual irrigation if raining
       ENDIF

       ! Add manual to automatic to find total irrigation
       ! wu_EveTr = wu_EveTr + (WuFr*WUProfM_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)*WUDay_id(3)) !Manual evergreen trees
       ! wu_DecTr = wu_DecTr + (WuFr*WUProfM_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)*WUDay_id(6)) !Manual deciduous trees
       ! wu_Grass = wu_Grass + (WuFr*WUProfM_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)*WUDay_id(9)) !Manual grass
       wu_EveTr = wu_EveTr + (get_Prof_SpecTime_sum(ih,imin,0,WUProfM_24hr(:,iu),tstep)*WuFr*WUDay_id(3)) !Manual evergreen trees
       wu_DecTr = wu_DecTr + (get_Prof_SpecTime_sum(ih,imin,0,WUProfM_24hr(:,iu),tstep)*WuFr*WUDay_id(6)) !Manual deciduous trees
       wu_Grass = wu_Grass + (get_Prof_SpecTime_sum(ih,imin,0,WUProfM_24hr(:,iu),tstep)*WuFr*WUDay_id(9)) !Manual grass
       ! Added HCW 12 Feb 2015.
       !wu_EveTr=wu_EveTr*sfr(ConifSurf)*IrrFracConif	!Water use for EveTr [mm]
       !wu_DecTr=wu_DecTr*sfr(DecidSurf)*IrrFracDecid	!Water use for DecTr [mm]
       !wu_Grass=wu_Grass*sfr(GrassSurf)*IrrFracGrass	!Water use for Grass [mm]
       wu_EveTr=wu_EveTr*IrrFracConif  !Water use for EveTr [mm]
       wu_DecTr=wu_DecTr*IrrFracDecid  !Water use for DecTr [mm]
       wu_Grass=wu_Grass*IrrFracGrass  !Water use for Grass [mm]

       ! Total water use for the whole study area [mm]
       wu = wu_EveTr*sfr(ConifSurf) + wu_DecTr*sfr(DecidSurf) + wu_Grass*sfr(GrassSurf)

    ENDIF   !End WU_choice
    ! --------------------------------------------------------------------------------

    ! Internal water use is supplied in SUEWS_Irrigation in mm h-1
    ! Convert to mm for the model timestep
    InternalWaterUse = InternalWaterUse_h/nsh_real

    ! Remove InternalWaterUse from the total water use
    ext_wu = wu-(InternalWaterUse+OverUse)
    ! Check ext_wu cannot be negative
    IF (ext_wu<0) THEN
       overUse=ABS(ext_wu)
       ext_wu=0
    ELSE
       OverUse=0
    ENDIF

    int_wu = wu-ext_wu

    ! Decrease the water use for each surface by the same proportion
    IF(ext_wu/=0.AND.wu/=0) THEN
       wu_EveTr = wu_EveTr*ext_wu/wu
       wu_DecTr = wu_DecTr*ext_wu/wu
       wu_Grass = wu_Grass*ext_wu/wu
    ENDIF

  endsubroutine SUEWS_cal_WaterUse
  !===================================================================================


END MODULE WaterDist_module

MODULE Snow_module

  IMPLICIT NONE
CONTAINS
  !This subroutine makes snow related calculations at the model time step. Needed for the
  !available energy in LUMPS and SUEWS. Made by LJ in Dec 2012
  !SUBROUTINES:
  !  MeltHeat - Calculation of snow related energy processes
  !  SnowCalc - Calculation of snow and soil storages
  !  Evap_SUEWS_Snow - Calculation of evaporation from the SnowPack
  !  snowRem - Removal of snow my snow clearing
  !  SnowDepletionCurve - Calculation of snow fractions
  !Last modified
  !  TS 17 Sep 2017 - added wrapper `Snow_cal_MeltHeat` for `SUEWS_driver`
  !  TS 04 Sep 2017 - added `veg_fr_snow` to update VegFractions with snow effect included
  !  TS 31 Aug 2017 - fixed the incomplete explicit interfaces
  !  LJ 24 Aug 2017 - added explicit interfaces
  !  LJ 3 May 2016  - Changed so that not all surface water freezes in 5-min timestep.
  !                    Re-organization of the snow routine due to this change
  !                    Calculation of albedo moved from MeltHeat to SnowCalc
  !  LJ 27 Jan 2016  - Tabs removed, cleaning of the code
  !  HCW 08 Dec 2015 - Added check for no Paved surfaces
  !  LJ 14 July 2015 - Code fixed to work with tstep.
  !  HCW 06 Mar 2015 - Unused variable 'i' removed.
  !  LJ Jan 2015     - Change the calculation from hourly timestep to timestep defined by nsh
  !  LJ May 2013     - Calculation of the energy balance for the SnowPack was modified
  !                        to use qn1_ind_snow(StoreDrainPrm)
  !=======================================================================================
  SUBROUTINE Snow_cal_MeltHeat(&
       snowUse,&!input
       lvS_J_kg,lv_J_kg,tstep_real,RadMeltFact,TempMeltFact,SnowAlbMax,&
       SnowDensMin,Temp_C,Precip,PrecipLimit,PrecipLimitAlb,&
       nsh_real,sfr,Tsurf_ind,Tsurf_ind_snow,state_id,qn1_ind_snow,&
       kup_ind_snow,Meltwaterstore,deltaQi,&
       SnowPack,snowFrac,SnowAlb,SnowDens,SnowfallCum,&!inout
       mwh,fwh,Qm,QmFreez,QmRain,&! output
       veg_fr,snowCalcSwitch,Qm_melt,Qm_freezState,Qm_rain,FreezMelt,&
       FreezState,FreezStateVol,rainOnSnow,SnowDepth,mw_ind,&
       dataOutLineSnow)!output

    IMPLICIT NONE
    INTEGER,PARAMETER::nsurf=7
    INTEGER,PARAMETER::PavSurf=1
    INTEGER,PARAMETER::BldgSurf=2
    INTEGER,PARAMETER::WaterSurf=7
    INTEGER,PARAMETER::ncolumnsDataOutSnow=102-5
    REAL(KIND(1d0)),PARAMETER::waterDens=999.8395 !Density of water in 0 cel deg

    !These are input to the module
    INTEGER,INTENT(in)::snowUse
    ! INTEGER,INTENT(in)::bldgsurf
    ! INTEGER,INTENT(in)::nsurf
    ! INTEGER,INTENT(in)::PavSurf
    ! INTEGER,INTENT(in)::WaterSurf

    REAL(KIND(1d0)),INTENT(in)::lvS_J_kg
    REAL(KIND(1d0)),INTENT(in)::lv_J_kg
    REAL(KIND(1d0)),INTENT(in)::tstep_real
    REAL(KIND(1d0)),INTENT(in)::RadMeltFact
    REAL(KIND(1d0)),INTENT(in)::TempMeltFact
    REAL(KIND(1d0)),INTENT(in)::SnowAlbMax
    REAL(KIND(1d0)),INTENT(in)::SnowDensMin
    REAL(KIND(1d0)),INTENT(in)::Temp_C
    REAL(KIND(1d0)),INTENT(in)::Precip
    REAL(KIND(1d0)),INTENT(in)::PrecipLimit
    REAL(KIND(1d0)),INTENT(in)::PrecipLimitAlb
    REAL(KIND(1d0)),INTENT(in)::nsh_real
    ! REAL(KIND(1d0)),INTENT(in)::waterdens

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Tsurf_ind
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Tsurf_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::state_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::qn1_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::kup_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Meltwaterstore
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::deltaQi


    !Input and output as this is updated in this subroutine
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowPack
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::snowFrac
    REAL(KIND(1d0)),INTENT(inout)::SnowAlb
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowDens
    REAL(KIND(1d0)),INTENT(inout)::SnowfallCum

    !Output:
    REAL(KIND(1d0)),INTENT(out)::mwh
    REAL(KIND(1d0)),INTENT(out)::fwh
    REAL(KIND(1d0)),INTENT(out)::Qm
    REAL(KIND(1d0)),INTENT(out)::QmFreez
    REAL(KIND(1d0)),INTENT(out)::QmRain

    REAL(KIND(1d0)),INTENT(out)::veg_fr

    INTEGER,DIMENSION(nsurf),INTENT(out)::snowCalcSwitch

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::Qm_melt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::Qm_freezState
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::Qm_rain
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::FreezMelt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::FreezState
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::FreezStateVol
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::rainOnSnow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::SnowDepth
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::mw_ind

    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutSnow),INTENT(out) :: dataOutLineSnow

    IF ( snowUse==1 ) THEN

       CALL MeltHeat(&
            bldgsurf,nsurf,PavSurf,WaterSurf,&
            lvS_J_kg,lv_J_kg,tstep_real,RadMeltFact,TempMeltFact,&
            SnowAlbMax,SnowDensMin,Temp_C,Precip,PrecipLimit,PrecipLimitAlb,&
            nsh_real,waterdens,sfr,Tsurf_ind,state_id,qn1_ind_snow,&
            Meltwaterstore,deltaQi,SnowPack,snowFrac,SnowAlb,SnowDens,SnowfallCum,&
            mwh,fwh,Qm,QmFreez,QmRain,snowCalcSwitch,&
            Qm_melt,Qm_freezState,Qm_rain,FreezMelt,FreezState,FreezStateVol,&
            rainOnSnow,SnowDepth,mw_ind)

       CALL veg_fr_snow(&
            sfr,snowFrac,nsurf,&!input
            veg_fr)!output


    ELSE ! no snow calculation
       mwh=0
       fwh=0
       Qm=0
       QmFreez=0
       QmRain=0
       SnowfallCum=0
       snowCalcSwitch=0
       Qm_melt=0
       Qm_freezState=0
       Qm_rain=0
       FreezMelt=0
       FreezState=0
       FreezStateVol=0
       rainOnSnow=0
       SnowDepth=0
       mw_ind=0

       ! update veg_fr when snowFrac=0
       snowFrac=0
       CALL veg_fr_snow(&
            sfr,snowFrac,nsurf,&!input
            veg_fr)!output

    END IF

    ! pack output into one line
    dataOutLineSnow=[&
         SnowPack(1:nsurf),mw_ind(1:nsurf),Qm_melt(1:nsurf),            & !26
         Qm_rain(1:nsurf),Qm_freezState(1:nsurf),snowFrac(1:(nsurf-1)), & !46
         rainOnSnow(1:nsurf),                                           & !53
         qn1_ind_snow(1:nsurf),kup_ind_snow(1:nsurf),freezMelt(1:nsurf),& !74
         MeltWaterStore(1:nsurf),SnowDens(1:nsurf),                     & !88
         snowDepth(1:nsurf),Tsurf_ind_snow(1:nsurf)]
    ! dataOutLineSnow=set_nan(dataOutLineSnow)

  END SUBROUTINE Snow_cal_MeltHeat


  SUBROUTINE MeltHeat(&
       bldgsurf,&!input
       nsurf,&
       PavSurf,&
       WaterSurf,&
       lvS_J_kg,&
       lv_J_kg,&
       tstep_real,&
       RadMeltFact,&
       TempMeltFact,&
       SnowAlbMax,&
       SnowDensMin,&
       Temp_C,&
       Precip,&
       PrecipLimit,&
       PrecipLimitAlb,&
       nsh_real,&
       waterdens,&
       sfr,&
       Tsurf_ind,&
       state_id,&
       qn1_ind_snow,&
       Meltwaterstore,&
       deltaQi,&
       SnowPack,&!inoout
       snowFrac,&
       SnowAlb,&
       SnowDens,&
       SnowfallCum,&
       mwh,&!output
       fwh,&
       Qm,&
       QmFreez,&
       QmRain,&
       snowCalcSwitch,&
       Qm_melt,&
       Qm_freezState,&
       Qm_rain,&
       FreezMelt,&
       FreezState,&
       FreezStateVol,&
       rainOnSnow,&
       SnowDepth,&
       mw_ind)

    IMPLICIT NONE

    !These are input to the module
    INTEGER,INTENT(in)::bldgsurf
    INTEGER,INTENT(in)::nsurf
    INTEGER,INTENT(in)::PavSurf
    INTEGER,INTENT(in)::WaterSurf

    REAL(KIND(1d0)),INTENT(in)::lvS_J_kg
    REAL(KIND(1d0)),INTENT(in)::lv_J_kg
    REAL(KIND(1d0)),INTENT(in)::tstep_real
    REAL(KIND(1d0)),INTENT(in)::RadMeltFact
    REAL(KIND(1d0)),INTENT(in)::TempMeltFact
    REAL(KIND(1d0)),INTENT(in)::SnowAlbMax
    REAL(KIND(1d0)),INTENT(in)::SnowDensMin
    REAL(KIND(1d0)),INTENT(in)::Temp_C
    REAL(KIND(1d0)),INTENT(in)::Precip
    REAL(KIND(1d0)),INTENT(in)::PrecipLimit
    REAL(KIND(1d0)),INTENT(in)::PrecipLimitAlb
    REAL(KIND(1d0)),INTENT(in)::nsh_real
    REAL(KIND(1d0)),INTENT(in)::waterdens

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Tsurf_ind
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::state_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::qn1_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Meltwaterstore
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::deltaQi


    !Input and output as this is updated in this subroutine
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowPack
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::snowFrac
    REAL(KIND(1d0)),INTENT(inout)::SnowAlb
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowDens
    REAL(KIND(1d0)),INTENT(inout)::SnowfallCum

    !Output:
    REAL(KIND(1d0)),INTENT(out)::mwh
    REAL(KIND(1d0)),INTENT(out)::fwh
    REAL(KIND(1d0)),INTENT(out)::Qm
    REAL(KIND(1d0)),INTENT(out)::QmFreez
    REAL(KIND(1d0)),INTENT(out)::QmRain

    !Output, dimension nsurf
    INTEGER,DIMENSION(nsurf),INTENT(out)::snowCalcSwitch

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::Qm_melt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::Qm_freezState
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::Qm_rain
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::FreezMelt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::FreezState
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::FreezStateVol
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::rainOnSnow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::SnowDepth
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::mw_ind

    ! local variables:
    REAL(KIND(1d0))::AdjMeltFact
    REAL(KIND(1d0))::Watfreeze

    REAL(KIND(1d0)),PARAMETER::cw=4190  !,ci=2090   !Specific heat capacity of water

    INTEGER::is,xx

    !Initialize snow variables
    mwh= 0 !Initialize snow melt and heat related to snowmelt
    fwh=0
    Qm=0
    QmFreez=0
    QmRain=0
    snowCalcSwitch=0
    Qm_melt=0
    Qm_freezState=0
    Qm_rain=0
    FreezMelt=0
    FreezState=0
    FreezStateVol=0
    rainOnSnow = 0
    SnowDepth = 0
    mw_ind=0

    !===dummy calculations===
    xx=bldgsurf
    xx=PavSurf
    !===dummy calculations end===


    !=========================================================================================
    DO is=1,nsurf  !Go each surface type through
       IF (sfr(is)/=0) THEN  !If surface type existing,

          IF (SnowPack(is)>0) THEN  !If SnowPack existing, calculate meltwater related water flows

             SnowDepth(is) = (SnowPack(is)/1000)*waterDens/SnowDens(is) !Snow depth in m

             !Calculate meltwater related water flows with hourly degree-day method.

             !These are for snow melting
             IF (Temp_C>=0) THEN
                IF (qn1_ind_snow(is)<0) THEN
                   mw_ind(is) = TempMeltFact*Temp_C             !(mm C−1 h−1)*(C) = in mm h-1
                ELSE
                   mw_ind(is) = RadMeltFact*(qn1_ind_snow(is))  !(mm m2 W−1 h−1)*(W m-2)= mm h-1 ??
                ENDIF

             ELSE  !Freezing equations
                AdjMeltFact=1  !Relationship between the temperature melt and freezing factors
                mw_ind(is) = TempMeltFact*Temp_C*AdjMeltFact ! in mm h-1
             ENDIF
             !Previous equation give the hourly values, divide these with the timestep number
             mw_ind(is) = mw_ind(is)/nsh_real

             IF (mw_ind(is)>SnowPack(is)) mw_ind(is) = SnowPack(is)!Limited by the previous timestep SnowPack

             !-----------------------------------------------------
             ! Heat consumed to snowmelt/refreezing within Tstep.
             ! Converted from mm nsh-1 to mm nsh-1 and to m s-1
             Qm_melt(is) = waterDens*((mw_ind(is)/tstep_real)/1000)*(lvS_J_kg-lv_J_kg)

             !If melt is negative this means freezing water in the SnowPack
             IF (mw_ind(is)<0) THEN

                FreezMelt(is) = -mw_ind(is) !Save this to variable FreezMelt
                mw_ind(is) = 0

                !Freezing water cannot exceed meltwater store
                IF (FreezMelt(is)>Meltwaterstore(is)) FreezMelt(is) = Meltwaterstore(is)

                !Recalculate melt related energy
                Qm_melt(is) = waterDens*((-FreezMelt(is)/tstep_real)/1000)*(lvS_J_kg-lv_J_kg)
             ENDIF

             !-----------------------------------------------------
             ! If air temperature is above zero, precipitation causes advective heat to the
             ! SnowPack. Eq (23) in Sun et al., 1999
             ! Calculation done at resolution of the model timestep
             IF (Temp_C>=PrecipLimit.AND.Precip>0) THEN
                Qm_rain(is) = waterDens*cw*(Temp_C-PrecipLimit)*(Precip*0.001/tstep_real)  !in W m-2
                IF (Qm_rain(is)<0) THEN !Can only be positive
                   Qm_rain(is) = 0
                ELSE
                   rainOnSnow(is) = Precip !Save information on the rain on snow event
                ENDIF
             ENDIF

          ENDIF !End if SnowPack

          !=================================================================

          !Freeze surface water state_id if cold enough.
          IF (Tsurf_ind(is)<0.AND.state_id(is)>0) THEN

             snowCalcSwitch(is)=1 !If water on ground this forms ice and snow calculations are made

             !Other surfaces than water treated first
             IF (is/=WaterSurf) THEN

                !FreezState(is) = state_id(is)
                !Previously all state_id could freeze in 5-min timestep. Now we calculate how much water
                !can freeze in a timestep based on the same temperature freezing fraction.
                FreezState(is) = -TempMeltFact*Tsurf_ind(is)/nsh_real

                !The amount of freezing water cannot be greater than the surface state_id
                IF (FreezState(is)>state_id(is)) FreezState(is) = state_id(is)

                IF (SnowPack(is)==0.OR.snowfrac(is)==0) THEN !SnowPack forms
                   FreezStateVol(is) = FreezState(is)
                ELSE                                         !There is snow already on ground
                   FreezStateVol(is) = FreezState(is)*(1-snowFrac(is))/snowFrac(is)
                ENDIF

                ! If the amount of freezing water is very small and there is state_id left to the ground
                ! no freezing of water will take place
                IF (FreezStateVol(is)<0.00000000001.AND.FreezState(is)<state_id(is)) THEN
                   FreezState(is) = 0
                   FreezStateVol(is) = 0
                ENDIF

                !Calculate the heat exchange in W m-2
                Qm_freezState(is) = -waterDens*(FreezState(is)/tstep_real/1000)*(lvS_J_kg-lv_J_kg)

                !Water surface separately
             ELSE
                !Calculate average value how much water can freeze above the water areas
                !Equation is -hA(T-T0) = rhoV(Cp+dT +Lf) in 5-min timestep
                !h=convective heat trasnfer,A, area of water,rwo water density,V volume, dT temperature difference
                !before and end of the 5-min period. dT equals zero, h=100 and when multiplied with Area, the equation
                !simplyfies to the this. LJ 14 July 2015
                Watfreeze = 100*(0-Temp_C)/(waterDens*(lvS_J_kg-lv_J_kg))
                FreezState(is) = Watfreeze
                Qm_freezState(is) = -waterDens*(Watfreeze/tstep_real/1000)*(lvS_J_kg-lv_J_kg)
             ENDIF

          ENDIF

          !======================================================================
          ! Define if any snowmelt calculations are made: SnowPack existing,
          ! freezing occuring on ground or from precip
          IF (is/=WaterSurf) THEN
             IF (SnowPack(is)>0.OR.(Precip>0.AND.Tsurf_ind(is)<0)) THEN
                snowCalcSwitch(is)=1
             ENDIF
          ELSE       !Water surface separately
             IF (SnowPack(WaterSurf)>0.OR.FreezState(WaterSurf)>0) THEN
                snowCalcSwitch(WaterSurf)=1
             ENDIF
          ENDIF

          !Update snow density of each surface
          IF (Precip>0.AND.Tsurf_ind(is)<0.AND.SnowPack(is)>0) THEN
             SnowDens(is) = SnowDens(is)*SnowPack(is)/(SnowPack(is)+Precip)+SnowDensMin*Precip/(SnowPack(is)+Precip)
          ENDIF

          !Weighted variables for the whole area
          mwh = mwh + mw_ind(is)*sfr(is)*snowFrac(is)        !Snowmelt
          fwh = fwh + FreezMelt(is)*sfr(is)*snowFrac(is)     !Freezing water
          Qm = Qm + Qm_melt(is)*sfr(is)*snowFrac(is)         !Energy consumed to the melt/freezing.
          QmRain = QmRain + Qm_rain(is)*sfr(is)*snowFrac(is) !Rain on snow
          QmFreez=QmFreez+deltaQi(is)*sfr(is)*snowFrac(is)+Qm_freezState(is)*sfr(is)*(1-snowFrac(is)) !Freezing water
       ENDIF

    ENDDO !End surface type

    !Update snow albedo to its maximum value if precipitation exists
    IF (Precip>0.AND.SUM(SnowPack)>0.AND.Temp_C<0) THEN

       SnowfallCum=SnowfallCum + Precip

       IF (SnowfallCum>PrecipLimitAlb) THEN

          SnowAlb=SnowAlbMax
          SnowfallCum=0
       ENDIF
    ELSE

       SnowfallCum=0
    ENDIF



  END SUBROUTINE MeltHeat


  !===============================================================================================
  !===============================================================================================
  SUBROUTINE SnowCalc(&
       tstep,imin,it,dectime,is,&!input
       EvapMethod,CRWmin,CRWmax,nsh_real,lvS_J_kg,lv_j_kg,avdens,&
       avRh,Press_hPa,Temp_C,RAsnow,psyc_hPa,avcp,sIce_hPa,&
       PervFraction,vegfraction,addimpervious,&
       numPM,s_hPa,ResistSurf,sp,RA,rb,tlv,snowdensmin,SnowProf_24hr,precip,&
       PipeCapacity,RunoffToWater,runoffAGimpervious,runoffAGveg,&
       addVeg,surplusWaterBody,SnowLimPaved,SnowLimBuild,FlowChange,drain,&
       WetThresh,stateOld,mw_ind,soilstorecap,rainonsnow,&
       freezmelt,freezstate,freezstatevol,&
       Qm_Melt,Qm_rain,Tsurf_ind,sfr,dayofWeek_id,StoreDrainPrm,snowD,&
       AddWater,addwaterrunoff,&
       SnowPack,SurplusEvap,&!inout
       snowFrac,MeltWaterStore,iceFrac,SnowDens,&
       runoffSnow,& ! output
       runoff,runoffSoil,chang,changSnow,SnowToSurf,state_id,ev_snow,soilmoist_id,&
       SnowDepth,SnowRemoval,swe,ev,chSnow_per_interval,&
       ev_per_tstep,qe_per_tstep,runoff_per_tstep,surf_chang_per_tstep,&
       runoffPipes,mwstore,runoffwaterbody)

    !Calculation of snow and water balance on 5 min timestep. Treats snowfree and snow covered
    !areas separately. Weighting is taken into account in the overall values.
    !Last modified:
    !  LJ in 6 May 2015 - Modified to run with timestep
    !  HCW 06 Mar 2015 - Unused variable 'i' removed.
    !  HCW 26 Jan 2015 - Added weekday/weekend option for snow clearing profiles
    !  LJ in 24 May 2013
    !========================================================================
    USE WaterDist_module,ONLY:updateFlood


    IMPLICIT NONE
    INTEGER,PARAMETER::nsurf=7! number of surface types
    INTEGER,PARAMETER::PavSurf   = 1  !New surface classes: Grass = 5th/7 surfaces
    INTEGER,PARAMETER::BldgSurf  = 2  !New surface classes: Grass = 5th/7 surfaces
    INTEGER,PARAMETER::ConifSurf = 3  !New surface classes: Grass = 5th/7 surfaces
    ! INTEGER,PARAMETER::DecidSurf = 4  !New surface classes: Grass = 5th/7 surfaces
    ! INTEGER,PARAMETER::GrassSurf = 5
    INTEGER,PARAMETER::BSoilSurf = 6!New surface classes: Grass = 5th/7 surfaces
    INTEGER,PARAMETER::WaterSurf = 7

    INTEGER,PARAMETER::snowfractionchoice=2 ! this PARAMETER is used all through the model
    REAL(KIND(1d0)),PARAMETER::waterDens=999.8395 !Density of water in 0 cel deg

    ! INTEGER,INTENT(in)::id
    ! INTEGER,INTENT(in)::nsurf
    INTEGER,INTENT(in)::tstep
    INTEGER,INTENT(in)::imin
    INTEGER,INTENT(in)::it
    INTEGER,INTENT(in)::is

    ! INTEGER,INTENT(in)::ConifSurf
    ! INTEGER,INTENT(in)::BSoilSurf
    ! INTEGER,INTENT(in)::BldgSurf
    ! INTEGER,INTENT(in)::PavSurf
    ! INTEGER,INTENT(in)::WaterSurf
    INTEGER,INTENT(in)::EvapMethod!Evaporation calculated according to Rutter (1) or Shuttleworth (2)
    INTEGER,DIMENSION(3),INTENT(in)  ::DayofWeek_id

    REAL(KIND(1d0)),INTENT(in)::dectime
    REAL(KIND(1d0)),INTENT(in)::CRWmin
    REAL(KIND(1d0)),INTENT(in)::CRWmax
    REAL(KIND(1d0)),INTENT(in)::nsh_real
    REAL(KIND(1d0)),INTENT(in)::lvS_J_kg
    REAL(KIND(1d0)),INTENT(in)::lv_j_kg
    REAL(KIND(1d0)),INTENT(in)::avdens
    ! REAL(KIND(1d0)),INTENT(in)::waterdens
    REAL(KIND(1d0)),INTENT(in)::avRh
    REAL(KIND(1d0)),INTENT(in)::Press_hPa
    REAL(KIND(1d0)),INTENT(in)::Temp_C
    REAL(KIND(1d0)),INTENT(in)::RAsnow
    REAL(KIND(1d0)),INTENT(in)::psyc_hPa
    REAL(KIND(1d0)),INTENT(in)::avcp
    REAL(KIND(1d0)),INTENT(in)::sIce_hPa
    REAL(KIND(1d0)),INTENT(in)::PervFraction
    REAL(KIND(1d0)),INTENT(in)::vegfraction
    REAL(KIND(1d0)),INTENT(in)::addimpervious
    REAL(KIND(1d0)),INTENT(in)::numPM
    REAL(KIND(1d0)),INTENT(in)::s_hPa
    REAL(KIND(1d0)),INTENT(in)::ResistSurf
    REAL(KIND(1d0)),INTENT(in)::sp
    REAL(KIND(1d0)),INTENT(in)::RA
    REAL(KIND(1d0)),INTENT(in)::rb
    REAL(KIND(1d0)),INTENT(in)::tlv
    REAL(KIND(1d0)),INTENT(in)::snowdensmin
    REAL(KIND(1d0)),INTENT(in)::precip
    REAL(KIND(1d0)),INTENT(in)::PipeCapacity
    REAL(KIND(1d0)),INTENT(in)::RunoffToWater
    REAL(KIND(1d0)),INTENT(in)::addVeg
    REAL(KIND(1d0)),INTENT(in)::SnowLimPaved
    REAL(KIND(1d0)),INTENT(in)::SnowLimBuild
    REAL(KIND(1d0)),INTENT(in)::FlowChange

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::drain
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::WetThresh
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::stateOld
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::mw_ind
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::soilstorecap
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::rainonsnow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::freezmelt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::freezstate
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::freezstatevol
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Qm_Melt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Qm_rain
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Tsurf_ind
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::snowD
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::AddWater
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::addwaterrunoff
    REAL(KIND(1d0)),DIMENSION(6,nsurf),INTENT(in)::StoreDrainPrm
    REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in)::SnowProf_24hr

    !Updated status: input and output
    REAL(KIND(1d0)),INTENT(inout)::runoffAGveg
    REAL(KIND(1d0)),INTENT(inout)::runoffAGimpervious
    REAL(KIND(1d0)),INTENT(inout)::surplusWaterBody

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowPack
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::snowFrac
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::MeltWaterStore
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::iceFrac
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowDens

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::runoffSnow !Initialize for runoff caused by snowmelting
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::runoff
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::runoffSoil
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::chang
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::changSnow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::SnowToSurf
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::state_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::SnowDepth
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::ev_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::soilmoist_id
    REAL(KIND(1d0)),DIMENSION(2),INTENT(out)::SnowRemoval



    REAL(KIND(1d0)),INTENT(out)::swe
    REAL(KIND(1d0)),INTENT(out)::ev
    REAL(KIND(1d0)),INTENT(out)::chSnow_per_interval
    REAL(KIND(1d0)),INTENT(out)::ev_per_tstep
    REAL(KIND(1d0)),INTENT(out)::qe_per_tstep
    REAL(KIND(1d0)),INTENT(out)::runoff_per_tstep
    REAL(KIND(1d0)),INTENT(out)::surf_chang_per_tstep
    REAL(KIND(1d0)),INTENT(out)::runoffPipes
    REAL(KIND(1d0)),INTENT(out)::mwstore
    REAL(KIND(1d0)),INTENT(out)::runoffwaterbody


    REAL(KIND(1d0)),DIMENSION(2),INTENT(inout):: SurplusEvap


    REAL(KIND(1d0))::qe
    REAL(KIND(1d0))::rss

    ! REAL(KIND(1d0))::Evap_SUEWS_Snow
    REAL(KIND(1d0))::MeltExcess      !Excess melt water that needs to leave SnowPack
    REAL(KIND(1d0))::snowTotInit
    REAL(KIND(1d0))::EvPart
    REAL(KIND(1d0))::runoffTest
    REAL(KIND(1d0))::snowFracFresh1   !Snow fraction for newly formed SnowPack
    REAL(KIND(1d0))::snowFracFresh2   !Snow fraction for newly formed SnowPack from state_id only
    REAL(KIND(1d0))::snowFracOld
    REAL(KIND(1d0))::WaterHoldCapFrac
    REAL(KIND(1d0))::FWC                !Water holding capacity of snow in mm
    ! REAL(KIND(1d0)):: SnowDepletionCurve

    INTEGER:: iu                        !1=weekday OR 2=weekend
    REAL(KIND(1d0)),PARAMETER :: IPThreshold_mmhr = 10   !Threshold for intense precipitation [mm hr-1]

    REAL(KIND(1d0)),DIMENSION(7)::capStore ! current storage capacity [mm]

    !========================================================================
    !Initialize variables for the calculation of water storages and evaporation
    ev_per_tstep         = 0
    qe_per_tstep         = 0
    runoff_per_tstep     = 0
    surf_chang_per_tstep = 0

    ! Use weekday or weekend snow clearing profile
    iu=1     !Set to 1=weekday
    IF(DayofWeek_id(1)==1.OR.DayofWeek_id(1)==7) iu=2  !Set to 2=weekend

    !write(*,*) is
    runoffSnow(is)=0 !Initialize for runoff caused by snowmelting
    runoff(is)=0
    runoffSoil(is)=0
    chang(is)=0
    changSnow(is)=0
    runoffTest=0
    SnowToSurf(is)=0
    EvPart=0
    ev=0
    snowFracFresh1=0
    snowFracFresh2=0
    snowFracOld=0

    !Initial SnowPack + meltwater in it
    snowTotInit=SnowPack(is)+MeltWaterStore(is)

    !Calculate water holding capacity (Jin et al. 1999)
    IF (SnowDens(is)>=200) THEN
       WaterHoldCapFrac=CRWmin
    ELSE
       WaterHoldCapFrac=CRWmin+(CRWmax-CRWmin)*(200-SnowDens(is))/200
    ENDIF

    !======================================================================
    ! Calculate evaporation from SnowPack and snow free surfaces (in mm)
    ! IF (snowFrac(is)<1) CALL Evap_SUEWS !ev and qe for snow free surface out
    capStore(is)=StoreDrainPrm(6,is)
    IF (snowFrac(is)<1) CALL Evap_SUEWS(&

                                ! input:
         EvapMethod,&!Evaporation calculated according to Rutter (1) or Shuttleworth (2)
         state_id(is),& ! wetness status
         WetThresh(is),&!When state_id > WetThresh, RS=0 limit in SUEWS_evap [mm] (specified in input files)
         capStore(is),& ! = StoreDrainPrm(is,6), current storage capacity [mm]
         numPM,&!numerator of P-M eqn
         s_hPa,&!Vapour pressure versus temperature slope in hPa
         psyc_hPa,&!Psychometric constant in hPa
         ResistSurf,&!Surface resistance
         sp,&!Term in calculation of E
         RA,&!Aerodynamic resistance
         rb,&!Boundary layer resistance
         tlv,&!Latent heat of vaporization per timestep [J kg-1 s-1], (tlv=lv_J_kg/tstep_real)

                                ! output:
         rss,&
         ev,&
         qe) ! latent heat flux [W m-2]

    IF (snowFrac(is)>0) THEN
       ev_snow(is) = Evap_SUEWS_Snow(Qm_Melt(is),Qm_rain(is),lvS_J_kg,avdens,avRh,Press_hPa,Temp_C,RAsnow,&
            psyc_hPa,tstep,avcp,sIce_hPa,dectime)
    ENDIF

    !If not enough water for evaporation in impervious surfaces,
    !evaporation is taken from pervious surfaces
    IF (is>2) THEN
       IF  (PervFraction/=0) THEN
          EvPart=(SurplusEvap(PavSurf)*sfr(PavSurf)+SurplusEvap(BldgSurf)*sfr(BldgSurf))/PervFraction
       ENDIF
    ENDIF


    !============================================================================
    !Water surface is treated separately
    IF (is==WaterSurf.AND.sfr(WaterSurf)>0) GO TO 606

    !The calculations are divided into 2 main parts
    ! 1) Surface is fully covered with snow at the beginning of the time step
    ! 2) Surface is not fully covered with snow but rather part is snow free OR
    !    surface not orginally covered with snow, but the snow forms at the current timestep

    !1)------------------------------------------------------------------
    !  ------------------------------------------------------------------
    IF (SnowPack(is)>0.AND.snowFrac(is)==1) THEN

       ev_snow(is)=ev_snow(is)+EvPart !Evaporation surplus

       !(Snowfall per interval+freezing of melt water and surface state_id) - (meltwater+evaporation from SnowPack)
       changSnow(is)=(Precip+freezMelt(is))-(mw_ind(is)+ev_snow(is)) !Calculate change in SnowPack (in mm)

       !If rain on snow event, add this water to meltwaterstore
       IF (rainOnSnow(is)>0) THEN
          changSnow(is)=changSnow(is)-Precip
          MeltWaterStore(is) = MeltWaterStore(is)+rainOnSnow(is)
       ENDIF

       SnowPack(is)=SnowPack(is)+changSnow(is)  !Update SnowPack

       !---------If SnowPack exists after the state_id calculations
       IF (SnowPack(is)>0) THEN

          !Add melted water to meltstore and freeze water according to freezMelt(is)
          MeltWaterStore(is) = MeltWaterStore(is) + mw_ind(is) - freezMelt(is)

          !Calculate water holding capacity (FWC: Valeo and Ho, 2004) of the SnowPack
          FWC = WaterHoldCapFrac*SnowPack(is)

          !If FWC is exceeded, excess meltwater (MeltExcess) will leave from the SnowPack
          IF (MeltWaterStore(is)>=FWC) THEN
             MeltExcess = 0                      !Initialize the excess meltwater
             MeltExcess = MeltWaterStore(is)-FWC !Calculate the exceess water
             MeltWaterStore(is) = FWC            !Update the meltwaterstore to the maximum it can hold
             runoffSnow(is) = runoffSnow(is) + MeltExcess
          ENDIF

          !At the end of the hour calculate possible snow removal
          IF (SnowProf_24hr(it,iu)==1.AND.is<3.AND.(imin==(nsh_real-1)/nsh_real*60))  &
               CALL snowRem(&
               is,PavSurf,BldgSurf,nsurf,&
               snowfrac,sfr,&
               SnowPack, SnowRemoval,&
               SnowLimPaved,SnowLimBuild)
          !----------If SnowPack is negative, it melts at this timestep
       ELSEIF (SnowPack(is)<0) THEN

          !If freezing meltwater inside this timestep, remove it from the MeltWaterStore
          MeltWaterStore(is)=MeltWaterStore(is)-freezMelt(is)+mw_ind(is)+SnowPack(is)
          SnowPack(is)=0.0   !Set the snow pack and snow
          snowFracOld=1
          snowFrac(is)=0
          snowDens(is)=0

          IF (MeltWaterStore(is)<0) THEN !Not enough water in the meltwater store,
             ev_snow(is)=ev_snow(is)+MeltWaterStore(is) !QUESTION: evaporation from snow is decreased?
             IF (ev_snow(is)<0) ev_snow(is)=0
             changSnow(is)=changSnow(is)+MeltWaterStore(is)
             MeltWaterStore(is)=0
          ELSE
             chang(is)=MeltWaterStore(is)  !Meltwater goes to surface state_id as no snow exists anymore
             state_id(is)=state_id(is)+chang(is)
             MeltWaterStore(is)=0
          ENDIF
       ENDIF !SnowPack negative or positive


       !2)------Surface not fully covered with snow-------------------------------------------
       !  ------------------------------------------------------------------------------------
    ELSEIF (snowFrac(is)<1) THEN

       !Snow calculations: SnowPack can either exist or form at the current timestep
       IF (SnowPack(is)>0) THEN
          ev_snow(is)=ev_snow(is)+EvPart !Evaporation surplus


          !----SnowPack water balance for the whole surface area. In reality snow depth = SnowPack/snowFrac(is)
          !(Snowfall per interval+freezing of melt water and surface state_id) - (meltwater+evaporation from SnowPack)
          changSnow(is)=(Precip+freezMelt(is)+freezStateVol(is))-(mw_ind(is)+ev_snow(is)) !Calculate change in SnowPack (in mm)

          !If rain on snow event, add this water to meltwaterstore
          IF (rainOnSnow(is)>0) THEN
             changSnow(is)=changSnow(is)-Precip
             MeltWaterStore(is) = MeltWaterStore(is)+rainOnSnow(is)
          ENDIF
          SnowPack(is)=SnowPack(is)+changSnow(is)


          !The fraction of snow will update when:
          !a) Surface state_id is dry but precipitation occurs =1
          !b) There is both precipitation and all surface state_id freezes =1
          !c) No precipitation but all state_id freezes at a single timestep =2
          !d) Part of the surface freezes
          IF (Precip>0.AND.FreezState(is)==state_id(is)) THEN !both a) and b)
             snowFracFresh1=1
          ELSEIF (Precip==0.AND.FreezState(is)>0.AND.FreezState(is)==state_id(is)) THEN
             snowFracFresh1=1

             !snowFracFresh1=SnowDepletionCurve(is,SnowPack(is),snowD(is))
             !if (snowFracFresh1<0.001) snowFracFresh1=0.001
          ELSEIF (FreezState(is)>0.AND.FreezState(is)<state_id(is)) THEN !This if not all water freezes
             snowFracFresh1=0.95 !Now this fraction set to something close to one. Should be improved in the future at some point
             !if (is==1)then
             ! write(*,*) id,it,imin,snowfrac(is),FreezState(is),state_id(is)
             ! pause
             !endif
          ENDIF

          !SnowPack can also form at the current timestep (2). If this forms purely from snowfall or/and all water at surface freezes,
          !the whole surface will be covered with snow. If there is water on ground this snowfall can immediately melt
          !and in this case the snow fraction is not necessarily 1 but its information is saved to snowFracFresh that
          !is taken into account in snow fraction after calculation of state_id.
       ELSEIF (SnowPack(is)==0.AND.Tsurf_ind(is)<0) THEN

          !The fraction of snow will get a value of 1 (ie full snow cover):
          !Surface state_id is dry but precipitation occurs, no precipitation but all state_id freezes at a single timestep,
          !There is both precipitation and all surface state_id freezes
          IF ((Precip>0.AND.state_id(is)==0).OR.(Precip==0.AND.FreezState(is)==state_id(is)).OR.&
               (Precip>0.AND.FreezState(is)==state_id(is))) THEN

             !ev=ev+EvPart
             changSnow(is)=Precip+FreezStateVol(is)
             SnowPack(is)=SnowPack(is)+changSnow(is)  !Update SnowPack

             snowFracFresh1=1
             iceFrac(is)=FreezState(is)/(FreezState(is)+Precip)
             SnowDens(is)=SnowDensMin
          ENDIF

          IF (FreezState(is)>0.AND.FreezState(is)<state_id(is)) THEN

             changSnow(is)=Precip+freezStateVol(is)
             SnowPack(is)=SnowPack(is)+changSnow(is)  !Update SnowPack
             snowFracFresh2=0.95 !Now this fraction set to something close to one. Should be improved in the future at some point

             !snowFracFresh2=SnowDepletionCurve(is,SnowPack(is),snowD(is))
             !if (snowFracFresh2<0.001) snowFracFresh2=0.001
             iceFrac(is)=1
             SnowDens(is)=SnowDensMin
             !write(*,*) 2,is,id,it,imin,snowfrac(is),FreezState(is),state_id(is),state_id(is)+Precip
             !pause

          ENDIF
       ENDIF

       !---------If SnowPack exists after the state_id calculations
       IF (SnowPack(is)>0) THEN

          !Add melted water to meltstore and freeze water according to freezMelt(is)
          MeltWaterStore(is) = MeltWaterStore(is) + mw_ind(is) - freezMelt(is)

          !Calculate water holding capacity (FWC: Valeo and Ho, 2004) of the SnowPack
          FWC = WaterHoldCapFrac*SnowPack(is)

          !If FWC is exceeded, excess meltwater (MeltExcess) will leave from the SnowPack
          IF (MeltWaterStore(is)>=FWC) THEN
             MeltExcess = 0                      !Initialize the excess meltwater
             MeltExcess = MeltWaterStore(is)-FWC !Calculate the exceess water
             MeltWaterStore(is) = FWC            !Update the meltwaterstore to the maximum it can hold

             !If the fraction of snow is greater than 0.8 or if the surface is is buildings,
             !the excess water will directly go to runoff. Otherwise it will flow to the
             !snow free area via SnowToSurf(is)
             IF ((snowFrac(is)>0.9.AND.is/=BldgSurf).OR.(is==BldgSurf)) THEN
                runoffSnow(is) = runoffSnow(is) + MeltExcess
             ELSE
                SnowToSurf(is) = SnowToSurf(is) + MeltExcess*snowFrac(is)/(1-snowFrac(is))
             ENDIF
          ENDIF

          !At the end of the hour calculate possible snow removal
          IF (SnowProf_24hr(it,iu)==1.AND.is<3.AND.(imin==(nsh_real-1)/nsh_real*60))  &
               CALL snowRem(&
               is,PavSurf,BldgSurf,nsurf,&
               snowfrac,sfr,&
               SnowPack, SnowRemoval,&
               SnowLimPaved,SnowLimBuild)

          !----------If SnowPack is negative, it melts at this timestep
       ELSEIF (SnowPack(is)<0) THEN

          !If freezing meltwater inside this timestep, remove it from the MeltWaterStore
          MeltWaterStore(is)=MeltWaterStore(is)-freezMelt(is)+mw_ind(is)+SnowPack(is)

          SnowPack(is)=0.0   !Set the snow pack and snow
          snowFracFresh1=0
          snowFracFresh2=0
          snowDens(is)=0

          IF (MeltWaterStore(is)<0) THEN !Not enough water in the meltwater store,
             ev_snow(is)=ev_snow(is)+MeltWaterStore(is) !QUESTION: evaporation from snow is decreased.?
             IF (ev_snow(is)<0) ev_snow(is)=0
             changSnow(is)=changSnow(is)+MeltWaterStore(is)
             MeltWaterStore(is)=0
          ELSE
             SnowToSurf(is)=SnowToSurf(is)+MeltWaterStore(is)*snowFrac(is)/(1-snowFrac(is))
             MeltWaterStore(is)=0
          ENDIF
       ENDIF !SnowPack negative or positive


       !--------
       !Next the snow free surface (3). Calculations only done if snowfraction is smaller than 1
       IF ((is==PavSurf.OR.is==BldgSurf).AND.snowFrac(is)<1) THEN  !Impervious surfaces (paved, buildings)

          !Surface store update. If precipitation is greater than the threshold, the exceeding water
          !goes directly to runoff
          IF (precip>IPThreshold_mmhr/nsh_real) THEN
             !runoff = runoff + (precipitation+water from the snow surface+water from other surfaces-the thereshold limit)
             runoff(is)=runoff(is)+(Precip+SnowToSurf(is)+AddWater(is)-IPThreshold_mmhr/nsh_real)
             chang(is)=IPThreshold_mmhr/nsh_real-(drain(is)+ev+freezState(is))
          ELSE
             !Add precip and water from other surfaces and remove drainage, evap and freezing of state_id
             chang(is)=Precip+SnowToSurf(is)+AddWater(is)-(drain(is)+ev+freezState(is))
          ENDIF

          state_id(is)=state_id(is)+chang(is) !Change in state_id (for whole surface area areasfr(is))

          !Add water from impervious grids
          ! Check sfr/=0 added HCW 08 Dec 2015
          IF (is==PavSurf.AND.sfr(PavSurf)>0) state_id(is)=state_id(is)+(addImpervious)/sfr(PavSurf)

          runoff(is)=runoff(is)+drain(is)*AddWaterRunoff(is) !Drainage (not flowing to other surfaces) goes to runoff

          IF(state_id(is)<0.0) THEN  !Surface state_id cannot be negative
             SurplusEvap(is)=ABS(state_id(is)) !take evaporation from other surfaces in mm
             ev = ev-SurplusEvap(is)
             state_id(is)=0.0
          ENDIF

       ELSEIF(is>=3.AND.snowFrac(is)<1) THEN ! Pervious surfaces (conif, decid, grass unirr, grass irr)

          ev=ev+EvPart

          !Change in water stores
          IF ( VegFraction>0 ) THEN
             IF (Precip+addVeg*(sfr(is)/VegFraction)>(IPThreshold_mmhr/nsh_real)) THEN !if 5min precipitation is larger than 10 mm
                runoff(is)=runoff(is)+(Precip+addVeg*(sfr(is)/VegFraction)+SnowToSurf(is)+AddWater(is)-(IPThreshold_mmhr/nsh_real))
                chang(is)=(IPThreshold_mmhr/nsh_real)-(drain(is)+ev+freezState(is))
             ELSE
                chang(is)=Precip+addVeg*(sfr(is)/VegFraction)+SnowToSurf(is)+AddWater(is)-(drain(is)+ev+freezState(is))
             ENDIF
          ELSE
             chang(is)=Precip+SnowToSurf(is)+AddWater(is)-(drain(is)+ev+freezState(is))
          END IF


          state_id(is)=state_id(is)+chang(is)

          !Add water in soil store only if ground is not frozen
          IF (Temp_C>0) THEN
             soilmoist_id(is)=soilmoist_id(is)+Drain(is)*AddWaterRunoff(is)*(1-snowFrac(is))
          ELSE
             runoff(is)=runoff(is)+Drain(is)*AddWaterRunoff(is)
          ENDIF

          !If state_id of the surface is negative, remove water from soilstore
          IF(state_id(is)<0.0) THEN

             IF ((soilmoist_id(is)+state_id(is))>=0.AND.Temp_C>0) THEN !If water in soilstore, water is removed

                soilmoist_id(is)=soilmoist_id(is)+state_id(is)*(1-snowFrac(is))
                state_id(is)=0.0

             ELSE !If not water in the soilstore evaporation does not occur
                chang(is)=chang(is)+state_id(is)
                ev=ev+state_id(is)
                state_id(is)=0.0
             ENDIF
          ENDIF !state_id is negative

          !If soilstorage is full at this point, excess will go to surface runoff
          IF (soilmoist_id(is)>soilstoreCap(is)) THEN
             runoffTest=runoffTest+(soilmoist_id(is)-soilstoreCap(is))
             soilmoist_id(is)=soilstoreCap(is)
          ELSEIF (soilmoist_id(is)<0) THEN
             soilmoist_id(is)=0
          ENDIF

       ENDIF !Surface type

    ENDIF !Surface fraction

    !-------------------------------------------------------------------------------------------------------------------

    !Calculate change in SnowPack and state_id for the respective surface areas
    !Here the case where not all surface state_id freezes is handled
    IF (snowFracFresh2>0) THEN
       surf_chang_per_tstep=surf_chang_per_tstep+(state_id(is)-stateOld(is))*sfr(is)*(1-snowFrac(is))&
            -Precip*sfr(is)*(1-snowFracFresh2)
       chSnow_per_interval=chSnow_per_interval+((SnowPack(is)+MeltWaterstore(is))-snowTotInit)*sfr(is)*(1-snowFrac(is))&
            -Precip*sfr(is)*snowFracFresh2
    ELSE
       surf_chang_per_tstep=surf_chang_per_tstep+(state_id(is)-stateOld(is))*sfr(is)*(1-snowFrac(is))
       chSnow_per_interval=chSnow_per_interval+((SnowPack(is)+MeltWaterstore(is))-snowTotInit)*sfr(is)*MAX(snowFrac(is),snowfracOld)
    ENDIF

    !Add evaporation to total
    IF (is==BldgSurf.OR.is==PavSurf) THEN
       ev_per_tstep=ev_per_tstep+ev*sfr(is)*(1-snowFrac(is))+ev_snow(is)*sfr(is)*MAX(snowFrac(is),snowfracOld)
       qe_per_tstep=qe_per_tstep+ev_snow(is)*lvS_J_kg*sfr(is)*snowFrac(is)&
            +ev*lv_J_kg*sfr(is)*(1-snowFrac(is))
    ELSE
       ev_per_tstep=ev_per_tstep+ev*sfr(is)*(1-snowFrac(is))+ev_snow(is)*sfr(is)*MAX(snowFrac(is),snowfracOld)
       qe_per_tstep=qe_per_tstep+ev_snow(is)*lvS_J_kg*sfr(is)*MAX(snowFrac(is),snowfracOld)+ev*lv_J_kg*sfr(is)*(1-snowFrac(is))
    ENDIF

    !========RUNOFF=======================

    !Add runoff to pipes
    runoffPipes=runoffPipes+runoffSnow(is)*sfr(is)*MAX(snowFrac(is),snowfracOld)+runoff(is)*sfr(is)*(1-snowFrac(is))&
         +runoffTest*sfr(is)
    CALL updateFlood(&
                                ! input:
         nsurf,is,PavSurf,BldgSurf,WaterSurf,ConifSurf,BSoilSurf,&
         sfr,PipeCapacity,RunoffToWater,&
                                ! inout:
         runoffAGimpervious,surplusWaterBody,runoffAGveg,runoffPipes)

    runoff_per_tstep=runoff_per_tstep+runoffSnow(is)*sfr(is)*MAX(snowFrac(is),snowfracOld)+runoff(is)*sfr(is)*(1-snowFrac(is))&
         +runoffTest*sfr(is)

    !===Update snow depth, weighted SWE, and Mwstore
    IF (SnowDens(is)/=0) THEN
       SnowDepth(is) = SnowPack(is)*waterDens/SnowDens(is)
    ENDIF

    ! Calculate overall snow water equivalent
    swe = swe + SnowPack(is)*sfr(is)*MAX(snowFrac(is),snowfracOld)
    MwStore = MwStore + MeltWaterStore(is)*sfr(is)*MAX(snowFrac(is),snowfracOld)

    !if (id==6.and.it==13.and.imin==20) then!
    !if (id==85.and.it==3.and.imin==10) then!
    ! if (id==92.and.it==21.and.imin==35) then!
    !  write(*,*)  ((SnowPack(is)+MeltWaterstore(is))-snowTotInit)*sfr(is)*(1-snowFrac(is)),&
    !              runoff(is)*sfr(is)*(1-snowFrac(is)),&
    !              ev*sfr(is)*(1-snowFrac(is)),&
    !              (state_id(is)-stateOld(is))*sfr(is)*(1-snowFrac(is)),Precip*sfr(is)
    !  write(*,*)  changSnow(is),runoff(is),ev,chang(is),runoffTest,FreezState(is) !changSnow(is)-freezMelt(is)
    !  write(*,*)  is,Precip,runoff_per_tstep,ev_per_tstep,surf_chang_per_tstep,chSnow_per_interval
    !  write(*,*)  is,Precip-runoff_per_tstep-ev_per_tstep,surf_chang_per_tstep+chSnow_per_interval
    !  write(*,*)  is,snowFrac(is),sfr(is),sfr(is)*ev_snow(is)
    !  pause
    ! endif

    !Only now update the new snow fractions both in the case that snow existing already on ground
    !and snow forms at the current timestep
    IF (snowFracFresh1>0) snowFrac(is)=snowFracFresh1
    IF (snowFracFresh2>0) snowFrac(is)=snowFracFresh2

    !Calculate new snow fraction here.
    !Tässä ongelmana että snow fraction muuttuu vain kun on sulamisvettä ja on vika tunti.
    !Tämä ei juuri koskaan toteudu johtuen lämpötilan vuorokausisyklistä
    !Kokeile tässä ajaa kahdella tavalla 1) ei tarvita Mw:tä
    !                                    2) päivitys voi tapahtua millon vain
    !if (SnowFractionChoice==2.and.imin==(nsh_real-1)/nsh_real*60) then
    IF (SnowFractionChoice==2) THEN
       IF (SnowPack(is)>0.AND.mw_ind(is)>0) THEN
          snowFrac(is) = SnowDepletionCurve(is,SnowPack(is),snowD(is))
          IF (snowFrac(is)<0.001) snowFrac(is)=0.001  !The snow fraction minimum is 1% of the surface
       ELSEIF (SnowPack(is)==0) THEN
          snowFrac(is)=0
       ENDIF
    ENDIF

    RETURN

    !==========================================================================
    !WATERBODY is treated separately as state_id always below ice if ice existing
    !Calculate change in SnowPack
606 changSnow(WaterSurf)=(Precip+freezMelt(WaterSurf)+freezState(WaterSurf))-&
         (mw_ind(WaterSurf)+ev_snow(WaterSurf))

    SnowPack(WaterSurf)=SnowPack(WaterSurf)+changSnow(WaterSurf) !Update SnowPack
    state_id(WaterSurf)=state_id(WaterSurf)+FlowChange-freezState(WaterSurf)  !Update state_id below ice

    !If SnowPack exists
    IF (SnowPack(WaterSurf)>0) THEN

       !Add melted water to meltstore and freeze water according to freezMelt(is)
       MeltWaterStore(WaterSurf)=MeltWaterStore(WaterSurf)+mw_ind(WaterSurf)-freezMelt(WaterSurf)

       !Calculate water holding capacity (FWC: Valeo and Ho, 2004) of the SnowPack
       FWC = WaterHoldCapFrac*SnowPack(WaterSurf)

       !If FWC is exceeded, add meltwater to state_id
       IF (MeltWaterStore(WaterSurf)>=FWC.AND.Temp_C>=0) THEN
          state_id(WaterSurf)=state_id(WaterSurf)+(MeltWaterStore(WaterSurf)-FWC)
          MeltWaterStore(WaterSurf) = FWC
       ENDIF

       !If SnowPack is negative, it melts at this timestep
    ELSEIF (SnowPack(is)<0) THEN

       !Add water to the meltwater store
       !If freezing meltwater inside this hour, remove it from the MeltWaterStore
       MeltWaterStore(WaterSurf) = MeltWaterStore(WaterSurf)-freezMelt(WaterSurf) &
            + mw_ind(WaterSurf)

       state_id(WaterSurf)=state_id(WaterSurf)+MeltWaterStore(WaterSurf)+SnowPack(WaterSurf) !Add meltwater to state_id
       SnowPack(WaterSurf)=0
       IF (state_id(WaterSurf)<0) ev_snow(WaterSurf)=ev_snow(WaterSurf)+state_id(WaterSurf)

    ENDIF !SnowPack negative or positive

    !Check water state_id separately
    IF (state_id(WaterSurf)>StoreDrainPrm(5,WaterSurf)) THEN
       runoff(WaterSurf)=runoff(WaterSurf)+(state_id(WaterSurf)-StoreDrainPrm(5,WaterSurf))
       state_id(WaterSurf)=StoreDrainPrm(5,WaterSurf)
       runoffWaterBody=runoffWaterBody+runoff(WaterSurf)*sfr(WaterSurf)
    ELSE
       state_id(WaterSurf)=state_id(WaterSurf)+surplusWaterBody

       IF (state_id(WaterSurf)>StoreDrainPrm(5,WaterSurf)) THEN
          runoffWaterBody=runoffWaterBody+(state_id(WaterSurf)-StoreDrainPrm(5,WaterSurf))*sfr(WaterSurf)
          state_id(WaterSurf)=StoreDrainPrm(5,WaterSurf)
       ENDIF
    ENDIF


    !Change state_id of snow and surface
    chSnow_per_interval=chSnow_per_interval+((SnowPack(WaterSurf)+MeltWaterstore(WaterSurf))-snowTotInit)*sfr(WaterSurf)
    !ch_per_interval=ch_per_interval+(state_id(WaterSurf)-stateOld(WaterSurf))*sfr(WaterSurf)
    surf_chang_per_tstep=surf_chang_per_tstep+(state_id(WaterSurf)-stateOld(WaterSurf))*sfr(WaterSurf)

    !Evaporation
    ev_per_tstep=ev_per_tstep+ev*sfr(WaterSurf)+ev_snow(WaterSurf)*sfr(WaterSurf)
    qe_per_tstep=qe_per_tstep+ev_snow(WaterSurf)*lvS_J_kg*sfr(WaterSurf)+ev*lv_J_kg*sfr(WaterSurf)
    runoff_per_tstep=runoff_per_tstep+(runoff(is)*sfr(is)) !The total runoff from the area

    IF (SnowPack(WaterSurf)>0) THEN     !Fraction only 1 or 0
       snowFrac(WaterSurf)=1
    ELSE
       snowFrac(WaterSurf)=0
    ENDIF

  END SUBROUTINE SnowCalc


  !==========================================================================
  !==========================================================================
  !Calculates evaporation from snow surface (ev_snow).

  FUNCTION Evap_SUEWS_Snow(Qm,QP,lvS_J_kg,avdens,avRh,Press_hPa,Temp_C,RAsnow,psyc_hPa,&
       tstep,avcp,sIce_hPa,dectime) RESULT(ev_snow)

    USE meteo,ONLY:sat_vap_pressice
    IMPLICIT NONE

    !INPUT
    REAL (KIND(1d0))::Qm,QP,&        !melt heat, advect. heat
         lvS_J_kg,avdens,avRh,&   !latent heat of sublimation, air density,relative humidity,
         Press_hPa,Temp_C,&       !air pressure, air temperature
         RAsnow,psyc_hPa,&        !aerodyn res snow, psychometric constant, type of evaporation calculation
         avcp,sIce_hPa,&            !spec. heat, satured curve on snow
         dectime

    !OTHER VARIABLES
    REAL (KIND(1d0))::e_snow,&     !PM equation obe line
         sae_snow,&   !s * (Available energy)
         qe_snow,&    !Latent heat flux
         ev_snow,&    !Evaporation
         vdrcIce,&    !Vapour pressure deficit
         esIce_hPa,&  !Saturation vapor pressure over ice
         EaIce_hPa,&  !Vapour pressure
         tlv_sub,&    !Latent heat for sublimation
         tstep_real   !timestep as real

    ! REAL (KIND(1d0)):: sat_vap_pressIce !Function

    INTEGER:: tstep,from=1
    !-----------------------------------------------------

    tstep_real = REAL(tstep,KIND(1d0))

    sae_snow=sIce_hPa*(Qp-Qm)   !Calculate the driving parameter in calculation of evaporation. Järvi et al. (2015)

    esIce_hPa= sat_vap_pressIce(Temp_C,Press_hPa,from,dectime) !Saturation vapor pressure over ice
    EaIce_hPa=avRh/100*esIce_hPa                       !Vapour pressure of water
    vdrcIce=(esIce_hPa-eaIce_hpa)*avdens*avcp          !Vapour pressure deficit
    tlv_sub=lvS_J_kg/tstep_real                        !Latent heat for sublimation
    e_snow=sae_snow+vdrcIce/RAsnow                     !PM equation
    qe_snow=e_snow/(sIce_hPa+psyc_hPa)                 !Latent heat (W/m^2)
    ev_snow=qe_snow/tlv_sub                            !Evaporation (in mm)

    RETURN

  END FUNCTION Evap_SUEWS_Snow

  !==========================================================================
  !==========================================================================
  ! Calculates mechanical removal of snow from roofs ans roads
  SUBROUTINE snowRem(&
       is,PavSurf,BldgSurf,nsurf,&
       snowfrac,sfr,&
       SnowPack, SnowRemoval,&
       SnowLimPaved,SnowLimBuild)

    IMPLICIT NONE
    INTEGER,INTENT(in)                          :: is,PavSurf,BldgSurf,nsurf
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in) :: snowfrac,sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out):: SnowPack, SnowRemoval
    REAL(KIND(1d0)),INTENT(in)                  :: SnowLimPaved,SnowLimBuild
    !write(*,*) is, SnowPack(is),SnowLimPaved,SnowLimBuild

    IF (is==PavSurf) THEN
       IF (SnowPack(PavSurf)>SnowLimPaved) THEN
          SnowRemoval(PavSurf) = (SnowPack(PavSurf)-SnowLimPaved)*sfr(PavSurf)*snowfrac(PavSurf)
          SnowPack(PavSurf)=SnowLimPaved
          !SnowPack(PavSurf)=SnowPack(PavSurf)/snowFrac(PavSurf)
       ENDIF
    ENDIF
    IF (is==BldgSurf)THEN
       IF (SnowPack(BldgSurf)>SnowLimBuild) THEN
          SnowRemoval(2) = (SnowPack(BldgSurf)-SnowLimBuild)*sfr(BldgSurf)*snowfrac(BldgSurf)
          SnowPack(BldgSurf)=SnowLimBuild
          !SnowPack(BldgSurf)=SnowPack(BldgSurf)/snowFrac(BldgSurf)
       ENDIF
    ENDIF
    !write(*,*) is, SnowPack(is),SnowLimPaved,SnowLimBuild
    !pause
  END SUBROUTINE snowRem

  !----------------------------------------------------------------------------
  !----------------------------------------------------------------------------
  FUNCTION   SnowDepletionCurve(is,swe,sweD) RESULT(asc)
    !This function calculates surface coverage of snow according to the
    !depletion curves in Valeo and Ho (2004).
    !INPUT: is   Surface type number
    !       swe  Snow water content
    !       sweD Limit for

    USE allocateArray

    IMPLICIT  NONE

    INTEGER::is
    REAL (KIND(1d0))::asc,sweD,swe


    !Impervious surface
    IF (is==PavSurf) THEN

       IF (swe<=sweD) THEN      !Snow water equivalent below threshold
          asc=((swe/sweD))**2
       ELSE
          asc=1
       ENDIF

       !Bldgs surface
    ELSEIF (is==BldgSurf) THEN

       IF (swe<=sweD) THEN
          IF ((swe/sweD)<0.9) THEN
             asc=(swe/sweD)*0.5
          ELSE
             asc=(swe/sweD)**8
          ENDIF
       ELSE
          asc=1
       ENDIF
    ELSEIF (is==WaterSurf) THEN
       IF (swe>0) asc=1

       !Vegetion surfaces
    ELSE
       IF (swe<=sweD) THEN

          asc=1-((1/3.1416)*ACOS(2*(swe/sweD)-1))**1.7
       ELSE
          asc=1
       ENDIF

    ENDIF

    !asc=real(int(10000.*asc))/10000  !4 decimal precision

    RETURN
  END FUNCTION SnowDepletionCurve


  SUBROUTINE veg_fr_snow(&
       sfr,snowFrac,nsurf,&!input
       veg_fr)!output

    IMPLICIT NONE

    INTEGER,INTENT(in) :: nsurf !< number of surface types

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in) :: sfr      !< surface fractions
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in) :: snowFrac !< snowy surface fractions [-]

    REAL(KIND(1d0)),INTENT(out) :: veg_fr   !< vegetated surface fractions [-]

    veg_fr = DOT_PRODUCT(sfr(3:7),1-snowFrac(3:7))

  END SUBROUTINE veg_fr_snow

  !In this subroutine the snow properties are updated. The aging functions work for hourly air
  !temperature (dt=1). As the code timestep is typically smaller than one hour, the new albedo
  !and density are calculated using the timestep air temperature and then these are scaled to timestep
  !according to NSH.  Made by LJ in sprint 2014
  !Last update:
  ! TS 17 Sep 2017 - Improve the explicit interface
  ! LJ 7 July 2015 - Changed to work with shorter timestep: defined by tstep. Cleaning of the code.
  !
  !========================================================================

  SUBROUTINE SnowUpdate(&
       nsurf,tstep,&!input
       Temp_C_hr,&
       tau_a,&
       tau_f,&
       tau_r,&
       SnowDensMax,&
       SnowDensMin,&
       SnowAlbMin,&
       SnowPack,&
       SnowAlb,&!inout
       SnowDens)


    IMPLICIT NONE

    INTEGER,INTENT(in)::nsurf
    INTEGER,INTENT(in)::tstep

    REAL(KIND(1D0)),INTENT(in)::Temp_C_hr        !Air temperature
    REAL(KIND(1D0)),INTENT(in)::tau_a
    REAL(KIND(1D0)),INTENT(in)::tau_f
    REAL(KIND(1D0)),INTENT(in)::tau_r
    REAL(KIND(1D0)),INTENT(in)::SnowDensMax
    REAL(KIND(1D0)),INTENT(in)::SnowDensMin
    REAL(KIND(1D0)),INTENT(in)::SnowAlbMin

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::SnowPack

    REAL(KIND(1d0)),INTENT(inout)::SnowAlb

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowDens


    INTEGER::is
    REAL(KIND(1D0))::alb_change,&     !Change in snow albedo
         dens_change,&    !Change in snow density
         tau_1         !Number of seconds in a day

    !Initialize
    alb_change=0
    dens_change=0
    tau_1=24*60*60

    !==========================================================
    !Calculation of snow albedo by Lemonsu et al. 2010
    !(org: Verseghy (1991)&Baker et al.(1990))
    IF (SUM(SnowPack)>0) THEN !Check if snow on any of the surfaces
       IF (Temp_C_hr<0) THEN
          !alb_change = tau_a*(60*60)/tau_1
          alb_change = tau_a*(tstep)/tau_1
          SnowAlb = SnowAlb-alb_change
       ELSE
          !alb_change = exp(-tau_f*(60*60)/tau_1)
          alb_change = EXP(-tau_f*(tstep)/tau_1)
          SnowAlb = (SnowAlb-SnowAlbMin)*alb_change+SnowAlbMin
       ENDIF
       IF (SnowAlb<SnowAlbMin) SnowAlb=SnowAlbMin !Albedo cannot be smaller than the min albedo
    ELSE
       SnowAlb = 0
    ENDIF

    !Update snow density: There is a mistake in Järvi et al. (2014): tau_h should be tau_1
    DO is=1,nsurf

       !If SnowPack existing
       IF (SnowPack(is)>0) THEN
          dens_change = EXP(-tau_r*(tstep)/tau_1)
          IF (SnowPack(is)>0) SnowDens(is) = (SnowDens(is)-SnowDensMax)*dens_change+SnowDensMax
          IF (SnowDens(is)>SnowDensMax) SnowDens(is)=SnowDensMax
       ELSE
          SnowDens(is) = SnowDensMin
       ENDIF
    ENDDO


  END SUBROUTINE SnowUpdate


END MODULE Snow_module

MODULE DailyState_module
  USE allocateArray,ONLY:&
       ndays,nsurf,nvegsurf,ivConif,ivDecid,ivGrass,ncolumnsDataOutDailyState


  IMPLICIT NONE
  ! INTEGER,PARAMETER::ndays=366
  ! INTEGER,PARAMETER::nvegsurf=3
  ! INTEGER,PARAMETER::ncolumnsDataOutDailyState=46

CONTAINS

  ! Calculation of daily state variables
  ! Responds to what has happened in the past (temperature, rainfall, etc)
  ! Updates each time step, but for many variables, correct values are calculated only at the end of each day!
  ! --> for these variables, the rest of the code MUST use values from the previous day
  ! N.B. Some of this code is repeated in SUEWS_Initial
  ! --> so if changes are made here, SUEWS_Initial may also need to be updated accordingly
  ! N.B. Currently, daily variables are calculated using 00:00-23:55 timestamps (for 5-min resolution); should use 00:05-00:00
  !
  ! Last modified:
  !  TS 09 Jul 2018  - Modified HDD array to hold values for actual calculation
  !  TS 18 Sep 2017  - Added explicit interface
  !  TS 07 Jun 2017  - Improve the format of output with more friendly alignment
  !  HCW 04 Jul 2016 - GridID can now be up to 10 digits long
  !  HCW 25 May 2016 - Added extra columns to daily state file (albedo for EveTr and Grass)
  !  HCW 24 May 2016 - Bug fixed in naming of SUEWS_cal_DailyState file (now uses GridIDmatrix(Gridiv) rather than Gridiv)
  !  LJ 27 Jan 2016  - Removal of tabs
  !  HCW 20 Aug 2015 - Sign of the porosity change corrected so that porosity is greatest when LAI is smallest
  !  HCW 03 Jul 2015 - Increased output resolution of P/day in SUEWS_cal_DailyState file to avoid rounding errors.
  !                    Albedo of EveTr and Grass now adjusted based on change in LAI for EveTr and Grass
  !                    (rather than DecTr)
  !  HCW 29 Jun 2015 - Added albChange for EveTr and Grass surfaces
  !  HCW 11 Jun 2015 - Bug fix from 05 Jun now fixed in a different way -
  !                    DecidCap is now treated the same as DecidAlb so should be able to cope with multiple grids.
  !  HCW 05 Jun 2015 - Bug fix - set all current storage capacities (StoreDrainPrm(6,)) to min. value, then set for DecTr
  !  LJ 11 Mar 2015  - Removed switch as no longer necessary
  !  HCW 06 Mar 2015 - iy used instead of year which does not have a value here
  !  HCW 20 Feb 2015 - Added StoreDrainPrm(6,is) for the current storage capacity
  !  Updated and corrected SUEWS_cal_DailyState output file
  !  LJ 05 Feb 2015  - SUEWS_cal_DailyState saving fixed. Now header is printed and the file closed and opened as suggested.
  ! N.B. Bug in daily Precip - needs fixing!!! - HCW thinks this is fixed 20 Feb 2015
  !  HCW 26 Jan 2015 - sfr and IrrFracs deleted from WUDay calculations, so that WUDay is not spread over
  !  the total area
  !  HCW 23 Jan 2015 - WUDay now has 9 columns (EveTr, DecTr, Grass; automatic, manual, total)
  !  HCW 27 Nov 2014 - Handles values for different grids (Gridiv & ir arguments)
  ! Added the calculation of surface temperature
  !  LJ 22 Feb 2013  - Snow albedo aging and calculation of snow density added,
  !  LJ 22 Jul 2013  - Calculation of LAI senescence from previous day length added
  ! sg feb 2012 - rewritten from LUMPS_LAI so done in real time
  !
  ! To Do
  !   - Account for change of year in 5-day running mean
  !   - Check LAI calcs (N/S hemisphere similarities; use of day length)
  !       - Take out doy limits (140,170, etc) and code as parameters
  !   - Could add different coefficients (Ie_m, Ie_a) for each vegetation type
  !==============================================================================
  SUBROUTINE SUEWS_cal_DailyState(&
       iy,id,it,imin,isec,tstep,tstep_prev,dt_since_start,DayofWeek_id,&!input
       WaterUseMethod,snowUse,Ie_start,Ie_end,&
       LAICalcYes,LAIType,&
       nsh_real,avkdn,Temp_C,Precip,BaseTHDD,&
       lat,Faut,LAI_obs,tau_a,tau_f,tau_r,&
       SnowDensMax,SnowDensMin,SnowAlbMin,&
       AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
       AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
       CapMax_dec,CapMin_dec,PorMax_dec,PorMin_dec,&
       Ie_a,Ie_m,DayWatPer,DayWat,SnowPack,&
       BaseT,BaseTe,GDDFull,SDDFull,LAIMin,LAIMax,LAIPower,&
       SnowAlb,SnowDens,&!inout
       GDD_id,HDD_id,LAI_id,LAI_id_prev,WUDay_id,&
       DecidCap_id,albDecTr_id,albEveTr_id,albGrass_id,porosity_id,&
       deltaLAI)!output

    USE Snow_module,ONLY:SnowUpdate
    USE datetime_module, ONLY: datetime,timedelta

    IMPLICIT NONE

    INTEGER,INTENT(IN)::iy
    INTEGER,INTENT(IN)::id
    INTEGER,INTENT(IN)::it
    INTEGER,INTENT(IN)::imin
    INTEGER,INTENT(IN)::isec
    INTEGER,INTENT(IN)::tstep
    INTEGER,INTENT(IN)::tstep_prev
    INTEGER,INTENT(IN)::dt_since_start


    INTEGER,INTENT(IN)::WaterUseMethod
    INTEGER,INTENT(IN)::snowUse
    INTEGER,INTENT(IN)::Ie_start   !Starting time of water use (DOY)
    INTEGER,INTENT(IN)::Ie_end       !Ending time of water use (DOY)
    INTEGER,INTENT(IN)::LAICalcYes


    INTEGER,DIMENSION(nvegsurf),INTENT(IN):: LAIType                  !LAI equation to use: original (0) or new (1)

    REAL(KIND(1d0)),INTENT(IN)::nsh_real
    REAL(KIND(1d0)),INTENT(IN)::avkdn
    REAL(KIND(1d0)),INTENT(IN)::Temp_C
    REAL(KIND(1d0)),INTENT(IN)::Precip
    REAL(KIND(1d0)),INTENT(IN)::BaseTHDD
    REAL(KIND(1d0)),INTENT(IN)::lat
    REAL(KIND(1d0)),INTENT(IN)::Faut
    REAL(KIND(1d0)),INTENT(IN)::LAI_obs
    REAL(KIND(1D0)),INTENT(IN)::tau_a
    REAL(KIND(1D0)),INTENT(IN)::tau_f
    REAL(KIND(1D0)),INTENT(IN)::tau_r
    REAL(KIND(1D0)),INTENT(IN)::SnowDensMax
    REAL(KIND(1D0)),INTENT(IN)::SnowDensMin
    REAL(KIND(1D0)),INTENT(IN)::SnowAlbMin
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_Grass
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_Grass
    REAL(KIND(1d0)),INTENT(IN)::CapMax_dec
    REAL(KIND(1d0)),INTENT(IN)::CapMin_dec
    REAL(KIND(1d0)),INTENT(IN)::PorMax_dec
    REAL(KIND(1d0)),INTENT(IN)::PorMin_dec
    ! REAL(KIND(1d0)),INTENT(IN) ::VegPhenLumps

    REAL(KIND(1d0)),DIMENSION(3),INTENT(IN) ::Ie_a
    REAL(KIND(1d0)),DIMENSION(3),INTENT(IN) ::Ie_m !Coefficients for automatic and manual irrigation models
    REAL(KIND(1d0)),DIMENSION(7),INTENT(IN) ::DayWatPer !% of houses following daily water
    REAL(KIND(1d0)),DIMENSION(7),INTENT(IN) ::DayWat !Days of watering allowed


    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(IN)      ::SnowPack
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)   ::BaseT !Base temperature for growing degree days [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)   ::BaseTe !Base temperature for senescence degree days [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)   ::GDDFull !Growing degree days needed for full capacity [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)   ::SDDFull !Senescence degree days needed to initiate leaf off [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)   ::LAIMin !Min LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)   ::LAIMax !Max LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(4,nvegsurf),INTENT(IN) ::LAIPower !Coeffs for LAI equation: 1,2 - leaf growth; 3,4 - leaf off


    REAL(KIND(1d0)),INTENT(INOUT)::SnowAlb

    REAL(KIND(1d0)),DIMENSION(5),INTENT(INOUT)       :: GDD_id !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(INOUT):: LAI_id !LAI for each veg surface [m2 m-2]


    ! REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::DecidCap
    ! REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::albDecTr
    ! REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::albEveTr
    ! REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::albGrass
    ! REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::porosity
    ! REAL(KIND(1d0)),DIMENSION( 0:ndays, 5),INTENT(INOUT):: GDD !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(12),INTENT(INOUT):: HDD_id          !Heating Degree Days (see SUEWS_DailyState.f95)
    ! REAL(KIND(1d0)),DIMENSION(-4:366,6),INTENT(INOUT):: HDD

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(INOUT)::SnowDens
    ! REAL(KIND(1d0)),DIMENSION(-4:ndays, nvegsurf),INTENT(INOUT):: LAI !LAI for each veg surface [m2 m-2]
    INTEGER,DIMENSION(3),INTENT(in)::DayofWeek_id

    !Daily water use for EveTr, DecTr, Grass [mm] (see SUEWS_DailyState.f95)
    ! REAL(KIND(1d0)),DIMENSION(0:ndays,9),INTENT(INOUT):: WUDay
    REAL(KIND(1d0)),DIMENSION(9),INTENT(OUT):: WUDay_id
    REAL(KIND(1d0)),INTENT(OUT)::deltaLAI
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(INOUT):: LAI_id_prev !LAI for each veg surface [m2 m-2]
    ! REAL(KIND(1d0)),DIMENSION(6),INTENT(INOUT)::HDD_id_use ! HDD of previous day

    REAL(KIND(1d0)),INTENT(INOUT):: DecidCap_id
    REAL(KIND(1d0)),INTENT(INOUT):: albDecTr_id
    REAL(KIND(1d0)),INTENT(INOUT):: albEveTr_id
    REAL(KIND(1d0)),INTENT(INOUT):: albGrass_id
    REAL(KIND(1d0)),INTENT(INOUT):: porosity_id

    LOGICAL :: first_tstep_Q ! if this is the first tstep of a day
    LOGICAL :: last_tstep_Q ! if this is the last tstep of a day
    TYPE(datetime) :: time_now,time_prev,time_next


    ! --------------------------------------------------------------------------------
    ! ------------- Key to daily arrays ----------------------------------------------
    ! HDD(1,) ---- Heating [degC]: used for accumulation during calculation
    ! HDD(2,) ---- Cooling [degC]: used for accumulation during calculation
    ! HDD(3,) ---- Daily mean temp [degC]: used for accumulation during calculation
    ! HDD(4,) ---- 5-day running mean temp [degC]: used for actual calculation
    ! HDD(5,) ---- Daily precip total [mm]
    ! HDD(6,) ---- Days since rain [d]
    ! HDD(,1) ---- used for agrregation during calculation
    ! HDD(,2) ---- value for previous day and used for actual calculation

    !
    ! GDD(,1) ---- Growing [degC]
    ! GDD(,2) ---- Senescence [degC]
    ! GDD(,3) ---- Daily min temp [degC]
    ! GDD(,4) ---- Daily max temp [degC]
    ! GDD(,5) ---- Daytime hours [h]
    !
    ! LAI(,1:3) -- LAI for each veg surface [m2 m-2]
    !
    ! WUDay(,1) - Daily water use total for Irr EveTr (automatic+manual) [mm]
    ! WUDay(,2) - Automatic irrigation for Irr EveTr [mm]
    ! WUDay(,3) - Manual irrigation for Irr EveTr [mm]
    ! WUDay(,4) - Daily water use total for Irr DecTr (automatic+manual) [mm]
    ! WUDay(,5) - Automatic irrigation for Irr DecTr [mm]
    ! WUDay(,6) - Manual irrigation for Irr DecTr [mm]
    ! WUDay(,7) - Daily water use total for Irr Grass (automatic+manual) [mm]
    ! WUDay(,8) - Automatic irrigation for Irr Grass [mm]
    ! WUDay(,9) - Manual irrigation for Irr Grass [mm]
    ! --------------------------------------------------------------------------------

    ! get timestamps
    time_now=datetime(year=iy)+timedelta(days=id-1, hours=it, minutes=imin, seconds= isec)
    time_prev=time_now-timedelta(seconds= tstep_prev)
    time_next=time_now+timedelta(seconds= tstep)

    ! test if time at now is the first/last tstep of today
    first_tstep_Q= time_now%getDay()/=time_prev%getDay()
    last_tstep_Q= time_now%getDay()/=time_next%getDay()



    ! --------------------------------------------------------------------------------
    ! On first timestep of each day, define whether the day each a workday or weekend
    IF (first_tstep_Q) THEN
       CALL update_DailyState_Start(&
            it,imin,&!input
            HDD_id)!inout
    ENDIF

    ! --------------------------------------------------------------------------------
    ! regular update at all timesteps of a day
    CALL update_DailyState_Day(&
         avkdn,&!input
         Temp_C,&
         Precip,&
         BaseTHDD,&
         nsh_real,&
         GDD_id,&!inout
         HDD_id)

    ! Update snow density, albedo surface fraction
    IF (snowUse==1) CALL SnowUpdate(&
         nsurf,tstep,Temp_C,tau_a,tau_f,tau_r,&!input
         SnowDensMax,SnowDensMin,SnowAlbMin,SnowPack,&
         SnowAlb,SnowDens)!inout

    ! --------------------------------------------------------------------------------
    ! On last timestep, perform the daily calculations -------------------------------
    ! Daily values not correct until end of each day,
    !  so main program should use values from the previous day
    IF (last_tstep_Q) THEN
       CALL update_DailyState_End(&
            id,it,imin,tstep,dt_since_start,&!input
            LAIType,Ie_end,Ie_start,LAICalcYes,&
            WaterUseMethod,DayofWeek_id,&
            AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
            BaseT,BaseTe,CapMax_dec,CapMin_dec,DayWat,DayWatPer,Faut,GDDFull,&
            Ie_a,Ie_m,LAIMax,LAIMin,LAIPower,lat,PorMax_dec,PorMin_dec,SDDFull,LAI_obs,&
            GDD_id,& !inout
            HDD_id,&
            LAI_id,LAI_id_prev,&
            WUDay_id,&
            DecidCap_id,&
            albDecTr_id,&
            albEveTr_id,&
            albGrass_id,&
            porosity_id,&
            deltaLAI)!output
       ! ,xBo)!output
    ENDIF   !End of section done only at the end of each day (i.e. only once per day)


    ! PRINT*, 'after_DailyState', iy,id,it,imin
    ! PRINT*, 'HDD(id)', HDD(id,:)
    ! PRINT*, 'HDD_id', HDD_id

    RETURN

  END SUBROUTINE SUEWS_cal_DailyState


  SUBROUTINE update_DailyState_End(&
       id,it,imin,tstep,dt_since_start,&!input
       LAIType,Ie_end,Ie_start,LAICalcYes,&
       WaterUseMethod,DayofWeek_id,&
       AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
       BaseT,BaseTe,CapMax_dec,CapMin_dec,DayWat,DayWatPer,Faut,GDDFull,&
       Ie_a,Ie_m,LAIMax,LAIMin,LAIPower,lat,PorMax_dec,PorMin_dec,SDDFull,LAI_obs,&
       GDD_id,& !inout
       HDD_id,&
       LAI_id,LAI_id_prev,&
       WUDay_id,&
       DecidCap_id,&
       albDecTr_id,&
       albEveTr_id,&
       albGrass_id,&
       porosity_id,&
       deltaLAI)!output
    IMPLICIT NONE

    INTEGER,INTENT(IN)::id
    INTEGER,INTENT(IN)::it
    INTEGER,INTENT(IN)::imin
    INTEGER,INTENT(IN)::tstep
    INTEGER,INTENT(IN)::dt_since_start
    INTEGER,INTENT(IN)::LAIType(nvegsurf)
    INTEGER,INTENT(IN)::Ie_end
    INTEGER,INTENT(IN)::Ie_start
    INTEGER,INTENT(IN)::LAICalcYes
    INTEGER,INTENT(IN)::WaterUseMethod
    INTEGER,INTENT(in)::DayofWeek_id(3)

    REAL(KIND(1d0)),INTENT(IN)::AlbMax_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_Grass
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_Grass
    REAL(KIND(1d0)),INTENT(IN)::BaseT(nvegsurf)
    REAL(KIND(1d0)),INTENT(IN)::BaseTe(nvegsurf)
    REAL(KIND(1d0)),INTENT(IN)::CapMax_dec
    REAL(KIND(1d0)),INTENT(IN)::CapMin_dec
    REAL(KIND(1d0)),INTENT(IN)::DayWat(7)
    REAL(KIND(1d0)),INTENT(IN)::DayWatPer(7)
    REAL(KIND(1d0)),INTENT(IN)::Faut
    REAL(KIND(1d0)),INTENT(IN)::GDDFull(nvegsurf)
    REAL(KIND(1d0)),INTENT(IN)::Ie_a(3)
    REAL(KIND(1d0)),INTENT(IN)::Ie_m(3)
    REAL(KIND(1d0)),INTENT(IN)::LAIMax(nvegsurf)
    REAL(KIND(1d0)),INTENT(IN)::LAIMin(nvegsurf)
    REAL(KIND(1d0)),INTENT(IN)::LAIPower(4,nvegsurf)
    REAL(KIND(1d0)),INTENT(IN)::lat
    REAL(KIND(1d0)),INTENT(IN)::PorMax_dec
    REAL(KIND(1d0)),INTENT(IN)::PorMin_dec
    REAL(KIND(1d0)),INTENT(IN)::SDDFull(nvegsurf)
    REAL(KIND(1d0)),INTENT(IN)::LAI_obs


    REAL(KIND(1d0)),DIMENSION(5),INTENT(INOUT)       ::GDD_id !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(12),INTENT(INOUT)     ::HDD_id
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(INOUT)::LAI_id !LAI for each veg surface [m2 m-2]

    ! REAL(KIND(1d0)),DIMENSION(6),INTENT(INOUT)::HDD_id_use ! HDD of previous day
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(INOUT)::LAI_id_prev ! LAI of previous day


    REAL(KIND(1d0)),DIMENSION(9),INTENT(OUT):: WUDay_id
    REAL(KIND(1d0)),INTENT(OUT)::deltaLAI


    REAL(KIND(1d0)),INTENT(INOUT):: DecidCap_id
    REAL(KIND(1d0)),INTENT(INOUT):: albDecTr_id
    REAL(KIND(1d0)),INTENT(INOUT):: albEveTr_id
    REAL(KIND(1d0)),INTENT(INOUT):: albGrass_id
    REAL(KIND(1d0)),INTENT(INOUT):: porosity_id


    ! CALL update_HDD(&
    !      id,it,imin,tstep,& !input
    !      HDD) !inout

    CALL update_HDD_X(&
         dt_since_start,it,imin,tstep,& !input
         HDD_id)!inout




    ! Calculate modelled daily water use ------------------------------------------
    ! CALL update_WaterUse(&
    !      id,WaterUseMethod,DayofWeek_id,lat,Faut,HDD_id,&!input
    !      Ie_a,Ie_m,Ie_start,Ie_end,DayWatPer,DayWat,&
    !      WUDay) !inout

    CALL update_WaterUse_X(&
         id,WaterUseMethod,DayofWeek_id,lat,Faut,HDD_id,&!input
         Ie_a,Ie_m,Ie_start,Ie_end,DayWatPer,DayWat,&
         WUDay_id) !output

    ! PRINT*, ''
    ! PRINT*, 'WUDay(id)',WUDay(id,:)
    ! PRINT*, 'WUDay_id',WUDay_id

    !------------------------------------------------------------------------------
    ! Calculation of LAI from growing degree days
    ! This was revised and checked on 16 Feb 2014 by LJ
    !------------------------------------------------------------------------------
    ! CALL update_GDDLAI(&
    !      id,LAICalcYes,& !input
    !      lat,LAI_obs,&
    !      BaseT,&
    !      BaseTe,&
    !      GDDFull,&
    !      SDDFull,&
    !      LAIMin,&
    !      LAIMax,&
    !      LAIPower,LAIType,&
    !      GDD,LAI) !inout

    CALL update_GDDLAI_X(&
         id,LAICalcYes,& !input
         lat,LAI_obs,&
         BaseT,BaseTe,&
         GDDFull,SDDFull,&
         LAIMin,LAIMax,LAIPower,LAIType,&
         GDD_id,LAI_id,&!inout
         LAI_id_prev) !output

    ! CALL update_Veg(&
    !      id,&!input
    !      LAImax,LAIMin,&
    !      AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
    !      AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
    !      CapMax_dec,CapMin_dec,&
    !      PorMax_dec,PorMin_dec,&
    !      LAI_id,LAI_id_prev,&
    !      DecidCap,&!inout
    !      albDecTr,albEveTr,albGrass,&
    !      porosity,&
    !      deltaLAI)!output

    CALL update_Veg_X(&
         LAImax,LAIMin,&!input
         AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
         AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
         CapMax_dec,CapMin_dec,&
         PorMax_dec,PorMin_dec,&
         LAI_id,LAI_id_prev,&
         DecidCap_id,&!inout
         albDecTr_id,&
         albEveTr_id,&
         albGrass_id,&
         porosity_id,&
         deltaLAI)!output


    ! PRINT*, 'DecidCap',DecidCap(id),DecidCap_id
    ! PRINT*, 'albDecTr',albDecTr(id),albDecTr_id
    ! PRINT*, 'albEveTr',albEveTr(id),albEveTr_id
    ! PRINT*, 'albGrass',albGrass(id),albGrass_id
    ! PRINT*, 'porosity',porosity(id),porosity_id


  END SUBROUTINE update_DailyState_End


  SUBROUTINE update_DailyState_Day(&
       avkdn,&!input
       Temp_C,&
       Precip,&
       BaseTHDD,&
       nsh_real,&
       GDD_id,&!inout
       HDD_id)
    IMPLICIT NONE

    ! INTEGER,INTENT(IN)::id
    REAL(KIND(1d0)),INTENT(IN)::avkdn
    REAL(KIND(1d0)),INTENT(IN)::Temp_C
    REAL(KIND(1d0)),INTENT(IN)::Precip
    REAL(KIND(1d0)),INTENT(IN)::BaseTHDD
    REAL(KIND(1d0)),INTENT(IN)::nsh_real

    ! REAL(KIND(1d0))::tstepcount
    ! REAL(KIND(1d0)),DIMENSION(-4:366,6),INTENT(INOUT):: HDD
    REAL(KIND(1d0)),DIMENSION(5),INTENT(INOUT):: GDD_id !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(12),INTENT(INOUT):: HDD_id          !Heating Degree Days (see SUEWS_DailyState.f95)
    ! REAL(KIND(1d0)),DIMENSION(5),INTENT(OUT):: GDD_id_prev !Growing Degree Days (see SUEWS_DailyState.f95)

    INTEGER::gamma1
    INTEGER::gamma2

    ! Daily min and max temp (these get updated through the day) ---------------------
    GDD_id(3) = MIN(Temp_C,GDD_id(3))     !Daily min T in column 3
    GDD_id(4) = MAX(Temp_C,GDD_id(4))     !Daily max T in column 4
    IF (avkdn>10) THEN
       GDD_id(5) = GDD_id(5)+1/nsh_real   !Cumulate daytime hours !Divide by nsh (HCW 01 Dec 2014)
    ENDIF

    ! Calculations related to heating and cooling degree days (HDD) ------------------
    ! See Sailor & Vasireddy (2006) EMS Eq 1,2 (theirs is hourly timestep)
    gamma1=MERGE(1, 0, (BaseTHDD-Temp_C)>=0)
    gamma2=MERGE(1, 0, (Temp_C-BaseTHDD)>=0)

    ! HDD(id,1)=HDD(id,1) + gamma1*(BaseTHDD-Temp_C)   !Heating
    ! HDD(id,2)=HDD(id,2) + gamma2*(Temp_C-BaseTHDD)   !Cooling
    ! HDD(id,3)=HDD(id,3) + Temp_C                     !Will become daily average temperature
    ! !      4 ------------------------------------!   !5-day running mean
    ! HDD(id,5)=HDD(id,5) + Precip                     !Daily precip total
    !      6 ------------------------------------!   !Days since rain

    HDD_id(1)=HDD_id(1) + gamma1*(BaseTHDD-Temp_C)   !Heating
    HDD_id(2)=HDD_id(2) + gamma2*(Temp_C-BaseTHDD)   !Cooling
    HDD_id(3)=HDD_id(3) + Temp_C                     !Will become daily average temperature
    !      4 ------------------------------------!   !5-day running mean
    HDD_id(5)=HDD_id(5) + Precip                     !Daily precip total
    !      6 ------------------------------------!   !Days since rain

  END SUBROUTINE update_DailyState_Day


  SUBROUTINE update_Veg(&
       id,&!input
       LAImax,LAIMin,&
       AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
       AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
       CapMax_dec,CapMin_dec,&
       PorMax_dec,PorMin_dec,&
       LAI_id,LAI_id_prev,&
       DecidCap,&!inout
       albDecTr,albEveTr,albGrass,&
       porosity,&
       deltaLAI)!output

    IMPLICIT NONE

    INTEGER,INTENT(IN)::id
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)::LAImax
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)::LAIMin

    REAL(KIND(1d0)),INTENT(IN)::AlbMax_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_Grass
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_Grass
    REAL(KIND(1d0)),INTENT(IN)::CapMax_dec
    REAL(KIND(1d0)),INTENT(IN)::CapMin_dec
    REAL(KIND(1d0)),INTENT(IN)::PorMax_dec
    REAL(KIND(1d0)),INTENT(IN)::PorMin_dec
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)::LAI_id,LAI_id_prev

    REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::DecidCap
    REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::albDecTr
    REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::albEveTr
    REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::albGrass
    REAL(KIND(1d0)),DIMENSION( 0:ndays),INTENT(INOUT)::porosity


    REAL(KIND(1d0)),INTENT(OUT)::deltaLAI

    INTEGER::iv

    REAL(KIND(1d0))::albChangeDecTr
    REAL(KIND(1d0))::albChangeEveTr
    REAL(KIND(1d0))::albChangeGrass
    REAL(KIND(1d0))::CapChange

    REAL(KIND(1d0))::deltaLAIEveTr
    REAL(KIND(1d0))::deltaLAIGrass
    REAL(KIND(1d0))::porChange
    !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ! Calculate the development of vegetation cover
    ! Albedo changes with LAI for each vegetation type
    ! Storage capacity and porosity are updated based on DecTr LAI only (seasonal variation in Grass and EveTr assumed small)
    ! If only LUMPS is used, set deciduous capacities to 0
    ! QUESTION: Assume porosity Change based on GO99- Heisler?
    deltaLAI=0
    deltaLAIEveTr=0
    deltaLAIGrass=0
    CapChange=0
    porChange=0
    albChangeDecTr=0
    albChangeEveTr=0
    albChangeGrass=0

    iv=ivDecid
    IF((LAI_id(iv)-LAI_id_prev(iv))/=0) THEN
       deltaLAI=(LAI_id(iv)-LAI_id_prev(iv))/(LAImax(iv)-LAIMin(iv))
       albChangeDecTr=(AlbMax_DecTr-AlbMin_DecTr)* deltaLAI
       CapChange=(CapMin_dec-CapMax_dec)* deltaLAI
       porChange=(PorMin_dec-PorMax_dec)* deltaLAI
    ENDIF

    iv=ivConif
    IF((LAI_id(iv)-LAI_id_prev(iv))/=0) THEN
       deltaLAIEveTr=(LAI_id(iv)-LAI_id_prev(iv))/(LAImax(iv)-LAIMin(iv))
       albChangeEveTr=(AlbMax_EveTr-AlbMin_EveTr)* deltaLAIEveTr    !!N.B. Currently uses deltaLAI for deciduous trees only!!
    ENDIF

    iv=ivGrass
    IF((LAI_id(iv)-LAI_id_prev(iv))/=0) THEN
       deltaLAIGrass=(LAI_id(iv)-LAI_id_prev(iv))/(LAImax(iv)-LAIMin(iv))
       albChangeGrass=(AlbMax_Grass-AlbMin_Grass)* deltaLAIGrass    !!N.B. Currently uses deltaLAI for deciduous trees only!!
    ENDIF

    iv=ivDecid

    !write(*,*) deltaLAI, deltaLAIEveTr, deltaLAIGrass

    DecidCap(id) = DecidCap(id-1) - CapChange
    albDecTr(id) = albDecTr(id-1) + albChangeDecTr
    porosity(id) = porosity(id-1) + porChange !- changed to + by HCW 20 Aug 2015 (porosity greatest when LAI smallest)
    !Also update albedo of EveTr and Grass surfaces
    albEveTr(id) = albEveTr(id-1) + albChangeEveTr
    albGrass(id) = albGrass(id-1) + albChangeGrass

  END SUBROUTINE update_Veg


  SUBROUTINE update_Veg_X(&
       LAImax,LAIMin,&!input
       AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
       AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
       CapMax_dec,CapMin_dec,&
       PorMax_dec,PorMin_dec,&
       LAI_id,LAI_id_prev,&
       DecidCap_id,&!inout
       albDecTr_id,&
       albEveTr_id,&
       albGrass_id,&
       porosity_id,&
       deltaLAI)!output

    IMPLICIT NONE

    ! INTEGER,INTENT(IN)::id
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)::LAImax
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)::LAIMin

    REAL(KIND(1d0)),INTENT(IN)::AlbMax_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMax_Grass
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_DecTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_EveTr
    REAL(KIND(1d0)),INTENT(IN)::AlbMin_Grass
    REAL(KIND(1d0)),INTENT(IN)::CapMax_dec
    REAL(KIND(1d0)),INTENT(IN)::CapMin_dec
    REAL(KIND(1d0)),INTENT(IN)::PorMax_dec
    REAL(KIND(1d0)),INTENT(IN)::PorMin_dec
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)::LAI_id,LAI_id_prev

    REAL(KIND(1d0)),INTENT(INOUT)::DecidCap_id
    REAL(KIND(1d0)),INTENT(INOUT)::albDecTr_id
    REAL(KIND(1d0)),INTENT(INOUT)::albEveTr_id
    REAL(KIND(1d0)),INTENT(INOUT)::albGrass_id
    REAL(KIND(1d0)),INTENT(INOUT)::porosity_id


    REAL(KIND(1d0)),INTENT(OUT)::deltaLAI

    INTEGER::iv

    REAL(KIND(1d0))::albChangeDecTr
    REAL(KIND(1d0))::albChangeEveTr
    REAL(KIND(1d0))::albChangeGrass
    REAL(KIND(1d0))::CapChange

    REAL(KIND(1d0))::deltaLAIEveTr
    REAL(KIND(1d0))::deltaLAIGrass
    REAL(KIND(1d0))::porChange
    !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ! Calculate the development of vegetation cover
    ! Albedo changes with LAI for each vegetation type
    ! Storage capacity and porosity are updated based on DecTr LAI only (seasonal variation in Grass and EveTr assumed small)
    ! If only LUMPS is used, set deciduous capacities to 0
    ! QUESTION: Assume porosity Change based on GO99- Heisler?
    deltaLAI=0
    deltaLAIEveTr=0
    deltaLAIGrass=0
    CapChange=0
    porChange=0
    albChangeDecTr=0
    albChangeEveTr=0
    albChangeGrass=0

    iv=ivDecid
    IF((LAI_id(iv)-LAI_id_prev(iv))/=0) THEN
       deltaLAI=(LAI_id(iv)-LAI_id_prev(iv))/(LAImax(iv)-LAIMin(iv))
       albChangeDecTr=(AlbMax_DecTr-AlbMin_DecTr)* deltaLAI
       CapChange=(CapMin_dec-CapMax_dec)* deltaLAI
       porChange=(PorMin_dec-PorMax_dec)* deltaLAI
    ENDIF

    iv=ivConif
    IF((LAI_id(iv)-LAI_id_prev(iv))/=0) THEN
       deltaLAIEveTr=(LAI_id(iv)-LAI_id_prev(iv))/(LAImax(iv)-LAIMin(iv))
       albChangeEveTr=(AlbMax_EveTr-AlbMin_EveTr)* deltaLAIEveTr    !!N.B. Currently uses deltaLAI for deciduous trees only!!
    ENDIF

    iv=ivGrass
    IF((LAI_id(iv)-LAI_id_prev(iv))/=0) THEN
       deltaLAIGrass=(LAI_id(iv)-LAI_id_prev(iv))/(LAImax(iv)-LAIMin(iv))
       albChangeGrass=(AlbMax_Grass-AlbMin_Grass)* deltaLAIGrass    !!N.B. Currently uses deltaLAI for deciduous trees only!!
    ENDIF

    iv=ivDecid

    !write(*,*) deltaLAI, deltaLAIEveTr, deltaLAIGrass

    DecidCap_id = DecidCap_id - CapChange
    albDecTr_id = albDecTr_id + albChangeDecTr
    porosity_id = porosity_id + porChange !- changed to + by HCW 20 Aug 2015 (porosity greatest when LAI smallest)
    !Also update albedo of EveTr and Grass surfaces
    albEveTr_id = albEveTr_id + albChangeEveTr
    albGrass_id = albGrass_id + albChangeGrass

  END SUBROUTINE update_Veg_X



  SUBROUTINE update_GDDLAI(&
       id,LAICalcYes,& !input
       lat,LAI_obs,&
       BaseT,&
       BaseTe,&
       GDDFull,&
       SDDFull,&
       LAIMin,&
       LAIMax,&
       LAIPower,LAIType,&
       GDD,LAI) !inout
    IMPLICIT NONE

    !------------------------------------------------------------------------------
    ! Calculation of LAI from growing degree days
    ! This was revised and checked on 16 Feb 2014 by LJ
    !------------------------------------------------------------------------------

    INTEGER,INTENT(IN)::id
    INTEGER,INTENT(IN)::LAICalcYes

    REAL(KIND(1d0)),INTENT(IN)::lat
    REAL(KIND(1d0)),INTENT(IN)::LAI_obs

    ! --- Vegetation phenology ---------------------------------------------------------------------
    ! Parameters provided in input information for each vegetation surface (SUEWS_Veg.txt)
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: BaseT          !Base temperature for growing degree days [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: BaseTe         !Base temperature for senescence degree days [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: GDDFull        !Growing degree days needed for full capacity [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: SDDFull        !Senescence degree days needed to initiate leaf off [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: LAIMin         !Min LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: LAIMax         !Max LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(4,nvegsurf),INTENT(IN):: LAIPower       !Coeffs for LAI equation: 1,2 - leaf growth; 3,4 - leaf off
    !! N.B. currently DecTr only, although input provided for all veg types
    INTEGER,DIMENSION(nvegsurf),INTENT(IN):: LAIType                  !LAI equation to use: original (0) or new (1)

    REAL(KIND(1d0)),DIMENSION( 0:ndays, 5),INTENT(INOUT)       :: GDD !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(-4:ndays, nvegsurf),INTENT(INOUT):: LAI !LAI for each veg surface [m2 m-2]

    REAL(KIND(1d0)):: no   !Switches and checks for GDD
    REAL(KIND(1d0))::yes   !Switches and checks for GDD
    REAL(KIND(1d0))::indHelp   !Switches and checks for GDD

    INTEGER:: critDays
    INTEGER::iv


    critDays=50   !Critical limit for GDD when GDD or SDD is set to zero

    ! Loop through vegetation types (iv)
    DO iv=1,NVegSurf
       ! Calculate GDD for each day from the minimum and maximum air temperature
       yes =((GDD(id,3)+GDD(id,4))/2-BaseT(iv))    !Leaf on
       no  =((GDD(id,3)+GDD(id,4))/2-BaseTe(iv))   !Leaf off

       indHelp = 0   !Help switch to allow GDD to go to zero in sprint-time !! QUESTION: What does this mean? HCW

       IF(yes<0) THEN   !GDD cannot be negative
          indHelp=yes   !Amount of negative GDD
          yes=0
       ENDIF

       IF(no>0) no=0    !SDD cannot be positive

       ! Calculate cumulative growing and senescence degree days
       GDD(id,1) = GDD(id-1,1)+yes
       GDD(id,2) = GDD(id-1,2)+no

       ! Possibility for cold spring
       IF(GDD(id,2)<=SDDFull(iv).AND.indHelp<0) THEN
          GDD(id,1)=0
       ENDIF

       IF(GDD(id,1)>=GDDFull(iv)) THEN   !Start senescence
          GDD(id,1)=GDDFull(iv)          !Leaves should not grow so delete yes from earlier
          IF(GDD(id,2)<-critDays) GDD(id,1)=0
       ENDIF

       IF (GDD(id,2)<=SDDFull(iv)) THEN   !After senescence now start growing leaves
          GDD(id,2)=SDDFull(iv)           !Leaves off so add back earlier
          IF(GDD(id,1)>critDays) GDD(id,2)=0
       ENDIF

       ! With these limits SDD, GDD is set to zero
       IF(GDD(id,2)<-critDays.AND.GDD(id,2)>SDDFull(iv))  GDD(id,1)=0
       IF(GDD(id,1)> critDays.AND.GDD(id,1)<GDDFull(iv))  GDD(id,2)=0

       ! Now calculate LAI itself
       IF(lat>=0) THEN   !Northern hemispere
          IF (id==140.AND.GDD(id,2)/=0)  GDD(id,2)=0  !If SDD is not zero by mid May, this is forced
          ! Set SDD to zero in summer time
          IF (GDD(id,1)> critDays.AND.id<170) GDD(id,2)=0
          ! Set GDD zero in winter time
          IF (GDD(id,2)<-critDays.AND.id>170) GDD(id,1)=0

          IF (LAItype(iv) < 0.5) THEN   !Original LAI type
             IF(GDD(id,1)>0.AND.GDD(id,1)<GDDFull(iv)) THEN       !Leaves can still grow
                LAI(id,iv)=(LAI(id-1,iv)**LAIPower(1,iv)*GDD(id,1)*LAIPower(2,iv))+LAI(id-1,iv)
             ELSEIF(GDD(id,2)<0.AND.GDD(id,2)>SDDFull(iv)) THEN   !Start senescence
                LAI(id,iv)=(LAI(id-1,iv)**LAIPower(3,iv)*GDD(id,2)*LAIPower(4,iv))+LAI(id-1,iv)
             ELSE
                LAI(id,iv)=LAI(id-1,iv)
             ENDIF
          ELSEIF (LAItype(iv)>=0.5) THEN
             IF(GDD(id,1)>0.AND.GDD(id,1)<GDDFull(iv)) THEN        !Leaves can still grow
                LAI(id,iv)=(LAI(id-1,iv)**LAIPower(1,iv)*GDD(id,1)*LAIPower(2,iv))+LAI(id-1,iv)
                !! Use day length to start senescence at high latitudes (N hemisphere)
             ELSEIF (GDD(id,5)<=12.AND.GDD(id,2)>SDDFull(iv)) THEN !Start senescence
                LAI(id,iv)=(LAI(id-1,iv)*LAIPower(3,iv)*(1-GDD(id,2))*LAIPower(4,iv))+LAI(id-1,iv)
             ELSE
                LAI(id,iv)=LAI(id-1,iv)
             ENDIF
          ENDIF

       ELSEIF (lat<0) THEN   !Southern hemisphere !! N.B. not identical to N hemisphere - return to later
          IF (id==300.AND.GDD(id,2)/=0)  GDD(id,2)=0   !If SDD is not zero by late Oct, this is forced
          ! Set SDD to zero in summer time
          IF (GDD(id,1)> critDays.AND.id>250) GDD(id,2)=0
          ! Set GDD zero in winter time
          IF (GDD(id,2)<-critDays.AND.id<250) GDD(id,1)=0

          IF (LAItype(iv) < 0.5) THEN   !Original LAI type
             IF(GDD(id,1)>0.AND.GDD(id,1)<GDDFull(iv)) THEN
                LAI(id,iv)=(LAI(id-1,iv)**LAIPower(1,iv)*GDD(id,1)*LAIPower(2,iv))+LAI(id-1,iv)
             ELSEIF(GDD(id,2)<0.AND.GDD(id,2)>SDDFull(iv)) THEN
                LAI(id,iv)=(LAI(id-1,iv)**LAIPower(3,iv)*GDD(id,2)*LAIPower(4,iv))+LAI(id-1,iv)
             ELSE
                LAI(id,iv)=LAI(id-1,iv)
             ENDIF
          ELSE
             IF(GDD(id,1)>0.AND.GDD(id,1)<GDDFull(iv)) THEN
                LAI(id,iv)=(LAI(id-1,iv)**LAIPower(1,iv)*GDD(id,1)*LAIPower(2,iv))+LAI(id-1,iv)
                !! Day length not used to start senescence in S hemisphere (not much land)
             ELSEIF(GDD(id,2)<0.AND.GDD(id,2)>SDDFull(iv)) THEN
                LAI(id,iv)=(LAI(id-1,iv)*LAIPower(3,iv)*(1-GDD(id,2))*LAIPower(4,iv))+LAI(id-1,iv)
             ELSE
                LAI(id,iv)=LAI(id-1,iv)
             ENDIF
          ENDIF
       ENDIF   !N or S hemisphere

       ! Check LAI within limits; if not set to limiting value
       IF(LAI(id,iv)>LAImax(iv))THEN
          LAI(id,iv)=LAImax(iv)
       ELSEIF(LAI(id,iv)<LAImin(iv))THEN
          LAI(id,iv)=LAImin(iv)
       ENDIF

    ENDDO   !End of loop over veg surfaces

    IF(LAICalcYes==0)THEN ! moved to SUEWS_cal_DailyState, TS 18 Sep 2017
       LAI(id-1,:)=LAI_obs ! check -- this is going to be a problem as it is not for each vegetation class
    ENDIF
    !------------------------------------------------------------------------------

  END SUBROUTINE update_GDDLAI



  SUBROUTINE update_GDDLAI_X(&
       id,LAICalcYes,& !input
       lat,LAI_obs,&
       BaseT,BaseTe,&
       GDDFull,SDDFull,&
       LAIMin,LAIMax,LAIPower,LAIType,&
       GDD_id,LAI_id,&!inout
       LAI_id_prev) !output
    IMPLICIT NONE

    !------------------------------------------------------------------------------
    ! Calculation of LAI from growing degree days
    ! This was revised and checked on 16 Feb 2014 by LJ
    !------------------------------------------------------------------------------

    INTEGER,INTENT(IN)::id
    INTEGER,INTENT(IN)::LAICalcYes

    REAL(KIND(1d0)),INTENT(IN)::lat
    REAL(KIND(1d0)),INTENT(IN)::LAI_obs

    ! --- Vegetation phenology ---------------------------------------------------------------------
    ! Parameters provided in input information for each vegetation surface (SUEWS_Veg.txt)
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: BaseT          !Base temperature for growing degree days [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: BaseTe         !Base temperature for senescence degree days [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: GDDFull        !Growing degree days needed for full capacity [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: SDDFull        !Senescence degree days needed to initiate leaf off [degC]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: LAIMin         !Min LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN)  :: LAIMax         !Max LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(4,nvegsurf),INTENT(IN):: LAIPower       !Coeffs for LAI equation: 1,2 - leaf growth; 3,4 - leaf off
    !! N.B. currently DecTr only, although input provided for all veg types
    INTEGER,DIMENSION(nvegsurf),INTENT(IN):: LAIType                  !LAI equation to use: original (0) or new (1)

    REAL(KIND(1d0)),DIMENSION(5),INTENT(INOUT)       :: GDD_id !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(INOUT):: LAI_id !LAI for each veg surface [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(OUT)::LAI_id_prev ! LAI of previous day

    REAL(KIND(1d0)):: no   !Switches and checks for GDD
    REAL(KIND(1d0))::yes   !Switches and checks for GDD
    REAL(KIND(1d0))::indHelp   !Switches and checks for GDD
    REAL(KIND(1d0)),DIMENSION(5)::GDD_id_prev ! GDD of previous day


    INTEGER:: critDays
    INTEGER::iv

    ! translate values of previous day to local variables
    GDD_id_prev=GDD_id
    LAI_id_prev=LAI_id


    critDays=50   !Critical limit for GDD when GDD or SDD is set to zero

    ! Loop through vegetation types (iv)
    DO iv=1,NVegSurf
       ! Calculate GDD for each day from the minimum and maximum air temperature
       yes =((GDD_id_prev(3)+GDD_id_prev(4))/2-BaseT(iv))    !Leaf on
       no  =((GDD_id_prev(3)+GDD_id_prev(4))/2-BaseTe(iv))   !Leaf off

       indHelp = 0   !Help switch to allow GDD to go to zero in sprint-time !! QUESTION: What does this mean? HCW

       IF(yes<0) THEN   !GDD cannot be negative
          indHelp=yes   !Amount of negative GDD
          yes=0
       ENDIF

       IF(no>0) no=0    !SDD cannot be positive

       ! Calculate cumulative growing and senescence degree days
       GDD_id(1) = GDD_id_prev(1)+yes
       GDD_id(2) = GDD_id_prev(2)+no

       ! Possibility for cold spring
       IF(GDD_id(2)<=SDDFull(iv).AND.indHelp<0) THEN
          GDD_id(1)=0
       ENDIF

       IF(GDD_id(1)>=GDDFull(iv)) THEN   !Start senescence
          GDD_id(1)=GDDFull(iv)          !Leaves should not grow so delete yes from earlier
          IF(GDD_id(2)<-critDays) GDD_id(1)=0
       ENDIF

       IF (GDD_id(2)<=SDDFull(iv)) THEN   !After senescence now start growing leaves
          GDD_id(2)=SDDFull(iv)           !Leaves off so add back earlier
          IF(GDD_id(1)>critDays) GDD_id(2)=0
       ENDIF

       ! With these limits SDD, GDD is set to zero
       IF(GDD_id(2)<-critDays.AND.GDD_id(2)>SDDFull(iv))  GDD_id(1)=0
       IF(GDD_id(1)> critDays.AND.GDD_id(1)<GDDFull(iv))  GDD_id(2)=0

       ! Now calculate LAI itself
       IF(lat>=0) THEN   !Northern hemispere
          IF (id==140.AND.GDD_id(2)/=0)  GDD_id(2)=0  !If SDD is not zero by mid May, this is forced
          ! Set SDD to zero in summer time
          IF (GDD_id(1)> critDays.AND.id<170) GDD_id(2)=0
          ! Set GDD zero in winter time
          IF (GDD_id(2)<-critDays.AND.id>170) GDD_id(1)=0

          IF (LAItype(iv) < 0.5) THEN   !Original LAI type
             IF(GDD_id(1)>0.AND.GDD_id(1)<GDDFull(iv)) THEN       !Leaves can still grow
                LAI_id(iv)=(LAI_id_prev(iv)**LAIPower(1,iv)*GDD_id(1)*LAIPower(2,iv))+LAI_id_prev(iv)
             ELSEIF(GDD_id(2)<0.AND.GDD_id(2)>SDDFull(iv)) THEN   !Start senescence
                LAI_id(iv)=(LAI_id_prev(iv)**LAIPower(3,iv)*GDD_id(2)*LAIPower(4,iv))+LAI_id_prev(iv)
             ELSE
                LAI_id(iv)=LAI_id_prev(iv)
             ENDIF
          ELSEIF (LAItype(iv)>=0.5) THEN
             IF(GDD_id(1)>0.AND.GDD_id(1)<GDDFull(iv)) THEN        !Leaves can still grow
                LAI_id(iv)=(LAI_id_prev(iv)**LAIPower(1,iv)*GDD_id(1)*LAIPower(2,iv))+LAI_id_prev(iv)
                !! Use day length to start senescence at high latitudes (N hemisphere)
             ELSEIF (GDD_id(5)<=12.AND.GDD_id(2)>SDDFull(iv)) THEN !Start senescence
                LAI_id(iv)=(LAI_id_prev(iv)*LAIPower(3,iv)*(1-GDD_id(2))*LAIPower(4,iv))+LAI_id_prev(iv)
             ELSE
                LAI_id(iv)=LAI_id_prev(iv)
             ENDIF
          ENDIF

       ELSEIF (lat<0) THEN   !Southern hemisphere !! N.B. not identical to N hemisphere - return to later
          IF (id==300.AND.GDD_id(2)/=0)  GDD_id(2)=0   !If SDD is not zero by late Oct, this is forced
          ! Set SDD to zero in summer time
          IF (GDD_id(1)> critDays.AND.id>250) GDD_id(2)=0
          ! Set GDD zero in winter time
          IF (GDD_id(2)<-critDays.AND.id<250) GDD_id(1)=0

          IF (LAItype(iv) < 0.5) THEN   !Original LAI type
             IF(GDD_id(1)>0.AND.GDD_id(1)<GDDFull(iv)) THEN
                LAI_id(iv)=(LAI_id_prev(iv)**LAIPower(1,iv)*GDD_id(1)*LAIPower(2,iv))+LAI_id_prev(iv)
             ELSEIF(GDD_id(2)<0.AND.GDD_id(2)>SDDFull(iv)) THEN
                LAI_id(iv)=(LAI_id_prev(iv)**LAIPower(3,iv)*GDD_id(2)*LAIPower(4,iv))+LAI_id_prev(iv)
             ELSE
                LAI_id(iv)=LAI_id_prev(iv)
             ENDIF
          ELSE
             IF(GDD_id(1)>0.AND.GDD_id(1)<GDDFull(iv)) THEN
                LAI_id(iv)=(LAI_id_prev(iv)**LAIPower(1,iv)*GDD_id(1)*LAIPower(2,iv))+LAI_id_prev(iv)
                !! Day length not used to start senescence in S hemisphere (not much land)
             ELSEIF(GDD_id(2)<0.AND.GDD_id(2)>SDDFull(iv)) THEN
                LAI_id(iv)=(LAI_id_prev(iv)*LAIPower(3,iv)*(1-GDD_id(2))*LAIPower(4,iv))+LAI_id_prev(iv)
             ELSE
                LAI_id(iv)=LAI_id_prev(iv)
             ENDIF
          ENDIF
       ENDIF   !N or S hemisphere

       ! Check LAI within limits; if not set to limiting value
       IF(LAI_id(iv)>LAImax(iv))THEN
          LAI_id(iv)=LAImax(iv)
       ELSEIF(LAI_id(iv)<LAImin(iv))THEN
          LAI_id(iv)=LAImin(iv)
       ENDIF

    ENDDO   !End of loop over veg surfaces

    IF(LAICalcYes==0)THEN ! moved to SUEWS_cal_DailyState, TS 18 Sep 2017
       ! LAI(id-1,:)=LAI_obs ! check -- this is going to be a problem as it is not for each vegetation class
       LAI_id=LAI_obs
    ENDIF
    !------------------------------------------------------------------------------

  END SUBROUTINE update_GDDLAI_X


  ! SUBROUTINE update_WaterUse(&
  !      id,WaterUseMethod,DayofWeek_id,lat,Faut,HDD_id,&!input
  !      Ie_a,Ie_m,Ie_start,Ie_end,DayWatPer,DayWat,&
  !      WUDay) !inout
  !
  !   IMPLICIT NONE
  !
  !   INTEGER,INTENT(IN) :: id
  !   INTEGER,INTENT(IN) :: WaterUseMethod
  !   INTEGER,INTENT(IN)::Ie_start   !Starting time of water use (DOY)
  !   INTEGER,INTENT(IN)::Ie_end       !Ending time of water use (DOY)
  !   INTEGER,DIMENSION(3),INTENT(IN)::DayofWeek_id
  !
  !   REAL(KIND(1d0)),INTENT(IN)::lat
  !   REAL(KIND(1d0)),INTENT(IN)::Faut          !Fraction of irrigated area using automatic irrigation
  !
  !   REAL(KIND(1d0)),DIMENSION(6),INTENT(IN)::HDD_id
  !   REAL(KIND(1d0)),DIMENSION(3),INTENT(IN)::Ie_a
  !   REAL(KIND(1d0)),DIMENSION(3),INTENT(IN)::Ie_m   !Coefficients for automatic and manual irrigation models
  !   REAL(KIND(1d0)),DIMENSION(7),INTENT(IN)::DayWatPer  !% of houses following daily water
  !   REAL(KIND(1d0)),DIMENSION(7),INTENT(IN)::DayWat       !Days of watering allowed
  !
  !   REAL(KIND(1d0)),DIMENSION(0:ndays,9),INTENT(INOUT):: WUDay       !Daily water use for EveTr, DecTr, Grass [mm] (see SUEWS_DailyState.f95)
  !
  !   INTEGER::wd        !Water use calculation is done when calc = 1
  !   INTEGER::&
  !        calc        !Water use calculation is done when calc = 1
  !
  !   IF (WaterUseMethod==0) THEN   !If water use is to be modelled (rather than observed)
  !
  !      wd=DayofWeek_id(1)
  !
  !      IF (DayWat(wd)==1.0) THEN      !1 indicates watering permitted on this day
  !         calc=0
  !         IF (lat>=0) THEN            !Northern Hemisphere
  !            IF (id>=Ie_start-1.AND.id<=Ie_end+1) calc=1   !Day between irrigation period
  !         ELSE                        !Southern Hemisphere
  !            calc=1
  !            IF (id>=Ie_end.AND.id<=Ie_start) calc=0       !Day between irrigation period
  !         ENDIF
  !
  !         IF(calc==1) THEN
  !            ! Model daily water use based on HDD_id(6)(days since rain) and HDD_id(3)(average temp)
  !            ! WUDay is the amount of water [mm] per day, applied to each of the irrigated areas
  !            ! N.B. These are the same for each vegetation type at the moment
  !
  !            ! ---- Automatic irrigation (evergreen trees) ----
  !            WUDay(id,2) = Faut*(Ie_a(1)+Ie_a(2)*HDD_id(3)+Ie_a(3)*HDD_id(6))*DayWatPer(wd)
  !            IF (WUDay(id,2)<0) WUDay(id,2)=0   !If modelled WU is negative -> 0
  !
  !            ! ---- Manual irrigation (evergreen trees) ----
  !            WUDay(id,3) = (1-Faut)*(Ie_m(1)+Ie_m(2)*HDD_id(3)+Ie_m(3)*HDD_id(6))*DayWatPer(wd)
  !            IF (WUDay(id,3)<0) WUDay(id,3)=0   !If modelled WU is negative -> 0
  !
  !            ! ---- Total evergreen trees water use (automatic + manual) ----
  !            WUDay(id,1)=(WUDay(id,2)+WUDay(id,3))
  !
  !            ! ---- Automatic irrigation (deciduous trees) ----
  !            WUDay(id,5) = Faut*(Ie_a(1)+Ie_a(2)*HDD_id(3)+Ie_a(3)*HDD_id(6))*DayWatPer(wd)
  !            IF (WUDay(id,5)<0) WUDay(id,5)=0   !If modelled WU is negative -> 0
  !
  !            ! ---- Manual irrigation (deciduous trees) ----
  !            WUDay(id,6) = (1-Faut)*(Ie_m(1)+Ie_m(2)*HDD_id(3)+Ie_m(3)*HDD_id(6))*DayWatPer(wd)
  !            IF (WUDay(id,6)<0) WUDay(id,6)=0   !If modelled WU is negative -> 0
  !
  !            ! ---- Total deciduous trees water use (automatic + manual) ----
  !            WUDay(id,4)=(WUDay(id,5)+WUDay(id,6))
  !
  !            ! ---- Automatic irrigation (grass) ----
  !            WUDay(id,8) = Faut*(Ie_a(1)+Ie_a(2)*HDD_id(3)+Ie_a(3)*HDD_id(6))*DayWatPer(wd)
  !            IF (WUDay(id,8)<0) WUDay(id,8)=0   !If modelled WU is negative -> 0
  !
  !            ! ---- Manual irrigation (grass) ----
  !            WUDay(id,9) = (1-Faut)*(Ie_m(1)+Ie_m(2)*HDD_id(3)+Ie_m(3)*HDD_id(6))*DayWatPer(wd)
  !            IF (WUDay(id,9)<0) WUDay(id,9)=0   !If modelled WU is negative -> 0
  !
  !            ! ---- Total grass water use (automatic + manual) ----
  !            WUDay(id,7)=(WUDay(id,8)+WUDay(id,9))
  !
  !         ELSE   !If no irrigation on this day
  !            WUDay(id,1)=0
  !            WUDay(id,2)=0
  !            WUDay(id,3)=0
  !            WUDay(id,4)=0
  !            WUDay(id,5)=0
  !            WUDay(id,6)=0
  !            WUDay(id,7)=0
  !            WUDay(id,8)=0
  !            WUDay(id,9)=0
  !         ENDIF
  !      ENDIF
  !   ENDIF
  !
  ! END SUBROUTINE update_WaterUse


  SUBROUTINE update_WaterUse_X(&
       id,WaterUseMethod,DayofWeek_id,lat,Faut,HDD_id,&!input
       Ie_a,Ie_m,Ie_start,Ie_end,DayWatPer,DayWat,&
       WUDay_id) !output

    IMPLICIT NONE

    INTEGER,INTENT(IN) :: id
    INTEGER,INTENT(IN) :: WaterUseMethod
    INTEGER,INTENT(IN)::Ie_start   !Starting time of water use (DOY)
    INTEGER,INTENT(IN)::Ie_end       !Ending time of water use (DOY)
    INTEGER,DIMENSION(3),INTENT(IN)::DayofWeek_id

    REAL(KIND(1d0)),INTENT(IN)::lat
    REAL(KIND(1d0)),INTENT(IN)::Faut          !Fraction of irrigated area using automatic irrigation

    REAL(KIND(1d0)),DIMENSION(12),INTENT(IN)::HDD_id
    REAL(KIND(1d0)),DIMENSION(3),INTENT(IN)::Ie_a
    REAL(KIND(1d0)),DIMENSION(3),INTENT(IN)::Ie_m   !Coefficients for automatic and manual irrigation models
    REAL(KIND(1d0)),DIMENSION(7),INTENT(IN)::DayWatPer  !% of houses following daily water
    REAL(KIND(1d0)),DIMENSION(7),INTENT(IN)::DayWat       !Days of watering allowed

    REAL(KIND(1d0)),DIMENSION(9),INTENT(OUT):: WUDay_id       !Daily water use for EveTr, DecTr, Grass [mm] (see SUEWS_DailyState.f95)

    INTEGER::wd        !Water use calculation is done when calc = 1
    INTEGER::calc        !Water use calculation is done when calc = 1

    REAL(KIND(1d0))::temp_avg
    REAL(KIND(1d0))::days_since_rain

    ! transfer HDD values
    temp_avg        = HDD_id(9)
    days_since_rain = HDD_id(12)

    ! initialise WUDay_id
    WUDay_id=0


    IF (WaterUseMethod==0) THEN   !If water use is to be modelled (rather than observed)

       wd=DayofWeek_id(1)

       IF (DayWat(wd)==1.0) THEN      !1 indicates watering permitted on this day
          calc=0
          IF (lat>=0) THEN            !Northern Hemisphere
             IF (id>=Ie_start-1.AND.id<=Ie_end+1) calc=1   !Day between irrigation period
          ELSE                        !Southern Hemisphere
             calc=1
             IF (id>=Ie_end.AND.id<=Ie_start) calc=0       !Day between irrigation period
          ENDIF

          IF(calc==1) THEN
             ! Model daily water use based on days_since_rain (days since rain) and temp_avg (average temp)
             ! WUDay is the amount of water [mm] per day, applied to each of the irrigated areas
             ! N.B. These are the same for each vegetation type at the moment

             ! ---- Automatic irrigation (evergreen trees) ----
             WUDay_id(2) = Faut*(Ie_a(1)+Ie_a(2)*temp_avg+Ie_a(3)*days_since_rain)*DayWatPer(wd)
             IF (WUDay_id(2)<0) WUDay_id(2)=0   !If modelled WU is negative -> 0

             ! ---- Manual irrigation (evergreen trees) ----
             WUDay_id(3) = (1-Faut)*(Ie_m(1)+Ie_m(2)*temp_avg+Ie_m(3)*days_since_rain)*DayWatPer(wd)
             IF (WUDay_id(3)<0) WUDay_id(3)=0   !If modelled WU is negative -> 0

             ! ---- Total evergreen trees water use (automatic + manual) ----
             WUDay_id(1)=(WUDay_id(2)+WUDay_id(3))

             ! ---- Automatic irrigation (deciduous trees) ----
             WUDay_id(5) = Faut*(Ie_a(1)+Ie_a(2)*temp_avg+Ie_a(3)*days_since_rain)*DayWatPer(wd)
             IF (WUDay_id(5)<0) WUDay_id(5)=0   !If modelled WU is negative -> 0

             ! ---- Manual irrigation (deciduous trees) ----
             WUDay_id(6) = (1-Faut)*(Ie_m(1)+Ie_m(2)*temp_avg+Ie_m(3)*days_since_rain)*DayWatPer(wd)
             IF (WUDay_id(6)<0) WUDay_id(6)=0   !If modelled WU is negative -> 0

             ! ---- Total deciduous trees water use (automatic + manual) ----
             WUDay_id(4)=(WUDay_id(5)+WUDay_id(6))

             ! ---- Automatic irrigation (grass) ----
             WUDay_id(8) = Faut*(Ie_a(1)+Ie_a(2)*temp_avg+Ie_a(3)*days_since_rain)*DayWatPer(wd)
             IF (WUDay_id(8)<0) WUDay_id(8)=0   !If modelled WU is negative -> 0

             ! ---- Manual irrigation (grass) ----
             WUDay_id(9) = (1-Faut)*(Ie_m(1)+Ie_m(2)*temp_avg+Ie_m(3)*days_since_rain)*DayWatPer(wd)
             IF (WUDay_id(9)<0) WUDay_id(9)=0   !If modelled WU is negative -> 0

             ! ---- Total grass water use (automatic + manual) ----
             WUDay_id(7)=(WUDay_id(8)+WUDay_id(9))

          ELSE   !If no irrigation on this day
             WUDay_id(1)=0
             WUDay_id(2)=0
             WUDay_id(3)=0
             WUDay_id(4)=0
             WUDay_id(5)=0
             WUDay_id(6)=0
             WUDay_id(7)=0
             WUDay_id(8)=0
             WUDay_id(9)=0
          ENDIF
       ENDIF
    ENDIF

  END SUBROUTINE update_WaterUse_X


  SUBROUTINE update_HDD(&
       id,it,imin,tstep,& !input
       HDD) !inout
    IMPLICIT NONE
    INTEGER,INTENT(IN)::id,it,imin,tstep

    REAL(KIND(1d0)),DIMENSION(-4:366,6),INTENT(INOUT):: HDD

    INTEGER:: jj
    REAL(KIND(1d0))::tstepcount

    ! count of timesteps performed during day `id`
    tstepcount=(it*60+imin)*60/tstep*1.
    ! Heating degree days (HDD) -------------
    HDD(id,1)=HDD(id,1)/tstepcount   !Heating
    HDD(id,2)=HDD(id,2)/tstepcount   !Cooling
    HDD(id,3)=HDD(id,3)/tstepcount   !Average temp

    ! Calculate 5-day running mean temp     !!Need to deal with the previous year - CHECK!!
    DO jj=1,5
       HDD(id,4)=HDD(id,4) + HDD(id-(jj-1),3)
    ENDDO
    HDD(id,4) = HDD(id,4)/5

    ! Calculate number of days since rain
    IF(HDD(id,5)>0) THEN        !Rain occurred
       HDD(id,6)=0
    ELSE
       HDD(id,6)=HDD(id-1,6)+1  !Days since rain
    ENDIF

  END SUBROUTINE update_HDD


  SUBROUTINE update_HDD_X(&
       dt_since_start,it,imin,tstep,& !input
       HDD_id)!inout
    IMPLICIT NONE
    INTEGER,INTENT(IN)::dt_since_start,it,imin,tstep

    REAL(KIND(1d0)),DIMENSION(12),INTENT(INOUT):: HDD_id
    ! REAL(KIND(1d0)),DIMENSION(6),INTENT(OUT):: HDD_id_use

    INTEGER:: days_prev
    REAL(KIND(1d0))::tstepcount

    ! count of timesteps performed during day `id`
    tstepcount=(it*60+imin)*60/tstep*1.
    ! Heating degree days (HDD) -------------
    HDD_id(1)=HDD_id(1)/tstepcount   !Heating
    HDD_id(2)=HDD_id(2)/tstepcount   !Cooling
    HDD_id(3)=HDD_id(3)/tstepcount   !Average temp

    ! Calculate a quasi-5-day-running-mean temp
    days_prev= MIN(4,& ! dt_since_start >= 4 days
         FLOOR(dt_since_start/(24*60*60)*1.)) ! dt_since_start < 4 days
    HDD_id(4) = (HDD_id(4)*days_prev+HDD_id(3))/(days_prev+1)

    ! Calculate number of days since rain
    IF(HDD_id(5)>0) THEN        !Rain occurred
       HDD_id(6)=0
    ELSE
       HDD_id(6)=HDD_id(6)+1  !Days since rain
    ENDIF

    ! save updated HDD_id(:,1) values to the other dimension
    HDD_id(6+1:6+6) = HDD_id(1:6)

  END SUBROUTINE update_HDD_X


  SUBROUTINE update_DailyState_Start(&
       it,imin,&!input
       HDD_id)!output
    IMPLICIT NONE
    INTEGER,INTENT(IN) :: it
    INTEGER,INTENT(IN) ::imin

    REAL(KIND(1d0)),DIMENSION(6),INTENT(INOUT) ::HDD_id
    REAL(KIND(1d0))::HDD_id_mav,HDD_id_daysSR

    ! reset HDD_id to ZERO except for:
    ! 5-day moving average
    HDD_id_mav=HDD_id(4)
    ! Days Since Rain
    HDD_id_daysSR=HDD_id(6)
    IF ( it == 0 .AND. imin ==0 ) THEN
       HDD_id=0
       HDD_id(4)=HDD_id_mav
       HDD_id(6)=HDD_id_daysSR
    END IF

  END SUBROUTINE update_DailyState_Start

  SUBROUTINE SUEWS_update_DailyState(&
       id,datetimeline,&!input
       Gridiv,NumberOfGrids,&
       DailyStateLine,&
       dataOutDailyState)!inout

    IMPLICIT NONE

    ! INTEGER,INTENT(IN) ::iy
    INTEGER,INTENT(IN) ::id
    ! INTEGER,INTENT(IN) ::it
    ! INTEGER,INTENT(IN) ::imin

    REAL(KIND(1d0)),DIMENSION(5),INTENT(IN)::datetimeline

    INTEGER,INTENT(IN)::Gridiv
    INTEGER,INTENT(IN)::NumberOfGrids
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutDailyState-5),INTENT(IN) :: DailyStateLine
    REAL(KIND(1d0)),DIMENSION(ndays,ncolumnsDataOutDailyState,NumberOfGrids),INTENT(INOUT):: dataOutDailyState

    ! write out to dataOutDailyState
    dataOutDailyState(id,1:5,Gridiv)=datetimeline
    ! dataOutDailyState(id,5,Gridiv)=dectime
    ! DailyStateLine will be -999 unless realistic values are calculated at the last timestep of each day
    dataOutDailyState(id,6:ncolumnsDataOutDailyState,Gridiv)=DailyStateLine

  END SUBROUTINE SUEWS_update_DailyState


  ! transfer results to a one-line output for SUEWS_cal_DailyState
  SUBROUTINE update_DailyState(&
       it,imin,nsh_real,&!input
       GDD_id,HDD_id,LAI_id,&
       DecidCap_id,&
       albDecTr_id,&
       albEveTr_id,&
       albGrass_id,&
       porosity_id,&
       WUDay_id,&
       deltaLAI,VegPhenLumps,&
       SnowAlb,SnowDens,&
       a1,a2,a3,&
       DailyStateLine)!out

    IMPLICIT NONE

    ! INTEGER,INTENT(IN) ::iy
    ! INTEGER,INTENT(IN) ::id
    INTEGER,INTENT(IN) ::it
    INTEGER,INTENT(IN) ::imin
    REAL(KIND(1d0)),INTENT(IN) ::nsh_real

    REAL(KIND(1d0)),DIMENSION(5),INTENT(IN):: GDD_id          !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(6),INTENT(IN):: HDD_id          !Heating Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(IN):: LAI_id   !LAI for each veg surface [m2 m-2]

    REAL(KIND(1d0)),INTENT(IN) ::DecidCap_id
    REAL(KIND(1d0)),INTENT(IN) ::albDecTr_id
    REAL(KIND(1d0)),INTENT(IN) ::albEveTr_id
    REAL(KIND(1d0)),INTENT(IN) ::albGrass_id
    REAL(KIND(1d0)),INTENT(IN) ::porosity_id
    REAL(KIND(1d0)),DIMENSION(9),INTENT(IN):: WUDay_id !Daily water use for EveTr, DecTr, Grass [mm] (see SUEWS_DailyState.f95)

    REAL(KIND(1d0)),INTENT(IN) ::deltaLAI
    REAL(KIND(1d0)),INTENT(IN) ::VegPhenLumps
    REAL(KIND(1d0)),INTENT(IN) ::SnowAlb
    REAL(KIND(1d0)),DIMENSION(7),INTENT(IN)::SnowDens
    REAL(KIND(1d0)),INTENT(IN) ::a1
    REAL(KIND(1d0)),INTENT(IN) ::a2
    REAL(KIND(1d0)),INTENT(IN) ::a3

    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutDailyState-5),INTENT(OUT) :: DailyStateLine

    ! initialise DailyStateLine
    DailyStateLine=-999
    IF (it==23 .AND. imin==(nsh_real-1)/nsh_real*60) THEN
       ! Write actual data only at the last timesstep of each day
       ! DailyStateLine(1:2)   = [iy,id]
       DailyStateLine(1:6)   = HDD_id
       DailyStateLine(6+1:6+5)  = GDD_id
       DailyStateLine(11+1:11+3) = LAI_id
       DailyStateLine(14+1:14+5) = [DecidCap_id,Porosity_id,AlbEveTr_id,AlbDecTr_id,AlbGrass_id]
       DailyStateLine(19+1:19+9) = WUDay_id(1:9)
       DailyStateLine(28+1)    = deltaLAI
       DailyStateLine(29+1)    = VegPhenLumps
       DailyStateLine(30+1:30+8) = [SnowAlb,SnowDens(1:7)]
       DailyStateLine(38+1:38+3) = [a1,a2,a3]

    END IF


  END SUBROUTINE update_DailyState


END MODULE DailyState_module

!==============================================================================
MODULE mod_interp
  !     Created on Thu Jan 22 00:06:32 2004
  IMPLICIT NONE

CONTAINS
  ELEMENTAL FUNCTION interp1d(x1,x2,y1,y2,xi) RESULT(yi)
    REAL(KIND(1d0)),INTENT(in) ::x1,x2,xi
    REAL(KIND(1d0)),INTENT(in) ::y1,y2
    REAL (KIND(1D0))::b0,b1
    REAL(KIND(1d0))         ::yi
    !integer         ::ny                 !!!!!FO!!!!!
    b1=(y2-y1)/(x2-x1)
    b0=y1-b1*x1
    yi=b0+b1*xi
  END FUNCTION interp1d
END MODULE mod_interp

!=============================================================================
MODULE mod_solver
  !     Created on Thu Jan 22 07:50:01 2004
  !     Copyright (c) 2001 MyCompany. All rights reserved.

  IMPLICIT NONE

CONTAINS

  FUNCTION NewtonPolynomial(x0,Pcoeff,conv,maxiter) RESULT(x)
    !Solves Newton's Method for a polynomial of the form
    !f(x)=Pcoeff(1)*x^n+Pcoeff(2)*x^n-1+...+Pcoeff(n+1)
    !                f(x(i))
    ! x(i+1) = x(i)- -------
    !                f'(x(i))
    !
    !conv is the level required for convergence
    !maxiter is the maximum allowed iterations
    !----------------------------------------------------
    REAL(KIND(1d0)) ::x0,x,conv
    REAL(KIND(1d0)) ::Pcoeff(:)
    REAL(KIND(1d0)) ::e, xprev
    REAL (KIND(1D0))::f,fp
    INTEGER ::maxiter
    INTEGER ::niter
    LOGICAL ::converged=.FALSE.
    INTEGER ::n,i,j

    e=HUGE(1.)
    n=SIZE(Pcoeff)
    x=x0
    DO i=1,maxiter
       IF (ABS(e)<conv) THEN
          converged=.TRUE.
          EXIT
       ENDIF
       f=0; fp = 0
       DO j=1,n-1
          f = f+Pcoeff(j)*x**(n-j)
          fp = fp + Pcoeff(j)*(n-j)*x**(n-j-1)                              !!FO!! derivative
       ENDDO

       f = f + Pcoeff(n)
       xprev = x
       IF (fp==0.) fp=TINY(1.)
       x = xprev - f/fp
       e = x-xprev
    ENDDO
    niter=i-1
    IF (.NOT.converged) THEN
       PRINT*, "Solution did not converge. Niter=", niter, " Error=", e
       x=x0
    ENDIF
  END FUNCTION NewtonPolynomial
END MODULE mod_solver
!==============================================================================

!==============================================================================
MODULE modSolarCalc
  USE MathConstants
  IMPLICIT NONE

CONTAINS
  !=======================================================
  FUNCTION min_zenith(lat,doy) RESULT(zmin)
    !returns max zenith
    !returns zenith in radians for lat, lng in degrees
    REAL(KIND(1d0)) ::lat,dectime,zmin
    REAL(KIND(1d0)) ::latr,decl
    INTEGER :: doy
    dectime=float(doy)
    latr=lat*dtr
    decl=0.409*COS(2*pi*(dectime-173)/365.25)
    zmin=pi/2.-ASIN(SIN(latr)*SIN(decl)-COS(latr)*COS(decl)*(-1))
  END FUNCTION min_zenith
  !=======================================================

  !=======================================================
  FUNCTION Local_apparent_time(lng,dectime) RESULT(la_time)
    !Oke, 1989, equation of time elsewhere
    REAL(KIND(1d0)) ::lng,dectime,la_time
    REAL(KIND(1d0)) ::gamma,eqtime,lmst

    lmst=dectime-4.*lng/60./1440.
    gamma=2.*pi/365.*(lmst-1.)
    eqtime=229.18*(7.5e-5+1.868e-3*COS(gamma)-0.032077*SIN(gamma)&
         &    -0.014615*COS(2.*gamma)-0.040849*SIN(2.*gamma))
    la_time=lmst+eqtime/1440.
  END FUNCTION Local_apparent_time
  !=======================================================

  SUBROUTINE Solar_angles(lat,lng,timezone,dectime,decl,zenith,azimuth)

    REAL, INTENT(in)  ::lat,lng,timezone,dectime
    INTEGER                 ::doy,hour,mn
    REAL(KIND(1d0)), INTENT(out)  ::decl,zenith,azimuth
    REAL (KIND(1d0))  ::ha,latr,eqtime,tst,&
         time_offset,gamma           !!!!!FO!!!!! lngr, phi, theta

    latr=lat*pi/180.
    doy=FLOOR(dectime)
    hour=FLOOR((dectime-doy)*24.)
    mn=FLOOR((dectime-doy-hour/24.)*60.)   !!!Check this

    gamma=2.*pi/365.25463*(doy-1.+(hour-12.)/24.)
    eqtime=229.18*(7.5e-5+1.868e-3*COS(gamma)-0.032077*SIN(gamma)&
         &    -0.014615*COS(2.*gamma)-0.040849*SIN(2.*gamma))
    decl=6.918e-3-0.399912*COS(gamma)+0.070257*SIN(gamma)&
         &    -0.006758*COS(2.*gamma)+9.07e-4*SIN(2.*gamma)-2.697e-3*COS(3.*gamma)&
         &    +1.48e-3*SIN(3.*gamma)
    time_offset=eqtime-4.*lng+60.*timezone
    tst=hour*60.+mn+time_offset
    ha=(tst/4.)-180.
    ha=ha*pi/180.

    zenith=ACOS(SIN(latr)*SIN(decl)+COS(latr)*COS(decl)*COS(ha))
    azimuth=pi+ACOS((SIN(latr)*COS(zenith)-SIN(decl))/(COS(latr)*SIN(zenith)))

    RETURN
  END SUBROUTINE Solar_angles

  !=========================== SolarTimes ==================================
  SUBROUTINE Solar_Times(lat,lng,timezone,dectime,sunrise,sunset,snoon)
    !  for sunrise and sunset ha = ha(zenith=90)
    !  timezone is offset to GMT e.g. -5 for EST

    REAL(KIND(1d0)), INTENT(in)  ::lat,lng,timezone,dectime
    INTEGER                 ::doy
    REAL(KIND(1d0)), INTENT(out)  ::sunrise, sunset, snoon
    REAL(KIND(1d0))  :: ha, latr, eqtime, gamma, zenith, decl
    latr = lat*dtr
    zenith=90.833*dtr
    doy=FLOOR(dectime)
    gamma=2.*pi/365.*(float(doy)-0.5) !fractional year
    eqtime=229.18*(7.5e-5+1.868e-3*COS(gamma)-0.032077*SIN(gamma)&
         &    -0.014615*COS(2.*gamma)-0.040849*SIN(2.*gamma))
    decl=6.918e-3-0.399912*COS(gamma)+0.070257*SIN(gamma)&
         &    -0.006758*COS(2.*gamma)+9.07e-4*SIN(2.*gamma)-2.697e-3*COS(3.*gamma)&
         &    +1.48e-3*SIN(3.*gamma)
    ha=ACOS(COS(zenith)/(COS(latr)*COS(decl))-TAN(latr)*TAN(decl))
    ha=ha*rtd
    sunrise = (720.-4.*(lng-ha)-eqtime)/60.-timezone
    sunset = (720.-4.*(lng+ha)-eqtime)/60.-timezone
    snoon = (720.-4.*lng-eqtime)/60.-timezone
    RETURN
  END SUBROUTINE Solar_Times
  !=======================================================
  FUNCTION kdown_surface(doy,zenith) RESULT(Isurf)
    ! Calculates ground level solar irradiance clear sky
    ! assuming transmissivity = 1
    ! let it report zero if zenith >= 90
    REAL(KIND(1d0))    ::zenith,Isurf
    INTEGER    ::doy
    REAL (KIND(1d0))::Rmean, Rse, cosZ,Itoa

    Rmean = 149.6   !Stull 1998
    Rse=solar_ESdist(doy)
    IF(zenith<pi/2.) THEN
       cosZ = COS(zenith)
       Itoa = 1370*(Rmean/Rse)**2    !top of the atmosphere
       Isurf = Itoa*cosZ      !ground level solar irradiance in W/m2
    ELSE
       Isurf = 0.
    ENDIF

  END FUNCTION kdown_surface

  !=======================================================
  FUNCTION SmithLambda(lat) RESULT(G)
    !read kriged data based on Smith 1966 (JAM)
    INTEGER :: lat,ios
    REAL,DIMENSION(365):: G

    OPEN(99,file="Smith1966.grd",access="direct",action="read",recl=365*4,iostat=ios)
    IF (ios/=0) THEN
       PRINT*, "Iostat=",ios," reading Smith1966.grd"
       STOP
    ENDIF
    READ(99,rec=lat+1,iostat=ios) G
    IF (ios/=0) PRINT*, "Iostat=", ios, " reading Smith1966.grd"
    CLOSE(99)
  END FUNCTION SmithLambda
  !=======================================================
  FUNCTION transmissivity_CD(P,Td,G,zenith) RESULT(trans)           !!!!!FO!!!!! ,doy
    ! bulk atmospheric transmissivity (Crawford and Duchon, 1999)
    ! P = pressure (hPa)
    ! Td = dewpoint (C)
    ! G parameter is empirical value from Smith 1966 (JAM)
    ! zenith in radians


    !        integer         ::doy           !!!!!FO!!!!!
    REAL(KIND(1d0))    ::P,Td,zenith,G,trans
    REAL (KIND(1d0))::m,TrTpg,u,Tw,Ta,cosZ
    REAL (KIND(1d0))::Tdf

    IF (zenith>80.*dtr) THEN
       cosZ=COS(80.*dtr)
    ELSE
       cosZ=COS(zenith)
    ENDIF
    Tdf = Td*1.8+32. !celsius to fahrenheit
    !  Transmission coefficients
    m = 35*cosZ/SQRT(1224.*cosZ*cosZ+1) !optical air mass at p=1013 mb
    TrTpg = 1.021-0.084*SQRT(m*(0.000949*P+0.051)) !first two trans coeff
    u = EXP(0.113-LOG(G+1)+0.0393*Tdf) !precipitable water
    Tw = 1-0.077*(u*m)**0.3    !vapor transmission coe3ff.
    Ta = 0.935**m        !4th trans coeff
    trans = TrTpg*Tw*Ta              !bulk atmospherics transmissivity
  END FUNCTION transmissivity_CD

  !   !=======================================================
  !   ! NB:this FUNCTION is problematic:
  !   ! these variables are NEVER initialized/calculated: tr,tg,tw,ta
  !   ! but used for calcuLAItng Sdir!
  !   FUNCTION kdown_niemala(S0,vap_press,Tk) RESULT(kdown)           !!!!!FO!!!!! ,albedo
  !     !from Niemala et al. 2001. Atmospheric Research 58:141-154
  !     ! using generalized formula only, no empirical data from site
  !     !11 October 2001
  !     ! S0=base solar insolation at the surface
  !     ! albedo = surface albedo (required for multireflection diffuse)
  !     ! vap_press=screen level vapor pressure (Pa)
  !     ! Tk=screen level air temperature (K)
  !     ! ta=aerosol transmissivity
  !     ! tR=Rayleigh scattering transmissivity
  !     ! tg=uniformly mixed gas transmissivity
  !     ! tw=water vapor transmissivity
  !     ! toz=ozone transmissivity
  ! !!!!!!!INCOMPLETE
  !     REAL  ::S0,vap_press,Tk,kdown           !!!!!FO!!!!! ,albedo
  !     REAL  ::Sdir,Diffuse,Diffuse_R,Diffuse_a,Diffuse_m
  !     REAL  ::tr,tg,tw,ta,toz, theta
  !     CALL transmissivity(vap_press,Tk,theta,tr,tg,tw,ta,toz)
  !     Sdir=0.9751*S0*tr*tg*tw*ta*toz
  !     Diffuse_R=0.
  !     Diffuse_a=0.
  !     Diffuse_m=0.
  !     Diffuse=Diffuse_R+Diffuse_a+Diffuse_m
  !     kdown=Sdir+Diffuse
  !   END FUNCTION kdown_niemala
  !   !=======================================================
  !   SUBROUTINE transmissivity(vap_press,Tk,theta,tr,tg,tw,ta,toz)
  !     !calculates atmospheric transmissivities for
  !     ! ta=aerosol transmissivity
  !     ! tR=Rayleigh scattering transmissivity
  !     ! tg=uniformly mixed gas transmissivity
  !     ! tw=water vapor transmissivity
  !     ! toz=ozone transmissivity
  !     ! from Iqbal (1983) and Niemala(2001)
  !     ! vap_press (Pa)
  !     ! Tk air temp (K)
  !     ! w=precipitable water content (cm)
  !     !==========INCOMPLETE
  !     REAL  ::Tk, vap_press,theta
  !     REAL  ::tr,tg,tw,ta,toz,w
  !     w=0.493*vap_press/Tk
  !     ta=0.59+0.012*theta-1.336e-4*theta*theta
  !
  !   END SUBROUTINE transmissivity

  !=======================================================
  FUNCTION solar_ESdist(doy) RESULT(Rse)
    !from Stull, 1998
    INTEGER  ::doy
    REAL(KIND(1d0))  ::Rse
    REAL (KIND(1d0)) ::MA,nu,e,a

    e = 0.0167
    a = 146.457

    MA = 2.*pi*(doy-3)/365.25463 !Mean anomaly
    nu=MA+0.0333988*SIN(MA)+.0003486*SIN(2.*MA)+5e-6*SIN(3.*MA) !true anomaly
    Rse = a*(1-e*e)/(1+e*COS(nu))

  END FUNCTION solar_ESdist

END MODULE modSolarCalc

!=====================================================================================
!=====================================================================================
MODULE heatflux
  IMPLICIT NONE
CONTAINS

  SUBROUTINE heatcond1d(T,Qs,dx,dt,k,rhocp,bc,bctype)
    REAL(KIND(1d0)),INTENT(inout)::T(:)
    REAL(KIND(1d0)),INTENT(in)::dx(:),dt,k(:),rhocp(:),bc(2)
    REAL(KIND(1d0)),INTENT(out)::Qs
    LOGICAL,INTENT(in)::bctype(2)
    INTEGER         ::i,n!,j       !!!!!FO!!!!!
    REAL(KIND(1d0)),ALLOCATABLE::w(:),a(:),T1(:)
    n=SIZE(T)
    ALLOCATE(w(0:n),a(n),T1(n))
    !w = interface tempea
    w(1:n)=T
    w(0)=bc(1); w(n)=bc(2)
    !convert from flux to equivalent temperature, not exact
    ! F = k dT/dX => dx*F/k + Ti = Ti
    IF (bctype(1)) w(0)=bc(1)*0.5*dx(1)/k(1)+w(1)
    IF (bctype(2)) w(n)=bc(2)*0.5*dx(n)/k(n)+w(n)

    a=k/dx
    DO i=1,n-1
       w(i)=(T(i+1)*a(i+1)+T(i)*a(i))/(a(i)+a(i+1))
    ENDDO
    !!FO!! print*, 'w: ', w
    DO i=1,n
       T1(i) = (dt/rhocp(i))*(w(i-1)-2*T(i) + w(i))*2*a(i)/dx(i) + T(i)
    ENDDO
    !!FO!! print*, 'T1: ', T1
    !for storage the internal distribution of heat should not be important
    Qs = (w(0)-T(1))*2*a(1) + (w(n)-T(n))*2*a(n)                           !!FO!! k*d(dT/dx)/dx = rhoCp*(dT/dt) -- rhoCp*(dT/dt)*dx = dQs -- dQs = k*d(dT/dx)
    ! Qs=sum((T1-T)*rhocp*dx)/dt!
    T=T1
  END SUBROUTINE heatcond1d
END MODULE heatflux

!==================================================================================


MODULE ESTM_module
  !===============================================================================
  ! revision history:
  ! TS 09 Oct 2017: re-organised ESTM subroutines into a module
  !===============================================================================
  IMPLICIT NONE


CONTAINS

  !======================================================================================
  ! Subroutine to read in ESTM data in the same way as met data (SUEWS_InitializeMetData)
  ! HCW 30 Jun 2016
  SUBROUTINE SUEWS_GetESTMData(lunit)
    USE allocateArray, ONLY:ncolsestmdata, estmforcingdata
    USE data_in, ONLY: fileestmts, skipheadermet
    USE sues_data, ONLY: tstep_real, tstep
    USE defaultnotUsed, ONLY: notused, ios_out
    USE Initial, ONLY: skippedlines, readlinesmetdata, gridcounter

    IMPLICIT NONE

    INTEGER,INTENT(in)::lunit
    INTEGER::i,iyy !,RunNumber,NSHcounter
    INTEGER :: iostat_var
    REAL(KIND(1d0)),DIMENSION(ncolsESTMdata):: ESTMArray
    REAL(KIND(1d0)):: imin_prev, ih_prev, iday_prev, tstep_estm   !For checks on temporal resolution of estm data

    !---------------------------------------------------------------

    !Open the file for reading and read the actual data
    !write(*,*) FileESTMTs
    OPEN(lunit,file=TRIM(FileESTMTs),status='old',err=315)
    CALL skipHeader(lunit,SkipHeaderMet)

    ! Skip to the right place in the ESTM file, depending on how many chunks have been read already
    IF (skippedLines>0) THEN
       DO iyy=1,skippedLines
          READ(lunit,*)
       ENDDO
    ENDIF

    ! Read in next chunk of ESTM data and fill ESTMForcingData array with data for every timestep
    DO i=1,ReadlinesMetdata
       READ(lunit,*,iostat=iostat_var) ESTMArray
       ESTMForcingData(i,1:ncolsESTMdata,GridCounter) = ESTMArray
       ! Check timestamp of met data file matches TSTEP specified in RunControl
       IF(i==1) THEN
          imin_prev = ESTMArray(4)
          ih_prev   = ESTMArray(3)
          iday_prev = ESTMArray(2)
       ELSEIF(i==2) THEN
          tstep_estm = ((ESTMArray(4)+60*ESTMArray(3)) - (imin_prev+60*ih_prev))*60   !tstep in seconds
          IF(tstep_estm/=tstep_real.AND.ESTMArray(2)==iday_prev) THEN
             CALL ErrorHint(39,'TSTEP in RunControl does not match TSTEP of ESTM data (DOY).',REAL(tstep,KIND(1d0)),tstep_estm,&
                  INT(ESTMArray(2)))
          ENDIF
       ENDIF
    ENDDO

    CLOSE(lunit)

    RETURN

315 CALL errorHint(11,TRIM(fileESTMTs),notUsed,notUsed,ios_out)

  END SUBROUTINE SUEWS_GetESTMData
  !======================================================================================


  !======================================================================================
  SUBROUTINE ESTM_initials

    ! Last modified HCW 30 Jun 2016 - reading in now done by SUEWS_GetESTMData subroutine.
    !                                 ESTM_initials now only runs once per run at the very start.
    ! Last modified HCW 15 Jun 2016 - code now reads in 5-min file (interpolation done beforehand, outside of SUEWS itself)

    USE defaultNotUsed
    USE PhysConstants, ONLY: c2k
    USE ESTM_data
    USE allocateArray
    USE data_in, ONLY: fileinputpath
    USE Initial, ONLY: numberofgrids

    IMPLICIT NONE

    !=====Read ESTMinput.nml================================
    NAMELIST/ESTMinput/TsurfChoice,&
         evolveTibld,              &
         ibldCHmod,                &
         LBC_soil,                 &
         THEAT_ON,                 &
         THEAT_OFF,                &
         THEAT_fix

    OPEN(511,file=TRIM(FileInputPath)//'ESTMinput.nml',status='old')
    READ(511,nml=ESTMinput)
    CLOSE(511)

    !Convert specified temperatures to Kelvin
    THEAT_ON=THEAT_ON+C2K
    THEAT_OFF=THEAT_OFF+C2K
    THEAT_fix=THEAT_fix+C2K

    ALLOCATE(Tair2_grids(NumberOfGrids))
    ALLOCATE(lup_ground_grids(NumberOfGrids))
    ALLOCATE(lup_wall_grids(NumberOfGrids))
    ALLOCATE(lup_roof_grids(NumberOfGrids))
    ALLOCATE(Tievolve_grids(NumberOfGrids))
    ALLOCATE(T0_ibld_grids(NumberOfGrids))
    ALLOCATE(T0_ground_grids(NumberOfGrids))
    ALLOCATE(T0_wall_grids(NumberOfGrids))
    ALLOCATE(T0_roof_grids(NumberOfGrids))
    ALLOCATE(TN_wall_grids(NumberOfGrids))
    ALLOCATE(TN_roof_grids(NumberOfGrids))

  END SUBROUTINE ESTM_initials
  !======================================================================================


  SUBROUTINE ESTM_translate(Gridiv)
    ! HCW 30 Jun 2016

    USE defaultNotUsed,ONLY: nan
    USE PhysConstants, ONLY: c2k, sbconst
    USE ESTM_data
    USE allocateArray
    USE gis_data, ONLY: bldgh
    USE Initial, ONLY: numberofgrids

    IMPLICIT NONE
    INTEGER :: i
    !REAL(KIND(1d0)) :: CFLval
    !REAL(KIND(1d0)) :: t5min
    REAL(KIND(1d0))::W,WB
    !CHARACTER (len=20)::FileCodeX
    !CHARACTER (len=150):: FileFinalTemp
    !LOGICAL:: inittemps=.FALSE.
    INTEGER:: ESTMStart=0
    INTEGER:: Gridiv

    !Set initial values at the start of each run for each grid
    IF(Gridiv == 1) ESTMStart = ESTMStart+1
    IF(ESTMStart==1) THEN

       !write(*,*) ' ESTMStart: ',ESTMStart, 'initialising ESTM for grid no. ', Gridiv

       TFLOOR=20.0 ! This is used only when radforce =T  !TODO:  should be put in the namelist
       TFLOOR=TFLOOR+C2K

       ! Initial values
       Tievolve=20.0 + C2K
       SHC_air=1230.0
       minshc_airbld=1300

       ! ---- Internal view factors ----
       !constant now but should be calculated in the future
       IVF_IW =   0.100000
       IVF_IR =   0.000000
       IVF_II =   0.900000
       IVF_IF =   0.000000
       IVF_WW =   0.050000
       IVF_WR =   0.000000
       IVF_WI =   0.950000
       IVF_WF =   0.000000
       IVF_RW =   0.050000
       IVF_RI =   0.950000
       IVF_RF =   0.000000
       IVF_FW =   0.050000
       IVF_FR =   0.000000
       IVF_FI =   0.950000

       Tair24HR=C2K

       !Ts5mindata(1,ncolsESTMdata) = -999
       ! !Fill Ts5mindata for current grid and met block - this is done in SUEWS_translate
       Ts5mindata(1,1:ncolsESTMdata) = ESTMForcingData(1,1:ncolsESTMdata,Gridiv)


       ! ---- Initialization of variables and parameters for first row of run for each grid ----
       ! N layers are calculated in SUEWS_translate
       IF ( .NOT. ALLOCATED(Tibld) ) THEN
          ! print*, "Nibld",Nibld
          ! print*, "Nwall",Nwall
          ! print*, "Nroof",Nroof
          ! print*, "Nground",Nground
          ALLOCATE(Tibld(Nibld),Twall(Nwall),Troof(Nroof),Tground(Nground),Tw_4(Nwall,4))
          ALLOCATE(Tibld_grids(Nibld,NumberOfGrids), &
               Twall_grids(Nwall,NumberOfGrids), &
               Troof_grids(Nroof,NumberOfGrids), &
               Tground_grids(Nground,NumberOfGrids), &
               Tw_4_grids(Nwall,4,NumberOfGrids))
       ENDIF

       ! Transfer variables from Ts5mindata to variable names
       ! N.B. column numbers here for the following file format - need to change if input columns change!
       ! dectime iy id it imin Tiair Tsurf Troof Troad Twall Twall_n Twall_e Twall_s Twall_w
       !        1  2  3  4    5     6     7     8     9     10      11      12      13       !new
       !
       ! Calculate temperature of each layer in Kelvin
       !  QUESTION: what if (Nground/Nwall/Nroof-1)==0? TS 21 Oct 2017
       DO i=1,Nground
          Tground(i)=(LBC_soil-Ts5mindata(1,cTs_Troad))*(i-1)/(Nground-1)+Ts5mindata(1,cTs_Troad)+C2K
       ENDDO
       DO i=1,Nwall
          Twall(i)=(Ts5mindata(1,cTs_Tiair)-Ts5mindata(1,cTs_Twall))*(i-1)/(Nwall-1)+Ts5mindata(1,cTs_Twall)+C2K
       ENDDO
       DO i=1,Nroof
          Troof(i)=(Ts5mindata(1,cTs_Tiair)-Ts5mindata(1,cTs_Troof))*(i-1)/(Nroof-1)+Ts5mindata(1,cTs_Troof)+C2K
       ENDDO
       Tibld(1:Nibld)=Ts5mindata(1,cTs_Tiair)+C2K

    ENDIF  !End of loop run only at start (for each grid)

    ! ---- Parameters related to land surface characteristics ----
    ! QUESTION: Would Zref=z be more appropriate?
    ZREF=2.0*BldgH      !!FO!! BldgH: mean bulding hight, zref: local scale reference height (local: ~ 10^2 x 10^2 -- 10^3 x 10^3 m^2)

    svf_ground=1.0
    svf_roof=1.0

    ! ==== roof (i.e. Bldgs)
    !froof=sfr(BldgSurf)   ! Moved to SUEWS_translate HCW 16 Jun 2016
    alb_roof=alb(BldgSurf)
    em_roof=emis(BldgSurf)

    ! ==== vegetation (i.e. EveTr, DecTr, Grass)
    !fveg=sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)  ! Moved to SUEWS_translate HCW 16 Jun 2016
    IF(fveg/=0) THEN
       alb_veg=(alb(ConifSurf)*sfr(ConifSurf) + alb(DecidSurf)*sfr(DecidSurf) + alb(GrassSurf)*sfr(GrassSurf))/fveg
       em_veg=(emis(ConifSurf)*sfr(ConifSurf) + emis(DecidSurf)*sfr(DecidSurf) + emis(GrassSurf)*sfr(GrassSurf))/fveg
    ELSE ! check fveg==0 scenario to avoid division-by-zero error, TS 21 Oct 2017
       alb_veg=NAN
       em_veg=NAN
    ENDIF

    ! ==== ground (i.e. Paved, EveTr, DecTr, Grass, BSoil, Water - all except Bldgs)
    !fground=sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)+sfr(PavSurf)+sfr(BsoilSurf)+sfr(WaterSurf) ! Moved to SUEWS_translate HCW 16 Jun 2016
    IF(fground/=0) THEN
       alb_ground=(alb(ConifSurf)*sfr(ConifSurf)+alb(DecidSurf)*sfr(DecidSurf)&
            +alb(GrassSurf)*sfr(GrassSurf)+alb(PavSurf)*sfr(PavSurf)&
            +alb(BsoilSurf)*sfr(BsoilSurf)+alb(WaterSurf)*sfr(WaterSurf))/fground
       em_ground=(emis(ConifSurf)*sfr(ConifSurf)+emis(DecidSurf)*sfr(DecidSurf)&
            +emis(GrassSurf)*sfr(GrassSurf)+emis(PavSurf)*sfr(PavSurf)&
            +emis(BsoilSurf)*sfr(BsoilSurf)+emis(WaterSurf)*sfr(WaterSurf))/fground
    ELSE ! check fground==0 scenario to avoid division-by-zero error, TS 21 Jul 2016
       alb_ground=NAN
       em_ground=NAN
    ENDIF

    IF(froof<1.0) THEN
       HW=fwall/(2.0*(1.0-froof))
    ELSE
       !  HW=0  !HCW if only roof, no ground
       HW=0.00001  ! to avoid zero-HW scenario TS 21 Oct 2017

    END IF
    HW=MAX(0.00001,HW)! to avoid zero-HW scenario TS 27 Oct 2017

    IF (Fground==1.0) THEN   !!FO!! if only ground, i.e. no houses
       W=1
       WB=0
       SVF_ground=1.
       zvf_WALL=0.
       SVF_WALL=0.
       SVF_ROOF=1.
       zvf_ground=0.
       xvf_wall=0.
       RVF_CANYON=1.
       RVF_ground=1.-FVEG
       RVF_ROOF=0
       RVF_WALL=0
       RVF_VEG=FVEG
    ELSE IF ( Fground==0.0 ) THEN !check fground==0 (or HW==0) scenario to avoid division-by-zero error, TS 21 Jul 2016
       ! the following values are calculated given HW=0
       W=0
       WB=1
       zvf_WALL= 0 !COS(ATAN(2/HW))  when HW=0                                 !!FO!! wall view factor for wall
       HW=0
       SVF_ground=MAX(COS(ATAN(2*HW)),0.00001)!!FO!! sky view factor for ground ! to avoid zero-division scenario TS 21 Oct 2017
       SVF_WALL=(1-zvf_WALL)/2                                                 !!FO!! sky view factor for wall
       zvf_ground=1-svf_ground                                                 !!FO!! wall view factor for ground
       xvf_wall=svf_wall                                                       !!FO!! ground view factor
       !   RVF_CANYON=COS(ATAN(2*ZREF/W))
       !   RVF_ROOF=1-RVF_CANYON
       !   RVF_WALL=(COS(ATAN(2*(ZREF-BldgH)/W))-RVF_CANYON)*RVF_CANYON
       !   RVF_ground=RVF_CANYON-RVF_WALL
       RVF_ground=(fground-fveg)*SVF_ground
       RVF_veg=fveg*SVF_ground
       RVF_ROOF=froof
       RVF_Wall=1-RVF_ROOF-RVF_ground-RVF_VEG
    ELSE
       W=BldgH/HW   !What about if HW = 0, need to add IF(Fground ==0) option ! fixed by setting a small number, TS 21 Oct 2017
       WB=W*SQRT(FROOF/Fground)
       SVF_ground=COS(ATAN(2*HW))                                              !!FO!! sky view factor for ground
       zvf_WALL=COS(ATAN(2/HW))                                                !!FO!! wall view factor for wall
       SVF_WALL=(1-zvf_WALL)/2                                                 !!FO!! sky view factor for wall
       zvf_ground=1-svf_ground                                                 !!FO!! wall view factor for ground
       xvf_wall=svf_wall                                                       !!FO!! ground view factor
       !   RVF_CANYON=COS(ATAN(2*ZREF/W))
       !   RVF_ROOF=1-RVF_CANYON
       !   RVF_WALL=(COS(ATAN(2*(ZREF-BldgH)/W))-RVF_CANYON)*RVF_CANYON
       !   RVF_ground=RVF_CANYON-RVF_WALL
       RVF_ground=(fground-fveg)*SVF_ground
       RVF_veg=fveg*SVF_ground
       RVF_ROOF=froof
       RVF_Wall=1-RVF_ROOF-RVF_ground-RVF_VEG
    ENDIF

    alb_avg=alb_ground*RVF_ground + alb_wall*RVF_WALL + alb_roof*RVF_ROOF + alb_veg*RVF_VEG

    sumalb=0.; nalb=0
    sumemis=0.; nemis=0

    !set emissivity for ceiling, wall and floor inside of buildings
    em_r = em_ibld; em_w=em_ibld; em_i=em_ibld; em_f=em_ibld

    !internal elements
    IF (nroom==0) THEN
       fibld = (FLOOR(BldgH/3.1-0.5)-1)*froof
    ELSE
       fibld = (2.-2./nroom)*fwall + (FLOOR(BldgH/3.1-0.5)-1)*froof
    ENDIF

    IF (fibld==0) fibld=0.00001 !this just ensures a solution to radiation
    finternal = froof+fibld+fwall
    IF (finternal==0) finternal=0.00001 ! to avoid zero-devision error TS 21 Oct 2017
    fair=zref-BldgH*froof
    IF (fair==0) fair=0.00001 ! to avoid zero-devision error TS 21 Oct 2017
    !ivf_ii=1.-ivf_iw-ivf_ir-ivf_if    !S.O. I do not know these are should be calculated or read from input files
    !ivf_ww=1.-ivf_wi-ivf_wr-ivf_wf
    !ivf_rw=1.-ivf_ri-ivf_rf;
    !ivf_fr=ivf_rf;

    IF ((ivf_ii+ivf_iw+ivf_ir+ivf_if > 1.0001) .OR. &
         (ivf_wi+ivf_ww+ivf_wr+ivf_wf > 1.0001) .OR. &
         (ivf_ri+ivf_rw+ivf_rf > 1.0001) .OR. &
         (ivf_fi+ivf_fw+ivf_fr > 1.0001) .OR. &
         (ivf_ii+ivf_iw+ivf_ir+ivf_if < 0.9999) .OR. &
         (ivf_wi+ivf_ww+ivf_wr+ivf_wf < 0.9999) .OR. &
         (ivf_ri+ivf_rw+ivf_rf < 0.9999) .OR. &
         (ivf_fi+ivf_fw+ivf_fr < 0.9999)) THEN
       PRINT*, "At least one internal view factor <> 1. Check ivf in ESTMinput.nml"
    ENDIF

    !=======Initial setting==============================================
    !! Rewritten by HCW 15 Jun 2016 to use existing SUEWS error handling
    !IF(inittemps) THEN
    !   write(*,*) 'inittemps:',inittemps
    !   FileFinalTemp=TRIM(FileOutputPath)//TRIM(FileCodeX)//'_ESTM_finaltemp.txt'
    !   OPEN(99,file=TRIM(FileFinalTemp),status='old',err=316)  ! Program stopped if error opening file
    !   READ(99,*) Twall,Troof,Tground,Tibld                    ! Twall, Troof, Tground & Tibld get new values
    !   CLOSE(99)
    !ENDIF
    !
    !!IF (inittemps) THEN                                                        !!FO!! inittemps=.true. set in nml file
    !!   OPEN(99,file='outputfiles/finaltemp.txt',status='old',iostat=ios)       !!FO!! has to exist
    !!
    !!   IF (ios/=0) CALL error('outputfiles/finaltemp.txt',ios,1)               !!FO!! calls mod_error.f95, writes that the opening failed and stops prg
    !!   IF (ios/=0) THEN
    !!      Twall   = (/273., 285., 291./)
    !!      Troof   = (/273., 285., 291./)
    !!      Tground = (/273., 275., 280., 290./)
    !!      Tibld   = (/293., 293., 293./)
    !!   ELSE
    !!      READ(99,*) Twall,Troof,Tground,Tibld                             !!FO!! if finaltemp.txt exists Twall[3], Troof[3], Tground[4] & Tibld[3] get new values
    !!      CLOSE(99)
    !!   ENDIF
    !!ENDIF

    !where (isnan(Twall))
    !    Twall = 273
    !endwhere
    !where (isnan(Troof))
    !    Troof = 273
    !endwhere
    !where (isnan(Tground))
    !    Tground = 281
    !endwhere
    !where (isnan(Tibld))
    !    Tibld = 293
    !endwhere

    IF(ESTMStart==1) THEN
       DO i=1,4
          Tw_4(:,i) = Twall  !!FO!! Tw_4 holds three differnet temp:s for each wall layer but the same set for all points of the compass
       ENDDO

       !initialize surface temperatures
       T0_ground=Tground(1)
       T0_wall=Twall(1)
       T0_roof=Troof(1)
       T0_ibld=Tibld(1)
       TN_roof=Troof(nroof)
       TN_wall=Twall(nwall)

       !initialize outgoing longwave   !QUESTION: HCW - Are these calculations compatible with those in LUMPS_NARP?
       LUP_ground=SBConst*EM_ground*T0_ground**4
       LUP_WALL=SBConst*EM_WALL*T0_WALL**4
       LUP_ROOF=SBConst*EM_ROOF*T0_ROOF**4

       !  PRINT*,"W,WB= ",W,WB
       !  PRINT*,'SVF_ground ','SVF_WALL ','zvf_WALL ','HW '
       !  PRINT*,SVF_ground,SVF_WALL,zvf_WALL,HW
       !  PRINT*,'RVF_ground ','RVF_WALL ','RVF_ROOF ','RVF_VEG'
       !  PRINT*,RVF_ground,RVF_WALL,RVF_ROOF,RVF_VEG
       !  print*,'Alb_avg (VF)=',alb_avg
       !  print*,'z0m, Zd', z0m, ZD


    ENDIF

    first=.TRUE.

    !======Courant-Friedrichs-Lewy condition=================================
    !This is comment out by S.O. for now
    ! NB: should be recovered for calculation stability, FO and TS, 11 Oct 2017
    !   CFLval = minval(0.5*zibld*zibld*ribld/kibld)   !!FO!! z*z*r/k => unit [s]
    !   if (Tstep>CFLval) then !CFL condition   !!FO!! CFL condition:  Courant�Friedrichs�Lewy condition is a necessary condition for convergence while solving
    !      write(*,*) "IBLD: CFL condition: Tstep=",Tstep,">",CFLval !!FO!! certain partial differential equations numerically by the method of finite differences (like eq 5 in Offerle et al.,2005)
    !      CFLfail=.TRUE.
    !   endif
    !   CFLval = minval(0.5*zroof*zroof*rroof/kroof)
    !   if (Tstep>CFLval) then !CFL condition
    !      write(*,*) "ROOF: CFL condition: Tstep=",Tstep,">",CFLval
    !      CFLfail=.TRUE.
    !   endif
    !   CFLval = minval(0.5*zwall*zwall*rwall/kwall)
    !   if (Tstep>CFLval) then !CFL condition
    !      write(*,*) "WALL: CFL condition: Tstep=",Tstep,">",CFLval
    !      CFLfail=.TRUE.
    !   endif
    !   CFLval = minval(0.5*zground*zground*rground/kground)
    !   if (Tstep>CFLval) then !CFL condition
    !      write(*,*) "ground: CFL condition: Tstep=",Tstep,">",CFLval
    !      CFLfail=.TRUE.
    !   endif
    !   if (CFLfail) then
    !      write(*,*) "Increase dX or decrease maxtimestep. Hit any key to continue"
    !      read (*,*)
    !   endif


    ! Tiaircyc = (1+(LondonQSJune_Barbican.Tair-Tiair)./(5*Tiair)).*(Tiair + 0.4*sin(LondonQSJune_Barbican.HOUR*2*pi/24-10/24*2*pi))    !!FO!! outdoor temp affected



    RETURN

    !     315 CALL errorHint(11,TRIM(fileESTMTs),notUsed,notUsed,NotUsedI)
    ! 316 CALL errorHint(11,TRIM(fileFinalTemp),notUsed,notUsed,NotUsedI)

  END SUBROUTINE ESTM_translate

  !===============================================================================
  SUBROUTINE ESTM(&
       Gridiv,&!input
       nsh,tstep,&
       avkdn, avu1, temp_c, zenith_deg, avrh, press_hpa, ldown,&
       bldgh,Ts5mindata_ir,&
       Tair24HR,&!inout
       dataOutLineESTM,QS)!output
    ! NB: HCW Questions:
    !                - should TFloor be set in namelist instead of hard-coded here?
    !                - zref used for radiation calculation and fair is set to 2*BldgH here. For compatibility with the rest of the
    !                  SUEWS model, should this be the (wind speed) measurement height z specified in RunControl.nml?
    !                - In SUEWS_translate, fwall=AreaWall/SurfaceArea. Is this correct?
    !                - If froof=1 (i.e. whole grid is building), is HW=0 correct?
    !                - Then is an IF(Fground ==0) option needed?
    !                - alb_wall=0.23 and em_wall=0.9 are set in LUMPS_module_constants. Shouldn't these be provided as input?
    !                - Do the LUP calculations here need to be compatible with those in LUMPS_NARP?
    !                - File opening rewritten using existing error handling in SUEWS - can delete mod_error module from SUEWS_ESTM_functions
    !                - In SUEWS_ESTM_v2016, the first row is set to -999. This may be acceptable at the
    !                  start of the run but should be handled properly between blocks of met data? - need to check what's actually happening here.
    !                - Many duplicate functions in SUEWS_ESTM_functions need changing to the existing SUEWS versions.
    !                - Are the following correctly initialised? T0_ibld, T0_ground, T0_wall, T0_roof, TN_wall, TN_roof, Tground, Twall, Troof, Tibld
    !                - What are Nalb, sumalb, Nemis and Sumemis for? Are they used correctly?
    !

    !SUEWS_ESTM_v2016
    ! revision:
    ! HCW 14 Jun 2016
    ! HCW 27 Jun 2016 Corrected iESTMcount bug - now increases for all grids together
    ! HCW 30 Jun 2016 Major changes to handle grids and met blocks
    ! TS  09 Oct 2017 Added explicit interface

    !Contains calculation for each time step
    !Calculate local scale heat storage from single building and surroundings observations
    !OFferle, May 2003
    !
    !MODIFICATION HISTORY
    !             15 DECEMBER 2003
    !             (1) CHANGED AIR EXCHANGE RATE TO ALSO BE DEPENDENT ON OUTSIDE AIR TEMPERATURE
    !             (2) ADDED SPECIFIC HEAT CALCULATION FOR AIR
    !             (3) RH ADDED AS VAR(14) IN INPUT FILE
    !  12 JANUARY 2004
    !             (1) ADDED ESTIMATED AVG NADIR LOOKING EXTERNAL SURFACE TEMPERATURE TO OUTPUT
    !                 WEIGHTED BY SURFACE FRACTION AND SVF. SVF_ROOF=1, SVF_WALLS = 1-SVF_ground
    !             (2) ADDED NET RADIATION (RN) CALCULATIONS FOR ALL SURFACES AND AVG RN TO OUTPUT BASED ON
    !                 RADIOMETER VIEW FROM ZREF
    !       14 JANUARY 2004
    !             (1) MOVED GRID SPECIFIC PARAMETERS OUT OF NAMELIST, INTO PARAMETER FILE E.G. ALB,EM,F
    !                 T0 MAKE CHANGES IN LOCATIONS EASIER.
    !
    !       23 JANUARY 2004 - Version 2
    !             (1) PUT ALL TEMPERATURES INTO K
    !             (2) added interpolation routine to run on shorter timesteps.
    !                 tested so that it doesn't change solution for forced temperatures.
    !                 however in version 2 the energy balance at the surface isn't correctly solved
    !
    !       25 JANUARY 2004 - Version 3
    !             (1) added solution to energy balance at surface
    !             (2) removed some extraneous code
    !             (3) added vegetation fractions for future development
    !             (4) some changes to input namelist.
    !             (5) need to add wind speed dependence for exchange coefficients
    !             (6) changed the way Rn_net is calculated. also radiometer view factor relationships
    !             (7) added a calculation for heat loss/gain to outside air (that going into building mass is storage)
    !                 this is labelled QFBLD which it is in a sense.
    !       6 FEBRUARY 2004
    !             (1) ADDED INTERNAL VIEW FACTOR FILE FOR INTERNAL GEOMETRY, INCLUDING FIXED FLOOR TEMPERATURE
    !             (2) added MeanU, MinWS to config, and U to ILOC.
    !
    !      11 FEBRUARY 2004
    !             (1) added site lat, long, elevation to inputs
    !             (2) need zenith angle for wall direct radiation interception
    !
    !      15 JUNE 2004
    !             (1) CORRECTED OUTPUT OF T0 FOR FORCED SURFACE TEMPERATURES
    !             (2) MADE SOME CHANGES TO RADIATION, COMPUTATION OF AVERAGE ALBEDO, ADDED AVERAGE EMISSIVITY
    !             (3) ADDED OUTPUT FILE FOR RADIATION COMPONENTS
    !             (4) CHANGED INPUT CONFIG SO CONVECTIVE EXCHANGE COEFFS ARE NOT USER SELECTABLE
    !             (5) MAY STILL BE PROBLEMS WITH WALL RADIATIVE EXCHANGE AND AVERAGE ALBEDO
    !             (6) CHANGED THE WAY HEAT STORAGE IS COMPUTED IN HEATCONDUCTION MODULE BUT THIS SHOULD NOT CHANGE RESULTS
    !
    !      16 NOVEMBER 2004
    !             (1) CHANGED AIR EXCHANGE RATE TO BE BASES ON DAILY TEMPERATURE CHANGES.
    !             (2) WRITES OUT FINAL LAYER TEMPERATURES AND INCLUDES OPTION TO READ AT BEGINNING.
    !
    !DESCRIPTION: uses explicit time differencing to compute heat conduction through roof, walls,
    !             internal mass, and grounds (elements). Air heat storage is computed from average air temperature
    !             Boundary conditions are determined by measured surface temperature(s) or computed
    !             from energy balance at the surface.
    !             Internal air temperature can either be fixed or allowed to evolve in response
    !             to air mass exchanges and convective heating from internal surfaces.
    !
    !INPUT:
    !FORCING DATA: DTIME,KDOWN,LDOWN,TSURF,TAIR_OUT,TAIR_IN,TROOF,TWALL_AVG,TWALL_N,TWALL_E,TWALL_S,TWALL_W,Tground,RH,U
    !NAMELIST    : HEATSTORAGE_vFO.NML
    !    &config
    !    ifile=FORCING DATA
    !    ofile=OUTPUT FILE
    !    pfile=HEAT STORAGE PARAMETER FILE
    !    Nibld = INTERNAL MASS LAYERS
    !    Nwall = EXTERNAL WALL LAYERS
    !    Nroof = ROOF LAYERS
    !    Nground = ground/SOIL LAYERS
    !    LBC_soil = LOWER BOUNDARY CONDITION FOR ground/SOIL
    !    iloc= INPUT COLUMNS IN DATA FILE
    !    evolveTibld= USE DIAGNOSTIC VALUE FOR INTERNAL BUILDING TEMPERATURE
    !                        0: don't use, use measured
    !                        1: TURN ON USE when temp goess ABOVE TINT_ON, off when temp is below TINT_OFF
    !                        2: always use diagnostic
    !    THEAT_ON= TEMPERATURE AT WHICH HEAT CONTROL IS TURNED ON
    !    THEAT_OFF= TEMPERATURE AT WHICH HEAT CONTROL IS TURNED OFF
    !       THEAT_FIX = Fixed internal temperature for climate control
    !    oneTsurf= USE SINGLE SURFACE TEMPERATURE TO DRIVE ALL LAYERS
    !    radforce= USE RADIATIVE ENERGY BALANCE TO DRIVE EXTERNAL TEMPERATURES
    !    maxtimestep=302, maximum time step in s for filling data gaps.
    !       Alt = STATION HEIGHT (m) FOR PRESSURE CALCULATION
    !       SPINUP = NUMBER OF LINES TO USE FOR SPINUP (REPEATS THESE LINES BUT ONLY OUTPUTS THE 2ND TIME)
    !    INITTEMP = if TRUE INITIALIZES TEMPERATURES TO THOSE IN FINALTEMP.TXT FILE
    !    CH_ibld = INTERNAL BUILDING CONVECTIVE EXCHANGE COEFFICIENT
    !       **** THESE SHOULD DEPEND ON WIND SPEED BUT CURRENTLY DO NOT ****
    !       CHAIR = CONVECTIVE EXCHANGE COEFFICIENT FOR ROOF
    !       chair_ground = ... FOR ground
    !       chair_wall = ... FOR WALL
    !    /
    ! ***************** PARAMETER FILE VARIABLES
    !               fveg = FRACTION OF ground SURFACE COVERED WITH VEG
    !               zveg = VEGETATION HEIGHT
    !               alb_veg = VEGETATION ALBEDO
    !               em_veg = VEGETATION EMISSIVITY
    !               ZREF = REFERENCE HEIGHT FOR FLUX CALCULATION
    !               BldgH    = mean building height
    !               HW    = CANYON ASPECT RATION
    !               f_X   = FRACTION OF X WHERE X IS INTERNAL, WALL, ROOF, ground
    !               Alb_x = ALBEDO OF X
    !               em_ibld = EMISSIVITY OF X
    !               TX    = INITIAL LAYER TEMPERATURES
    !               zX    = LAYER THICKNESS
    !               kX    = LAYER THERMAL CONDUCTIVITY
    !               ribld = LAYER VOLUMETRIC HEAT CAPACITY
    !
    !****************** INTERNAL VIEW FACTOR FILE
    !OUTPUT:      fixed format text with single header, heatstorage for all elements, and temperatures
    !             for each element-layer.
    !===============================================================================

    USE meteo, ONLY: pi, heatcapacity_air
    USE mod_solver
    USE modSolarCalc                                                        !!FO!! :modsolarcalc.f95
    USE MathConstants                                                       !!FO!! :MathConstants_module.f95
    USE PhysConstants
    USE heatflux
    USE ESTM_data

    IMPLICIT NONE
    INTEGER, PARAMETER:: ncolsESTMdata=13
    ! INTEGER, PARAMETER:: ncolumnsDataOutESTM=32
    INTEGER, PARAMETER:: cTs_Tiair = 5
    INTEGER, PARAMETER:: cTs_Tsurf = 6
    INTEGER, PARAMETER:: cTs_Troof = 7
    INTEGER, PARAMETER:: cTs_Troad = 8
    INTEGER, PARAMETER:: cTs_Twall = 9
    INTEGER, PARAMETER:: cTs_Twall_n = 10
    INTEGER, PARAMETER:: cTs_Twall_e = 11
    INTEGER, PARAMETER:: cTs_Twall_s = 12
    INTEGER, PARAMETER:: cTs_Twall_w = 13
    REAL(KIND(1d0)),PARAMETER::NAN=-999

    INTEGER,INTENT(in)::Gridiv
    INTEGER,INTENT(in)::nsh,tstep
    ! INTEGER,INTENT(in)::iy !Year
    ! INTEGER,INTENT(in)::id !Day of year
    ! INTEGER,INTENT(in)::it !Hour
    ! INTEGER,INTENT(in)::imin          !Minutes

    REAL(KIND(1d0)),INTENT(in)::avkdn
    REAL(KIND(1d0)),INTENT(in)::avu1
    REAL(KIND(1d0)),INTENT(in)::temp_c
    REAL(KIND(1d0)),INTENT(in)::zenith_deg
    REAL(KIND(1d0)),INTENT(in)::avrh
    REAL(KIND(1d0)),INTENT(in)::press_hpa
    REAL(KIND(1d0)),INTENT(in)::ldown
    REAL(KIND(1d0)),INTENT(in)::bldgh
    ! REAL(KIND(1d0)),INTENT(in):: dectime        !Decimal time
    REAL(KIND(1d0)),DIMENSION(ncolsESTMdata),INTENT(in)::  Ts5mindata_ir     !surface temperature input data
    REAL(KIND(1d0)),DIMENSION(24*nsh),INTENT(inout) ::   Tair24HR ! may be replaced with MetForcingData by extracting the Tiar part

    REAL(KIND(1d0)),DIMENSION(27),INTENT(out):: dataOutLineESTM
    !Output to SUEWS
    REAL(KIND(1d0)),INTENT(out)::QS
    !Input from SUEWS, corrected as Gridiv by TS 09 Jun 2016


    !Use only in this subroutine
    INTEGER::i, ii
    INTEGER:: Tair2Set=0
    REAL(KIND(1d0))::AIREXHR, AIREXDT
    REAL(KIND(1d0)),DIMENSION(2)::bc
    REAL(KIND(1d0))::chair_ground,chair_wall
    REAL(KIND(1d0))::EM_EQUIV
    REAL(KIND(1d0))::kdz
    REAL(KIND(1d0))::kup_estm,LUP_net,kdn_estm
    REAL(KIND(1d0))::QHestm
    REAL(KIND(1d0))::QFBld !Anthropogenic heat from HVAC
    REAL(KIND(1d0))::shc_airbld
    REAL(KIND(1d0))::sw_hor,sw_vert
    REAL(KIND(1d0))::T0
    REAL(KIND(1d0))::Tinternal,Tsurf_all,Troof_in,Troad,Twall_all,Tw_n,Tw_e,Tw_s,Tw_w
    REAL(KIND(1d0))::Twallout(5),Troofout(5),Tibldout(5),Tgroundout(5)
    REAL(KIND(1d0))::Tadd,Tveg
    REAL(KIND(1d0))::Tairmix
    REAL(KIND(1d0))::RN
    REAL(KIND(1d0))::Rs_roof,Rl_roof,RN_ROOF
    REAL(KIND(1d0))::Rs_wall,Rl_wall,RN_WALL
    REAL(KIND(1d0))::Rs_ground,Rl_ground,RN_ground
    REAL(KIND(1d0))::Rs_ibld,Rl_ibld
    REAL(KIND(1d0))::Rs_iroof,Rl_iroof
    REAL(KIND(1d0))::Rs_iwall,Rl_iwall
    REAL(KIND(1d0))::zenith_rad
    REAL(KIND(1d0))::dum(50)
    REAL(KIND(1d0))::bldgHX ! local bldgHX=max(bldgH,0.001)
    REAL(KIND(1d0)),PARAMETER::WSmin=0.1  ! Check why there is this condition. S.O.
    LOGICAL::radforce, groundradforce

    radforce       = .FALSE.
    groundradforce = .FALSE. !Close the radiation scheme in original ESTM S.O.O.

    bldgHX=MAX(bldgH,0.001) ! this is to prevent zero building height

    ! Set -999s for first row
    ! dum=(/-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,&
    !      -999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,&
    !      -999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,&
    !      -999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,&
    !      -999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999.,-999./)
    dum=[(-999,i=1,50)]

    !External bulk exchange coefficients - set these somewhere more sensible***
    CHR=0.005
    CHAIR=CHR
    CHAIR_ground=CHAIR
    CHAIR_WALL=CHAIR

    !Get met data for use in ESTM subroutine
    kdn_estm=avkdn
    WS=avu1
    IF (WS<WSMin) WS=WSmin
    Tair1=Temp_C+C2K
    ! Set initial value of Tair2 to air temp
    IF(Gridiv == 1) Tair2Set = Tair2Set+1
    IF(Tair2Set==1) THEN
       Tair2=Temp_C+C2K
    ELSE
       Tair2 = Tair2_grids(Gridiv)
       ! Also get other variables for this grid
       Tievolve = Tievolve_grids(Gridiv)
       lup_ground = lup_ground_grids(Gridiv)
       lup_wall = lup_wall_grids(Gridiv)
       lup_roof = lup_roof_grids(Gridiv)
       T0_ibld = T0_ibld_grids(Gridiv)
       T0_ground = T0_ground_grids(Gridiv)
       T0_wall = T0_wall_grids(Gridiv)
       T0_roof = T0_roof_grids(Gridiv)
       TN_wall = TN_wall_grids(Gridiv)
       TN_roof = TN_roof_grids(Gridiv)
       Tground(:) = Tground_grids(:,Gridiv)
       Twall(:) = Twall_grids(:,Gridiv)
       Troof(:) = Troof_grids(:,Gridiv)
       Tibld(:) = Tibld_grids(:,Gridiv)
       Tw_4 = Tw_4_grids(:,:,Gridiv)

    ENDIF

    ! Get Ts from Ts5min data array
    ! Tinternal  = Ts5mindata(ir,cTs_Tiair)
    ! Tsurf_all  = Ts5mindata(ir,cTs_Tsurf)
    ! Troof_in   = Ts5mindata(ir,cTs_Troof)
    ! Troad      = Ts5mindata(ir,cTs_Troad)
    ! Twall_all  = Ts5mindata(ir,cTs_Twall)
    !
    ! Tw_n       = Ts5mindata(ir,cTs_Twall_n)
    ! Tw_e       = Ts5mindata(ir,cTs_Twall_e)
    ! Tw_s       = Ts5mindata(ir,cTs_Twall_s)
    ! Tw_w       = Ts5mindata(ir,cTs_Twall_w)
    Tinternal  = Ts5mindata_ir(cTs_Tiair)
    Tsurf_all  = Ts5mindata_ir(cTs_Tsurf)
    Troof_in   = Ts5mindata_ir(cTs_Troof)
    Troad      = Ts5mindata_ir(cTs_Troad)
    Twall_all  = Ts5mindata_ir(cTs_Twall)

    Tw_n       = Ts5mindata_ir(cTs_Twall_n)
    Tw_e       = Ts5mindata_ir(cTs_Twall_e)
    Tw_s       = Ts5mindata_ir(cTs_Twall_s)
    Tw_w       = Ts5mindata_ir(cTs_Twall_w)

    !    if (any(isnan(Ts5mindata))) then                                    !!FO!! can't use data when time gap is too big (or neg.) or data is NaN
    !        if (spindone) then                                                  !!FO!! writes a line of NaNs
    !            write(20,'(1F8.4,I6,100f10.1)') dectime,it,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,&
    !                -0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,&
    !                -0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,&
    !                -0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.,-0./0.
    !        endif
    !        return ! changed from cycle            !!FO!! returns to beginning of do-loop, i.e. doesn't make any heat calculations
    !    endif
    !!FO!! this loop is used to run through the calculations (SPINUP number of times) to achieve better numerical stability
    !!FO!! when if condition is met the program starts over from the beginning of the input file and the calculations are performed
    !!FO!! ...once again, but this time saved to the output file
    !!FO!! it's because of this if statement arrangement that the output result starts at input time #2 (if not SPINUP=0 as originally in heatstorage_vFO.nml)
    !    IF (NLINESREAD>datalines.AND..NOT.SPINDONE) THEN                        !!FO!! at this stage spindone = .false.
    !        NLINESREAD=0
    !        SPINDONE=.TRUE.
    !PRINT*, "SPUNUP"
    !        return ! changed from cycle
    !    ENDIF

    !! Write first row of each met block as -999
    !IF (first) THEN  !Set to true in ESTM_initials
    !!   !Tair2=Temp_C+C2K !This is now set in SUEWS_translate for ir=0 only
    !!   ! first=.FALSE.
    !   IF(Gridiv == NumberOfGrids) first=.FALSE.  !Set to false only after all grids have run
    !   dataOutESTM(ir,1:32,Gridiv)=(/REAL(iy,KIND(1D0)),REAL(id,KIND(1D0)),&
    !        REAL(it,KIND(1D0)),REAL(imin,KIND(1D0)),dectime,(dum(ii),ii=1,27)/)
    !   RETURN
    !ENDIF

    ! What are these constants? - Need defining somewhere
    zenith_rad=zenith_deg/180*PI
    IF (zenith_rad>0.AND.zenith_rad<PI/2.-HW) THEN  !ZENITH MUST BE HIGHER THAN BUILDINGS FOR DIRECT INTERCEPTION
       tanzenith = MIN(TAN(zenith_rad),5.67) !LIMITS TO ANGLES LESS THAN 80 EVEN FOR LOW HW
       tanzenith = tanzenith*kdn_estm/(1370*COS(zenith_rad)) !REDUCTION FACTOR FOR MAXIMUM
    ELSE
       tanzenith = 0.
    ENDIF

    SHC_air=HEATCAPACITY_AIR(Tair1,avrh,Press_hPa)   ! Use SUEWS version
    Tair24HR=EOSHIFT(Tair24HR, 1, Tair1, 1) !!!*** NB: Check this. and is this the tair of past 24 hrs? TS 10 Oct 2017
    Tairday=SUM(Tair24HR)/(24*nsh)


    !Evolution of building temperature from heat added by convection
    SELECT CASE(evolvetibld)   !EvolveTiBld specifies which internal building temperature approach to use
    CASE(0)
       diagnoseTi=.FALSE.
       HVAC=.FALSE. !use data in file                                !!FO!! use measured indoor temperature (Tref in Lodz2002HS.txt)
    CASE(1)                                                                                   !!FO!! use of HVAC to counteract T changes
       diagnoseTi=.TRUE.
       IF (Tievolve>THEAT_OFF) THEN   !THEAT_OFF now converted to Kelvin in ESTM_initials - HCW 15 Jun 2016
          !IF (Tievolve>THEAT_OFF+C2K) THEN
          HVAC=.FALSE.
       ELSEIF (Tievolve<THEAT_ON) THEN   !THEAT_OFF now converted to Kelvin in ESTM_initials - HCW 15 Jun 2016
          !ELSEIF (Tievolve<THEAT_ON+C2K) THEN
          HVAC=.TRUE.
       ENDIF
    CASE(2)
       diagnoseTi=.TRUE.                                                                 !!FO!! convection between ibld and inside of external walls(?)
    END SELECT

    !ASSUME AIR MIXES IN PROPORTION TO # OF EXCHANGES
    IF (Tairday>20.+C2K.AND.Tievolve>25.+C2K.AND.TAIR1<Tievolve.AND..NOT.HVAC) THEN
       AIREXHR = 2.0  !Windows or exterior doors on 3 sides (ASHRAE 1981 22.8)
    ELSEIF (Tairday<17.+C2K.OR.HVAC) THEN
       AIREXHR = 0.5 !No window or exterior doors, storm sash or weathertripped (ASHRAE 1981 22.8)
    ELSE
       AIREXHR = 1.0
    ENDIF

    AIREXDT=AIREXHR*(Tstep/3600.0)
    shc_airbld=MAX(HEATCAPACITY_AIR(TiEVOLVE,avrh,Press_hPa),0.00001) ! to avoid zero-division scenario TS 21 Oct 2017
    IF (shc_airbld<minshc_airbld) minshc_airbld=shc_airbld

    !internal convective exchange coefficients                         !!FO!! ibldCHmod = 0 originally
    !iBldCHmod specifies method for convective exchange coeffs
    IF (ibldCHmod==1) THEN       !ASHRAE 2001
       CH_ibld  = 1.31*(ABS(T0_ibld-Tievolve))**0.25/shc_airbld
       CH_iwall = 1.31*(ABS(TN_wall-Tievolve))**0.25/shc_airbld
       CH_iroof = 1.52*(ABS(TN_roof-Tievolve))**0.25/shc_airbld
       IF (ABS(TN_roof-Tievolve)>0) CH_iroof=CH_iroof*0.39 !effect of convection is weaker downward
    ELSEIF (ibldCHmod==2) THEN   !Awbi, H.B. 1998, Energy and Buildings 28: 219-227
       CH_ibld  = 1.823*(ABS(T0_ibld-Tievolve))**0.293/shc_airbld
       CH_iwall = 1.823*(ABS(TN_wall-Tievolve))**0.293/shc_airbld
       CH_iroof = 2.175*(ABS(TN_roof-Tievolve))**0.308/shc_airbld
       IF (ABS(TN_roof-Tievolve)>0) CH_iroof=0.704*(ABS(TN_roof-Tievolve))**0.133/shc_airbld !effect of convection is weaker downward
    ENDIF

    !Evolving T = (Previous Temp + dT from Sensible heat flux) mixed with outside air
    !ASSUMES THE CH_BLD INCLUDES THE EFFECT OF VENTILATION RATE IN m/s (e.g. if a normal CH is .005 and
    !the value here is .003 the assumed ventilation is 0.6 m/s                                 !!FO!! CH_ibld=0.0015 from heatstorage_Barbican.nml => ventilation=0.3 m/s
    Tairmix =  (Tievolve + TAIR1*AIREXDT)/(1.0+AIREXDT)
    QFBld= froof*(Tievolve-Tairmix)*shc_airbld*bldgHX/Tstep !heat added or lost, requires cooling or heating if HVAC on

    !!FO!! CH_xxxx has unit [m/s]  !!**HCW what is going on with tstep here??
    Tievolve = Tairmix+Tstep/bldgHX/finternal* &                                                                         !!FO!! finternal(=froof+fibld+fwall) => normalisation of fractions
         (CH_ibld*fibld*(T0_ibld-Tievolve)+CH_iroof*froof*(TN_roof-Tievolve)+CH_iwall*fwall*(TN_wall-Tievolve))      !!FO!! [K] = [K] + [s/m]*([m/s]*([K]))

    IF (.NOT.diagnoseTi) Tievolve=Tinternal+C2K
    IF (HVAC) THEN !Run up/down to set point +/- 1 degree with adjustment of 90% per hour
       Tadd=(SIGN(-1.0d0,THEAT_fix-Tievolve)+THEAT_fix-Tievolve)*MIN(4.*Tstep/3600.0,0.9) !!**HCW check??
       Tievolve=Tievolve+Tadd
    ENDIF


    !========>RADIATION<================
    IF (kdn_estm<0) kdn_estm=0. !set non-zero shortwave to zero  !Should this be moved up to line 183/4?

    !external components, no diffuse
    !for reflections complete absorption is assumed
    !for shortwave these are net values
    !for longwave these are incoming only
    !MUST DIVIDE SHORTWAVE INTO DIRECT AND DIFFUSE
    sw_hor =kdn_estm           !incoming solar on horizontal surface
    sw_vert=kdn_estm*tanzenith !incoming solar on vertical surface = kdown(obs)*sin(zenith)/cos(zenith)

    Rs_roof=svf_roof*(1.0-alb_roof)*sw_hor
    Rl_roof=svf_roof*em_roof*ldown

    Rs_ground=svf_ground*(1.-alb_ground)*sw_hor+&
         zvf_ground*svf_wall*alb_wall*sw_vert*(1-alb_ground)+&
         zvf_ground*svf_ground*alb_ground*sw_hor*xvf_wall*alb_wall

    Rl_ground=svf_ground*ldown*em_ground+zvf_ground*(lup_wall+svf_wall*ldown*(1-em_wall))*em_ground

    Rs_wall=svf_wall*(1.-alb_wall)*sw_vert+&
         zvf_wall*svf_wall*alb_wall*sw_vert*(1.+zvf_wall*alb_wall)+&
         xvf_wall*svf_ground*alb_ground*sw_hor*(1-alb_wall)+&
         zvf_ground*xvf_wall*svf_ground*alb_ground*sw_hor*alb_wall

    !wall to wall exchange handled simultaneously with seb calc
    Rl_wall=svf_wall*ldown*em_wall+zvf_wall*svf_wall*ldown*(1-em_wall)*em_wall+&
         xvf_wall*(lup_ground+svf_ground*ldown*(1-em_ground))*em_wall

    !DIFFICULT TO DETERMINE WHAT THIS IS EXACTLY, DONT INCLUDE WALLS
    kup_estm=kdn_estm-RVF_ROOF*Rs_roof-(RVF_ground+RVF_WALL)*Rs_ground/svf_ground-RVF_VEG*ALB_VEG*kdn_estm
    IF (kdn_estm > 10 .AND. kup_estm > 0) THEN
       alb_avg = kup_estm/kdn_estm
       sumalb  = sumalb+alb_avg
       Nalb    = Nalb+1
    ENDIF


    !internal components
    Rs_ibld=0 ! This could change if there are windows (need solar angles or wall svf * fraction glazing * transmissivity)
    !internal incoming longwave terms do not include the view factors for its own surface e.g. for ibld and walls
    !added floor view factors
    Rl_ibld=SBConst*(ivf_iw*em_w*TN_wall**4 +&
         ivf_ir*em_r*TN_roof**4 +&
         ivf_if*em_f*Tfloor**4)
    Rs_iwall=0
    Rl_iwall=SBConst*(ivf_wi*em_i*T0_ibld**4 +&
         ivf_wr*em_r*TN_roof**4 +&
         ivf_wf*em_f*Tfloor**4)
    Rs_iroof=0
    Rl_iroof=SBConst*(ivf_ri*em_i*T0_ibld**4 +&
         ivf_rw*em_w*TN_wall**4 +&
         ivf_rf*em_f*Tfloor**4)

    !========>INTERNAL<================
    bctype=.FALSE.
    kdz=2*kibld(1)/zibld(1)
    Pcoeff=(/em_ibld*SBConst*(1-ivf_ii*em_ibld),0.0d0,0.0d0,kdz+shc_airbld*CH_ibld,&
         -kdz*Tibld(1)-shc_airbld*CH_ibld*Tievolve-Rs_ibld-Rl_ibld/)
    T0_ibld=NewtonPolynomial(T0_ibld,Pcoeff,conv,maxiter)
    bc(1)=T0_ibld                                                       !!FO!! this leads to Tibld(1) = Tibld(3) , i.e. ...
    bc(2)=bc(1)                                                         !!FO!! temperature equal on both sides of inside wall
    CALL heatcond1d(Tibld,Qsibld,zibld(1:Nibld),REAL(Tstep,KIND(1d0)),kibld(1:Nibld),ribld(1:Nibld),bc,bctype)

    !========>WALLS<================
    bctype=.FALSE.
    kdz=2*kwall(nwall)/zwall(nwall)
    Pcoeff=(/em_ibld*SBConst*(1-ivf_ww*em_ibld),0.0d0,0.0d0,kdz+shc_airbld*CH_iwall,&
         -kdz*Twall(nwall)-shc_airbld*CH_iwall*Tievolve-Rs_iwall-Rl_iwall/)
    TN_wall=NewtonPolynomial(TN_wall,Pcoeff,conv,maxiter)
    bc(2)=TN_wall                                                       !!FO!! boundary condition #2 = inner surface Twall, originally from lodz_parms_ltm.txt or finaltemp.txt

    IF (TsurfChoice<2 .OR.radforce) THEN
       IF (radforce) THEN                                              !!FO!! 1st prio: radforce
          kdz=2*kwall(1)/zwall(1)
          Pcoeff=(/em_wall*SBConst*(1-zvf_wall*em_wall),0.0d0,0.0d0,kdz+shc_air*chair_wall*WS,&
               -kdz*Twall(1)-shc_air*chair_wall*WS*Tair1-Rs_wall-Rl_wall/)
          T0_wall=NewtonPolynomial(T0_wall,Pcoeff,conv,maxiter)
          bc(1)=T0_wall                                               !!FO!! boundary condition #1 = outer surface Twall, originally from lodz_parms_ltm.txt or finaltemp.txt
       ELSEIF (TsurfChoice==0) THEN
          bc(1)=Tsurf_all+C2K; T0_wall=bc(1)
       ELSEIF (TsurfChoice==1) THEN
          bc(1)=Twall_all+C2K; T0_wall=bc(1)
       ENDIF                                                           !!FO!! Tsoil in Lodz2002HS.txt NB => Lodz2002HS.txt doesn't work with onewall = TRUE

       CALL heatcond1d(Twall,Qswall,zwall(1:nwall),REAL(Tstep,KIND(1d0)),kwall(1:nwall),rwall(1:nwall),bc,bctype)     !!FO!! new set of Twalls are calculated from heat conduction through wall

    ELSEIF(TsurfChoice==2) THEN!SPECIAL FOR 4 WALLS
       T0_wall=0.
       DO i=1,4 !do 4 walls
          bc(1)=Tw_n+Tw_e+Tw_s+Tw_w+C2K; T0_wall=T0_wall+bc(1)
          CALL heatcond1d(Tw_4(:,i),Qs_4(i),zwall(1:nwall),REAL(Tstep,KIND(1d0)),kwall(1:nwall),rwall(1:nwall),bc,bctype)
       ENDDO
       !Take average of 4 wall values
       T0_wall=T0_wall/4.
       Qswall = SUM(Qs_4)/4.
       Twall = SUM(Tw_4,2)/4.
    ENDIF

    !========>ROOF<================
    bctype=.FALSE.
    kdz=2*kroof(nroof)/zroof(nroof)
    Pcoeff=(/em_ibld*SBConst,0.0d0,0.0d0,kdz+shc_airbld*CH_iroof,&
         -kdz*Troof(nroof)-shc_airbld*CH_iroof*Tievolve-Rs_iroof-Rl_iroof/)
    TN_roof=NewtonPolynomial(TN_roof,Pcoeff,conv,maxiter)
    bc(2)=TN_roof

    IF (radforce) THEN
       kdz=2*kroof(1)/zroof(1)
       Pcoeff=(/em_roof*SBConst,0.0d0,0.0d0,kdz+shc_air*chair*WS,&
            -kdz*Troof(1)-shc_air*chair*WS*Tair1-Rs_roof-Rl_roof/)
       T0_roof=NewtonPolynomial(T0_roof,Pcoeff,conv,maxiter)
       bc(1)=T0_roof
    ELSEIF (TsurfChoice==0) THEN
       bc(1)=Tsurf_all+C2K; T0_roof=bc(1)
    ELSE
       bc(1)=Troof_in+C2K; T0_roof=bc(1)
    ENDIF

    CALL heatcond1d(Troof,Qsroof,zroof(1:nroof),REAL(Tstep,KIND(1d0)),kroof(1:nroof),rroof(1:nroof),bc,bctype)


    !========>ground<================
    bctype=.FALSE.
    kdz=2*kground(1)/zground(1)

    IF (radforce.OR.groundradforce) THEN
       Pcoeff=(/em_ground*SBConst,0.0d0,0.0d0,kdz+shc_air*chair_ground*WS,&
            -kdz*Tground(1)-shc_air*chair_ground*WS*Tair1-Rs_ground-Rl_ground/)
       T0_ground=NewtonPolynomial(T0_ground,Pcoeff,conv,maxiter)
       bc(1)=T0_ground
    ELSEIF (TsurfChoice==0) THEN
       bc(1)=Tsurf_all+C2K; T0_ground=bc(1)
    ELSE
       bc(1)=Troad+C2K; T0_ground=bc(1)
    ENDIF

    bc(2)=LBC_soil+C2K
    !     bc(2)=0.; bctype(2)=.t.

    IF ( fground/=0. )   THEN   ! check fground==0 scenario to avoid division-by-zero error, TS 21 Jul 2016
       CALL heatcond1d(Tground,Qsground,zground(1:Nground),REAL(Tstep,KIND(1d0)),kground(1:Nground),rground(1:Nground),bc,bctype)
    ELSE
       Qsground=NAN
    END IF

    Qsair = fair*SHC_air*(Tair1-Tair2)/Tstep
    Qsibld = Qsibld*fibld
    Qswall = Qswall*fwall
    Qsroof = Qsroof*froof
    Qsground = Qsground*fground
    QS = Qsibld + Qswall + Qsroof + Qsground                              !!FO!! QSair not included; called QS in output file (column #10)


    !write(*,*) Qsair, QSibld, Qswall, Qsroof, Qsground, QS

    !========>Radiation<================
    !note that the LUP for individual components does not include reflected
    LUP_ground = SBConst*EM_ground*T0_ground**4
    LUP_WALL   = SBConst*EM_WALL*T0_WALL**4
    LUP_ROOF   = SBConst*EM_ROOF*T0_ROOF**4
    TVEG       = TAIR1
    LUP_VEG    = SBConst*EM_VEG*TVEG**4
    T0         = RVF_ground*T0_ground+RVF_WALL*T0_WALL+RVF_ROOF*T0_ROOF+RVF_VEG*TVEG
    LUP_net    = RVF_ground*LUP_ground+RVF_WALL*LUP_WALL+RVF_ROOF*LUP_ROOF+RVF_VEG*LUP_VEG
    EM_EQUIV   = LUP_net/(SBConst*T0**4) !!FO!! apparent emissivity of the atmosphere [cloudless sky: >� Ldown from gases in the lowest 100 m] calculated from surface at T0
    RN_ground  = rs_ground+rl_ground-lup_ground
    RN_ROOF    = rs_roof+rl_roof-lup_roof
    RN_WALL    = rs_wall+rl_wall-lup_wall*(1-zvf_wall*em_wall)
    RN         = kdn_estm-kup_estm+ldown*EM_EQUIV-lup_net !!FO!! average net radiation (at z > zref ????) = shortwave down - shortwave up + [longwave down * apparent emissivity] - longwave up
    QHestm     = (T0-Tair1)*CHair*SHC_air*WS
    sumemis    = sumemis+EM_EQUIV
    nemis      = nemis+1

    ! IF (SPINDONE) THEN                                                      !!FO!! only the last set of values in the time interpolation loop is written to file

    IF (Nwall<5)THEN
       Twallout  =(/Twall,(dum(ii),  ii=1,(5-Nwall))/)
    ELSE
       Twallout=Twall
    ENDIF

    IF (Nroof<5) THEN
       Troofout  =(/Troof,(dum(ii),  ii=1,(5-Nroof))/);
    ELSE
       Troofout=Troof
    ENDIF

    IF (Nground<5)THEN
       Tgroundout=(/Tground,(dum(ii),ii=1,(5-Nground))/)
    ELSE
       Tgroundout=Tground
    ENDIF

    IF (Nibld<5)THEN
       Tibldout  =(/Tibld,(dum(ii),  ii=1,(5-Nibld))/)
    ELSE
       Tibldout=Tibld
    ENDIF

    ! dataOutESTM(ir,1:ncolumnsDataOutESTM,Gridiv)=[&
    !      REAL(iy,KIND(1D0)),REAL(id,KIND(1D0)),REAL(it,KIND(1D0)),REAL(imin,KIND(1D0)), dectime,&!5
    !      QS,Qsair,Qswall,Qsroof,Qsground,Qsibld,&!11
    !      Twallout,Troofout,Tgroundout,Tibldout,Tievolve]!32 !NB. These all have 5 elements except Tievolve (1).
    dataOutLineESTM=[&
         QS,Qsair,Qswall,Qsroof,Qsground,Qsibld,&!6
         Twallout,Troofout,Tgroundout,Tibldout,Tievolve]!27 !NB. These all have 5 elements except Tievolve (1).
    ! set invalid values to nan
    dataOutLineESTM=set_nan(dataOutLineESTM)
    ! call r8vec_print(ncolumnsDataOutESTM-5,dataOutESTM(ir,6:ncolumnsDataOutESTM,Gridiv),'dataOutESTM')


    Tair2=Tair1

    ! Save variables for this grid
    Tair2_grids(Gridiv)=Tair1
    lup_ground_grids(Gridiv) = lup_ground
    lup_wall_grids(Gridiv) = lup_wall
    lup_roof_grids(Gridiv) = lup_roof
    Tievolve_grids(Gridiv) = Tievolve
    T0_ibld_grids(Gridiv) = T0_ibld
    T0_ground_grids(Gridiv) = T0_ground
    T0_wall_grids(Gridiv) = T0_wall
    T0_roof_grids(Gridiv) = T0_roof
    TN_wall_grids(Gridiv) = TN_wall
    TN_roof_grids(Gridiv) = TN_roof
    Tground_grids(:,Gridiv) = Tground(:)
    Twall_grids(:,Gridiv) = Twall(:)
    Troof_grids(:,Gridiv) = Troof(:)
    Tibld_grids(:,Gridiv) = Tibld(:)
    Tw_4_grids(:,:,Gridiv) = Tw_4(:,:)

  END SUBROUTINE ESTM

  !===============set variable of invalid value to NAN====================================
  ELEMENTAL FUNCTION set_nan(x) RESULT(xx)
    IMPLICIT NONE
    REAL(KIND(1d0)),PARAMETER::pNAN=9999
    REAL(KIND(1d0)),PARAMETER::NAN=-999
    REAL(KIND(1d0)),INTENT(in)::x
    REAL(KIND(1d0))::xx

    IF(ABS(x)>pNAN) THEN
       xx=NAN
    ELSE
       xx=x
    ENDIF

  END FUNCTION set_nan
  !========================================================================

END MODULE ESTM_module

MODULE ctrl_output
  !===========================================================================================
  ! generic output functions for SUEWS
  ! authors: Ting Sun (ting.sun@reading.ac.uk)
  !
  ! disclamier:
  !     This code employs the netCDF Fortran 90 API.
  !     Full documentation of the netCDF Fortran 90 API can be found at:
  !     https://www.unidata.ucar.edu/software/netcdf/netcdf-4/newdocs/netcdf-f90/
  !     Part of the work is under the help of examples provided by the documentation.
  !
  ! purpose:
  ! these subroutines write out the results of SUEWS in netCDF format.
  !
  !
  ! history:
  ! TS 20161209: initial version of netcdf function
  ! TS 20161213: standalise the txt2nc procedure
  ! TS 20170414: generic output procedures
  ! TS 20171016: added support for DailyState
  ! TS 20171017: combined txt and nc wrappers into one: reduced duplicate code at two places
  !===========================================================================================


  USE allocateArray
  ! USE cbl_module
  USE data_in
  ! USE defaultNotUsed
  ! USE ESTM_data
  USE gis_data
  ! USE initial
  USE sues_data
  USE time
  USE strings

  IMPLICIT NONE


  INTEGER :: n

  CHARACTER(len=10),PARAMETER:: & !Define useful formats here
       fy   = 'i0004,1X',& !4 digit integer for year
       ft   = 'i0004,1X',& !3 digit integer for id, it, imin
       fd   = 'f08.4,1X',& !3 digits + 4 dp for dectime
       f94  = 'f09.4,1X',& !standard output format: 4 dp + 4 digits
       f104 = 'f10.4,1X',& !standard output format: 4 dp + 5 digits
       f106 = 'f10.6,1X',& !standard output format: 6 dp + 3 digits
       f146 = 'f14.6,1X'   !standard output format: 6 dp + 7 digits

  CHARACTER(len= 1),PARAMETER:: & ! Define aggregation methods here
       aT = 'T',&   !time columns
       aA = 'A',&   !average
       aS = 'S',&   !sum
       aL = 'L'     !last value

  CHARACTER(len= 3):: itext

  ! define type: variable attributes
  TYPE varAttr
     CHARACTER(len = 15) :: header ! short name in headers
     CHARACTER(len = 12) :: unit   ! unit
     CHARACTER(len = 10) :: fmt    ! output format
     CHARACTER(len = 50) :: longNm ! long name for detailed description
     CHARACTER(len = 1)  :: aggreg ! aggregation method
     CHARACTER(len = 10) :: group  ! group: datetime, default, ESTM, Snow, etc.
     INTEGER             :: level  ! output priority level: 0 for highest (defualt output)
  END TYPE varAttr

  ! initialise valist
  TYPE(varAttr) :: varList(300)

  ! datetime:
  DATA(varList(n), n=1,5)/&
       varAttr('Year'    , 'YYYY' , fy , 'Year'         , aT , 'datetime' , 0),&
       varAttr('DOY'     , 'DOY'  , ft , 'Day of Year'  , aT , 'datetime' , 0),&
       varAttr('Hour'    , 'HH'   , ft , 'Hour'         , aT , 'datetime' , 0),&
       varAttr('Min'     , 'MM'   , ft , 'Minute'       , aT , 'datetime' , 0),&
       varAttr('Dectime' , '-'    , fd , 'Decimal time' , aT , 'datetime' , 0)&
       /

  ! defualt:
  DATA(varList(n), n=5+1,ncolumnsDataOutSUEWS)/&
       varAttr('Kdown'      , 'W m-2'        , f104 , 'Incoming shortwave radiation'                     , aA , 'SUEWS' , 0)     , &
       varAttr('Kup'        , 'W m-2'        , f104 , 'Outgoing shortwave radiation'                     , aA , 'SUEWS' , 0)     , &
       varAttr('Ldown'      , 'W m-2'        , f104 , 'Incoming longwave radiation'                      , aA , 'SUEWS' , 0)     , &
       varAttr('Lup'        , 'W m-2'        , f104 , 'Outgoing longwave radiation'                      , aA , 'SUEWS' , 0)     , &
       varAttr('Tsurf'      , 'degC'         , f104 , 'Bulk surface temperature'                         , aA , 'SUEWS' , 0)     , &
       varAttr('QN'         , 'W m-2'        , f104 , 'Net all-wave radiation'                           , aA , 'SUEWS' , 0)     , &
       varAttr('QF'         , 'W m-2'        , f104 , 'Anthropogenic heat flux'                          , aA , 'SUEWS' , 0)     , &
       varAttr('QS'         , 'W m-2'        , f104 , 'Net storage heat flux'                            , aA , 'SUEWS' , 0)     , &
       varAttr('QH'         , 'W m-2'        , f104 , 'Sensible heat flux'                               , aA , 'SUEWS' , 0)     , &
       varAttr('QE'         , 'W m-2'        , f104 , 'Latent heat flux'                                 , aA , 'SUEWS' , 0)     , &
       varAttr('QHlumps'    , 'W m-2'        , f104 , 'Sensible heat flux (using LUMPS)'                 , aA , 'SUEWS' , 1)     , &
       varAttr('QElumps'    , 'W m-2'        , f104 , 'Latent heat flux (using LUMPS)'                   , aA , 'SUEWS' , 1)     , &
       varAttr('QHresis'    , 'W m-2'        , f104 , 'Sensible heat flux (resistance method)'           , aA , 'SUEWS' , 1)     , &
       varAttr('Rain'       , 'mm'           , f106 , 'Rain'                                             , aS , 'SUEWS' , 0)     , &
       varAttr('Irr'        , 'mm'           , f106 , 'Irrigation'                                       , aS , 'SUEWS' , 0)     , &
       varAttr('Evap'       , 'mm'           , f106 , 'Evaporation'                                      , aS , 'SUEWS' , 0)     , &
       varAttr('RO'         , 'mm'           , f106 , 'Runoff'                                           , aS , 'SUEWS' , 0)     , &
       varAttr('TotCh'      , 'mm'           , f106 , 'Surface and soil moisture change'                 , aS , 'SUEWS' , 0)     , &
       varAttr('SurfCh'     , 'mm'           , f106 , 'Surface moisture change'                          , aS , 'SUEWS' , 0)     , &
       varAttr('State'      , 'mm'           , f104 , 'Surface Wetness State'                            , aL , 'SUEWS' , 0)     , &
       varAttr('NWtrState'  , 'mm'           , f106 , 'Surface wetness state (non-water surfaces)'       , aL , 'SUEWS' , 0)     , &
       varAttr('Drainage'   , 'mm'           , f106 , 'Drainage'                                         , aS , 'SUEWS' , 0)     , &
       varAttr('SMD'        , 'mm'           , f94  , 'Soil Moisture Deficit'                            , aL , 'SUEWS' , 0)     , &
       varAttr('FlowCh'     , 'mm'           , f104 , 'Additional flow into water body'                  , aS , 'SUEWS' , 1)     , &
       varAttr('AddWater'   , 'mm'           , f104 , 'Addtional water from other grids'                 , aS , 'SUEWS' , 1)     , &
       varAttr('ROSoil'     , 'mm'           , f106 , 'Runoff to soil'                                   , aS , 'SUEWS' , 1)     , &
       varAttr('ROPipe'     , 'mm'           , f106 , 'Runoff to pipes'                                  , aS , 'SUEWS' , 1)     , &
       varAttr('ROImp'      , 'mm'           , f106 , 'Runoff over impervious surfaces'                  , aS , 'SUEWS' , 1)     , &
       varAttr('ROVeg'      , 'mm'           , f106 , 'Runoff over vegetated surfaces'                   , aS , 'SUEWS' , 1)     , &
       varAttr('ROWater'    , 'mm'           , f106 , 'Runoff for water surface'                         , aS , 'SUEWS' , 1)     , &
       varAttr('WUInt'      , 'mm'           , f94  , 'InternalWaterUse'                                 , aS , 'SUEWS' , 1)     , &
       varAttr('WUEveTr'    , 'mm'           , f94  , 'Water use for evergreen trees'                    , aS , 'SUEWS' , 1)     , &
       varAttr('WUDecTr'    , 'mm'           , f94  , 'Water use for deciduous trees'                    , aS , 'SUEWS' , 1)     , &
       varAttr('WUGrass'    , 'mm'           , f94  , 'Water use for grass'                              , aS , 'SUEWS' , 1)     , &
       varAttr('SMDPaved'   , 'mm'           , f94  , 'Soil moisture deficit for paved surface'          , aL , 'SUEWS' , 1)     , &
       varAttr('SMDBldgs'   , 'mm'           , f94  , 'Soil moisture deficit for building surface'       , aL , 'SUEWS' , 1)     , &
       varAttr('SMDEveTr'   , 'mm'           , f94  , 'Soil moisture deficit for evergreen tree surface' , aL , 'SUEWS' , 1)     , &
       varAttr('SMDDecTr'   , 'mm'           , f94  , 'Soil moisture deficit for deciduous tree surface' , aL , 'SUEWS' , 1)     , &
       varAttr('SMDGrass'   , 'mm'           , f94  , 'Soil moisture deficit for grass surface'          , aL , 'SUEWS' , 1)     , &
       varAttr('SMDBSoil'   , 'mm'           , f94  , 'Soil moisture deficit for bare soil surface'      , aL , 'SUEWS' , 1)     , &
       varAttr('StPaved'    , 'mm'           , f94  , 'Surface wetness state for paved surface'          , aL , 'SUEWS' , 1)     , &
       varAttr('StBldgs'    , 'mm'           , f94  , 'Surface wetness state for building surface'       , aL , 'SUEWS' , 1)     , &
       varAttr('StEveTr'    , 'mm'           , f94  , 'Surface wetness state for evergreen tree surface' , aL , 'SUEWS' , 1)     , &
       varAttr('StDecTr'    , 'mm'           , f94  , 'Surface wetness state for deciduous tree surface' , aL , 'SUEWS' , 1)     , &
       varAttr('StGrass'    , 'mm'           , f94  , 'Surface wetness state for grass surface'          , aL , 'SUEWS' , 1)     , &
       varAttr('StBSoil'    , 'mm'           , f94  , 'Surface wetness state for bare soil surface'      , aL , 'SUEWS' , 1)     , &
       varAttr('StWater'    , 'mm'           , f104 , 'Surface wetness state for water surface'          , aL , 'SUEWS' , 1)     , &
       varAttr('Zenith'     , 'degree'       , f94  , 'Solar zenith angle'                               , aL , 'SUEWS' , 0)     , &
       varAttr('Azimuth'    , 'degree'       , f94  , 'Solar azimuth angle'                              , aL , 'SUEWS' , 0)     , &
       varAttr('AlbBulk'    , '1'            , f94  , 'Bulk albedo'                                      , aA , 'SUEWS' , 0)     , &
       varAttr('Fcld'       , '1'            , f94  , 'Cloud fraction'                                   , aA , 'SUEWS' , 0)     , &
       varAttr('LAI'        , 'm2 m-2'       , f94  , 'Leaf area index'                                  , aA , 'SUEWS' , 0)     , &
       varAttr('z0m'        , 'm'            , f94  , 'Roughness length for momentum'                    , aA , 'SUEWS' , 1)     , &
       varAttr('zdm'        , 'm'            , f94  , 'Zero-plane displacement height'                   , aA , 'SUEWS' , 1)     , &
       varAttr('UStar'      , 'm s-1'        , f94  , 'Friction velocity'                                , aA , 'SUEWS' , 0)     , &
       varAttr('Lob'        , 'm'            , f104 , 'Obukhov length'                                   , aA , 'SUEWS' , 0)     , &
       varAttr('RA'         , 's m-1'        , f104 , 'Aerodynamic resistance'                           , aA , 'SUEWS' , 1)     , &
       varAttr('RS'         , 's m-1'        , f104 , 'Surface resistance'                               , aA , 'SUEWS' , 1)     , &
       varAttr('Fc'         , 'umol m-2 s-1' , f94  , 'CO2 flux'                                         , aA , 'SUEWS' , 0)     , &
       varAttr('FcPhoto'    , 'umol m-2 s-1' , f94  , 'CO2 flux from photosynthesis'                     , aA , 'SUEWS' , 1)     , &
       varAttr('FcRespi'    , 'umol m-2 s-1' , f94  , 'CO2 flux from respiration'                        , aA , 'SUEWS' , 1)     , &
       varAttr('FcMetab'    , 'umol m-2 s-1' , f94  , 'CO2 flux from metabolism'                         , aA , 'SUEWS' , 1)     , &
       varAttr('FcTraff'    , 'umol m-2 s-1' , f94  , 'CO2 flux from traffic'                            , aA , 'SUEWS' , 1)     , &
       varAttr('FcBuild'    , 'umol m-2 s-1' , f94  , 'CO2 flux from buildings'                          , aA , 'SUEWS' , 1)     , &
       varAttr('QNSnowFr'   , 'W m-2'        , f94  , 'Net all-wave radiation for non-snow area'         , aA , 'SUEWS' , 2)     , &
       varAttr('QNSnow'     , 'W m-2'        , f94  , 'Net all-wave radiation for snow area'             , aA , 'SUEWS' , 2)     , &
       varAttr('AlbSnow'    , '-'            , f94  , 'Snow albedo'                                      , aA , 'SUEWS' , 2)     , &
       varAttr('QM'         , 'W m-2'        , f106 , 'Snow-related heat exchange'                       , aA , 'SUEWS' , 2)     , &
       varAttr('QMFreeze'   , 'W m-2'        , f106 , 'Internal energy change'                           , aA , 'SUEWS' , 2)     , &
       varAttr('QMRain'     , 'W m-2'        , f106 , 'Heat released by rain on snow'                    , aA , 'SUEWS' , 2)     , &
       varAttr('SWE'        , 'mm'           , f104 , 'Snow water equivalent'                            , aA , 'SUEWS' , 2)     , &
       varAttr('MeltWater'  , 'mm'           , f104 , 'Meltwater'                                        , aA , 'SUEWS' , 2)     , &
       varAttr('MeltWStore' , 'mm'           , f104 , 'Meltwater store'                                  , aA , 'SUEWS' , 2)     , &
       varAttr('SnowCh'     , 'mm'           , f104 , 'Change in snow pack'                              , aA , 'SUEWS' , 2)     , &
       varAttr('SnowRPaved' , 'mm'           , f94  , 'Snow removed from paved surface'                  , aS , 'SUEWS' , 2)     , &
       varAttr('SnowRBldg'  , 'mm'           , f94  , 'Snow removed from building surface'               , aS , 'SUEWS' , 2)     , &
       varAttr('Ts'         , 'degC'         , f94  , 'Skin temperature'                                 , aA , 'SUEWS' , 0)     , &
       varAttr('T2'         , 'degC'         , f94  , 'Air temperature at 2 m'                           , aA , 'SUEWS' , 0)     , &
       varAttr('Q2'         , 'g kg-1'       , f94  , 'Specific humidity at 2 m'                         , aA , 'SUEWS' , 0)     , &
       varAttr('U10'        , 'm s-1'        , f94  , 'Wind speed at 10 m'                               , aA , 'SUEWS' , 0)   &
       /

  ! SOLWEIG:
  DATA(varList(n), n=85+1,85+ncolumnsdataOutSOL-5)/&
       varAttr('azimuth'    , 'to_add' , f106 , 'azimuth'    , aA , 'SOLWEIG' , 0)  , &
       varAttr('altitude'   , 'to_add' , f106 , 'altitude'   , aA , 'SOLWEIG' , 0)  , &
       varAttr('GlobalRad'  , 'to_add' , f106 , 'GlobalRad'  , aA , 'SOLWEIG' , 0)  , &
       varAttr('DiffuseRad' , 'to_add' , f106 , 'DiffuseRad' , aA , 'SOLWEIG' , 0)  , &
       varAttr('DirectRad'  , 'to_add' , f106 , 'DirectRad'  , aA , 'SOLWEIG' , 0)  , &
       varAttr('Kdown2d'    , 'to_add' , f106 , 'Kdown2d'    , aA , 'SOLWEIG' , 0)  , &
       varAttr('Kup2d'      , 'to_add' , f106 , 'Kup2d'      , aA , 'SOLWEIG' , 0)  , &
       varAttr('Ksouth'     , 'to_add' , f106 , 'Ksouth'     , aA , 'SOLWEIG' , 0)  , &
       varAttr('Kwest'      , 'to_add' , f106 , 'Kwest'      , aA , 'SOLWEIG' , 0)  , &
       varAttr('Knorth'     , 'to_add' , f106 , 'Knorth'     , aA , 'SOLWEIG' , 0)  , &
       varAttr('Keast'      , 'to_add' , f106 , 'Keast'      , aA , 'SOLWEIG' , 0)  , &
       varAttr('Ldown2d'    , 'to_add' , f106 , 'Ldown2d'    , aA , 'SOLWEIG' , 0)  , &
       varAttr('Lup2d'      , 'to_add' , f106 , 'Lup2d'      , aA , 'SOLWEIG' , 0)  , &
       varAttr('Lsouth'     , 'to_add' , f106 , 'Lsouth'     , aA , 'SOLWEIG' , 0)  , &
       varAttr('Lwest'      , 'to_add' , f106 , 'Lwest'      , aA , 'SOLWEIG' , 0)  , &
       varAttr('Lnorth'     , 'to_add' , f106 , 'Lnorth'     , aA , 'SOLWEIG' , 0)  , &
       varAttr('Least'      , 'to_add' , f106 , 'Least'      , aA , 'SOLWEIG' , 0)  , &
       varAttr('Tmrt'       , 'to_add' , f106 , 'Tmrt'       , aA , 'SOLWEIG' , 0)  , &
       varAttr('I0'         , 'to_add' , f106 , 'I0'         , aA , 'SOLWEIG' , 0)  , &
       varAttr('CI'         , 'to_add' , f106 , 'CI'         , aA , 'SOLWEIG' , 0)  , &
       varAttr('gvf'        , 'to_add' , f106 , 'gvf'        , aA , 'SOLWEIG' , 0)  , &
       varAttr('shadow'     , 'to_add' , f106 , 'shadow'     , aA , 'SOLWEIG' , 0)  , &
       varAttr('svf'        , 'to_add' , f106 , 'svf'        , aA , 'SOLWEIG' , 0)  , &
       varAttr('svfbuveg'   , 'to_add' , f106 , 'svfbuveg'   , aA , 'SOLWEIG' , 0)  , &
       varAttr('Ta'         , 'to_add' , f106 , 'Ta'         , aA , 'SOLWEIG' , 0)  , &
       varAttr('Tg'         , 'to_add' , f106 , 'Tg'         , aA , 'SOLWEIG' , 0)&
       /

  ! BL:
  DATA(varList(n), n=111+1,111+ncolumnsdataOutBL-5)/&
       varAttr('z'         , 'to_add' , f104 , 'z'         , aA , 'BL' , 0)  , &
       varAttr('theta'     , 'to_add' , f104 , 'theta'     , aA , 'BL' , 0)  , &
       varAttr('q'         , 'to_add' , f104 , 'q'         , aA , 'BL' , 0)  , &
       varAttr('theta+'    , 'to_add' , f104 , 'theta+'    , aA , 'BL' , 0)  , &
       varAttr('q+'        , 'to_add' , f104 , 'q+'        , aA , 'BL' , 0)  , &
       varAttr('Temp_C'    , 'to_add' , f104 , 'Temp_C'    , aA , 'BL' , 0)  , &
       varAttr('rh'        , 'to_add' , f104 , 'rh'        , aA , 'BL' , 0)  , &
       varAttr('QH_use'    , 'to_add' , f104 , 'QH_use'    , aA , 'BL' , 0)  , &
       varAttr('QE_use'    , 'to_add' , f104 , 'QE_use'    , aA , 'BL' , 0)  , &
       varAttr('Press_hPa' , 'to_add' , f104 , 'Press_hPa' , aA , 'BL' , 0)  , &
       varAttr('avu1'      , 'to_add' , f104 , 'avu1'      , aA , 'BL' , 0)  , &
       varAttr('UStar'     , 'to_add' , f104 , 'UStar'     , aA , 'BL' , 0)  , &
       varAttr('avdens'    , 'to_add' , f104 , 'avdens'    , aA , 'BL' , 0)  , &
       varAttr('lv_J_kg'   , 'to_add' , f146 , 'lv_J_kg'   , aA , 'BL' , 0)  , &
       varAttr('avcp'      , 'to_add' , f104 , 'avcp'      , aA , 'BL' , 0)  , &
       varAttr('gamt'      , 'to_add' , f104 , 'gamt'      , aA , 'BL' , 0)  , &
       varAttr('gamq'      , 'to_add' , f104 , 'gamq'      , aA , 'BL' , 0)&
       /

  ! Snow:
  DATA(varList(n), n=128+1,128+ncolumnsDataOutSnow-5)/&
       varAttr('SWE_Paved'      , 'to_add' , f106 , 'SWE_Paved'      , aA , 'snow' , 0)  , &
       varAttr('SWE_Bldgs'      , 'to_add' , f106 , 'SWE_Bldgs'      , aA , 'snow' , 0)  , &
       varAttr('SWE_EveTr'      , 'to_add' , f106 , 'SWE_EveTr'      , aA , 'snow' , 0)  , &
       varAttr('SWE_DecTr'      , 'to_add' , f106 , 'SWE_DecTr'      , aA , 'snow' , 0)  , &
       varAttr('SWE_Grass'      , 'to_add' , f106 , 'SWE_Grass'      , aA , 'snow' , 0)  , &
       varAttr('SWE_BSoil'      , 'to_add' , f106 , 'SWE_BSoil'      , aA , 'snow' , 0)  , &
       varAttr('SWE_Water'      , 'to_add' , f106 , 'SWE_Water'      , aA , 'snow' , 0)  , &
       varAttr('Mw_Paved'       , 'to_add' , f106 , 'Mw_Paved'       , aA , 'snow' , 0)  , &
       varAttr('Mw_Bldgs'       , 'to_add' , f106 , 'Mw_Bldgs'       , aA , 'snow' , 0)  , &
       varAttr('Mw_EveTr'       , 'to_add' , f106 , 'Mw_EveTr'       , aA , 'snow' , 0)  , &
       varAttr('Mw_DecTr'       , 'to_add' , f106 , 'Mw_DecTr'       , aA , 'snow' , 0)  , &
       varAttr('Mw_Grass'       , 'to_add' , f106 , 'Mw_Grass'       , aA , 'snow' , 0)  , &
       varAttr('Mw_BSoil'       , 'to_add' , f106 , 'Mw_BSoil'       , aA , 'snow' , 0)  , &
       varAttr('Mw_Water'       , 'to_add' , f106 , 'Mw_Water'       , aA , 'snow' , 0)  , &
       varAttr('Qm_Paved'       , 'to_add' , f106 , 'Qm_Paved'       , aA , 'snow' , 0)  , &
       varAttr('Qm_Bldgs'       , 'to_add' , f106 , 'Qm_Bldgs'       , aA , 'snow' , 0)  , &
       varAttr('Qm_EveTr'       , 'to_add' , f106 , 'Qm_EveTr'       , aA , 'snow' , 0)  , &
       varAttr('Qm_DecTr'       , 'to_add' , f106 , 'Qm_DecTr'       , aA , 'snow' , 0)  , &
       varAttr('Qm_Grass'       , 'to_add' , f106 , 'Qm_Grass'       , aA , 'snow' , 0)  , &
       varAttr('Qm_BSoil'       , 'to_add' , f106 , 'Qm_BSoil'       , aA , 'snow' , 0)  , &
       varAttr('Qm_Water'       , 'to_add' , f106 , 'Qm_Water'       , aA , 'snow' , 0)  , &
       varAttr('Qa_Paved'       , 'to_add' , f106 , 'Qa_Paved'       , aA , 'snow' , 0)  , &
       varAttr('Qa_Bldgs'       , 'to_add' , f106 , 'Qa_Bldgs'       , aA , 'snow' , 0)  , &
       varAttr('Qa_EveTr'       , 'to_add' , f106 , 'Qa_EveTr'       , aA , 'snow' , 0)  , &
       varAttr('Qa_DecTr'       , 'to_add' , f106 , 'Qa_DecTr'       , aA , 'snow' , 0)  , &
       varAttr('Qa_Grass'       , 'to_add' , f106 , 'Qa_Grass'       , aA , 'snow' , 0)  , &
       varAttr('Qa_BSoil'       , 'to_add' , f106 , 'Qa_BSoil'       , aA , 'snow' , 0)  , &
       varAttr('Qa_Water'       , 'to_add' , f106 , 'Qa_Water'       , aA , 'snow' , 0)  , &
       varAttr('QmFr_Paved'     , 'to_add' , f106 , 'QmFr_Paved'     , aA , 'snow' , 0)  , &
       varAttr('QmFr_Bldgs'     , 'to_add' , f106 , 'QmFr_Bldgs'     , aA , 'snow' , 0)  , &
       varAttr('QmFr_EveTr'     , 'to_add' , f106 , 'QmFr_EveTr'     , aA , 'snow' , 0)  , &
       varAttr('QmFr_DecTr'     , 'to_add' , f106 , 'QmFr_DecTr'     , aA , 'snow' , 0)  , &
       varAttr('QmFr_Grass'     , 'to_add' , f106 , 'QmFr_Grass'     , aA , 'snow' , 0)  , &
       varAttr('QmFr_BSoil'     , 'to_add' , f106 , 'QmFr_BSoil'     , aA , 'snow' , 0)  , &
       varAttr('QmFr_Water'     , 'to_add' , f106 , 'QmFr_Water'     , aA , 'snow' , 0)  , &
       varAttr('fr_Paved'       , 'to_add' , f106 , 'fr_Paved'       , aA , 'snow' , 0)  , &
       varAttr('fr_Bldgs'       , 'to_add' , f106 , 'fr_Bldgs'       , aA , 'snow' , 0)  , &
       varAttr('fr_EveTr'       , 'to_add' , f106 , 'fr_EveTr'       , aA , 'snow' , 0)  , &
       varAttr('fr_DecTr'       , 'to_add' , f106 , 'fr_DecTr'       , aA , 'snow' , 0)  , &
       varAttr('fr_Grass'       , 'to_add' , f106 , 'fr_Grass'       , aA , 'snow' , 0)  , &
       varAttr('fr_BSoil'       , 'to_add' , f106 , 'fr_BSoil'       , aA , 'snow' , 0)  , &
       varAttr('RainSn_Paved'   , 'to_add' , f146 , 'RainSn_Paved'   , aA , 'snow' , 0)  , &
       varAttr('RainSn_Bldgs'   , 'to_add' , f146 , 'RainSn_Bldgs'   , aA , 'snow' , 0)  , &
       varAttr('RainSn_EveTr'   , 'to_add' , f146 , 'RainSn_EveTr'   , aA , 'snow' , 0)  , &
       varAttr('RainSn_DecTr'   , 'to_add' , f146 , 'RainSn_DecTr'   , aA , 'snow' , 0)  , &
       varAttr('RainSn_Grass'   , 'to_add' , f146 , 'RainSn_Grass'   , aA , 'snow' , 0)  , &
       varAttr('RainSn_BSoil'   , 'to_add' , f146 , 'RainSn_BSoil'   , aA , 'snow' , 0)  , &
       varAttr('RainSn_Water'   , 'to_add' , f146 , 'RainSn_Water'   , aA , 'snow' , 0)  , &
       varAttr('Qn_PavedSnow'   , 'to_add' , f146 , 'Qn_PavedSnow'   , aA , 'snow' , 0)  , &
       varAttr('Qn_BldgsSnow'   , 'to_add' , f146 , 'Qn_BldgsSnow'   , aA , 'snow' , 0)  , &
       varAttr('Qn_EveTrSnpw'   , 'to_add' , f146 , 'Qn_EveTrSnpw'   , aA , 'snow' , 0)  , &
       varAttr('Qn_DecTrSnow'   , 'to_add' , f146 , 'Qn_DecTrSnow'   , aA , 'snow' , 0)  , &
       varAttr('Qn_GrassSnpw'   , 'to_add' , f146 , 'Qn_GrassSnpw'   , aA , 'snow' , 0)  , &
       varAttr('Qn_BSoilSnow'   , 'to_add' , f146 , 'Qn_BSoilSnow'   , aA , 'snow' , 0)  , &
       varAttr('Qn_WaterSnow'   , 'to_add' , f146 , 'Qn_WaterSnow'   , aA , 'snow' , 0)  , &
       varAttr('kup_PavedSnow'  , 'to_add' , f146 , 'kup_PavedSnow'  , aA , 'snow' , 0)  , &
       varAttr('kup_BldgsSnow'  , 'to_add' , f146 , 'kup_BldgsSnow'  , aA , 'snow' , 0)  , &
       varAttr('kup_EveTrSnpw'  , 'to_add' , f146 , 'kup_EveTrSnpw'  , aA , 'snow' , 0)  , &
       varAttr('kup_DecTrSnow'  , 'to_add' , f146 , 'kup_DecTrSnow'  , aA , 'snow' , 0)  , &
       varAttr('kup_GrassSnpw'  , 'to_add' , f146 , 'kup_GrassSnpw'  , aA , 'snow' , 0)  , &
       varAttr('kup_BSoilSnow'  , 'to_add' , f146 , 'kup_BSoilSnow'  , aA , 'snow' , 0)  , &
       varAttr('kup_WaterSnow'  , 'to_add' , f146 , 'kup_WaterSnow'  , aA , 'snow' , 0)  , &
       varAttr('frMelt_Paved'   , 'to_add' , f146 , 'frMelt_Paved'   , aA , 'snow' , 0)  , &
       varAttr('frMelt_Bldgs'   , 'to_add' , f146 , 'frMelt_Bldgs'   , aA , 'snow' , 0)  , &
       varAttr('frMelt_EveTr'   , 'to_add' , f146 , 'frMelt_EveTr'   , aA , 'snow' , 0)  , &
       varAttr('frMelt_DecTr'   , 'to_add' , f146 , 'frMelt_DecTr'   , aA , 'snow' , 0)  , &
       varAttr('frMelt_Grass'   , 'to_add' , f146 , 'frMelt_Grass'   , aA , 'snow' , 0)  , &
       varAttr('frMelt_BSoil'   , 'to_add' , f146 , 'frMelt_BSoil'   , aA , 'snow' , 0)  , &
       varAttr('frMelt_Water'   , 'to_add' , f146 , 'frMelt_Water'   , aA , 'snow' , 0)  , &
       varAttr('MwStore_Paved'  , 'to_add' , f146 , 'MwStore_Paved'  , aA , 'snow' , 0)  , &
       varAttr('MwStore_Bldgs'  , 'to_add' , f146 , 'MwStore_Bldgs'  , aA , 'snow' , 0)  , &
       varAttr('MwStore_EveTr'  , 'to_add' , f146 , 'MwStore_EveTr'  , aA , 'snow' , 0)  , &
       varAttr('MwStore_DecTr'  , 'to_add' , f146 , 'MwStore_DecTr'  , aA , 'snow' , 0)  , &
       varAttr('MwStore_Grass'  , 'to_add' , f146 , 'MwStore_Grass'  , aA , 'snow' , 0)  , &
       varAttr('MwStore_BSoil'  , 'to_add' , f146 , 'MwStore_BSoil'  , aA , 'snow' , 0)  , &
       varAttr('MwStore_Water'  , 'to_add' , f146 , 'MwStore_Water'  , aA , 'snow' , 0)  , &
       varAttr('SnowDens_Paved' , 'to_add' , f146 , 'SnowDens_Paved' , aA , 'snow' , 0)  , &
       varAttr('SnowDens_Bldgs' , 'to_add' , f146 , 'SnowDens_Bldgs' , aA , 'snow' , 0)  , &
       varAttr('SnowDens_EveTr' , 'to_add' , f146 , 'SnowDens_EveTr' , aA , 'snow' , 0)  , &
       varAttr('SnowDens_DecTr' , 'to_add' , f146 , 'SnowDens_DecTr' , aA , 'snow' , 0)  , &
       varAttr('SnowDens_Grass' , 'to_add' , f146 , 'SnowDens_Grass' , aA , 'snow' , 0)  , &
       varAttr('SnowDens_BSoil' , 'to_add' , f146 , 'SnowDens_BSoil' , aA , 'snow' , 0)  , &
       varAttr('SnowDens_Water' , 'to_add' , f146 , 'SnowDens_Water' , aA , 'snow' , 0)  , &
       varAttr('Sd_Paved'       , 'to_add' , f106 , 'Sd_Paved'       , aA , 'snow' , 0)  , &
       varAttr('Sd_Bldgs'       , 'to_add' , f106 , 'Sd_Bldgs'       , aA , 'snow' , 0)  , &
       varAttr('Sd_EveTr'       , 'to_add' , f106 , 'Sd_EveTr'       , aA , 'snow' , 0)  , &
       varAttr('Sd_DecTr'       , 'to_add' , f106 , 'Sd_DecTr'       , aA , 'snow' , 0)  , &
       varAttr('Sd_Grass'       , 'to_add' , f106 , 'Sd_Grass'       , aA , 'snow' , 0)  , &
       varAttr('Sd_BSoil'       , 'to_add' , f106 , 'Sd_BSoil'       , aA , 'snow' , 0)  , &
       varAttr('Sd_Water'       , 'to_add' , f106 , 'Sd_Water'       , aA , 'snow' , 0)  , &
       varAttr('Tsnow_Paved'    , 'to_add' , f146 , 'Tsnow_Paved'    , aA , 'snow' , 0)  , &
       varAttr('Tsnow_Bldgs'    , 'to_add' , f146 , 'Tsnow_Bldgs'    , aA , 'snow' , 0)  , &
       varAttr('Tsnow_EveTr'    , 'to_add' , f146 , 'Tsnow_EveTr'    , aA , 'snow' , 0)  , &
       varAttr('Tsnow_DecTr'    , 'to_add' , f146 , 'Tsnow_DecTr'    , aA , 'snow' , 0)  , &
       varAttr('Tsnow_Grass'    , 'to_add' , f146 , 'Tsnow_Grass'    , aA , 'snow' , 0)  , &
       varAttr('Tsnow_BSoil'    , 'to_add' , f146 , 'Tsnow_BSoil'    , aA , 'snow' , 0)  , &
       varAttr('Tsnow_Water'    , 'to_add' , f146 , 'Tsnow_Water'    , aA , 'snow' , 0)&
       /

  ! ESTM:
  DATA(varList(n), n=225+1,225+ncolumnsDataOutESTM-5)/&
       varAttr('QS'       , 'W m-2' , f104 , 'Total Storage'                            , aA , 'ESTM' , 0) , &
       varAttr('QSAir'    , 'W m-2' , f104 , 'Storage air'                              , aA , 'ESTM' , 0) , &
       varAttr('QSWall'   , 'W m-2' , f104 , 'Storage Wall'                             , aA , 'ESTM' , 0) , &
       varAttr('QSRoof'   , 'W m-2' , f104 , 'Storage Roof'                             , aA , 'ESTM' , 0) , &
       varAttr('QSGround' , 'W m-2' , f104 , 'Storage Ground'                           , aA , 'ESTM' , 0) , &
       varAttr('QSIBld'   , 'W m-2' , f104 , 'Storage Internal building'                , aA , 'ESTM' , 0) , &
       varAttr('TWALL1'   , 'degK'  , f104 , 'Temperature in wall layer 1'              , aA , 'ESTM' , 0) , &
       varAttr('TWALL2'   , 'degK'  , f104 , 'Temperature in wall layer 2'              , aA , 'ESTM' , 0) , &
       varAttr('TWALL3'   , 'degK'  , f104 , 'Temperature in wall layer 3'              , aA , 'ESTM' , 0) , &
       varAttr('TWALL4'   , 'degK'  , f104 , 'Temperature in wall layer 4'              , aA , 'ESTM' , 0) , &
       varAttr('TWALL5'   , 'degK'  , f104 , 'Temperature in wall layer 5'              , aA , 'ESTM' , 0) , &
       varAttr('TROOF1'   , 'degK'  , f104 , 'Temperature in roof layer 1'              , aA , 'ESTM' , 0) , &
       varAttr('TROOF2'   , 'degK'  , f104 , 'Temperature in roof layer 2'              , aA , 'ESTM' , 0) , &
       varAttr('TROOF3'   , 'degK'  , f104 , 'Temperature in roof layer 3'              , aA , 'ESTM' , 0) , &
       varAttr('TROOF4'   , 'degK'  , f104 , 'Temperature in roof layer 4'              , aA , 'ESTM' , 0) , &
       varAttr('TROOF5'   , 'degK'  , f104 , 'Temperature in roof layer 5'              , aA , 'ESTM' , 0) , &
       varAttr('TGROUND1' , 'degK'  , f104 , 'Temperature in ground layer 1'            , aA , 'ESTM' , 0) , &
       varAttr('TGROUND2' , 'degK'  , f104 , 'Temperature in ground layer 2'            , aA , 'ESTM' , 0) , &
       varAttr('TGROUND3' , 'degK'  , f104 , 'Temperature in ground layer 3'            , aA , 'ESTM' , 0) , &
       varAttr('TGROUND4' , 'degK'  , f104 , 'Temperature in ground layer 4'            , aA , 'ESTM' , 0) , &
       varAttr('TGROUND5' , 'degK'  , f104 , 'Temperature in ground layer 5'            , aA , 'ESTM' , 0) , &
       varAttr('TiBLD1'   , 'degK'  , f104 , 'Temperature in internal building layer 1' , aA , 'ESTM' , 0) , &
       varAttr('TiBLD2'   , 'degK'  , f104 , 'Temperature in internal building layer 2' , aA , 'ESTM' , 0) , &
       varAttr('TiBLD3'   , 'degK'  , f104 , 'Temperature in internal building layer 3' , aA , 'ESTM' , 0) , &
       varAttr('TiBLD4'   , 'degK'  , f104 , 'Temperature in internal building layer 4' , aA , 'ESTM' , 0) , &
       varAttr('TiBLD5'   , 'degK'  , f104 , 'Temperature in internal building layer 5' , aA , 'ESTM' , 0) , &
       varAttr('TaBLD'    , 'degK'  , f104 , 'Indoor air temperature'                   , aA , 'ESTM' , 0) &
       /

  ! DailyState:
  DATA(varList(n), n=252+1,252+ncolumnsDataOutDailyState-5)/&
       varAttr('HDD1_h'     , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('HDD2_c'     , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('HDD3_Tmean' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('HDD4_T5d'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('P_day'      , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DaysSR'     , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('GDD1_g'     , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('GDD2_s'     , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('GDD3_Tmin'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('GDD4_Tmax'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('GDD5_DLHrs' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('LAI_EveTr'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('LAI_DecTr'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('LAI_Grass'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DecidCap'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('Porosity'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('AlbEveTr'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('AlbDecTr'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('AlbGrass'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_EveTr1'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_EveTr2'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_EveTr3'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_DecTr1'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_DecTr2'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_DecTr3'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_Grass1'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_Grass2'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('WU_Grass3'  , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('deltaLAI'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('LAIlumps'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('AlbSnow'    , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DSnowPvd'   , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DSnowBldgs' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DSnowEveTr' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DSnowDecTr' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DSnowGrass' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DSnowBSoil' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('DSnowWater' , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('a1'         , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('a2'         , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0), &
       varAttr('a3'         , 'to be added' , f104 , 'to be added' , aL , 'DailyState' , 0)  &
       /


CONTAINS
  ! main wrapper that handles both txt and nc files
  SUBROUTINE SUEWS_Output(irMax,iv,Gridiv,iyr)
    IMPLICIT NONE
    INTEGER,INTENT(in) :: irMax
    INTEGER,INTENT(in) ::iv,Gridiv,iyr

    INTEGER :: xx,err,outLevel,i
    TYPE(varAttr),DIMENSION(:),ALLOCATABLE::varListX
    CHARACTER(len=10) :: grpList0(6)
    CHARACTER(len=10),DIMENSION(:),ALLOCATABLE :: grpList
    LOGICAL :: grpCond(6)

    ! determine outLevel
    SELECT CASE (WriteOutOption)
    CASE (0) !all (not snow-related)
       outLevel=1
    CASE (1) !all plus snow-related
       outLevel=2
    CASE (2) !minimal output
       outLevel=0
    END SELECT


    ! determine groups to output
    ! TODO: needs to be smarter, automate this filtering
    grpList0(1)='SUEWS'
    grpList0(2)='SOLWEIG'
    grpList0(3)='BL'
    grpList0(4)='snow'
    grpList0(5)='ESTM'
    grpList0(6)='DailyState'
    grpCond=(/.TRUE.,&
         SOLWEIGpoi_out==1,&
         CBLuse>=1,&
         SnowUse>=1,&
         StorageHeatMethod==4 .OR. StorageHeatMethod==14,&
         .TRUE./)
    xx=COUNT(grpCond)

    ! PRINT*, grpList0,xx

    ALLOCATE(grpList(xx), stat=err)
    IF ( err/= 0) PRINT *, "grpList: Allocation request denied"

    grpList=PACK(grpList0, mask=grpCond)

    ! PRINT*, grpList,SIZE(grpList, dim=1)

    ! loop over all groups
    DO i = 1, SIZE(grpList),1
       !PRINT*, 'i',i
       xx=COUNT(varList%group == TRIM(grpList(i)), dim=1)
       !  PRINT*, 'number of variables:',xx, 'in group: ',grpList(i)
       !  print*, 'all group names: ',varList%group
       ALLOCATE(varListX(5+xx), stat=err)
       IF ( err/= 0) PRINT *, "varListX: Allocation request denied"
       ! datetime
       varListX(1:5)=varList(1:5)
       ! variable
       varListX(6:5+xx)=PACK(varList, mask=(varList%group == TRIM(grpList(i))))

       IF  (TRIM(varListX(SIZE(varListX))%group) /= 'DailyState') THEN
          ! all output arrays but DailyState
          ! all output frequency option:
          ! as forcing:
          IF ( ResolutionFilesOut == Tstep .OR. KeepTstepFilesOut == 1 ) THEN
                CALL SUEWS_Output_txt_grp(iv,irMax,iyr,varListX,Gridiv,outLevel,Tstep)

          ENDIF
          !  as specified ResolutionFilesOut:
          IF ( ResolutionFilesOut /= Tstep ) THEN
                CALL SUEWS_Output_txt_grp(iv,irMax,iyr,varListX,Gridiv,outLevel,ResolutionFilesOut)
          ENDIF
       ELSE
          !  DailyState array, which does not need aggregation
             CALL SUEWS_Output_txt_grp(iv,irMax,iyr,varListX,Gridiv,outLevel,Tstep)
       ENDIF

       IF (ALLOCATED(varListX)) DEALLOCATE(varListX, stat=err)
       IF ( err/= 0) PRINT *, "varListX: Deallocation request denied"
       !  PRINT*, 'i',i,'end'

    END DO
  END SUBROUTINE SUEWS_Output


  ! output wrapper function for one group
  SUBROUTINE SUEWS_Output_txt_grp(iv,irMax,iyr,varList,Gridiv,outLevel,outFreq_s)
    IMPLICIT NONE

    TYPE(varAttr),DIMENSION(:),INTENT(in)::varList
    INTEGER,INTENT(in) :: iv,irMax,iyr,Gridiv,outLevel,outFreq_s

    INTEGER :: err

    INTEGER,DIMENSION(:),ALLOCATABLE  ::id_seq ! id sequence as in the dataOutX/dataOutX_agg
    REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::dataOutX
    REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::dataOutX_agg

    IF (.NOT. ALLOCATED(dataOutX)) THEN
       ALLOCATE(dataOutX(irMax,SIZE(varList)), stat=err)
       IF ( err/= 0) PRINT *, "dataOutX: Allocation request denied"
    ENDIF

    ! determine dataOutX array according to variable group
    SELECT CASE (TRIM(varList(SIZE(varList))%group))
    CASE ('SUEWS') !default
       dataOutX=dataOutSUEWS(1:irMax,1:SIZE(varList),Gridiv)

    CASE ('SOLWEIG') !SOLWEIG
       ! todo: inconsistent data structure
       dataOutX=dataOutSOL(1:irMax,1:SIZE(varList),Gridiv)

    CASE ('BL') !BL
       dataOutX=dataOutBL(1:irMax,1:SIZE(varList),Gridiv)

    CASE ('snow')    !snow
       dataOutX=dataOutSnow(1:irMax,1:SIZE(varList),Gridiv)

    CASE ('ESTM')    !ESTM
       dataOutX=dataOutESTM(1:irMax,1:SIZE(varList),Gridiv)

    CASE ('DailyState')    !DailyState
       ! get correct day index
       CALL unique(INT(PACK(dataOutSUEWS(1:irMax,2,Gridiv),&
            mask=(dataOutSUEWS(1:irMax,3,Gridiv)==23 &
            .AND.dataOutSUEWS(1:irMax,4,Gridiv)==(nsh-1.)/nsh*60))),&
            id_seq)


       IF (ALLOCATED(dataOutX)) THEN
          DEALLOCATE(dataOutX)
          IF ( err/= 0) PRINT *, "dataOutX: Deallocation request denied"
       ENDIF

       IF (.NOT. ALLOCATED(dataOutX)) THEN
          ALLOCATE(dataOutX(SIZE(id_seq),SIZE(varList)), stat=err)
          IF ( err/= 0) PRINT *, "dataOutX: Allocation request denied"
       ENDIF

       dataOutX=dataOutDailyState(id_seq,1:SIZE(varList),Gridiv)
       ! print*, id_seq
       ! print*, dataOutDailyState(id_seq,1:SIZE(varList),Gridiv)
       ! print*, 1/(nsh-nsh)
    END SELECT

    ! aggregation:
    ! aggregation is done for every group but 'DailyState'
    IF  (TRIM(varList(SIZE(varList))%group) /= 'DailyState') THEN

       CALL SUEWS_Output_Agg(dataOutX_agg,dataOutX,varList,irMax,outFreq_s)
    ELSE
       IF (.NOT. ALLOCATED(dataOutX_agg)) THEN
          ALLOCATE(dataOutX_agg(SIZE(dataOutX, dim=1),SIZE(varList)), stat=err)
          IF ( err/= 0) PRINT *, ": Allocation request denied"
       ENDIF
       dataOutX_agg=dataOutX
    ENDIF

    ! output:
    ! initialise file when processing first metblock
    IF ( iv == 1 ) CALL SUEWS_Output_Init(dataOutX_agg,varList,iyr,Gridiv,outLevel)

    ! append the aggregated data to the specific txt file
    CALL SUEWS_Write_txt(dataOutX_agg,varList,iyr,Gridiv,outLevel)

  END SUBROUTINE SUEWS_Output_txt_grp

  ! initialise an output file with file name and headers
  SUBROUTINE SUEWS_Output_Init(dataOutX,varList,iyr,Gridiv,outLevel)
    IMPLICIT NONE
    REAL(KIND(1d0)),DIMENSION(:,:),INTENT(in)::dataOutX
    TYPE(varAttr),DIMENSION(:),INTENT(in)::varList
    INTEGER,INTENT(in) :: iyr,Gridiv,outLevel

    TYPE(varAttr),DIMENSION(:),ALLOCATABLE::varListSel
    INTEGER :: xx,err,fn,i,nargs
    CHARACTER(len=365) :: FileOut
    CHARACTER(len=3) :: itext
    CHARACTER(len=6) :: args(5)
    CHARACTER(len=16*SIZE(varList)) :: FormatOut
    CHARACTER(len=16) :: formatX
    CHARACTER(len=16), DIMENSION(:), ALLOCATABLE:: headerOut

    ! select variables to output
    xx=COUNT((varList%level<= outLevel), dim=1)
    WRITE(itext,'(i3)') xx
    ALLOCATE(varListSel(xx), stat=err)
    IF ( err/= 0) PRINT *, "varListSel: Allocation request denied"
    varListSel=PACK(varList, mask=(varList%level<= outLevel))

    ! generate file name
    CALL filename_gen(dataOutX,varList,iyr,Gridiv,FileOut)

    ! store right-aligned headers
    ALLOCATE(headerOut(xx), stat=err)
    IF ( err/= 0) PRINT *, "headerOut: Allocation request denied"

    ! create format string:
    DO i = 1, SIZE(varListSel)
       CALL parse(varListSel(i)%fmt,'if.,',args,nargs)
       formatX=ADJUSTL('(a'//TRIM(args(2))//',1x)')
       ! adjust headers to right-aligned
       WRITE(headerOut(i),formatX) ADJUSTR(TRIM(ADJUSTL(varListSel(i)%header)))
       IF ( i==1 ) THEN
          FormatOut=ADJUSTL(TRIM(formatX))
       ELSE
          FormatOut=TRIM(FormatOut)//' '//ADJUSTL(TRIM(formatX))
       END IF
    END DO
    FormatOut='('//TRIM(ADJUSTL(FormatOut))//')'

    ! create file
    fn=9
    OPEN(fn,file=TRIM(ADJUSTL(FileOut)),status='unknown')
    ! PRINT*, 'FileOut in SUEWS_Output_Init: ',FileOut

    ! write out headers
    WRITE(fn, FormatOut) headerOut
    CLOSE(fn)

    ! write out format file
    CALL formatFile_gen(dataOutX,varList,iyr,Gridiv,outLevel)

    ! clean up
    IF (ALLOCATED(varListSel)) DEALLOCATE(varListSel, stat=err)
    IF ( err/= 0) PRINT *, "varListSel: Deallocation request denied"
    IF (ALLOCATED(headerOut)) DEALLOCATE(headerOut, stat=err)
    IF ( err/= 0) PRINT *, "headerOut: Deallocation request denied"

  END SUBROUTINE SUEWS_Output_Init

  ! generate output format file
  SUBROUTINE formatFile_gen(dataOutX,varList,iyr,Gridiv,outLevel)
    IMPLICIT NONE
    REAL(KIND(1d0)),DIMENSION(:,:),INTENT(in)::dataOutX
    TYPE(varAttr),DIMENSION(:),INTENT(in)::varList
    INTEGER,INTENT(in) :: iyr,Gridiv,outLevel

    TYPE(varAttr),DIMENSION(:),ALLOCATABLE::varListSel
    INTEGER :: xx,err,fn,i
    CHARACTER(len=365) :: FileOut
    CHARACTER(len=50*300) :: str_cat
    CHARACTER(len=50) :: str_x=''
    CHARACTER(len=3) :: itext

    ! get filename
    CALL filename_gen(dataOutX,varList,iyr,Gridiv,FileOut,1)

    !select variables to output
    xx=COUNT((varList%level<= outLevel), dim=1)
    ALLOCATE(varListSel(xx), stat=err)
    IF ( err/= 0) PRINT *, "varListSel: Allocation request denied"
    varListSel=PACK(varList, mask=(varList%level<= outLevel))

    ! create file
    fn=9
    OPEN(fn,file=TRIM(ADJUSTL(FileOut)),status='unknown')

    ! write out format strings
    ! column number:
    str_cat=''
    DO i = 1, SIZE(varListSel)
       WRITE(itext,'(i3)') i
       IF ( i==1 ) THEN
          str_cat=TRIM(ADJUSTL(itext))
       ELSE
          str_cat=TRIM(str_cat)//';'//ADJUSTL(itext)
       ENDIF
    END DO
    WRITE(fn,'(a)') TRIM(str_cat)

    ! header:
    str_cat=''
    DO i = 1, SIZE(varListSel)
       str_x=varListSel(i)%header
       IF ( i==1 ) THEN
          str_cat=TRIM(ADJUSTL(str_x))
       ELSE
          str_cat=TRIM(str_cat)//';'//ADJUSTL(str_x)
       ENDIF
    END DO
    WRITE(fn,'(a)') TRIM(str_cat)

    ! long name:
    str_cat=''
    DO i = 1, SIZE(varListSel)
       str_x=varListSel(i)%longNm
       IF ( i==1 ) THEN
          str_cat=TRIM(ADJUSTL(str_x))
       ELSE
          str_cat=TRIM(str_cat)//';'//ADJUSTL(str_x)
       ENDIF
    END DO
    WRITE(fn,'(a)') TRIM(str_cat)

    ! unit:
    str_cat=''
    DO i = 1, SIZE(varListSel)
       str_x=varListSel(i)%unit
       IF ( i==1 ) THEN
          str_cat=TRIM(ADJUSTL(str_x))
       ELSE
          str_cat=TRIM(str_cat)//';'//ADJUSTL(str_x)
       ENDIF
    END DO
    WRITE(fn,'(a)') TRIM(str_cat)

    ! format:
    str_cat=''
    DO i = 1, SIZE(varListSel)
       str_x=varListSel(i)%fmt
       IF ( i==1 ) THEN
          str_cat=TRIM(ADJUSTL(str_x))
       ELSE
          str_cat=TRIM(str_cat)//';'//ADJUSTL(str_x)
       ENDIF
    END DO
    WRITE(fn,'(a)') TRIM(str_cat)

    ! aggregation method:
    str_cat=''
    DO i = 1, SIZE(varListSel)
       str_x=varListSel(i)%aggreg
       IF ( i==1 ) THEN
          str_cat=TRIM(ADJUSTL(str_x))
       ELSE
          str_cat=TRIM(str_cat)//';'//ADJUSTL(str_x)
       ENDIF
    END DO
    WRITE(fn,'(a)') TRIM(str_cat)

    ! close file
    CLOSE(fn)

    ! clean up
    IF (ALLOCATED(varListSel)) DEALLOCATE(varListSel, stat=err)
    IF ( err/= 0) PRINT *, "varListSel: Deallocation request denied"

  END SUBROUTINE formatFile_gen

  ! aggregate data to specified resolution
  SUBROUTINE SUEWS_Output_Agg(dataOut_agg,dataOutX,varList,irMax,outFreq_s)
    IMPLICIT NONE
    REAL(KIND(1d0)),DIMENSION(:,:),INTENT(in)::dataOutX
    TYPE(varAttr),DIMENSION(:),INTENT(in)::varList
    INTEGER,INTENT(in) :: irMax,outFreq_s
    REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE,INTENT(out)::dataOut_agg

    INTEGER ::  nlinesOut,i,j,x
    REAL(KIND(1d0))::dataOut_aggX(1:SIZE(varList))
    REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::dataOut_agg0
    nlinesOut=INT(nsh/(60.*60/outFreq_s))
    ! nGrid=SIZE(dataOutX, dim=3)

    ALLOCATE(dataOut_agg(INT(irMax/nlinesOut),SIZE(varList)))
    ALLOCATE(dataOut_agg0(nlinesOut,SIZE(varList)))


    DO i=nlinesOut,irMax,nlinesOut
       x=i/nlinesOut
       dataOut_agg0=dataOutX(i-nlinesOut+1:i,:)
       DO j = 1, SIZE(varList), 1
          ! aggregating different variables
          SELECT CASE (varList(j)%aggreg)
          CASE (aT) !time columns, aT
             dataOut_aggX(j)=dataOut_agg0(nlinesOut,j)
          CASE (aA) !average, aA
             dataOut_aggX(j)=SUM(dataOut_agg0(:,j))/nlinesOut
          CASE (aS) !sum, aS
             dataOut_aggX(j)=SUM(dataOut_agg0(:,j))
          CASE (aL) !last value, aL
             dataOut_aggX(j)=dataOut_agg0(nlinesOut,j)
          END SELECT

          IF ( Diagnose==1 .AND. i==irMax ) THEN
             ! IF ( i==irMax ) THEN
             PRINT*, 'raw data of ',j,':'
             PRINT*, dataOut_agg0(:,j)
             PRINT*, 'aggregated with method: ',varList(j)%aggreg
             PRINT*, dataOut_aggX(j)
             PRINT*, ''
          END IF
       END DO
       dataOut_agg(x,:)=dataOut_aggX
    END DO

  END SUBROUTINE SUEWS_Output_Agg


  ! append output data to the specific file at the specified outLevel
  SUBROUTINE SUEWS_Write_txt(dataOutX,varList,iyr,Gridiv,outLevel)
    IMPLICIT NONE
    REAL(KIND(1d0)),DIMENSION(:,:),INTENT(in)::dataOutX
    TYPE(varAttr),DIMENSION(:),INTENT(in)::varList
    INTEGER,INTENT(in) :: iyr,Gridiv,outLevel

    REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE::dataOutSel
    TYPE(varAttr),DIMENSION(:),ALLOCATABLE::varListSel
    CHARACTER(len=365) :: FileOut
    INTEGER :: fn,i,xx,err
    INTEGER :: sizeVarListSel,sizedataOutX
    CHARACTER(len=12*SIZE(varList)) :: FormatOut
    ! LOGICAL :: initQ_file
    FormatOut=''

    IF(Diagnose==1) WRITE(*,*) 'Writting data of group: ',varList(SIZE(varList))%group

    !select variables to output
    sizeVarListSel=COUNT((varList%level<= outLevel), dim=1)
    ALLOCATE(varListSel(sizeVarListSel), stat=err)
    IF ( err/= 0) PRINT *, "varListSel: Allocation request denied"
    varListSel=PACK(varList, mask=(varList%level<= outLevel))

    ! copy data accordingly
    sizedataOutX=SIZE(dataOutX, dim=1)
    ALLOCATE(dataOutSel(sizedataOutX,sizeVarListSel), stat=err)
    IF ( err/= 0) PRINT *, "dataOutSel: Allocation request denied"
    ! print*, SIZE(varList%level),PACK((/(i,i=1,SIZE(varList%level))/), varList%level <= outLevel)
    ! print*, irMax,shape(dataOutX)
    dataOutSel=dataOutX(:,PACK((/(i,i=1,SIZE(varList%level))/), varList%level <= outLevel))


    ! create format string:
    DO i = 1, sizeVarListSel
       ! PRINT*,''
       ! PRINT*,i
       ! PRINT*, LEN_TRIM(FormatOut),TRIM(FormatOut)
       ! PRINT*, LEN_TRIM(TRIM(FormatOut)//','),TRIM(FormatOut)//','
       IF ( i==1 ) THEN
          ! FormatOut=ADJUSTL(varListSel(i)%fmt)
          FormatOut=varListSel(i)%fmt
       ELSE

          ! FormatOut=TRIM(FormatOut)//','//ADJUSTL(varListSel(i)%fmt)
          FormatOut=TRIM(FormatOut)//','//TRIM(varListSel(i)%fmt)
       END IF
       ! PRINT*,''
       ! PRINT*,i
       ! PRINT*, 'FormatOut',FormatOut
    END DO
    FormatOut='('//TRIM(ADJUSTL(FormatOut))//')'

    ! get filename
    CALL filename_gen(dataOutSel,varListSel,iyr,Gridiv,FileOut)
    ! PRINT*, 'FileOut in SUEWS_Write_txt: ',FileOut

    ! test if FileOut has been initialised
    ! IF ( .NOT. initQ_file(FileOut) ) THEN
    !    CALL SUEWS_Output_Init(dataOutSel,varListSel,Gridiv,outLevel)
    ! END IF

    ! write out data
    fn=50
    OPEN(fn,file=TRIM(fileout),position='append')!,err=112)
    DO i=1,sizedataOutX
       ! PRINT*, 'Writting',i
       ! PRINT*, 'FormatOut',FormatOut
       ! PRINT*, dataOutSel(i,1:sizeVarListSel)
       WRITE(fn,FormatOut) &
            (INT(dataOutSel(i,xx)),xx=1,4),&
            (dataOutSel(i,xx),xx=5,sizeVarListSel)
    ENDDO
    CLOSE (fn)

    IF (ALLOCATED(varListSel)) DEALLOCATE(varListSel, stat=err)
    IF ( err/= 0) PRINT *, "varListSel: Deallocation request denied"

    IF (ALLOCATED(dataOutSel)) DEALLOCATE(dataOutSel, stat=err)
    IF ( err/= 0) PRINT *, "dataOutSel: Deallocation request denied"

  END SUBROUTINE SUEWS_Write_txt


  SUBROUTINE filename_gen(dataOutX,varList,iyr,Gridiv,FileOut,opt_fmt)
    USE datetime_module

    IMPLICIT NONE
    REAL(KIND(1d0)),DIMENSION(:,:),INTENT(in)::dataOutX ! to determine year & output frequency
    TYPE(varAttr),DIMENSION(:),INTENT(in)::varList ! to determine output group
    INTEGER,INTENT(in) :: iyr ! to determine year
    INTEGER,INTENT(in) :: Gridiv ! to determine grid name as in SiteSelect
    INTEGER,INTENT(in),OPTIONAL :: opt_fmt ! to determine if a format file
    CHARACTER(len=365),INTENT(out) :: FileOut ! the output file name

    CHARACTER(len=20):: str_out_min,str_grid,&
         str_date,str_year,str_DOY,str_grp,str_sfx
    INTEGER :: year_int,DOY_int,val_fmt,delta_t_min
    TYPE(datetime) :: dt1,dt2
    TYPE(timedelta) :: dt_x

    ! initialise with a default value
    val_fmt=-999

    IF( PRESENT(opt_fmt) ) val_fmt = opt_fmt

    ! PRINT*, varList(:)%header
    ! PRINT*, 'dataOutX(1)',dataOutX(1,:)

    ! date:
    DOY_int=INT(dataOutX(1,2))
    WRITE(str_DOY,'(i3.3)') DOY_int


    ! year for txt use specified value to avoid conflicts when crossing years
    year_int=iyr
    WRITE(str_year,'(i4)') year_int
    str_date='_'//TRIM(ADJUSTL(str_year))

    ! output frequency in minute:
    IF ( varList(6)%group == 'DailyState' ) THEN
       str_out_min='' ! ignore this for DailyState
    ELSE
       ! derive output frequency from output arrays
       ! dt_x=
       dt1=datetime(INT(dataOutX(1,1)), 1, 1)+&
            timedelta(days=INT(dataOutX(1,2)-1),&
            hours=INT(dataOutX(1,3)),&
            minutes=INT(dataOutX(1,4)))

       dt2=datetime(INT(dataOutX(2,1)), 1, 1)+&
            timedelta(days=INT(dataOutX(2,2)-1),&
            hours=INT(dataOutX(2,3)),&
            minutes=INT(dataOutX(2,4)))

       dt_x=dt2-dt1
       delta_t_min=INT(dt_x%total_seconds()/60)
       WRITE(str_out_min,'(i4)') delta_t_min
       str_out_min='_'//TRIM(ADJUSTL(str_out_min))
    ENDIF

    ! group: output type
    str_grp=varList(6)%group
    IF ( LEN(TRIM(str_grp)) > 0 ) str_grp='_'//TRIM(ADJUSTL(str_grp))

    ! grid name:
    WRITE(str_grid,'(i10)') GridIDmatrix(Gridiv)

    ! suffix:
    str_sfx='.txt'

    ! filename: fileout
    FileOut=TRIM(FileOutputPath)//&
         TRIM(FileCode)//&
         TRIM(ADJUSTL(str_grid))//&
         TRIM(ADJUSTL(str_date))//&
         TRIM(ADJUSTL(str_grp))//&
         TRIM(ADJUSTL(str_out_min))//&
         TRIM(ADJUSTL(str_sfx))

    ! filename: format
    IF ( val_fmt==1 ) THEN
       FileOut=TRIM(FileOutputPath)//&
            TRIM(FileCode)//&
            TRIM(ADJUSTL(str_grp))//&
            '_OutputFormat.txt'
    END IF


  END SUBROUTINE filename_gen


  SUBROUTINE unique(vec,vec_unique)
    ! Return only the unique values from vec.

    IMPLICIT NONE

    INTEGER,DIMENSION(:),INTENT(in) :: vec
    INTEGER,DIMENSION(:),ALLOCATABLE,INTENT(out) :: vec_unique

    INTEGER :: i,num
    LOGICAL,DIMENSION(SIZE(vec)) :: mask

    mask = .FALSE.

    DO i=1,SIZE(vec)

       !count the number of occurrences of this element:
       num = COUNT( vec(i)==vec )

       IF (num==1) THEN
          !there is only one, flag it:
          mask(i) = .TRUE.
       ELSE
          !flag this value only if it hasn't already been flagged:
          IF (.NOT. ANY(vec(i)==vec .AND. mask) ) mask(i) = .TRUE.
       END IF

    END DO

    !return only flagged elements:
    ALLOCATE( vec_unique(COUNT(mask)) )
    vec_unique = PACK( vec, mask )

    !if you also need it sorted, then do so.
    ! For example, with slatec routine:
    !call ISORT (vec_unique, [0], size(vec_unique), 1)

  END SUBROUTINE unique


  ! test if a txt file has been initialised
  LOGICAL FUNCTION initQ_file(FileName)
    IMPLICIT NONE
    CHARACTER(len=365),INTENT(in) :: FileName ! the output file name
    LOGICAL :: existQ
    CHARACTER(len=1000) :: longstring

    INQUIRE( file=TRIM(FileName), exist=existQ )
    IF ( existQ ) THEN
       OPEN(10,file=TRIM(FileName))
       READ(10,'(a)') longstring
       ! print*, 'longstring: ',longstring
       IF ( VERIFY(longstring,'Year')==0 ) initQ_file = .FALSE.
       CLOSE(unit=10)
    ELSE
       initQ_file = .FALSE.
    END IF

  END FUNCTION initQ_file



  !========================================================================================
  FUNCTION count_lines(filename) RESULT(nlines)
    ! count the number of valid lines in a file
    ! invalid line starting with -9

    !========================================================================================
    IMPLICIT NONE
    CHARACTER(len=*)    :: filename
    INTEGER             :: nlines
    INTEGER             :: io,iv

    OPEN(10,file=filename, iostat=io, status='old')

    ! if io error found, report iostat and exit
    IF (io/=0) THEN
       PRINT*, 'io', io, 'for', filename
       STOP 'Cannot open file! '
    ENDIF

    nlines = 0
    DO
       READ(10,*,iostat=io) iv
       IF (io < 0 .OR. iv ==-9) EXIT

       nlines = nlines + 1
    END DO
    CLOSE(10)
    nlines=nlines-1 ! skip header
  END FUNCTION count_lines

  SUBROUTINE output_name_n(i,name,group,aggreg)
    ! used by f2py module `SuPy` to handle output names
    IMPLICIT NONE
    ! the dimension is potentially incorrect,
    ! which should be consistent with that in output module
    INTEGER,INTENT(in) :: i
    CHARACTER(len = 15),INTENT(out) :: name,group,aggreg

    INTEGER :: nVar
    nVar=SIZE(varList, dim=1)
    IF ( i<nVar .AND.i>0  ) THEN
       name   = TRIM(varList(i)%header)
       group  = TRIM(varList(i)%group)
       aggreg = TRIM(varList(i)%aggreg)
    ELSE
       name   = ''
       group  = ''
       aggreg = ''
    END IF


  END SUBROUTINE output_name_n


  SUBROUTINE output_size(nVar)
    ! used by f2py module `SuPy` to get size of the output list
    IMPLICIT NONE
    ! the dimension is potentially incorrect,
    ! which should be consistent with that in output module
    INTEGER,INTENT(out) :: nVar

    nVar=SIZE(varList, dim=1)

  END SUBROUTINE output_size


  !===========================================================================!
  ! write the output of final SUEWS results in netCDF
  !   with spatial layout of QGIS convention
  ! the spatial matrix arranges successive rows down the page (i.e., north to south)
  !   and succesive columns across (i.e., west to east)
  ! the output file frequency is the same as metblocks in the main SUEWS loop
  !===========================================================================!


END MODULE ctrl_output

!========================================================================================
!> AnOHM: Analytical Objective Hysteresis Model
!> @author
!> Ting Sun, ting.sun@reading.ac.uk
!> @brief
!> calculate heat storage.
!> @ref model details refer to
!> https://doi.org/10.5194/gmd-2016-300
! history:
! 20160301: initial version
! 20170109: updated dqndt calculation in accordance with SUEWS_OHM.f95 (HCW)
! 20170810: revamped structure
! 20170825: improved Bowen calculation
!========================================================================================
MODULE AnOHM_module

  IMPLICIT NONE
CONTAINS

  !========================================================================================
  !> High level wrapper for AnOHM calculation
  !! @brief
  !! calculate heat storage based within AnOHM framework.
  !! @returns
  !! -# grid ensemble heat storage:
  !! QS = a1*(Q*)+a2*(dQ*/dt)+a3
  !! -# grid ensemble OHM coefficients: a1, a2 and a3
  SUBROUTINE AnOHM(&
       tstep,dt_since_start,&
       qn1,qn1_av,dqndt,qf,&
       MetForcingData_grid,moist_surf,&
       alb, emis, cpAnOHM, kkAnOHM, chAnOHM,&! input
       sfr,nsurf,EmissionsMethod,id,Gridiv,&
       a1,a2,a3,qs,deltaQi)! output

    IMPLICIT NONE
    INTEGER, INTENT(in) :: tstep          ! time step [s]
    INTEGER, INTENT(in) :: dt_since_start ! time since simulation starts [s]

    REAL(KIND(1d0)),INTENT(in),DIMENSION(:,:)::MetForcingData_grid !< met forcing array of grid

    REAL(KIND(1d0)),INTENT(in):: qn1               !< net all-wave radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: qf                !< anthropogenic heat flux [W m-2]
    REAL(KIND(1d0)),INTENT(in):: sfr(nsurf)        !< surface fraction (0-1) [-]
    REAL(KIND(1d0)),INTENT(in):: moist_surf(nsurf) !< non-dimensional surface wetness status (0-1) [-]

    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)::alb  !< albedo [-]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)::emis !< emissivity [-]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)::cpAnOHM   !< heat capacity [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)::kkAnOHM   !< thermal conductivity [W m-1 K-1]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)::chAnOHM   !< bulk transfer coef [J m-3 K-1]

    INTEGER,INTENT(in):: id                !< day of year [-]
    INTEGER,INTENT(in):: Gridiv            !< grid id [-]
    INTEGER,INTENT(in):: EmissionsMethod !< AnthropHeat option [-]
    INTEGER,INTENT(in):: nsurf             !< number of surfaces [-]
    ! INTEGER,INTENT(in):: nsh               !< number of timesteps in one hour [-]

    REAL(KIND(1d0)),INTENT(inout)::qn1_av
    REAL(KIND(1d0)),INTENT(inout)::dqndt  !Rate of change of net radiation [W m-2 h-1] at t-1


    ! REAL(KIND(1d0)),INTENT(inout)::qn1_store(nsh) !< stored qn1 [W m-2]
    ! REAL(KIND(1d0)),INTENT(inout)::qn1_av_store(2*nsh+1) !< average net radiation over previous hour [W m-2]

    REAL(KIND(1d0)),INTENT(out):: a1 !< AnOHM coefficients of grid [-]
    REAL(KIND(1d0)),INTENT(out):: a2 !< AnOHM coefficients of grid [h]
    REAL(KIND(1d0)),INTENT(out):: a3 !< AnOHM coefficients of grid [W m-2]
    REAL(KIND(1d0)),INTENT(out):: qs !< storage heat flux [W m-2]
    REAL(KIND(1d0)),INTENT(out):: deltaQi(nsurf) !< storage heat flux of snow surfaces

    INTEGER :: is,xid !< @var qn1 net all-wave radiation
    INTEGER,SAVE :: id_save ! store index of the valid day with enough data
    REAL(KIND(1d0)),PARAMETER::NotUsed=-55.5!< @var qn1 net all-wave radiation
    INTEGER,PARAMETER::notUsedI=-55!< @var qn1 net all-wave radiation
    LOGICAL :: idQ ! whether id contains enough data

    ! REAL(KIND(1d0))                  :: dqndt       !< rate of change of net radiation [W m-2 h-1] at t-2
    ! REAL(KIND(1d0))                  :: surfrac     !< surface fraction accounting for SnowFrac if appropriate
    REAL(KIND(1d0)),DIMENSION(nsurf) :: xa1,xa2,xa3 !< temporary AnOHM coefs.
    ! REAL(KIND(1d0))                  :: qn1_av      ! average net radiation over previous hour [W m-2]
    ! REAL(KIND(1d0))                  :: nsh_nna     ! number of timesteps per hour with non -999 values (used for spinup)

    ! initialize output variables
    xa1     = 0.1
    xa2     = 0.2
    xa3     = 10
    qs      = -999
    deltaQi = 0 ! NB: as snow part is not implemented within AnOHM yet, this is just a placeholder

    ! to test if the current met block contains enough data for AnOHM
    ! TODO: more robust selection should be implemented
    ! daylight hours >= 6
    idQ=COUNT(MetForcingData_grid(:,2)==id .AND. & ! day of year
         MetForcingData_grid(:,4)==0 .AND. & ! minutes
         MetForcingData_grid(:,15)>0) & ! Sd
         >= 6

    ! PRINT*, idQ
    IF ( idQ ) THEN
       ! given enough data, calculate coefficients of day `id`
       xid=id
       id_save=id ! store index of the valid day with enough data
    ELSE
       ! otherwise calculate coefficients of yesterday: `id-1`
       xid=id_save
    END IF

    DO is=1,nsurf
       !   call AnOHM to calculate the coefs.
       CALL AnOHM_coef(is,xid,Gridiv,MetForcingData_grid,moist_surf,EmissionsMethod,qf,& !input
            alb, emis, cpAnOHM, kkAnOHM, chAnOHM,&! input
            xa1(is),xa2(is),xa3(is))                         ! output
       ! print*, 'AnOHM_coef are: ',xa1,xa2,xa3
    ENDDO

    !   calculate the areally-weighted OHM coefficients
    a1=DOT_PRODUCT(xa1,sfr)
    a2=DOT_PRODUCT(xa2,sfr)
    a3=DOT_PRODUCT(xa3,sfr)


    !   Calculate radiation part ------------------------------------------------------------
    qs=-999          !qs  = Net storage heat flux  [W m-2]
    IF(qn1>-999) THEN   !qn1 = Net all-wave radiation [W m-2]

       ! Store instantaneous qn1 values for previous hour (qn1_store) and average (qn1_av)
       ! CALL OHM_dqndt_cal(nsh,qn1,qn1_store,qn1_av_store,dqndt)
       CALL OHM_dqndt_cal_X(tstep,dt_since_start,qn1_av,qn1,dqndt)

       ! Calculate net storage heat flux
       CALL OHM_QS_cal(qn1,dqndt,a1,a2,a3,qs)

    ELSE
       CALL ErrorHint(21,'SUEWS_AnOHM.f95: bad value for qn found during qs calculation.',qn1,NotUsed,notUsedI)
    ENDIF

  END SUBROUTINE AnOHM
  !========================================================================================

  !========================================================================================
  !> High level wrapper for AnOHM coefficients calculation
  !! @brief
  !! calculate OHM coefficients within AnOHM framework.
  !! @returns
  !! -# OHM coefficients of a given surface type: a1, a2 and a3
  SUBROUTINE AnOHM_coef(&
       sfc_typ,xid,xgrid,&!input
       MetForcingData_grid,moist,EmissionsMethod,qf,& !input
       alb, emis, cpAnOHM, kkAnOHM, chAnOHM,&! input
       xa1,xa2,xa3)                         ! output

    IMPLICIT NONE

    ! input
    INTEGER,INTENT(in):: sfc_typ           !< surface type [-]
    INTEGER,INTENT(in):: xid               !< day of year [-]
    INTEGER,INTENT(in):: xgrid             !< grid id [-]
    INTEGER,INTENT(in):: EmissionsMethod !< AnthropHeat option [-]

    REAL(KIND(1d0)),INTENT(in):: qf                !< anthropogenic heat flux [W m-2]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)   :: alb                 !< albedo [-]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)   :: emis                !< emissivity [-]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)   :: cpAnOHM                  !< heat capacity [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)   :: kkAnOHM                  !< thermal conductivity [W m-1 K-1]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)   :: chAnOHM                  !< bulk transfer coef [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:)   :: moist               !< surface wetness status [-]
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:,:) :: MetForcingData_grid !< met forcing array of grid

    ! output
    REAL(KIND(1d0)),INTENT(out) :: xa1 !< AnOHM coefficients of grid [-]
    REAL(KIND(1d0)),INTENT(out) :: xa2 !< AnOHM coefficients of grid [h]
    REAL(KIND(1d0)),INTENT(out) :: xa3 !< AnOHM coefficients of grid [W m-2]

    ! surface temperature related scales:
    REAL(KIND(1d0)):: ATs   !< daily amplitude of surface temperature [K]
    REAL(KIND(1d0)):: mTs   !< daily mean of surface temperature [K]
    REAL(KIND(1d0)):: gamma !< phase difference between Ts and Sd [rad]

    !   forcing scales
    REAL(KIND(1d0))::ASd,mSd,tSd !< solar radiation
    REAL(KIND(1d0))::ATa,mTa,tTa !< air temperature
    REAL(KIND(1d0))::tau         !< phase lag between Sd and Ta (Ta-Sd)
    REAL(KIND(1d0))::mWS,mWF,mAH !< mean values of WS, WF and AH


    !   forcings:
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::Sd   ! incoming solar radiation [W m-2]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::Ta   ! air temperature [degC]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::RH   ! relative humidity [%]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::pres ! air pressure [hPa]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::WS   ! wind speed [m s-1]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::WF   ! water flux density [m3 s-1 m-2]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::AH   ! anthropogenic heat [W m-2]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE::tHr  ! time [hr]

    !   sfc. properties:
    REAL(KIND(1d0)) ::xalb   ! albedo,
    REAL(KIND(1d0)) ::xemis  ! emissivity,
    REAL(KIND(1d0)) ::xcp    ! heat capacity,
    REAL(KIND(1d0)) ::xk     ! thermal conductivity,
    REAL(KIND(1d0)) ::xch    ! bulk transfer coef.
    REAL(KIND(1d0)) ::xBo    ! Bowen ratio
    REAL(KIND(1d0)) ::xeta   ! effective absorption coefficient
    REAL(KIND(1d0)) ::xmu    ! effective absorption fraction
    REAL(KIND(1d0)) ::xmoist ! surface wetness



    ! locally saved variables:
    ! if coefficients have been calculated, just reload them
    ! otherwise, do the calculation
    INTEGER,SAVE :: id_save,grid_save
    REAL(KIND(1d0)), SAVE:: coeff_grid_day(7,3)=-999.


    ! PRINT*, 'xid,id_save',xid,id_save
    ! PRINT*, 'xgrid,grid_save',xgrid,grid_save
    ! PRINT*, 'sfc_typ',sfc_typ
    ! PRINT*, 'coeff_grid_day',coeff_grid_day(sfc_typ,:)
    IF ( xid==id_save .AND. xgrid ==grid_save) THEN
       ! if coefficients have been calculated, just reload them
       !  print*, 'here no repetition'
       xa1=coeff_grid_day(sfc_typ,1)
       xa2=coeff_grid_day(sfc_typ,2)
       xa3=coeff_grid_day(sfc_typ,3)
    ELSE


       ! load forcing characteristics:
       CALL AnOHM_Fc(&
            xid,MetForcingData_grid,EmissionsMethod,qf,& ! input
            ASd,mSd,tSd,ATa,mTa,tTa,tau,mWS,mWF,mAH)    ! output

       ! load forcing variables:
       CALL AnOHM_FcLoad(&
            xid,MetForcingData_grid,EmissionsMethod,qf,& ! input
            Sd,Ta,RH,pres,WS,WF,AH,tHr)                 ! output

       ! load sfc. properties:
       xalb   = alb(sfc_typ)
       xemis  = emis(sfc_typ)
       xcp    = cpAnOHM(sfc_typ)
       xk     = kkAnOHM(sfc_typ)
       xch    = chAnOHM(sfc_typ)
       xmoist = moist(sfc_typ)

       !  PRINT*, 'xBo before:',xBo
       ! calculate Bowen ratio:
       CALL AnOHM_Bo_cal(&
            sfc_typ,&
            Sd,Ta,RH,pres,tHr,               & ! input: forcing
            ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH, & ! input: forcing
            xalb,xemis,xcp,xk,xch,xmoist,    & ! input: sfc properties
            tSd,                             & ! input: peaking time of Sd in hour
            xBo)                               ! output: Bowen ratio
       !  PRINT*, 'xBo after:',xBo

       !  calculate AnOHM coefficients
       SELECT CASE (sfc_typ)
       CASE (1:6) ! land surfaces
          CALL  AnOHM_coef_land_cal(&
               ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,& ! input: forcing
               xalb,xemis,xcp,xk,xch,xBo,      & ! input: sfc properties
               xa1,xa2,xa3,ATs,mTs,gamma)                    ! output: surface temperature related scales by AnOHM

       CASE (7) ! water surface
          ! NB:give fixed values for the moment
          xeta = 0.3
          xmu  = 0.2
          CALL  AnOHM_coef_water_cal(&
               ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,&   ! input: forcing
               xalb,xemis,xcp,xk,xch,xBo,xeta,xmu,&   ! input: sfc properties
               xa1,xa2,xa3,ATs,mTs,gamma)            ! output

          ! save variables for marking status as done
          id_save =xid
          grid_save=xgrid

       END SELECT
       ! save variables for reusing values of the same day
       coeff_grid_day(sfc_typ,:)=(/xa1,xa2,xa3/)
    END IF

  END SUBROUTINE AnOHM_coef
  !========================================================================================

  !========================================================================================
  !> calculate the surface temperature related parameters (ATs, mTs, gamma)
  !> based on forcings and sfc. conditions
  !> @return
  !> @b xTs surface temperature at local time
  SUBROUTINE AnOHM_xTs(&
       sfc_typ,& !input: surface type
       ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,&   ! input: forcing
       xalb,xemis,xcp,xk,xch,xBo,&   ! input: sfc properties
       tSd,& !input: peaking time of Sd in hour
       xTHr,&! input: time in hour
       xTs)! output: surface temperature

    IMPLICIT NONE
    ! input:
    INTEGER,INTENT(in):: sfc_typ !< surface type (land: 1-6, water: 7)

    ! input: forcing scales
    REAL(KIND(1d0)),INTENT(in):: ASd !< daily amplitude of solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: mSd !< daily mean solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: ATa !< daily amplitude of air temperature [K]
    REAL(KIND(1d0)),INTENT(in):: mTa !< daily mean air temperature [K]
    REAL(KIND(1d0)),INTENT(in):: tau !< phase lag between Sd and Ta (Ta-Sd) [rad]
    REAL(KIND(1d0)),INTENT(in):: mWS !< daily mean wind speed [m s-1]
    REAL(KIND(1d0)),INTENT(in):: mWF !< daily mean underground moisture flux [m3 s-1 m-2]
    REAL(KIND(1d0)),INTENT(in):: mAH !< daily mean anthropogenic heat flux [W m-2]

    ! input: sfc properties
    REAL(KIND(1d0)),INTENT(in):: xalb  !< albedo [-]
    REAL(KIND(1d0)),INTENT(in):: xemis !< emissivity [-]
    REAL(KIND(1d0)),INTENT(in):: xcp   !< heat capacity [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in):: xk    !< thermal conductivity [W m-1 K-1]
    REAL(KIND(1d0)),INTENT(in):: xch   !< bulk transfer coef [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in):: xBo   !< Bowen ratio [-]
    REAL(KIND(1d0)):: xeta  !< effective absorption fraction [-]
    REAL(KIND(1d0)):: xmu   !< effective absorption coefficient [m-1]

    ! input: temporal-related
    REAL(KIND(1d0)),INTENT(in):: tSd  !< local peaking time of Sd, hour
    REAL(KIND(1d0)),INTENT(in):: xTHr !< local time to calculate Ts, hour

    ! output:
    REAL(KIND(1d0)),INTENT(out) :: xTs !< surface temperature at xTHr(hr)

    !   local
    REAL(KIND(1d0)) :: &
         xa1,xa2,xa3,&!coefficients
         ATs,mTs,gamma !surface temperature related scales by AnOHM

    ! constant:
    REAL(KIND(1d0)), PARAMETER :: PI    = ATAN(1.0)*4      ! Pi
    REAL(KIND(1d0)), PARAMETER :: OMEGA = 2*Pi/(24*60*60)  ! augular velocity of Earth

    SELECT CASE (sfc_typ)
    CASE (1:6) ! land surfaces
       CALL  AnOHM_coef_land_cal(&
            ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,& ! input: forcing
            xalb,xemis,xcp,xk,xch,xBo,      & ! input: sfc properties
            xa1,xa2,xa3,ATs,mTs,gamma)                    ! output: surface temperature related scales by AnOHM


    CASE (7) ! water surface
       ! !   NB:give fixed values for the moment
       xeta  = 0.3
       xmu   = 0.2
       CALL  AnOHM_coef_water_cal(&
            ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,&   ! input: forcing
            xalb,xemis,xcp,xk,xch,xBo,xeta,xmu,&   ! input: sfc properties
            xa1,xa2,xa3,ATs,mTs,gamma)            ! output

    END SELECT

    ! for a local time xTHr (in hour):
    xTs=ATs*SIN(OMEGA*(xTHr-tSd+6)*3600-gamma)+mTs

  END SUBROUTINE AnOHM_xTs
  !========================================================================================

  !========================================================================================
  SUBROUTINE AnOHM_coef_land_cal(&
       ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,&   ! input: forcing
       xalb,xemis,xcp,xk,xch,xBo,&   ! input: sfc properties
       xa1,xa2,xa3,ATs,mTs,gamma)            ! output

    IMPLICIT NONE

    ! input: forcing scales
    REAL(KIND(1d0)),INTENT(in):: ASd !< daily amplitude of solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: mSd !< daily mean solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: ATa !< daily amplitude of air temperature [K]
    REAL(KIND(1d0)),INTENT(in):: mTa !< daily mean air temperature [K]
    REAL(KIND(1d0)),INTENT(in):: tau !< phase lag between Sd and Ta (Ta-Sd) [rad]
    REAL(KIND(1d0)),INTENT(in):: mWS !< daily mean wind speed [m s-1]
    REAL(KIND(1d0)),INTENT(in):: mWF !< daily mean underground moisture flux [m3 s-1 m-2]
    REAL(KIND(1d0)),INTENT(in):: mAH !< daily mean anthropogenic heat flux [W m-2]
    ! input: sfc properties
    REAL(KIND(1d0)),INTENT(in):: xalb  !< albedo [-]
    REAL(KIND(1d0)),INTENT(in):: xemis !< emissivity [-]
    REAL(KIND(1d0)),INTENT(in):: xcp   !< heat capacity [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in):: xk    !< thermal conductivity [W m-1 K-1]
    REAL(KIND(1d0)),INTENT(in):: xch   !< bulk transfer coef [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in):: xBo   !< Bowen ratio [-]

    ! output
    REAL(KIND(1d0)),INTENT(out) :: xa1   !< AnOHM coefficients of grid [-]
    REAL(KIND(1d0)),INTENT(out) :: xa2   !< AnOHM coefficients of grid [h]
    REAL(KIND(1d0)),INTENT(out) :: xa3   !< AnOHM coefficients of grid [W m-2]
    REAL(KIND(1d0)),INTENT(out) :: ATs   !< daily amplitude of surface temperature [K]
    REAL(KIND(1d0)),INTENT(out) :: mTs   !< daily mean of surface temperature [K]
    REAL(KIND(1d0)),INTENT(out) :: gamma !< phase difference between Ts and Sd [K]


    !   constant
    REAL(KIND(1d0)), PARAMETER :: SIGMA = 5.67e-8          ! Stefan-Boltzman
    REAL(KIND(1d0)), PARAMETER :: PI    = ATAN(1.0)*4      ! Pi
    REAL(KIND(1d0)), PARAMETER :: OMEGA = 2*Pi/(24*60*60)  ! augular velocity of Earth

    !   local variables:
    REAL(KIND(1d0)) :: beta              ! inverse Bowen ratio
    REAL(KIND(1d0)) :: f,fL,fT           ! energy redistribution factors
    REAL(KIND(1d0)) :: lambda            ! thermal diffusivity
    REAL(KIND(1d0)) :: delta,m,n         ! water flux related variables
    REAL(KIND(1d0)) :: ms,ns             ! m, n related
    REAL(KIND(1d0)) :: ceta,cphi         ! phase related temporary variables
    REAL(KIND(1d0)) :: eta,phi,xlag      ! phase related temporary variables
    REAL(KIND(1d0)) :: xx1,xx2,xx3,xchWS ! temporary use
    ! LOGICAL         :: flagGood = .TRUE. ! quality flag, T for good, F for bad



    !   give fixed values for test
    !   properties
    !   xalb  = .2
    !   xemis = .9
    !   xcp   = 1e6
    !   xk    = 1.2
    !   xch   = 4
    !   xBo    = 2
    !   forcings
    !   ASd = 400
    !   mSd = 100
    !   ATa = 23
    !   mTa = 23+C2K
    !   tau = PI/6
    !   WS  = 1
    !   AH  = 0
    !   Wf  = 0

    ! PRINT*, '********sfc_typ: ',sfc_typ,' start********'
    !   initialize flagGood as .TRUE.
    ! flagGood = .TRUE.
    ! PRINT*, flagGood

    !   calculate sfc properties related parameters:
    xchWS = xch*mWS

    !     xch    = CRA/RA !update bulk trsf. coeff. with RA (aerodyn. res.)
    IF ( ABS(xBo)<0.001 ) THEN
       beta   = 1/0.001
    ELSE
       beta   = 1/xBo
    END IF

    ! PRINT*, 'beta:', beta
    f      = ((1+beta)*xchWS+4*SIGMA*xemis*mTa**3)
    !     print*, 'xch',xch,'mTa',mTa,'dLu',4*SIGMA*xemis*mTa**3
    fL     = 4*SIGMA*xemis*mTa**3
    !     print*, 'fL',fL
    fT     = (1+beta)*xchWS
    !     print*, 'fT',fT
    lambda = xk/xcp
    !     print*, 'lambda',lambda
    delta  = SQRT(.5*(mWF**2+SQRT(mWF**4+16*lambda**2*OMEGA**2)))
    !     print*, 'delta',delta
    m      = (2*lambda)/(delta+mWF)
    n      = delta/OMEGA
    !     print*, 'm',m,'n',n


    !   calculate surface temperature related parameters:
    mTs   = (mSd*(1-xalb)/f)+mTa
    ms    = 1+xk/(f*m)
    ns    = xk/(f*n)
    !     print*, 'ms,ns:', ms,ns
    xx1   = f*SIN(tau)*ATa
    !     print*, 'xx1',xx1
    xx2   = (1-xalb)*ASd+f*COS(tau)*ATa
    !     print*, 'xx2',xx2
    gamma = ATAN(ns/ms)+ATAN(xx1/xx2)
    !     print*, 'gamma:', gamma
    ATs   = -(SIN(tau)*ATa)/(ns*COS(gamma)-ms*SIN(gamma))
    !     print*,  'ATs:', ATs

    !   calculate net radiation related parameters:
    xx1  = (ns*COS(gamma)+SIN(gamma)-ms*SIN(gamma))*SIN(tau)*ATa*fL
    xx2  = (xalb-1)*(ns*COS(gamma)-ms*SIN(gamma))*ASd
    xx3  = (-ms*COS(tau)*SIN(tau)+COS(gamma)*(ns*COS(tau)+SIN(tau)))*ATa*fL
    xx2  = xx2-xx3
    phi  = ATAN(xx1/xx2)
    xx3  = (ns*COS(gamma)-ms*SIN(gamma))
    xx1  = (1+SIN(gamma)/xx3)*SIN(tau)*ATa*fL
    xx2  = (xalb-1)*ASd-(COS(tau)+COS(gamma)*SIN(tau)/xx3)*ATa*fL
    cphi = SQRT(xx1**2+xx2**2)

    !   calculate heat storage related parameters:
    xx1  = m*COS(gamma)-n*SIN(gamma)
    xx2  = m*SIN(gamma)+n*COS(gamma)
    eta  = ATAN(xx1/xx2)
    !     if ( eta<0 ) print*, 'lambda,delta,m,n,gamma:', lambda,delta,m,n,gamma
    xx1  = xk**2*(m**2+n**2)*ATs**2
    xx2  = m**2*n**2
    ceta = SQRT(xx1/xx2)

    !   key phase lag:
    xlag = eta-phi

    !   calculate the OHM coeffs.:
    !   a1:
    xa1 = (ceta*COS(xlag))/cphi

    !   a2:
    xa2 = (ceta*SIN(xlag))/(OMEGA*cphi)
    xa2 = xa2/3600 ! convert the unit from s-1 to h-1

    !   a3:
    xa3  = -xa1*(fT/f)*(mSd*(1-xalb))-mAH


    !     print*, 'ceta,cphi', ceta,cphi
    !     print*, 'tau,eta,phi,xlag in deg:',tau/pi*180,eta/pi*180,phi/pi*180,xlag/pi*180

    ! PRINT*, '********sfc_typ: ',sfc_typ,' end********'

  END SUBROUTINE AnOHM_coef_land_cal
  !========================================================================================

  !========================================================================================
  !> a wrapper for retrieving AnOHM coefficients of water body
  !> @returns
  !! -# OHM coefficients of a given surface type: a1, a2 and a3
  !> @Caution: NB: this SUBROUTINE hasn't been well tested.
  SUBROUTINE AnOHM_coef_water_cal(&
       ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,&   ! input: forcing
       xalb,xemis,xcp,xk,xch,xBo,xeta,xmu,&   ! input: sfc properties
       xa1,xa2,xa3,ATs,mTs,gamma)            ! output


    IMPLICIT NONE

    ! input: forcing scales
    REAL(KIND(1d0)),INTENT(in):: ASd !< daily amplitude of solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: mSd !< daily mean solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: ATa !< daily amplitude of air temperature [K]
    REAL(KIND(1d0)),INTENT(in):: mTa !< daily mean air temperature [K]
    REAL(KIND(1d0)),INTENT(in):: tau !< phase lag between Sd and Ta (Ta-Sd) [rad]
    REAL(KIND(1d0)),INTENT(in):: mWS !< daily mean wind speed [m s-1]
    REAL(KIND(1d0)),INTENT(in):: mWF !< daily mean underground moisture flux [m3 s-1 m-2]
    REAL(KIND(1d0)),INTENT(in):: mAH !< daily mean anthropogenic heat flux [W m-2]

    ! input: sfc properties
    REAL(KIND(1d0)),INTENT(in):: xalb  !< albedo [-]
    REAL(KIND(1d0)),INTENT(in):: xemis !< emissivity [-]
    REAL(KIND(1d0)),INTENT(in):: xcp   !< heat capacity [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in):: xk    !< thermal conductivity [W m-1 K-1]
    REAL(KIND(1d0)),INTENT(in):: xch   !< bulk transfer coef [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in):: xBo   !< Bowen ratio [-]
    REAL(KIND(1d0)),INTENT(in):: xeta  !< effective absorption fraction [-]
    REAL(KIND(1d0)),INTENT(in):: xmu   !< effective absorption coefficient [m-1]

    ! output
    REAL(KIND(1d0)),INTENT(out) :: xa1   !< AnOHM coefficients of grid [-]
    REAL(KIND(1d0)),INTENT(out) :: xa2   !< AnOHM coefficients of grid [h]
    REAL(KIND(1d0)),INTENT(out) :: xa3   !< AnOHM coefficients of grid [W m-2]
    REAL(KIND(1d0)),INTENT(out) :: ATs   !< daily amplitude of surface temperature [K]
    REAL(KIND(1d0)),INTENT(out) :: mTs   !< daily mean of surface temperature [K]
    REAL(KIND(1d0)),INTENT(out) :: gamma !< phase difference between Ts and Sd [K]

    !   constant
    REAL(KIND(1d0)), PARAMETER :: SIGMA = 5.67e-8          ! Stefan-Boltzman
    REAL(KIND(1d0)), PARAMETER :: PI    = ATAN(1.0)*4      ! Pi
    REAL(KIND(1d0)), PARAMETER :: OMEGA = 2*Pi/(24*60*60)  ! augular velocity of Earth

    !   local variables:
    REAL(KIND(1d0)) :: beta                   ! inverse Bowen ratio
    REAL(KIND(1d0)) :: f,fL,fT                ! energy redistribution factors
    REAL(KIND(1d0)) :: lambda,calb            ! temporary use
    REAL(KIND(1d0)) :: delta             ! sfc. temperature related variables
    ! REAL(KIND(1d0)) :: delta,m,n              ! sfc. temperature related variables
    REAL(KIND(1d0)) :: xm,xn                  ! m, n related
    ! REAL(KIND(1d0)) :: gamma              ! phase lag scale
    REAL(KIND(1d0)) :: phi              ! phase lag scale
    ! REAL(KIND(1d0)) :: ATs,mTs                ! surface temperature amplitude
    REAL(KIND(1d0)) :: czeta,ctheta           ! phase related temporary variables
    REAL(KIND(1d0)) :: zeta,theta,xlag           ! phase related temporary variables
    REAL(KIND(1d0)) :: xx1,xx2,xx3            ! temporary use
    REAL(KIND(1d0)) :: kappa                  ! temporary use
    REAL(KIND(1d0)) :: dtau,dpsi,dphi         ! temporary use
    REAL(KIND(1d0)) :: cdtau,cdpsi,cdphi      ! temporary use
    REAL(KIND(1d0)) :: xxT,xxkappa,xxdltphi,xchWS   ! temporary use
    ! LOGICAL :: flagGood = .TRUE.  ! quality flag, T for good, F for bad

    ! ====not used====
    REAL(KIND(1d0)) :: dummy
    dummy=mah+mwf
    ! ====not used====

    !   calculate sfc properties related parameters:
    xm     = xk*xmu**2
    xn     = xcp*OMEGA
    phi    = ATAN(xn/xm)
    kappa  = SQRT(xcp*OMEGA/(2*xk))

    ! mWS=SUM(WS, dim=1, mask=(WS>0))/SIZE(WS, dim=1)
    xchWS    = xch*mWS
    beta   = 1/xBo
    f      = ((1+beta)*xchWS+4*SIGMA*xemis*mTa**3)
    fL     = 4*SIGMA*xemis*mTa**3
    fT     = (1+beta)*xchWS

    calb=1-xalb


    lambda= SQRT(xm**2+xn**2)

    dtau=ATAN(xk*kappa/(f+xk*kappa))
    dpsi=ATAN((xk-xmu)/kappa)
    dphi=ATAN(kappa*(f+xk*xmu)/(f*(kappa-xmu)+xk*kappa*(2*kappa-xmu)))
    cdtau=SQRT((xk*kappa)**2+(f+xk*kappa)**2)
    cdpsi=SQRT((xk-xmu)**2+kappa**2)
    cdphi=cdtau*cdpsi

    !   calculate surface temperature related parameters:
    ! daily mean:
    mTs   = (mSd*(1-xalb+xeta)/f)+mTa
    ! amplitude:
    xx1 = (xk*xeta*xmu*calb*ASd*cdpsi)**2
    xx2 = 2*lambda*SQRT(xx1)*(calb*ASd*SIN(phi-dpsi)+f*ATa*SIN(tau+phi-dpsi))
    xx3 = lambda**2*((calb*ASd+COS(tau)*f*ATa)**2+(SIN(tau)*f*ATa)**2)
    ATs = 1/(cdtau*lambda)*SQRT(xx1+xx2+xx3)
    ! phase lag:
    xx1 = (xk*kappa*calb*ASd+cdtau*f*ATa*SIN(tau+dtau))*lambda    &
         +(xk*xeta*xmu*calb*ASd*cdphi*SIN(phi+dphi))
    xx2 = ((f+xk*kappa)*calb*ASd-cdtau*f*ATa*COS(tau+dtau))*lambda&
         -xk*xeta*xmu*calb*ASd*cdphi*COS(phi+dphi)
    delta = ATAN(xx1/xx2)
    gamma = delta

    ! calculate net radiation related parameters:
    ! phase lag:
    xx1    = fL*(ATs*SIN(delta)-ATa*SIN(tau))
    xx2    = calb*ASd-fL*(ATs*COS(delta)-ATa*COS(tau))
    theta  = ATAN(xx1/xx2)
    ! amplitude:
    ctheta = SQRT(xx1**2+xx2**2)

    !   calculate heat storage related parameters:
    ! scales:
    xxT      = SQRT(2.)*kappa*lambda*ATs
    xxkappa  = cdpsi*xeta*xmu*ASd
    xxdltphi = COS(delta)*SIN(dpsi)*COS(phi)-SIN(delta)*COS(dpsi)*SIN(phi)
    ! phase lag:
    xx1  = xxT*SIN(PI/4-delta)+xxkappa*SIN(phi+dpsi)
    xx2  = xxT*SIN(PI/4+delta)-xxkappa*SIN(PHI-dpsi)
    zeta = ATAN(xx1/xx2)
    ! amplitude:
    xx1   = 2*SQRT(2.)*xxkappa*xxT*xxdltphi
    xx2   = (1-COS(2*dpsi)*COS(2*phi))*xxkappa**2
    xx3   = xxT**2
    czeta = xk/lambda*SQRT(xx1+xx2+xx3)


    !   calculate the OHM coeffs.:
    xlag = zeta-theta
    ! a1:
    xa1  = (czeta*COS(xlag))/ctheta

    !   write(*,*) 'ceta,xlag,cphi:', ceta,xlag,cphi
    !   a2:
    xa2  = (czeta*SIN(xlag))/(OMEGA*ctheta)
    xa2  = xa2/3600 ! convert the unit from s-1 to h-1

    !   a3:
    xa3  = mSd*(xalb-1)*(xeta+(fT-fL*xeta)/f*xa1)



    ! print*,  'sfc_typ_water:', sfc_typ
    ! print*, 'a1,a2,a3:', xa1,xa2,xa3

  END SUBROUTINE AnOHM_coef_water_cal
  !========================================================================================

  !========================================================================================
  SUBROUTINE AnOHM_Fc(&
       xid,MetForcingData_grid,EmissionsMethod,qf,& ! input
       ASd,mSd,tSd,ATa,mTa,tTa,tau,mWS,mWF,mAH)    ! output

    IMPLICIT NONE

    !   input
    INTEGER,INTENT(in):: xid
    INTEGER,INTENT(in):: EmissionsMethod
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:,:) ::MetForcingData_grid
    REAL(KIND(1d0)),INTENT(in):: qf                !< anthropogenic heat flux [W m-2]

    !   output
    REAL(KIND(1d0)),INTENT(out):: ASd !< daily amplitude of solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(out):: mSd !< daily mean solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(out):: tSd !< local peaking time of solar radiation [hr]
    REAL(KIND(1d0)),INTENT(out):: ATa !< daily amplitude of air temperature [degC]
    REAL(KIND(1d0)),INTENT(out):: mTa !< daily mean air temperature [degC]
    REAL(KIND(1d0)),INTENT(out):: tTa !< local peaking time of air temperature [hour]
    REAL(KIND(1d0)),INTENT(out):: tau !< phase lag between Sd and Ta (Ta-Sd) [rad]
    REAL(KIND(1d0)),INTENT(out):: mWS !< daily mean wind speed [m s-1]
    REAL(KIND(1d0)),INTENT(out):: mWF !< daily mean underground moisture flux [m3 s-1 m-2]
    REAL(KIND(1d0)),INTENT(out):: mAH !< daily mean anthropogenic heat flux [W m-2]

    !   forcings:
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: Sd   !< incoming solar radiation [W m-2]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: Ta   !< air temperature [degC]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: RH   !< relative humidity [%]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: pres !< Atmospheric pressure [hPa]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: WS   ! wind speed [m s-1]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: WF   ! water flux density [m3 s-1 m-2]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: AH   ! anthropogenic heat [W m-2]
    REAL(KIND(1d0)), DIMENSION(:),ALLOCATABLE:: tHr  ! local time [hr]


    ! load forcing variables:
    CALL AnOHM_FcLoad(xid,MetForcingData_grid,EmissionsMethod,qf,Sd,Ta,RH,pres,WS,WF,AH,tHr)
    ! calculate forcing scales for AnOHM:
    CALL AnOHM_FcCal(Sd,Ta,WS,WF,AH,tHr,ASd,mSd,tSd,ATa,mTa,tTa,tau,mWS,mWF,mAH)

    ! CALL r8vec_print(SIZE(sd, dim=1),sd,'Sd')
    ! PRINT*, ASd,mSd,tSd

    ! CALL r8vec_print(SIZE(ta, dim=1),ta,'Ta')
    ! PRINT*, ATa,mTa,tTa

  END SUBROUTINE AnOHM_Fc
  !========================================================================================

  !========================================================================================
  !> load forcing series for AnOHM_FcCal
  SUBROUTINE AnOHM_FcLoad(&
       xid,MetForcingData_grid,EmissionsMethod,qf,& ! input
       Sd,Ta,RH,pres,WS,WF,AH,tHr) ! output

    IMPLICIT NONE

    !   input
    INTEGER,INTENT(in):: xid !< day of year
    INTEGER,INTENT(in):: EmissionsMethod !< AnthropHeat option
    REAL(KIND(1d0)),INTENT(in),DIMENSION(:,:) ::MetForcingData_grid !< met forcing array of grid
    REAL(KIND(1d0)),INTENT(in):: qf                !< anthropogenic heat flux [W m-2]

    !   output
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: Sd  !< incoming solar radiation [W m-2]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: Ta  !< air temperature [degC]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: RH  !< relative humidity [%]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: pres!< atmospheric pressure [mbar]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: WS  !< wind speed [m s-1]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: WF  !< water flux density [m3 s-1 m-2]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: AH  !< anthropogenic heat [W m-2]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(out), ALLOCATABLE:: tHr !< local time  [hr]


    !   local variables:
    REAL(KIND(1d0)),DIMENSION(:,:),ALLOCATABLE :: subMet ! subset array of daytime series

    INTEGER :: err
    INTEGER :: lenMetData,nVar


    LOGICAL, ALLOCATABLE :: metMask(:)

    ! construct mask
    IF (ALLOCATED(metMask)) DEALLOCATE(metMask, stat=err)
    ALLOCATE(metMask(SIZE(MetForcingData_grid, dim=1)))
    metMask=(MetForcingData_grid(:,2)==xid & ! day=xid
         .AND. MetForcingData_grid(:,4)==0)! tmin=0

    ! determine the length of subset
    lenMetData = COUNT(metMask)

    ! construct array for time and met variables
    nVar=8! number of variables to retrieve
    ! print*, 'good 1'
    ! allocate subMet:
    IF (ALLOCATED(subMet)) DEALLOCATE(subMet, stat=err)
    ALLOCATE(subMet(lenMetData,nVar))
    subMet=RESHAPE(PACK(MetForcingData_grid(:,(/3,& !time: hour
         15,12,11,13,10,12,9/)),&! met: Sd, Ta, RH, pres, WS, WF, AH
                                ! NB: WF not used: a placeholder
         SPREAD(metMask, dim=2, ncopies=nVar)),& ! replicate mask vector to 2D array
         (/lenMetData,nVar/)) ! convert to target shape


    ! re-allocate arrays as their sizes may change during passing
    IF (ALLOCATED(tHr)) DEALLOCATE(tHr, stat=err)
    ALLOCATE(tHr(lenMetData))
    IF (ALLOCATED(Sd)) DEALLOCATE(Sd, stat=err)
    ALLOCATE(Sd(lenMetData))
    IF (ALLOCATED(Ta)) DEALLOCATE(Ta, stat=err)
    ALLOCATE(Ta(lenMetData))
    IF (ALLOCATED(RH)) DEALLOCATE(RH, stat=err)
    ALLOCATE(RH(lenMetData))
    IF (ALLOCATED(pres)) DEALLOCATE(pres, stat=err)
    ALLOCATE(pres(lenMetData))
    IF (ALLOCATED(WS)) DEALLOCATE(WS, stat=err)
    ALLOCATE(WS(lenMetData))
    IF (ALLOCATED(WF)) DEALLOCATE(WF, stat=err)
    ALLOCATE(WF(lenMetData))
    IF (ALLOCATED(AH)) DEALLOCATE(AH, stat=err)
    ALLOCATE(AH(lenMetData))

    ! load the sublist into forcing variables
    tHr  = subMet(:,1)! time in hour
    Sd   = subMet(:,2)
    Ta   = subMet(:,3)
    RH   = subMet(:,4)
    pres = subMet(:,5)
    WS   = subMet(:,6)
    WF   = 0          ! set as 0 for the moment
    IF ( EmissionsMethod == 0 ) THEN
       AH = subMet(:,8)    ! read in from MetForcingData_grid,
    ELSE
       ! AH = 0 ! temporarily change to zero;
       AH =  qf ! use modelled value
       !  AH = mAH_grids(xid-1,xgrid)
    END IF


  END SUBROUTINE AnOHM_FcLoad
  !========================================================================================

  !========================================================================================
  !> calculate the key parameters of a sinusoidal curve for AnOHM forcings
  !> i.e., a, b, c in a*Sin(Pi/12*t+b)+c
  SUBROUTINE AnOHM_FcCal(&
       Sd,Ta,WS,WF,AH,tHr,&                     ! input
       ASd,mSd,tSd,ATa,mTa,tTa,tau,mWS,mWF,mAH) ! output
    IMPLICIT NONE

    ! input
    REAL(KIND(1d0)),DIMENSION(:),INTENT(in):: Sd  !< incoming shortwave radiation [W m-2]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(in):: Ta  !< air temperature [degC]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(in):: WS  !< wind speed [m s-1]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(in):: WF  !< water flux density [m3 s-1 m-2]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(in):: AH  !< anthropogenic heat [W m-2]
    REAL(KIND(1d0)),DIMENSION(:),INTENT(in):: tHr !< time [hr]

    ! output
    REAL(KIND(1d0)),INTENT(out):: ASd !< daily amplitude of solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(out):: mSd !< daily mean solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(out):: tSd !< local peaking time of solar radiation [hr]
    REAL(KIND(1d0)),INTENT(out):: ATa !< daily amplitude of air temperature [degC]
    REAL(KIND(1d0)),INTENT(out):: mTa !< daily mean air temperature [degC]
    REAL(KIND(1d0)),INTENT(out):: tTa !< local peaking time of air temperature [hr]
    REAL(KIND(1d0)),INTENT(out):: tau !< phase lag between Sd and Ta (Ta-Sd) [rad]
    REAL(KIND(1d0)),INTENT(out):: mWS !< daily mean wind speed [m s-1]
    REAL(KIND(1d0)),INTENT(out):: mWF !< daily mean underground moisture flux [m3 s-1 m-2]
    REAL(KIND(1d0)),INTENT(out):: mAH !< daily mean anthropogenic heat flux [W m-2]

    !   constant
    REAL(KIND(1d0)), PARAMETER :: PI  = ATAN(1.0)*4 ! Pi
    REAL(KIND(1d0)), PARAMETER :: C2K = 273.15      ! degC to K

    !   local variables:
    REAL(KIND(1d0)),ALLOCATABLE :: tHrDay(:) ! daytime tHr when Sd>0
    REAL(KIND(1d0)),ALLOCATABLE :: selX(:)   ! daytime sublist of met variable when Sd>0


    ! REAL(KIND(1d0)) :: xx              ! temporary use
    INTEGER :: err,lenDay
    LOGICAL,DIMENSION(:),ALLOCATABLE::SdMask



    ALLOCATE(SdMask(SIZE(Sd, dim=1)), stat=err)
    IF ( err/= 0) PRINT *, "SdMask: Allocation request denied"
    SdMask=Sd>5
    lenDay=COUNT(SdMask)

    ! CALL r8vec_print(24,Sd,'Sd')
    ! CALL r8vec_print(24,tHr,'tHr')
    ALLOCATE(tHrDay(lenDay), stat=err)
    IF ( err/= 0) PRINT *, "tHrDay: Allocation request denied"
    tHrDay=PACK(tHr, mask=SdMask)


    ALLOCATE(selX(lenDay), stat=err)
    IF ( err/= 0) PRINT *, "selX: Allocation request denied"

    !   calculate sinusoidal scales of Sd:
    ! PRINT*, 'Calc. Sd...'
    selX=PACK(Sd, mask=SdMask)
    ASd=(MAXVAL(selX)-MINVAL(selX))/2
    mSd=SUM(selX)/lenDay
    tSd=12
    CALL AnOHM_ShapeFit(tHrDay,selX,ASd,mSd,tSd)
    ! CALL r8vec_print(lenDay,selX,'Sd Day:')
    !   modify ill-shaped days to go through
    ! IF ( ASd < 0 .OR. tSd > 15) THEN
    !    !         ASd = abs(ASd)
    !    !         tSd = 12 ! assume Sd peaks at 12:00LST
    !    CALL r8vec_print(lenDay,tHrDay,'tHrDay:')
    !    CALL r8vec_print(lenDay,selX,'Sd Day:')
    !    PRINT*, 'ASd:', ASd
    !    PRINT*, 'mSd:', mSd
    !    PRINT*, 'tSd:', tSd
    ! END IF
    ! PRINT*, 'Sd Day:', selX

    ! add corrections on mSd to fix the overestimated a3 during cold periods
    IF ( mSd+ASd<MAXVAL(selX) ) THEN
       ! PRINT*, 'Sd max:', MAXVAL(selX)
       ! PRINT*, 'ASd:', ASd
       ! PRINT*, 'mSd before:', mSd
       mSd=MAXVAL(selX)-ASd
       ! PRINT*, 'mSd after:', mSd
       ! PRINT*,''
    END IF

    !   calculate sinusoidal scales of Ta:
    ! PRINT*, 'Calc. Ta...'
    selX=PACK(Ta, mask=SdMask)
    ATa=(MAXVAL(selX)-MINVAL(selX))/2
    mTa=SUM(selX)/lenDay
    tTa=12
    CALL AnOHM_ShapeFit(tHrDay,selX,ATa,mTa,tTa)
    ! CALL r8vec_print(lenDay,selX,'Ta Day:')
    IF ( mTa < 60 ) mTa = mTa+C2K ! correct the Celsius to Kelvin
    !   modify ill-shaped days to go through
    IF ( ATa < 0 ) THEN
       !         ATa = abs(ATa)
       !         tTa = 14 ! assume Ta peaks at 14:00LST
       CALL r8vec_print(lenDay,selX,'Ta Day:')
       PRINT*, 'ATa:', ATa
       PRINT*, 'mTa:', mTa
       PRINT*, 'tTa:', tTa
    END IF
    ! PRINT*, 'Ta:', Ta(10:16)


    !   calculate the phase lag between Sd and Ta:
    tau = (tTa-tSd)/24*2*PI
    ! PRINT*, 'tau:', tau

    !   calculate the mean values:
    selX=PACK(WS, mask=SdMask)
    mWS = SUM(selX)/lenDay  ! mean value of WS

    selX=PACK(WF, mask=SdMask)
    mWF = SUM(selX)/lenDay  ! mean value of WF

    selX=PACK(AH, mask=SdMask)
    mAH = SUM(selX)/lenDay  ! mean value of AH
    ! PRINT*, 'mWS:', mWS
    !     print*, 'mWF:', mWF
    !     print*, 'mAH:', mAH
    IF (ALLOCATED(SdMask)) DEALLOCATE(SdMask, stat=err)
    IF ( err/= 0) PRINT *, "SdMask: Deallocation request denied"

    IF (ALLOCATED(tHrDay)) DEALLOCATE(tHrDay, stat=err)
    IF ( err/= 0) PRINT *, "tHrDay: Deallocation request denied"

    IF (ALLOCATED(selX)) DEALLOCATE(selX, stat=err)
    IF ( err/= 0) PRINT *, "selX: Deallocation request denied"

  END SUBROUTINE AnOHM_FcCal
  !========================================================================================

  !========================================================================================
  !> calculate the key parameters of a sinusoidal curve for AnOHM forcings
  !> i.e., a, b, c in a*Sin(Pi/12*t+b)+c, where t is in hour
  SUBROUTINE AnOHM_ShapeFit(&
       tHr,obs,&      !input
       amp,mean,tpeak)!output
    IMPLICIT NONE

    !   input
    REAL(KIND(1d0)),INTENT(in) :: tHr(:)  !< time in hour
    REAL(KIND(1d0)),INTENT(in) :: obs(:)  !< observation

    !   output
    REAL(KIND(1d0)),INTENT(out) :: amp     !< amplitude
    REAL(KIND(1d0)),INTENT(out) :: mean    !< average
    REAL(KIND(1d0)),INTENT(out) :: tpeak   !< peaking time (h)

    INTEGER :: m,n,info,err         ! temporary use

    ! EXTERNAL fSin
    REAL ( KIND(1d0) ),ALLOCATABLE:: fvec(:),x(:)

    REAL ( KIND(1d0) ):: tol= 0.00001D+00 ! tolerance

    n=3 ! number of parameters to determine
    m=SIZE(tHr, dim=1) ! number of observation pairs
    ! PRINT*, 'm',m


    ALLOCATE(fvec(m), stat=err)
    IF ( err/= 0) PRINT *, "fvec: Allocation request denied"

    ALLOCATE(x(n), stat=err)
    IF ( err/= 0) PRINT *, "x: Allocation request denied"


    ! initial guess for fitting
    x=(/mean,amp,tpeak/)


    ! use minpack subroutine 'lmstr1' to fit the sinusoidal form
    CALL lmdif1( fSin, m, n, x, tHr, obs, fvec, tol, info )

    ! x   = (/mean,amp,delta/), see subroutine 'fSin' for the meaning of this vector
    mean  = x(1)
    amp   = x(2)
    tpeak = x(3)+6 ! when t = delta + 6 (hr of LST), t is tpeak.

    ! adjust fitted parameters to physical range:
    ! amp>0
    IF ( amp<0 ) THEN
       !  PRINT*, ''
       !  PRINT*, 'before:'
       !  PRINT*, amp,tpeak,mean
       !  CALL r8vec_print(SIZE(tHR, dim=1),tHR,'tHR')
       !  CALL r8vec_print(SIZE(obs, dim=1),obs,'obs')
       amp=ABS(amp)
       tpeak=x(3)-12+6+24
       tpeak=MOD(tpeak,24.)
       !  PRINT*, 'after:'
       !  PRINT*, amp,tpeak,mean
    END IF
    tpeak=MOD(tpeak,24.)

  END SUBROUTINE AnOHM_ShapeFit
  !========================================================================================

  !========================================================================================
  !> sinusoidal function f(t) for fitting:
  !> f(t) = mean+amp*Sin(Pi/12(t-delta))
  !> x    = (/mean,amp,delta/) contains the fitting parameters
  SUBROUTINE fSin(m, n, x, xdat, ydat, fvec, iflag)

    IMPLICIT NONE
    INTEGER ( kind = 4 ) m
    INTEGER ( kind = 4 ) n

    ! REAL ( kind = 8 ) fjrow(n)
    REAL ( kind = 8 ) fvec(m),& ! residual vector
         xdat(m),ydat(m) ! (x,y) observations for fitting

    INTEGER ( kind = 4 ) iflag,i
    REAL ( kind = 8 ) x(n)
    REAL(KIND(1d0)), PARAMETER :: PI  = ATAN(1.0)*4      ! Pi

    IF ( iflag == 0 ) THEN

       WRITE ( *, '(a)' ) ''
       DO i = 1, n
          WRITE ( *, '(g14.6)' ) x(i)
       END DO

    ELSE  IF ( iflag == 1 ) THEN
       fvec(1:m) = x(1) + x(2) * SIN(2*PI/24*(xdat(1:m)-x(3))) - ydat(1:m)

    END IF
    RETURN

  END SUBROUTINE fSin
  !========================================================================================

  !========================================================================================
  !> estimate daytime Bowen ratio for calculation of AnOHM coefficients
  SUBROUTINE AnOHM_Bo_cal(&
       sfc_typ,& ! surface type
       Sd,Ta,RH,pres,tHr,              & ! input: forcing
       ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,& ! input: forcing
       xalb,xemis,xcp,xk,xch,xSM,      & ! input: sfc properties
       tSd,                            & ! input: peaking time of Sd in hour
       xBo)                              ! output: Bowen ratio


    IMPLICIT NONE

    ! input:
    INTEGER, INTENT(in) :: sfc_typ ! unknown Bowen ratio

    ! input: daytime series
    REAL(kind = 8), INTENT(in), DIMENSION(:) ::Sd  !< incoming solar radiation [W m-2]
    REAL(kind = 8), INTENT(in), DIMENSION(:) ::Ta  !< air temperature [degC]
    REAL(kind = 8), INTENT(in), DIMENSION(:) ::RH  !< relative humidity [%]
    REAL(kind = 8), INTENT(in), DIMENSION(:) ::pres!< Atmospheric pressure [mbar]
    REAL(kind = 8), INTENT(in), DIMENSION(:) ::tHr !< local time  [hr]

    ! input: forcing scales
    REAL(KIND(1d0)),INTENT(in):: ASd !< daily amplitude of solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: mSd !< daily mean solar radiation [W m-2]
    REAL(KIND(1d0)),INTENT(in):: tSd !< local peaking time of solar radiation [hr]
    REAL(KIND(1d0)),INTENT(in):: ATa !< daily amplitude of air temperature [degC]
    REAL(KIND(1d0)),INTENT(in):: mTa !< daily mean air temperature [degC]
    REAL(KIND(1d0)),INTENT(in):: tau !< phase lag between Sd and Ta (Ta-Sd) [rad]
    REAL(KIND(1d0)),INTENT(in):: mWS !< daily mean wind speed [m s-1]
    REAL(KIND(1d0)),INTENT(in):: mWF !< daily mean underground moisture flux [m3 s-1 m-2]
    REAL(KIND(1d0)),INTENT(in):: mAH !< daily mean anthropogenic heat flux [W m-2]

    ! input: surface properties
    REAL(KIND(1d0)),INTENT(in) :: xalb  !< albedo [-]
    REAL(KIND(1d0)),INTENT(in) :: xemis !< emissivity [-]
    REAL(KIND(1d0)),INTENT(in) :: xcp   !< heat capacity [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in) :: xk    !< thermal conductivity [W m-1 K-1]
    REAL(KIND(1d0)),INTENT(in) :: xch   !< bulk transfer coef [J m-3 K-1]
    REAL(KIND(1d0)),INTENT(in) :: xSM   !< surface moisture status [-]

    ! output:
    REAL(kind=8), INTENT(out) :: xBo ! unknown Bowen ratio [-]

    ! EXTERNAL fcnBo

    REAL(kind=8), ALLOCATABLE :: x(:),fvec(:),prms(:)

    INTEGER :: lenDay,n,m,info,err,nVar,nPrm
    LOGICAL, DIMENSION(:), ALLOCATABLE :: maskDay
    REAL(kind=8) :: tol=1E-20

    ! LOGICAL, ALLOCATABLE,DIMENSION(:) :: metMask

    ! daytime mask
    ALLOCATE(maskDay(SIZE(sd)),stat=err)
    maskDay=sd>5
    ! length of daytime series
    lenDay=SIZE(PACK(sd, mask=maskDay), dim=1)
    ! ! daytime mask
    ! IF (ALLOCATED(metMask)) DEALLOCATE(metMask, stat=err)
    ! ALLOCATE(metMask(lenDay))
    ! metMask=(Sd>0)


    ! assign x vector:
    n=1
    ALLOCATE(x(n), stat=err)
    IF ( err/= 0) PRINT *, "x: Allocation request denied"
    ALLOCATE(fvec(n), stat=err)
    IF ( err/= 0) PRINT *, "fvec: Allocation request denied"

    ! pass initial Bowen ratio:
    xBo=10
    x(1)= xBo

    ! NB: set these numbers properly if any changes made to this subroutine:
    ! number of parameters to pass:
    nPrm=16
    ! number of met variables to pass:
    nVar=5
    ! length of x vector that holds unknown and parameters
    m=nPrm+nVar*lenDay

    ALLOCATE(prms(m), stat=err)
    IF ( err/= 0) PRINT *, "prms: Allocation request denied"

    ! pass forcing scales:
    prms(1)=ASd
    prms(2)=mSd
    prms(3)=ATa
    prms(4)=mTa
    prms(5)=tau
    prms(6)=mWS
    prms(7)=mWF
    prms(8)=mAH

    ! pass sfc. property scales:
    prms(9)=xalb
    prms(10)=xemis
    prms(11)=xcp
    prms(12)=xk
    prms(13)=xch
    prms(14)=xSM

    ! pass tSd:
    prms(15)=tSd

    ! pass tSd:
    prms(16)=sfc_typ*1.0


    ! extract daytime series
    prms(nPrm+1:m)=PACK((/Sd,Ta,RH,pres,tHr/), &
         mask=PACK(SPREAD(maskDay, dim=2, ncopies=nVar),.TRUE.))

    ! PRINT*, 'xBo before solve:',x(1)
    ! PRINT*, 'fvec before solve:',fvec(1)
    ! PRINT*, 'xSM:',xSM
    ! solve nonlinear equation fcnBo(x)=0
    CALL hybrd1(fcnBo,n,x,fvec,tol,info,m,prms)
    xBo=x(1)
    ! PRINT*, 'xBo after solve: ',x(1)
    ! PRINT*, 'fvec after solve:',fvec(1)

    IF (ALLOCATED(x)) DEALLOCATE(x, stat=err)
    IF ( err/= 0) PRINT *, "x: Deallocation request denied"
    IF (ALLOCATED(fvec)) DEALLOCATE(fvec, stat=err)
    IF ( err/= 0) PRINT *, "fvec: Deallocation request denied"
    IF (ALLOCATED(prms)) DEALLOCATE(prms, stat=err)
    IF ( err/= 0) PRINT *, "prms: Deallocation request denied"

  END SUBROUTINE AnOHM_Bo_cal
  !========================================================================================

  !========================================================================================
  !> this fucntion will construct an equaiton for Bo calculation
  SUBROUTINE fcnBo( n, x, fvec, iflag, m, prms )

    IMPLICIT NONE
    !    Input, external FCN, the name of the user-supplied subroutine which
    !    calculates the functions.  The routine should have the form:
    !      subroutine fcn ( n, x, fvec, iflag )
    INTEGER ( kind = 4 ):: n
    INTEGER ( kind = 4 ):: m
    INTEGER ( kind = 4 ):: iflag
    REAL ( kind = 8 ):: fvec(n)
    REAL ( kind = 8 ):: x(n) ! x(1) as unknown Bo
    REAL ( kind = 8 ):: prms(m) ! prms(i) used for passing parameters

    ! the unknow: Bowen ratio
    REAL(kind = 8):: xBo

    ! forcing scales
    REAL(kind = 8):: ASd
    REAL(kind = 8):: mSd
    REAL(kind = 8):: ATa
    REAL(kind = 8):: mTa
    REAL(kind = 8):: tau
    REAL(kind = 8):: mWS
    REAL(kind = 8):: mWF
    REAL(kind = 8):: mAH

    ! sfc. property scales
    REAL(kind = 8):: xalb
    REAL(kind = 8):: xemis
    REAL(kind = 8):: xcp
    REAL(kind = 8):: xk
    REAL(kind = 8):: xch

    ! peaking time of Sd in hour
    REAL(kind = 8)::tSd

    ! surface moisture status [-]
    REAL(kind = 8)::xSM

    ! surface type
    INTEGER :: sfc_typ


    ! array of daytime series
    REAL(kind=8), DIMENSION(:,:),ALLOCATABLE :: dayArray

    ! daytime series
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: Sd  !< incoming solar radiation, W m-2
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: Ta  !< air temperature, degC
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: RH  !< relative humidity, %
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: pres!< Atmospheric pressure, mbar
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: tHr !< time, hour
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: Ts  ! surface temperature, degC
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: qa  ! specific humidity, kg kg-1
    REAL(kind = 8), DIMENSION(:),ALLOCATABLE :: qs  ! Saturated specific humidity at surface,kg kg-1

    ! conversion constant:
    REAL(kind = 8),PARAMETER:: C2K=273.15 ! degC to K

    ! thermodynamic values at standard temperature (293.15 K) and pressure (101325 pascals):
    REAL(kind = 8),PARAMETER:: cp_air = 1006.38    ! specific heat capacity of air, J kg-1 K-1
    REAL(kind = 8),PARAMETER:: Lv_air = 2264.705E3 ! latent heat of vaporization of water, J kg-1

    INTEGER :: lenDay,i,err,nVar,nPrm


    IF ( iflag == 0 ) THEN
       ! only print out the x vector

       WRITE ( *, '(a)' ) ''
       CALL r8vec_print(n,x,'x in fcnBo')

    ELSE  IF ( iflag == 1 ) THEN
       ! calculate fvec at x:
       ! pass unknown:
       xBo=x(1)

       ! pass forcing scales:
       ASd = prms(1)
       mSd = prms(2)
       ATa = prms(3)
       mTa = prms(4)
       tau = prms(5)
       mWS = prms(6)
       mWF = prms(7)
       mAH = prms(8)

       ! pass sfc. property scales:
       xalb  = prms(9)
       xemis = prms(10)
       xcp   = prms(11)
       xk    = prms(12)
       xch   = prms(13)
       xSM   = MIN(prms(14),1.0)

       ! pass tSd:
       tSd=prms(15)

       ! pass tSd:
       sfc_typ=INT(prms(16))

       ! set number of parameters according to the above code
       nPrm=16

       ! number of met variables to pass:
       nVar=5
       ! length of daytime series
       lenDay=(m-nPrm)/nVar
       ! allocate daytime series
       ALLOCATE(dayArray(nVar,lenDay), stat=err)
       IF ( err/= 0) PRINT *, "dayArray: Allocation request denied"
       dayArray=RESHAPE(prms(nPrm+1:SIZE(prms)), shape=(/nVar,lenDay/),order=(/2,1/))

       ! pass daytime series
       ! Sd:
       ALLOCATE(Sd(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "Sd: Allocation request denied"
       Sd(:)=dayArray(1,:)
       ! Ta:
       ALLOCATE(Ta(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "Ta: Allocation request denied"
       Ta(:)=dayArray(2,:)
       ! RH:
       ALLOCATE(RH(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "RH: Allocation request denied"
       RH(:)=dayArray(3,:)
       ! pres:
       ALLOCATE(pres(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "pres: Allocation request denied"
       pres(:)=dayArray(4,:)
       ! tHr:
       ALLOCATE(tHr(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "tHr: Allocation request denied"
       tHr(:)=dayArray(5,:)


       !  PRINT*, 'n',n
       !  PRINT*, 'lenDay',lenDay
       !  PRINT*, 'nVar',nVar
       !  PRINT*, 'shape of dayArray',SHAPE(dayArray)
       !  PRINT*, 'shape of met variables',SHAPE(Ta),SHAPE(RH),SHAPE(pres),SHAPE(tHr)

       ALLOCATE(Ts(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "Ts: Allocation request denied"
       ALLOCATE(qs(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "qs: Allocation request denied"
       ALLOCATE(qa(lenDay), stat=err)
       IF ( err/= 0) PRINT *, "qa: Allocation request denied"


       ! calculate sums of QH and QE series in the daytime
       IF ( xSM==0 ) THEN
          xBo=1000 ! extremely arid
       ELSE
          ! PRINT*, 'lenDay',lenDay
          DO i = 1, lenDay, 1
             ! calculate surface temperature
             CALL AnOHM_xTs(&
                  sfc_typ,&
                  ASd,mSd,ATa,mTa,tau,mWS,mWF,mAH,&   ! input: forcing
                  xalb,xemis,xcp,xk,xch,xBo,&   ! input: sfc properties
                  tSd,& !input: peaking time of Sd in hour
                  tHr(i),&! input: time in hour
                  Ts(i))! output: surface temperature, K

             ! convert K to degC
             Ts(i)=MIN(Ts(i)-C2K,-40.)

             ! calculate saturation specific humidity
             qs(i)=qsat_fn(Ts(i),pres(i))

             ! calculate specific humidity
             qa(i)=qa_fn(Ta(i),RH(i),pres(i))

             ! PRINT*,''
             ! PRINT*, 'tHr',tHr(i)
             ! PRINT*, 'Sd',Sd(i)
             ! PRINT*, 'Ts',Ts(i)
             ! PRINT*, 'pres',pres(i)
             ! PRINT*, 'qs',qs(i)
             ! PRINT*, 'Ta',Ta(i)
             ! PRINT*, 'RH',RH(i)
             ! PRINT*, 'pres',pres(i)
             ! PRINT*, 'qa',qa(i)

          END DO

          ! below for testing:
          ! rho_air=1.293, air density, kg m-3
          ! RA=60, nominal aerodynamic resistence, s m-1
          ! PRINT*,''
          ! PRINT*, 'QH:',SUM(cp_air*(Ts-Ta)*1.293/60)/lenDay
          ! PRINT*, 'xSM:',xSM
          ! PRINT*, 'QE:',SUM(xSM*Lv_air*(qs-qa)*1.293/60)/lenDay
          ! PRINT*,''

          xBo = SUM(cp_air*(Ts-Ta))/& ! sum(QH)
               SUM(xSM*Lv_air*(qs-qa))! sum(QE)

       END IF

       ! f(Bo)-Bo==0
       fvec(1)=x(1)-xBo

       ! deallocate arrays
       IF (ALLOCATED(dayArray)) DEALLOCATE(dayArray, stat=err)
       IF ( err/= 0) PRINT *, "dayArray: Deallocation request denied"
       IF (ALLOCATED(Sd)) DEALLOCATE(Sd, stat=err)
       IF ( err/= 0) PRINT *, "Sd: Deallocation request denied"
       IF (ALLOCATED(Ta)) DEALLOCATE(Ta, stat=err)
       IF ( err/= 0) PRINT *, "Ta: Deallocation request denied"
       IF (ALLOCATED(RH)) DEALLOCATE(RH, stat=err)
       IF ( err/= 0) PRINT *, "RH: Deallocation request denied"
       IF (ALLOCATED(pres)) DEALLOCATE(pres, stat=err)
       IF ( err/= 0) PRINT *, "pres: Deallocation request denied"
       IF (ALLOCATED(tHr)) DEALLOCATE(tHr, stat=err)
       IF ( err/= 0) PRINT *, "tHr: Deallocation request denied"
       IF (ALLOCATED(Ts)) DEALLOCATE(Ts, stat=err)
       IF ( err/= 0) PRINT *, "Ts: Deallocation request denied"
       IF (ALLOCATED(qa)) DEALLOCATE(qa, stat=err)
       IF ( err/= 0) PRINT *, "qa: Deallocation request denied"
       IF (ALLOCATED(qs)) DEALLOCATE(qs, stat=err)
       IF ( err/= 0) PRINT *, "qs: Deallocation request denied"

    END IF
    RETURN

  END SUBROUTINE fcnBo
  !========================================================================================

  !========================================================================================
  !> calculate saturation vapor pressure (es)
  !> at air temperature (Ta)
  !> (MRR, 1987)
  FUNCTION esat_fn(Ta) RESULT(esat)
    REAL (KIND(1D0))::Ta  !< air temperature [degC]
    REAL (KIND(1D0))::esat  !< saturation vapor pressure [hPa]

    REAL (KIND(1D0)),PARAMETER::A=6.106 !< Teten coefficients
    REAL (KIND(1D0)),PARAMETER::B=17.27 !< Teten coefficients
    REAL (KIND(1D0)),PARAMETER::C=237.3 !< Teten coefficients

    esat = A*EXP(B*Ta/(C+Ta))
  END FUNCTION esat_fn
  !========================================================================================

  !========================================================================================
  !> calculate saturation specific humidity (qsat)
  !> at air temperature (Ta) and atmospheric pressure (pres)
  !> (MRR, 1987)
  FUNCTION qsat_fn(Ta,pres) RESULT(qsat)
    REAL (KIND(1D0))::Ta  !< air temperature [degC]
    REAL (KIND(1D0))::es  !< saturation vapor pressure [hPa]
    REAL (KIND(1D0))::qsat!< saturation specific humidity [kg kg-1]
    REAL (KIND(1D0))::pres!< atmospheric pressure [hPa]

    REAL (KIND(1D0)),PARAMETER::molar         = 0.028965  !< Dry air molar fraction [kg mol-1]
    REAL (KIND(1D0)),PARAMETER::molar_wat_vap = 0.0180153 !< Molar fraction of water vapor [kg mol-1]

    es = esat_fn(Ta)
    qsat = (molar_wat_vap/molar)*es/pres!(rmh2o/rmair)*ES/PMB
  END FUNCTION qsat_fn
  !========================================================================================

  !========================================================================================
  !> convert relative humidity (RH) to specific humidity (qa)
  !> at air temperature (Ta) and atmospheric pressure (pres)
  FUNCTION qa_fn(Ta,RH,pres) RESULT(qa)

    REAL (KIND(1D0))::Ta  !< air temperature [degC]
    REAL (KIND(1D0))::RH  !< relative humidity [%]
    REAL (KIND(1D0))::ea  !< vapor pressure [hPa]
    REAL (KIND(1D0))::es  !< saturation vapor pressure [hPa]
    REAL (KIND(1D0))::pres!< atmospheric pressure [hPa]
    REAL (KIND(1D0))::qa  !< saturation specific humidity [kg kg-1]

    REAL (KIND(1D0)),PARAMETER::molar         = 0.028965  !< Dry air molar fraction [kg mol-1]
    REAL (KIND(1D0)),PARAMETER::molar_wat_vap = 0.0180153 !< Molar fraction of water vapor [kg mol-1]

    es = esat_fn(Ta)
    ea = es*RH/100
    qa = (molar_wat_vap/molar)*ea/pres!(rmh2o/rmair)*ES/PMB
  END FUNCTION qa_fn
  !========================================================================================

END MODULE AnOHM_module

!========================================================================================
! SUEWS driver subroutines
! TS 31 Aug 2017: initial version
! TS 02 Oct 2017: added `SUEWS_cal_Main` as the generic wrapper
! TS 03 Oct 2017: added `SUEWS_cal_AnthropogenicEmission`
MODULE SUEWS_Driver
  USE meteo,ONLY:qsatf,RH2qa,qa2RH
  USE AtmMoistStab_module,ONLY:LUMPS_cal_AtmMoist,STAB_lumps,stab_fn_heat,stab_fn_mom
  USE NARP_MODULE,ONLY:NARP_cal_SunPosition
  USE AnOHM_module,ONLY:AnOHM
  USE ESTM_module,ONLY:ESTM
  USE Snow_module,ONLY:SnowCalc,Snow_cal_MeltHeat
  USE DailyState_module,ONLY:SUEWS_cal_DailyState,update_DailyState
  USE WaterDist_module,ONLY:drainage,soilstore,&
       SUEWS_cal_SoilMoist,SUEWS_update_SoilMoist,&
       ReDistributeWater,SUEWS_cal_HorizontalSoilWater,&
       SUEWS_cal_WaterUse
  ! USE ctrl_output,ONLY:varList
  USE allocateArray,ONLY:&
       nsurf,nvegsurf,&
       PavSurf,BldgSurf,ConifSurf,DecidSurf,GrassSurf,BSoilSurf,WaterSurf,&
       ivConif,ivDecid,ivGrass,&
       ncolumnsDataOutSUEWS,ncolumnsDataOutSnow,&
       ncolumnsDataOutESTM,ncolumnsDataOutDailyState


  IMPLICIT NONE

CONTAINS
  ! ===================MAIN CALCULATION WRAPPER FOR ENERGY AND WATER FLUX===========
  SUBROUTINE SUEWS_cal_Main(&
       AerodynamicResistanceMethod,AH_MIN,AHProf_24hr,AH_SLOPE_Cooling,& ! input&inout in alphabetical order
       AH_SLOPE_Heating,&
       alb,AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
       AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
       alpha_bioCO2,alpha_enh_bioCO2,alt,avkdn,avRh,avU1,BaseT,BaseTe,&
       BaseTHDD,beta_bioCO2,beta_enh_bioCO2,bldgH,CapMax_dec,CapMin_dec,&
       chAnOHM,cpAnOHM,CRWmax,CRWmin,DayWat,DayWatPer,&
       DecTreeH,Diagnose,DiagQN,DiagQS,DRAINRT,&
       dt_since_start,dqndt,qn1_av,dqnsdt,qn1_s_av,&
       EF_umolCO2perJ,emis,EmissionsMethod,EnEF_v_Jkm,endDLS,EveTreeH,FAIBldg,&
       FAIDecTree,FAIEveTree,Faut,FcEF_v_kgkm,fcld_obs,FlowChange,&
       FrFossilFuel_Heat,FrFossilFuel_NonHeat,G1,G2,G3,G4,G5,G6,GDD_id,&
       GDDFull,Gridiv,gsModel,HDD_id,HumActivity_24hr,&
       IceFrac,id,Ie_a,Ie_end,Ie_m,Ie_start,imin,&
       InternalWaterUse_h,IrrFracConif,IrrFracDecid,IrrFracGrass,isec,it,EvapMethod,&
       iy,kkAnOHM,Kmax,LAI_id,LAICalcYes,LAIMax,LAIMin,LAI_obs,&
       LAIPower,LAIType,lat,ldown_obs,lng,MaxConductance,MaxQFMetab,&
       MeltWaterStore,MetForcingData_grid,MinQFMetab,min_res_bioCO2,&
       NARP_EMIS_SNOW,NARP_TRANS_SITE,NetRadiationMethod,&
       NumCapita,OHM_coef,OHMIncQF,OHM_threshSW,&
       OHM_threshWD,PipeCapacity,PopDensDaytime,&
       PopDensNighttime,PopProf_24hr,PorMax_dec,PorMin_dec,&
       Precip,PrecipLimit,PrecipLimitAlb,Press_hPa,&
       QF0_BEU,Qf_A,Qf_B,Qf_C,&
       qn1_obs,qh_obs,qs_obs,qf_obs,&
       RadMeltFact,RAINCOVER,RainMaxRes,resp_a,resp_b,&
       RoughLenHeatMethod,RoughLenMomMethod,RunoffToWater,S1,S2,&
       SatHydraulicConduct,SDDFull,sfr,SMDMethod,SnowAlb,SnowAlbMax,&
       SnowAlbMin,snowD,SnowDens,SnowDensMax,SnowDensMin,SnowfallCum,snowFrac,&
       SnowLimBuild,SnowLimPaved,snow_obs,SnowPack,SnowProf_24hr,snowUse,SoilDepth,&
       soilmoist_id,soilstoreCap,StabilityMethod,startDLS,state_id,StateLimit,&
       StorageHeatMethod,StoreDrainPrm,SurfaceArea,Tair24HR,tau_a,tau_f,tau_r,&
       T_CRITIC_Cooling,T_CRITIC_Heating,Temp_C,TempMeltFact,TH,&
       theta_bioCO2,timezone,TL,TrafficRate,TrafficUnits,&
       TraffProf_24hr,Ts5mindata_ir,tstep,tstep_prev,veg_type,&
       WaterDist,WaterUseMethod,WetThresh,&
       WUDay_id,DecidCap_id,albDecTr_id,albEveTr_id,albGrass_id,porosity_id,&
       WUProfA_24hr,WUProfM_24hr,xsmd,Z,z0m_in,zdm_in,&
       datetimeLine,dataOutLineSUEWS,dataOutLineSnow,dataOutLineESTM,&!output
       DailyStateLine)!output

    IMPLICIT NONE

    ! input variables
    INTEGER,INTENT(IN)::AerodynamicResistanceMethod
    INTEGER,INTENT(IN)::Diagnose
    INTEGER,INTENT(IN)::DiagQN
    INTEGER,INTENT(IN)::DiagQS
    INTEGER,INTENT(IN)::startDLS
    INTEGER,INTENT(IN)::endDLS
    INTEGER,INTENT(IN)::EmissionsMethod
    INTEGER,INTENT(IN)::Gridiv
    INTEGER,INTENT(IN)::gsModel
    INTEGER,INTENT(IN)::id
    INTEGER,INTENT(IN)::Ie_end
    INTEGER,INTENT(IN)::Ie_start
    INTEGER,INTENT(IN)::isec
    INTEGER,INTENT(IN)::imin
    INTEGER,INTENT(IN)::it
    INTEGER,INTENT(IN)::EvapMethod
    INTEGER,INTENT(IN)::iy
    INTEGER,INTENT(IN)::LAICalcYes
    INTEGER,INTENT(IN)::NetRadiationMethod
    INTEGER,INTENT(IN)::OHMIncQF
    INTEGER,INTENT(IN)::RoughLenHeatMethod
    INTEGER,INTENT(IN)::RoughLenMomMethod
    INTEGER,INTENT(IN)::SMDMethod
    INTEGER,INTENT(IN)::snowUse
    INTEGER,INTENT(IN)::StabilityMethod
    INTEGER,INTENT(IN)::StorageHeatMethod
    INTEGER,INTENT(IN)::tstep
    INTEGER,INTENT(IN)::tstep_prev ! tstep size of the previous step
    INTEGER,INTENT(in)::dt_since_start ! time since simulation starts [s]
    INTEGER,INTENT(IN)::veg_type
    INTEGER,INTENT(IN)::WaterUseMethod

    REAL(KIND(1D0)),INTENT(IN)::AlbMax_DecTr
    REAL(KIND(1D0)),INTENT(IN)::AlbMax_EveTr
    REAL(KIND(1D0)),INTENT(IN)::AlbMax_Grass
    REAL(KIND(1D0)),INTENT(IN)::AlbMin_DecTr
    REAL(KIND(1D0)),INTENT(IN)::AlbMin_EveTr
    REAL(KIND(1D0)),INTENT(IN)::AlbMin_Grass
    REAL(KIND(1D0)),INTENT(IN)::alt
    REAL(KIND(1D0)),INTENT(IN)::avkdn
    REAL(KIND(1D0)),INTENT(IN)::avRh
    REAL(KIND(1D0)),INTENT(IN)::avU1
    REAL(KIND(1D0)),INTENT(IN)::BaseTHDD
    REAL(KIND(1D0)),INTENT(IN)::bldgH
    REAL(KIND(1D0)),INTENT(IN)::CapMax_dec
    REAL(KIND(1D0)),INTENT(IN)::CapMin_dec
    REAL(KIND(1D0)),INTENT(IN)::CRWmax
    REAL(KIND(1D0)),INTENT(IN)::CRWmin
    REAL(KIND(1D0)),INTENT(IN)::DecTreeH
    REAL(KIND(1D0)),INTENT(IN)::DRAINRT
    REAL(KIND(1D0)),INTENT(IN)::EF_umolCO2perJ
    REAL(KIND(1D0)),INTENT(IN)::EnEF_v_Jkm
    REAL(KIND(1D0)),INTENT(IN)::EveTreeH
    REAL(KIND(1D0)),INTENT(IN)::FAIBldg
    REAL(KIND(1D0)),INTENT(IN)::FAIDecTree
    REAL(KIND(1D0)),INTENT(IN)::FAIEveTree
    REAL(KIND(1D0)),INTENT(IN)::Faut
    REAL(KIND(1D0)),INTENT(IN)::FcEF_v_kgkm
    REAL(KIND(1D0)),INTENT(IN)::fcld_obs
    REAL(KIND(1D0)),INTENT(IN)::FlowChange
    REAL(KIND(1D0)),INTENT(IN)::FrFossilFuel_Heat
    REAL(KIND(1D0)),INTENT(IN)::FrFossilFuel_NonHeat
    REAL(KIND(1D0)),INTENT(IN)::G1
    REAL(KIND(1D0)),INTENT(IN)::G2
    REAL(KIND(1D0)),INTENT(IN)::G3
    REAL(KIND(1D0)),INTENT(IN)::G4
    REAL(KIND(1D0)),INTENT(IN)::G5
    REAL(KIND(1D0)),INTENT(IN)::G6
    REAL(KIND(1D0)),INTENT(IN)::InternalWaterUse_h
    REAL(KIND(1D0)),INTENT(IN)::IrrFracConif
    REAL(KIND(1D0)),INTENT(IN)::IrrFracDecid
    REAL(KIND(1D0)),INTENT(IN)::IrrFracGrass
    REAL(KIND(1D0)),INTENT(IN)::Kmax
    REAL(KIND(1D0)),INTENT(IN)::LAI_obs
    REAL(KIND(1D0)),INTENT(IN)::lat
    REAL(KIND(1D0)),INTENT(IN)::ldown_obs
    REAL(KIND(1D0)),INTENT(IN)::lng
    REAL(KIND(1D0)),INTENT(IN)::MaxQFMetab
    REAL(KIND(1D0)),INTENT(IN)::MinQFMetab
    REAL(KIND(1D0)),INTENT(IN)::NARP_EMIS_SNOW
    REAL(KIND(1D0)),INTENT(IN)::NARP_TRANS_SITE
    REAL(KIND(1D0)),INTENT(IN)::NumCapita
    REAL(KIND(1D0)),INTENT(IN)::PipeCapacity
    REAL(KIND(1D0)),INTENT(IN)::PopDensDaytime
    REAL(KIND(1D0)),INTENT(IN)::PopDensNighttime
    REAL(KIND(1D0)),INTENT(IN)::PorMax_dec
    REAL(KIND(1D0)),INTENT(IN)::PorMin_dec
    REAL(KIND(1D0)),INTENT(IN)::Precip
    REAL(KIND(1D0)),INTENT(IN)::PrecipLimit
    REAL(KIND(1D0)),INTENT(IN)::PrecipLimitAlb
    REAL(KIND(1D0)),INTENT(IN)::Press_hPa
    REAL(KIND(1D0)),INTENT(IN)::qh_obs
    REAL(KIND(1D0)),INTENT(IN)::qn1_obs
    REAL(KIND(1D0)),INTENT(IN)::qs_obs
    REAL(KIND(1D0)),INTENT(IN)::qf_obs
    REAL(KIND(1D0)),INTENT(IN)::RadMeltFact
    REAL(KIND(1D0)),INTENT(IN)::RAINCOVER
    REAL(KIND(1D0)),INTENT(IN)::RainMaxRes
    REAL(KIND(1D0)),INTENT(IN)::RunoffToWater
    REAL(KIND(1D0)),INTENT(IN)::S1
    REAL(KIND(1D0)),INTENT(IN)::S2
    REAL(KIND(1D0)),INTENT(IN)::SnowAlbMax
    REAL(KIND(1D0)),INTENT(IN)::SnowAlbMin
    REAL(KIND(1D0)),INTENT(IN)::SnowDensMax
    REAL(KIND(1D0)),INTENT(IN)::SnowDensMin
    REAL(KIND(1D0)),INTENT(IN)::SnowLimBuild
    REAL(KIND(1D0)),INTENT(IN)::SnowLimPaved
    REAL(KIND(1D0)),INTENT(IN)::snow_obs
    REAL(KIND(1D0)),INTENT(IN)::SurfaceArea
    REAL(KIND(1D0)),INTENT(IN)::tau_a
    REAL(KIND(1D0)),INTENT(IN)::tau_f
    REAL(KIND(1D0)),INTENT(IN)::tau_r
    REAL(KIND(1D0)),INTENT(IN)::Temp_C
    REAL(KIND(1D0)),INTENT(IN)::TempMeltFact
    REAL(KIND(1D0)),INTENT(IN)::TH
    REAL(KIND(1D0)),INTENT(IN)::timezone
    REAL(KIND(1D0)),INTENT(IN)::TL
    REAL(KIND(1D0)),INTENT(IN)::TrafficUnits
    REAL(KIND(1D0)),INTENT(IN)::xsmd
    REAL(KIND(1D0)),INTENT(IN)::Z
    REAL(KIND(1D0)),INTENT(IN)::z0m_in
    REAL(KIND(1D0)),INTENT(IN)::zdm_in

    INTEGER,DIMENSION(NVEGSURF),INTENT(IN)::LAIType

    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::AH_MIN
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::AH_SLOPE_Cooling
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::AH_SLOPE_Heating
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::QF0_BEU
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::Qf_A
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::Qf_B
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::Qf_C
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::T_CRITIC_Cooling
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::T_CRITIC_Heating
    REAL(KIND(1D0)),DIMENSION(2),INTENT(IN)               ::TrafficRate
    REAL(KIND(1D0)),DIMENSION(3),INTENT(IN)               ::Ie_a
    REAL(KIND(1D0)),DIMENSION(3),INTENT(IN)               ::Ie_m
    REAL(KIND(1D0)),DIMENSION(3),INTENT(IN)               ::MaxConductance
    REAL(KIND(1D0)),DIMENSION(7),INTENT(IN)               ::DayWat
    REAL(KIND(1D0)),DIMENSION(7),INTENT(IN)               ::DayWatPer
    REAL(KIND(1D0)),DIMENSION(nsurf+1),INTENT(IN)         ::OHM_threshSW
    REAL(KIND(1D0)),DIMENSION(nsurf+1),INTENT(IN)         ::OHM_threshWD
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::chAnOHM
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::cpAnOHM
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::emis
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::kkAnOHM
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::SatHydraulicConduct
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::sfr
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::snowD
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::SoilDepth
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::soilstoreCap
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::StateLimit
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)           ::WetThresh
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::alpha_bioCO2
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::alpha_enh_bioCO2
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::BaseT
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::BaseTe
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::beta_bioCO2
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::beta_enh_bioCO2
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::GDDFull
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::LAIMax
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::LAIMin
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::min_res_bioCO2
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::resp_a
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::resp_b
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::SDDFull
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(IN)          ::SnowProf_24hr
    REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(IN)        ::theta_bioCO2
    REAL(KIND(1D0)),DIMENSION(4,NVEGSURF),INTENT(IN)      ::LAIPower
    REAL(KIND(1D0)),DIMENSION(nsurf+1,4,3),INTENT(IN)     ::OHM_coef
    REAL(KIND(1D0)),DIMENSION(NSURF+1,NSURF-1),INTENT(IN) ::WaterDist
    REAL(KIND(1d0)),DIMENSION(:),INTENT(IN)               ::Ts5mindata_ir
    REAL(KIND(1D0)),DIMENSION(:,:),INTENT(IN)             ::MetForcingData_grid

    ! REAL(KIND(1D0)),DIMENSION(24*3600/tstep,2),INTENT(IN) ::AHProf_tstep
    ! REAL(KIND(1D0)),DIMENSION(24*3600/tstep,2),INTENT(IN) ::HumActivity_tstep
    ! REAL(KIND(1D0)),DIMENSION(24*3600/tstep,2),INTENT(IN) ::PopProf_tstep
    ! REAL(KIND(1D0)),DIMENSION(24*3600/tstep,2),INTENT(IN) ::TraffProf_tstep
    ! REAL(KIND(1D0)),DIMENSION(24*3600/tstep,2),INTENT(IN) ::WUProfA_tstep
    ! REAL(KIND(1D0)),DIMENSION(24*3600/tstep,2),INTENT(IN) ::WUProfM_tstep

    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(IN) ::AHProf_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(IN) ::HumActivity_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(IN) ::PopProf_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(IN) ::TraffProf_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(IN) ::WUProfA_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(IN) ::WUProfM_24hr

    ! inout variables
    REAL(KIND(1D0)),INTENT(INOUT)                             ::SnowfallCum
    REAL(KIND(1D0)),INTENT(INOUT)                             ::SnowAlb
    REAL(KIND(1d0)),INTENT(INOUT)                             ::qn1_av
    REAL(KIND(1d0)),INTENT(INOUT)                             ::dqndt
    REAL(KIND(1d0)),INTENT(INOUT)                             ::qn1_s_av
    REAL(KIND(1d0)),INTENT(INOUT)                             ::dqnsdt
    REAL(KIND(1d0)),DIMENSION(24*3600/tstep),INTENT(INOUT)    ::Tair24HR
    ! REAL(KIND(1D0)),DIMENSION(2*3600/tstep+1),INTENT(INOUT)   ::qn1_av_store_grid
    ! REAL(KIND(1D0)),DIMENSION(3600/tstep),INTENT(INOUT)       ::qn1_store_grid
    ! REAL(KIND(1D0)),DIMENSION(2*3600/tstep+1),INTENT(INOUT)   ::qn1_S_av_store_grid
    ! REAL(KIND(1D0)),DIMENSION(3600/tstep),INTENT(INOUT)       ::qn1_S_store_grid

    ! REAL(KIND(1D0)),DIMENSION(0:NDAYS),INTENT(INOUT)          ::albDecTr
    ! REAL(KIND(1D0)),DIMENSION(0:NDAYS),INTENT(INOUT)          ::albEveTr
    ! REAL(KIND(1D0)),DIMENSION(0:NDAYS),INTENT(INOUT)          ::albGrass
    ! REAL(KIND(1D0)),DIMENSION(0:NDAYS),INTENT(INOUT)          ::DecidCap
    ! REAL(KIND(1D0)),DIMENSION(0:NDAYS),INTENT(INOUT)          ::porosity

    ! REAL(KIND(1D0)),DIMENSION(0:NDAYS,5),INTENT(INOUT)        ::GDD

    ! REAL(KIND(1D0)),DIMENSION(0:NDAYS,9),INTENT(INOUT)        ::WUDay

    REAL(KIND(1D0)),DIMENSION(6,NSURF),INTENT(INOUT)          ::StoreDrainPrm
    ! REAL(KIND(1D0)),DIMENSION(-4:NDAYS,6),INTENT(INOUT)       ::HDD
    ! REAL(KIND(1D0)),DIMENSION(-4:NDAYS,NVEGSURF),INTENT(INOUT)::LAI
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::alb
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::IceFrac
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::MeltWaterStore
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::SnowDens
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::snowFrac
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::SnowPack
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::soilmoist_id
    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(INOUT)   ::state_id
    REAL(KIND(1d0)),DIMENSION(5),INTENT(INOUT)       ::GDD_id !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(12),INTENT(INOUT)       ::HDD_id !Heating Degree Days (see SUEWS_DailyState.f95)
    ! REAL(KIND(1d0)),DIMENSION(6),INTENT(INOUT)       ::HDD_id_use !Heating Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(INOUT)::LAI_id !LAI for each veg surface [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(9),INTENT(OUT)::WUDay_id

    REAL(KIND(1d0)),INTENT(INOUT):: DecidCap_id
    REAL(KIND(1d0)),INTENT(INOUT):: albDecTr_id
    REAL(KIND(1d0)),INTENT(INOUT):: albEveTr_id
    REAL(KIND(1d0)),INTENT(INOUT):: albGrass_id
    REAL(KIND(1d0)),INTENT(INOUT):: porosity_id


    ! output variables
    REAL(KIND(1D0)),DIMENSION(5),INTENT(OUT)                           ::datetimeLine
    REAL(KIND(1D0)),DIMENSION(ncolumnsDataOutSUEWS-5),INTENT(OUT)      ::dataOutLineSUEWS
    REAL(KIND(1D0)),DIMENSION(ncolumnsDataOutSnow-5),INTENT(OUT)       ::dataOutLineSnow
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutESTM-5),INTENT(OUT)       ::dataOutLineESTM
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutDailyState-5),INTENT(OUT) ::DailyStateLine

    ! local variables
    REAL(KIND(1D0))::a1
    REAL(KIND(1D0))::a2
    REAL(KIND(1D0))::a3
    REAL(KIND(1D0))::AdditionalWater
    REAL(KIND(1D0))::avU10_ms
    REAL(KIND(1D0))::azimuth
    REAL(KIND(1D0))::chSnow_per_interval

    REAL(KIND(1D0))::dens_dry
    REAL(KIND(1d0))::deltaLAI
    REAL(KIND(1D0))::drain_per_tstep
    REAL(KIND(1D0))::Ea_hPa
    REAL(KIND(1D0))::E_mod
    REAL(KIND(1D0))::es_hPa
    REAL(KIND(1D0))::ev
    REAL(KIND(1D0))::ev_per_tstep
    REAL(KIND(1D0))::ext_wu
    REAL(KIND(1D0))::Fc
    REAL(KIND(1D0))::Fc_anthro
    REAL(KIND(1D0))::Fc_biogen
    REAL(KIND(1D0))::Fc_build
    REAL(KIND(1D0))::fcld
    REAL(KIND(1D0))::Fc_metab
    REAL(KIND(1D0))::Fc_photo
    REAL(KIND(1D0))::Fc_respi
    REAL(KIND(1D0))::Fc_traff
    REAL(KIND(1D0))::fwh
    REAL(KIND(1D0))::gsc
    REAL(KIND(1D0))::H_mod
    REAL(KIND(1D0))::int_wu
    REAL(KIND(1D0))::kclear
    REAL(KIND(1D0))::kup
    REAL(KIND(1D0))::ldown
    REAL(KIND(1D0))::lup
    REAL(KIND(1D0))::L_mod
    REAL(KIND(1D0))::mwh
    REAL(KIND(1D0))::mwstore
    REAL(KIND(1D0))::NWstate_per_tstep
    REAL(KIND(1D0))::planF
    REAL(KIND(1D0))::p_mm
    REAL(KIND(1D0))::zL
    REAL(KIND(1D0))::q2_gkg
    REAL(KIND(1D0))::qeOut
    REAL(KIND(1D0))::qe_per_tstep
    REAL(KIND(1D0))::qf
    REAL(KIND(1D0))::QF_SAHP
    REAL(KIND(1D0))::qh
    REAL(KIND(1D0))::qh_residual
    REAL(KIND(1D0))::qh_resist
    REAL(KIND(1D0))::Qm
    REAL(KIND(1D0))::QmFreez
    REAL(KIND(1D0))::QmRain
    REAL(KIND(1D0))::qn1
    REAL(KIND(1D0))::qn1_S
    REAL(KIND(1D0))::qn1_snowfree
    REAL(KIND(1D0))::qs
    REAL(KIND(1D0))::RA
    REAL(KIND(1D0))::ResistSurf
    REAL(KIND(1D0))::rss
    REAL(KIND(1d0))::runoffAGveg
    REAL(KIND(1d0))::runoffAGimpervious
    REAL(KIND(1D0))::runoff_per_tstep
    REAL(KIND(1D0))::runoffPipes
    REAL(KIND(1D0))::runoffPipes_m3
    REAL(KIND(1D0))::runoffSoil_per_tstep
    REAL(KIND(1D0))::runoffwaterbody
    REAL(KIND(1D0))::runoffWaterBody_m3
    REAL(KIND(1D0))::smd
    REAL(KIND(1D0))::SoilState
    REAL(KIND(1D0))::state_per_tstep
    REAL(KIND(1D0))::surf_chang_per_tstep
    REAL(KIND(1D0))::swe
    REAL(KIND(1D0))::t2_C
    REAL(KIND(1D0))::tskin_C
    REAL(KIND(1D0))::TempVeg
    REAL(KIND(1D0))::tot_chang_per_tstep
    REAL(KIND(1D0))::TStar
    REAL(KIND(1D0))::tsurf
    REAL(KIND(1D0))::UStar
    REAL(KIND(1D0))::VPD_Pa
    REAL(KIND(1D0))::WUAreaDecTr_m2
    REAL(KIND(1D0))::WUAreaEveTr_m2
    REAL(KIND(1D0))::WUAreaGrass_m2
    REAL(KIND(1D0))::WUAreaTotal_m2
    REAL(KIND(1D0))::wu_DecTr
    REAL(KIND(1D0))::wu_EveTr
    REAL(KIND(1D0))::wu_Grass
    REAL(KIND(1D0))::wu_m3
    REAL(KIND(1D0))::z0m
    REAL(KIND(1D0))::zdm
    REAL(KIND(1D0))::ZENITH_deg
    REAL(KIND(1D0))::Zh



    REAL(KIND(1d0)),DIMENSION(nvegsurf):: LAI_id_prev !LAI for each veg surface [m2 m-2]

    REAL(KIND(1D0)),DIMENSION(2)::SnowRemoval
    REAL(KIND(1D0)),DIMENSION(NSURF)::chang
    REAL(KIND(1D0)),DIMENSION(NSURF)::changSnow
    REAL(KIND(1D0)),DIMENSION(NSURF)::evap
    REAL(KIND(1D0)),DIMENSION(NSURF)::ev_snow
    REAL(KIND(1D0)),DIMENSION(NSURF)::FreezMelt
    REAL(KIND(1d0)),DIMENSION(nsurf)::kup_ind_snow
    REAL(KIND(1D0)),DIMENSION(NSURF)::mw_ind
    REAL(KIND(1D0)),DIMENSION(NSURF)::Qm_freezState
    REAL(KIND(1D0)),DIMENSION(NSURF)::Qm_melt
    REAL(KIND(1D0)),DIMENSION(NSURF)::Qm_rain
    REAL(KIND(1D0)),DIMENSION(NSURF)::qn1_ind_snow
    REAL(KIND(1D0)),DIMENSION(NSURF)::rainOnSnow
    REAL(KIND(1D0)),DIMENSION(NSURF)::rss_nsurf
    REAL(KIND(1D0)),DIMENSION(NSURF)::runoff
    REAL(KIND(1D0)),DIMENSION(NSURF)::runoffSnow
    REAL(KIND(1D0)),DIMENSION(NSURF)::runoffSoil
    REAL(KIND(1D0)),DIMENSION(NSURF)::smd_nsurf
    REAL(KIND(1D0)),DIMENSION(NSURF)::SnowToSurf
    REAL(KIND(1D0)),DIMENSION(NSURF)::snowDepth


    REAL(KIND(1d0)),DIMENSION(nsurf)::Tsurf_ind_snow

    INTEGER,DIMENSION(NSURF)::snowCalcSwitch
    INTEGER,DIMENSION(3)    ::dayofWeek_id
    INTEGER::DLS

    REAL(KIND(1D0))::avcp
    REAL(KIND(1D0))::avdens
    REAL(KIND(1D0))::dq
    REAL(KIND(1D0))::lv_J_kg
    REAL(KIND(1D0))::lvS_J_kg
    REAL(KIND(1D0))::psyc_hPa
    REAL(KIND(1D0))::qe
    REAL(KIND(1D0))::RAsnow
    REAL(KIND(1D0))::rb
    REAL(KIND(1D0))::runoff_per_interval
    REAL(KIND(1D0))::s_hPa
    REAL(KIND(1D0))::sIce_hpa
    REAL(KIND(1D0))::SoilMoistCap
    REAL(KIND(1D0))::veg_fr
    REAL(KIND(1D0))::VegPhenLumps
    REAL(KIND(1D0))::VPd_hpa
    REAL(KIND(1D0))::vsmd
    REAL(KIND(1D0))::ZZD

    REAL(KIND(1D0)),DIMENSION(NSURF)::deltaQi
    REAL(KIND(1D0)),DIMENSION(NSURF)::drain
    REAL(KIND(1D0)),DIMENSION(NSURF)::FreezState
    REAL(KIND(1D0)),DIMENSION(NSURF)::FreezStateVol
    REAL(KIND(1D0)),DIMENSION(NSURF)::soilmoistOld
    REAL(KIND(1D0)),DIMENSION(NSURF)::stateOld
    REAL(KIND(1D0)),DIMENSION(NSURF)::tsurf_ind

    ! TODO: TS 25 Oct 2017
    ! the `add-*` variables are not used currently as grid-to-grid connection is NOT set up.
    ! set these variables as zero.
    REAL(KIND(1D0))::addImpervious=0
    REAL(KIND(1D0))::addPipes=0
    REAL(KIND(1D0))::addVeg=0
    REAL(KIND(1D0))::addWaterBody=0
    REAL(KIND(1D0)),DIMENSION(NSURF)::AddWater=0
    REAL(KIND(1D0)),DIMENSION(NSURF)::AddWaterRunoff=0

    ! values that are derived from tstep
    INTEGER::nsh ! number of timesteps per hour
    REAL(KIND(1D0))::nsh_real ! nsh in type real
    REAL(KIND(1D0))::tstep_real ! tstep in type real
    REAL(KIND(1D0))::dectime

    ! values that are derived from sfr (surface fractions)
    REAL(KIND(1D0))::VegFraction
    REAL(KIND(1D0))::ImpervFraction
    REAL(KIND(1D0))::PervFraction
    REAL(KIND(1D0))::NonWaterFraction

    ! calculate dectime
    CALL SUEWS_cal_dectime(&
         id,it,imin,isec,& ! input
         dectime) ! output

    ! calculate tstep related VARIABLES
    CALL SUEWS_cal_tstep(&
         tstep,& ! input
         nsh, nsh_real, tstep_real) ! output

    ! calculate surface fraction related VARIABLES
    CALL SUEWS_cal_surf(&
         sfr,& !input
         VegFraction,ImpervFraction,PervFraction,NonWaterFraction) ! output

    ! calculate dayofweek information
    CALL SUEWS_cal_weekday(&
         iy,id,lat,& !input
         dayofWeek_id) !output

    ! calculate dayofweek information
    CALL SUEWS_cal_DLS(&
         id,startDLS,endDLS,& !input
         DLS) !output


    !==============main calculation start=======================
    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_cal_RoughnessParameters...'
    IF(Diagnose==1) PRINT*, 'z0m_in =',z0m_in
    CALL SUEWS_cal_RoughnessParameters(&
         RoughLenMomMethod,sfr,&!input
         bldgH,EveTreeH,DecTreeH,&
         porosity_id,FAIBldg,FAIEveTree,FAIDecTree,&
         z0m_in,zdm_in,Z,&
         planF,&!output
         Zh,z0m,zdm,ZZD)

    ! Calculate sun position
    IF(Diagnose==1) WRITE(*,*) 'Calling NARP_cal_SunPosition...'
    CALL NARP_cal_SunPosition(&
         REAL(iy,KIND(1d0)),&!input:
         dectime-tstep/2,&! sun position at middle of timestep before
         timezone,lat,lng,alt,&
         azimuth,zenith_deg)!output:


    !Call the SUEWS_cal_DailyState routine to get surface characteristics ready
    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_cal_DailyState...'
    CALL SUEWS_cal_DailyState(&
         iy,id,it,imin,isec,tstep,tstep_prev,dt_since_start,DayofWeek_id,&!input
         WaterUseMethod,snowUse,Ie_start,Ie_end,&
         LAICalcYes,LAIType,&
         nsh_real,avkdn,Temp_C,Precip,BaseTHDD,&
         lat,Faut,LAI_obs,tau_a,tau_f,tau_r,&
         SnowDensMax,SnowDensMin,SnowAlbMin,&
         AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
         AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
         CapMax_dec,CapMin_dec,PorMax_dec,PorMin_dec,&
         Ie_a,Ie_m,DayWatPer,DayWat,SnowPack,&
         BaseT,BaseTe,GDDFull,SDDFull,LAIMin,LAIMax,LAIPower,&
         SnowAlb,SnowDens,&!inout
         GDD_id,HDD_id,LAI_id,LAI_id_prev,WUDay_id,&
         DecidCap_id,albDecTr_id,albEveTr_id,albGrass_id,porosity_id,&
         deltaLAI)!output


    !Calculation of density and other water related parameters
    IF(Diagnose==1) WRITE(*,*) 'Calling LUMPS_cal_AtmMoist...'
    CALL LUMPS_cal_AtmMoist(&
         Temp_C,Press_hPa,avRh,dectime,&! input:
         lv_J_kg,lvS_J_kg,&! output:
         es_hPa,Ea_hPa,VPd_hpa,VPD_Pa,dq,dens_dry,avcp,avdens)


    !======== Calculate soil moisture =========
    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_update_SoilMoist...'
    CALL SUEWS_update_SoilMoist(&
         NonWaterFraction,&!input
         soilstoreCap,sfr,soilmoist_id,&
         SoilMoistCap,SoilState,&!output
         vsmd,smd)


    ! ===================NET ALLWAVE RADIATION================================
    CALL SUEWS_cal_Qn(&
         NetRadiationMethod,snowUse,&!input
         Diagnose,snow_obs,ldown_obs,fcld_obs,&
         dectime,ZENITH_deg,avKdn,Temp_C,avRH,ea_hPa,qn1_obs,&
         SnowAlb,DiagQN,&
         NARP_TRANS_SITE,NARP_EMIS_SNOW,IceFrac,sfr,emis,&
         alb,albDecTr_id,DecidCap_id,albEveTr_id,albGrass_id,StoreDrainPrm,&!inout
         snowFrac,ldown,fcld,&!output
         qn1,qn1_snowfree,qn1_S,kclear,kup,lup,tsurf,&
         qn1_ind_snow,kup_ind_snow,Tsurf_ind_snow,Tsurf_ind)


    ! ===================ANTHROPOGENIC HEAT FLUX================================
    CALL SUEWS_cal_AnthropogenicEmission(&
         QF_obs,&
         AH_MIN,AHProf_24hr,AH_SLOPE_Cooling,AH_SLOPE_Heating,alpha_bioCO2,&
         alpha_enh_bioCO2,avkdn,beta_bioCO2,beta_enh_bioCO2,dayofWeek_id,&
         Diagnose,DLS,EF_umolCO2perJ,EmissionsMethod,EnEF_v_Jkm,Fc,Fc_anthro,Fc_biogen,&
         Fc_build,FcEF_v_kgkm,Fc_metab,Fc_photo,Fc_respi,Fc_traff,FrFossilFuel_Heat,&
         FrFossilFuel_NonHeat,HDD_id,HumActivity_24hr,id,imin,it,LAI_id,LAIMax,LAIMin,&
         MaxQFMetab,MinQFMetab,min_res_bioCO2,nsh,NumCapita,&
         PopDensDaytime,PopDensNighttime,PopProf_24hr,QF,QF0_BEU,Qf_A,Qf_B,Qf_C,QF_SAHP,&
         resp_a,resp_b,sfr,snowFrac,T_CRITIC_Cooling,T_CRITIC_Heating,Temp_C,&
         theta_bioCO2,TrafficRate,TrafficUnits,TraffProf_24hr)


    ! =================STORAGE HEAT FLUX=======================================
    CALL SUEWS_cal_Qs(&
         StorageHeatMethod,qs_obs,OHMIncQF,Gridiv,&!input
         id,tstep,dt_since_start,Diagnose,sfr,&
         OHM_coef,OHM_threshSW,OHM_threshWD,&
         soilmoist_id,soilstoreCap,state_id,nsh,SnowUse,DiagQS,&
         HDD_id,MetForcingData_grid,Ts5mindata_ir,qf,qn1,&
         avkdn, avu1, temp_c, zenith_deg, avrh, press_hpa, ldown,&
         bldgh,alb,emis,cpAnOHM,kkAnOHM,chAnOHM,EmissionsMethod,&
         Tair24HR,qn1_av,dqndt,qn1_s_av,dqnsdt,&!inout
         StoreDrainPrm,&
         qn1_S,snowFrac,dataOutLineESTM,qs,&!output
         deltaQi,a1,a2,a3)


    !==================Energy related to snow melting/freezing processes=======
    IF(Diagnose==1) WRITE(*,*) 'Calling MeltHeat'
    CALL Snow_cal_MeltHeat(&
         snowUse,&!input
         lvS_J_kg,lv_J_kg,tstep_real,RadMeltFact,TempMeltFact,SnowAlbMax,&
         SnowDensMin,Temp_C,Precip,PrecipLimit,PrecipLimitAlb,&
         nsh_real,sfr,Tsurf_ind,Tsurf_ind_snow,state_id,qn1_ind_snow,&
         kup_ind_snow,Meltwaterstore,deltaQi,&
         SnowPack,snowFrac,SnowAlb,SnowDens,SnowfallCum,&!inout
         mwh,fwh,Qm,QmFreez,QmRain,&! output
         veg_fr,snowCalcSwitch,Qm_melt,Qm_freezState,Qm_rain,FreezMelt,&
         FreezState,FreezStateVol,rainOnSnow,SnowDepth,mw_ind,&
         dataOutLineSnow)!output



    !==========================Turbulent Fluxes================================
    IF(Diagnose==1) WRITE(*,*) 'Calling LUMPS_cal_QHQE...'
    !Calculate QH and QE from LUMPS
    CALL LUMPS_cal_QHQE(&
         veg_type,& !input
         snowUse,qn1,qf,qs,Qm,Temp_C,Veg_Fr,avcp,Press_hPa,lv_J_kg,&
         tstep_real,DRAINRT,nsh_real,&
         Precip,RainMaxRes,RAINCOVER,sfr,LAI_id,LAImax,LAImin,&
         H_mod,& !output
         E_mod,psyc_hPa,s_hPa,sIce_hpa,TempVeg,VegPhenLumps)


    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_cal_WaterUse...'
    !Gives the external and internal water uses per timestep
    CALL SUEWS_cal_WaterUse(&
         nsh_real,& ! input:
         SurfaceArea,sfr,&
         IrrFracConif,IrrFracDecid,IrrFracGrass,&
         dayofWeek_id,WUProfA_24hr,WUProfM_24hr,&
         InternalWaterUse_h,HDD_id,WUDay_id,&
         WaterUseMethod,NSH,it,imin,DLS,&
         WUAreaEveTr_m2,WUAreaDecTr_m2,& ! output:
         WUAreaGrass_m2,WUAreaTotal_m2,&
         wu_EveTr,wu_DecTr,wu_Grass,wu_m3,int_wu,ext_wu)


    !===============Resistance Calculations=======================
    CALL SUEWS_cal_Resistance(&
         StabilityMethod,&!input:
         Diagnose,AerodynamicResistanceMethod,RoughLenHeatMethod,snowUse,&
         id,it,gsModel,SMDMethod,&
         qh_obs,avdens,avcp,h_mod,qn1,dectime,zzd,z0m,zdm,&
         avU1,Temp_C,VegFraction,avkdn,&
         Kmax,&
         g1,g2,g3,g4,&
         g5,g6,s1,s2,&
         th,tl,&
         dq,xsmd,vsmd,MaxConductance,LAIMax,LAI_id,snowFrac,sfr,&
         UStar,TStar,L_mod,&!output
         zL,gsc,ResistSurf,RA,RAsnow,rb)


    !============= calculate water balance =============
    CALL SUEWS_cal_Water(&
         Diagnose,&!input
         snowUse,NonWaterFraction,addPipes,addImpervious,addVeg,addWaterBody,&
         state_id,soilmoist_id,sfr,StoreDrainPrm,WaterDist,nsh_real,&
         drain_per_tstep,&  !output
         drain,AddWaterRunoff,&
         AdditionalWater,runoffPipes,runoff_per_interval,&
         AddWater,stateOld,soilmoistOld)
    !============= calculate water balance end =============

    !======== Evaporation and surface state_id ========
    CALL SUEWS_cal_QE(&
         Diagnose,&!input
         tstep,imin,it,EvapMethod,snowCalcSwitch,DayofWeek_id,CRWmin,CRWmax,&
         nsh_real,dectime,lvS_J_kg,lv_j_kg,avdens,avRh,Press_hPa,Temp_C,&
         RAsnow,psyc_hPa,avcp,sIce_hPa,&
         PervFraction,vegfraction,addimpervious,qn1_snowfree,qf,qs,vpd_hPa,s_hPa,&
         ResistSurf,RA,rb,tstep_real,snowdensmin,precip,PipeCapacity,RunoffToWater,&
         NonWaterFraction,wu_EveTr,wu_DecTr,wu_Grass,addVeg,addWaterBody,SnowLimPaved,SnowLimBuild,&
         SurfaceArea,FlowChange,drain,WetThresh,stateOld,mw_ind,soilstorecap,rainonsnow,&
         freezmelt,freezstate,freezstatevol,Qm_Melt,Qm_rain,Tsurf_ind,sfr,&
         StateLimit,AddWater,addwaterrunoff,StoreDrainPrm,snowD,&
         runoff_per_interval,state_id,soilmoist_id,SnowPack,snowFrac,MeltWaterStore,&! inout:
         iceFrac,SnowDens,&
         SnowProf_24hr,& ! output:
         runoffSnow,runoff,runoffSoil,chang,changSnow,&
         snowDepth,SnowToSurf,ev_snow,SnowRemoval,&
         evap,rss_nsurf,p_mm,rss,qe,state_per_tstep,NWstate_per_tstep,qeOut,&
         swe,ev,chSnow_per_interval,ev_per_tstep,qe_per_tstep,runoff_per_tstep,&
         surf_chang_per_tstep,runoffPipes,mwstore,runoffwaterbody,&
         runoffAGveg,runoffAGimpervious,runoffWaterBody_m3,runoffPipes_m3)
    !======== Evaporation and surface state_id end========

    !============ Sensible heat flux ===============
    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_cal_QH...'
    CALL SUEWS_cal_QH(&
         1,&
         qn1,qf,QmRain,qeOut,qs,QmFreez,qm,avdens,avcp,tsurf,Temp_C,RA,&
         qh,qh_residual,qh_resist)!output
    !============ Sensible heat flux end===============

    !=== Horizontal movement between soil stores ===
    ! Now water is allowed to move horizontally between the soil stores
    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_cal_HorizontalSoilWater...'
    CALL SUEWS_cal_HorizontalSoilWater(&
         sfr,&! input: ! surface fractions
         SoilStoreCap,&!Capacity of soil store for each surface [mm]
         SoilDepth,&!Depth of sub-surface soil store for each surface [mm]
         SatHydraulicConduct,&!Saturated hydraulic conductivity for each soil subsurface [mm s-1]
         SurfaceArea,&!Surface area of the study area [m2]
         NonWaterFraction,&! sum of surface cover fractions for all except water surfaces
         tstep_real,& !tstep cast as a real for use in calculations
         soilmoist_id,&! inout:!Soil moisture of each surface type [mm]
         runoffSoil,&!Soil runoff from each soil sub-surface [mm]
         runoffSoil_per_tstep&!  output:!Runoff to deep soil per timestep [mm] (for whole surface, excluding water body)
         )

    !========== Calculate soil moisture ============
    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_cal_SoilMoist...'
    CALL SUEWS_cal_SoilMoist(&
         SMDMethod,xsmd,NonWaterFraction,SoilMoistCap,&!input
         SoilStoreCap,surf_chang_per_tstep,&
         soilmoist_id,soilmoistOld,sfr,&
         smd,smd_nsurf,tot_chang_per_tstep,SoilState)!output


    !============ surface-level diagonostics ===============
    IF(Diagnose==1) WRITE(*,*) 'Calling SUEWS_cal_Diagnostics...'
    CALL SUEWS_cal_Diagnostics(&
         dectime,&!input
         avU1,Temp_C,avRH,Press_hPa,&
         qh,qe,&
         VegFraction,z,z0m,zdm,RA,avdens,avcp,lv_J_kg,tstep_real,&
         RoughLenHeatMethod,StabilityMethod,&
         avU10_ms,t2_C,q2_gkg,tskin_C)!output
    !============ surface-level diagonostics end ===============


    !==============main calculation end=======================

    !==============translation of  output variables into output array===========
    CALL SUEWS_update_outputLine(&
         AdditionalWater,alb,avkdn,avU10_ms,azimuth,&!input
         chSnow_per_interval,dectime,&
         drain_per_tstep,E_mod,ev_per_tstep,ext_wu,Fc,Fc_build,fcld,&
         Fc_metab,Fc_photo,Fc_respi,Fc_traff,FlowChange,&
         h_mod,id,imin,int_wu,it,iy,&
         kup,LAI_id,ldown,l_mod,lup,mwh,&
         MwStore,&
         nsh_real,NWstate_per_tstep,Precip,q2_gkg,&
         qeOut,qf,qh,qh_resist,Qm,QmFreez,&
         QmRain,qn1,qn1_S,qn1_snowfree,qs,RA,&
         resistsurf,runoffAGimpervious,runoffAGveg,&
         runoff_per_tstep,runoffPipes,runoffSoil_per_tstep,&
         runoffWaterBody,sfr,smd,smd_nsurf,SnowAlb,SnowRemoval,&
         state_id,state_per_tstep,surf_chang_per_tstep,swe,t2_C,tskin_C,&
         tot_chang_per_tstep,tsurf,UStar,wu_DecTr,&
         wu_EveTr,wu_Grass,z0m,zdm,zenith_deg,&
         datetimeLine,dataOutLineSUEWS)!output

    ! model state_id:

    ! daily state_id:
    CALL update_DailyState(&
         it,imin,nsh_real,&!input
         GDD_id,HDD_id,LAI_id,&
         DecidCap_id,&
         albDecTr_id,&
         albEveTr_id,&
         albGrass_id,&
         porosity_id,&
         WUDay_id,&
         deltaLAI,VegPhenLumps,&
         SnowAlb,SnowDens,&
         a1,a2,a3,&
         DailyStateLine)!out

    !==============translation end ================

  END SUBROUTINE SUEWS_cal_Main
  ! ================================================================================

  ! ===================ANTHROPOGENIC HEAT + CO2 FLUX================================
  SUBROUTINE SUEWS_cal_AnthropogenicEmission(&
       QF_obs,&
       AH_MIN,AHProf_24hr,AH_SLOPE_Cooling,AH_SLOPE_Heating,alpha_bioCO2,&
       alpha_enh_bioCO2,avkdn,beta_bioCO2,beta_enh_bioCO2,dayofWeek_id,&
       Diagnose,DLS,EF_umolCO2perJ,EmissionsMethod,EnEF_v_Jkm,Fc,Fc_anthro,Fc_biogen,&
       Fc_build,FcEF_v_kgkm,Fc_metab,Fc_photo,Fc_respi,Fc_traff,FrFossilFuel_Heat,&
       FrFossilFuel_NonHeat,HDD_id,HumActivity_24hr,id,imin,it,LAI_id,LAIMax,LAIMin,&
       MaxQFMetab,MinQFMetab,min_res_bioCO2,nsh,NumCapita,&
       PopDensDaytime,PopDensNighttime,PopProf_24hr,QF,QF0_BEU,Qf_A,Qf_B,Qf_C,QF_SAHP,&
       resp_a,resp_b,sfr,snowFrac,T_CRITIC_Cooling,T_CRITIC_Heating,Temp_C,&
       theta_bioCO2,TrafficRate,TrafficUnits,TraffProf_24hr)

    IMPLICIT NONE

    INTEGER,INTENT(in)::Diagnose
    INTEGER,INTENT(in)::EmissionsMethod
    INTEGER,INTENT(in)::id
    INTEGER,INTENT(in)::it
    INTEGER,INTENT(in)::imin
    INTEGER,INTENT(in)::DLS
    INTEGER,INTENT(in)::nsh
    ! INTEGER,INTENT(in)::notUsedI
    INTEGER,DIMENSION(3),INTENT(in)::dayofWeek_id
    REAL(KIND(1d0)),DIMENSION(6,2),INTENT(in)::HDD_id
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::Qf_A
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::Qf_B
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::Qf_C
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::AH_MIN
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::AH_SLOPE_Heating
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::AH_SLOPE_Cooling
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::T_CRITIC_Heating
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::T_CRITIC_Cooling
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::TrafficRate
    REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::QF0_BEU
    REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in)::AHProf_24hr
    REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in)::HumActivity_24hr
    REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in)::TraffProf_24hr
    REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in)::PopProf_24hr
    REAL(KIND(1D0)),INTENT(in)::EF_umolCO2perJ
    REAL(KIND(1D0)),INTENT(in)::FcEF_v_kgkm
    REAL(KIND(1D0)),INTENT(in)::EnEF_v_Jkm
    REAL(KIND(1D0)),INTENT(in)::TrafficUnits
    REAL(KIND(1D0)),INTENT(in)::FrFossilFuel_Heat
    REAL(KIND(1D0)),INTENT(in)::FrFossilFuel_NonHeat
    REAL(KIND(1D0)),INTENT(in)::MinQFMetab
    REAL(KIND(1D0)),INTENT(in)::MaxQFMetab
    REAL(KIND(1D0)),INTENT(in)::NumCapita
    REAL(KIND(1D0)),INTENT(in)::PopDensDaytime
    REAL(KIND(1D0)),INTENT(in)::PopDensNighttime
    REAL(KIND(1D0)),INTENT(in)::Temp_C
    REAL(KIND(1D0)),INTENT(in)::QF_obs
    REAL(KIND(1D0)),INTENT(out)::QF
    REAL(KIND(1D0)),INTENT(out)::QF_SAHP
    REAL(KIND(1D0)),INTENT(out)::Fc_anthro
    REAL(KIND(1D0)),INTENT(out)::Fc_metab
    REAL(KIND(1D0)),INTENT(out)::Fc_traff
    REAL(KIND(1D0)),INTENT(out)::Fc_build
    REAL(KIND(1d0)),INTENT(in)::avkdn
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::snowFrac
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::LAI_id
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::LAIMin
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in):: LAIMax
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::alpha_bioCO2
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::beta_bioCO2
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::theta_bioCO2
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::alpha_enh_bioCO2
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::beta_enh_bioCO2
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::resp_a
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::resp_b
    REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::min_res_bioCO2
    REAL(KIND(1D0)),INTENT(out)::Fc_biogen
    REAL(KIND(1D0)),INTENT(out)::Fc_respi
    REAL(KIND(1D0)),INTENT(out)::Fc_photo
    REAL(KIND(1D0)),INTENT(out)::Fc

    INTEGER,PARAMETER :: notUsedI=-999
    REAL(KIND(1D0)),PARAMETER::notUsed=-999


    !ih=it-DLS           !Moved to subroutine AnthropogenicEmissions MH 29 June 2017
    !IF(ih<0) ih=23

    ! IF(EmissionsMethod>0 .AND. EmissionsMethod<=6)THEN
    !    IF(Diagnose==1) WRITE(*,*) 'Calling AnthropogenicEmissions...'
    !    CALL AnthropogenicEmissions(&
    !         EmissionsMethod,&
    !         id,it,imin,DLS,nsh,DayofWeek_id,&
    !         EF_umolCO2perJ,FcEF_v_kgkm,EnEF_v_Jkm,TrafficUnits,&
    !         FrFossilFuel_Heat,FrFossilFuel_NonHeat,&
    !         MinQFMetab,MaxQFMetab,&
    !         NumCapita,PopDensDaytime,PopDensNighttime,&
    !         Temp_C,HDD_id,Qf_A,Qf_B,Qf_C,&
    !         AH_MIN,AH_SLOPE_Heating,AH_SLOPE_Cooling,&
    !         T_CRITIC_Heating,T_CRITIC_Cooling,&
    !         TrafficRate,&
    !         QF0_BEU,QF_SAHP,&
    !         Fc_anthro,Fc_metab,Fc_traff,Fc_build,&
    !         AHProf_tstep,HumActivity_tstep,TraffProf_tstep,PopProf_tstep)
    !
    !    Fc_anthro=0
    !    Fc_metab=0
    !    Fc_traff=0
    !    Fc_build=0
    !    Fc_biogen=0
    !    Fc_respi=0
    !    Fc_photo=0
    ! ELSEIF(EmissionsMethod>=11)THEN
    !    IF(Diagnose==1) WRITE(*,*) 'Calling AnthropogenicEmissions...'
    !    CALL AnthropogenicEmissions(&
    !         EmissionsMethod,&
    !         id,it,imin,DLS,nsh,DayofWeek_id,&
    !         EF_umolCO2perJ,FcEF_v_kgkm,EnEF_v_Jkm,TrafficUnits,&
    !         FrFossilFuel_Heat,FrFossilFuel_NonHeat,&
    !         MinQFMetab,MaxQFMetab,&
    !         NumCapita,PopDensDaytime,PopDensNighttime,&
    !         Temp_C,HDD_id,Qf_A,Qf_B,Qf_C,&
    !         AH_MIN,AH_SLOPE_Heating,AH_SLOPE_Cooling,&
    !         T_CRITIC_Heating,T_CRITIC_Cooling,&
    !         TrafficRate,&
    !         QF0_BEU,QF_SAHP,&
    !         Fc_anthro,Fc_metab,Fc_traff,Fc_build,&
    !         AHProf_tstep,HumActivity_tstep,TraffProf_tstep,PopProf_tstep)
    !
    !
    ! ELSEIF(EmissionsMethod==0)THEN
    !    IF(Diagnose==1) WRITE(*,*) 'Calling AnthropogenicEmissions...'
    !    CALL AnthropogenicEmissions(&
    !         EmissionsMethod,&
    !         id,it,imin,DLS,nsh,DayofWeek_id,&
    !         EF_umolCO2perJ,FcEF_v_kgkm,EnEF_v_Jkm,TrafficUnits,&
    !         FrFossilFuel_Heat,FrFossilFuel_NonHeat,&
    !         MinQFMetab,MaxQFMetab,&
    !         NumCapita,PopDensDaytime,PopDensNighttime,&
    !         Temp_C,HDD_id,Qf_A,Qf_B,Qf_C,&
    !         AH_MIN,AH_SLOPE_Heating,AH_SLOPE_Cooling,&
    !         T_CRITIC_Heating,T_CRITIC_Cooling,&
    !         TrafficRate,&
    !         QF0_BEU,QF_SAHP,&
    !         Fc_anthro,Fc_metab,Fc_traff,Fc_build,&
    !         AHProf_tstep,HumActivity_tstep,TraffProf_tstep,PopProf_tstep)
    !
    ! ELSE
    !    CALL ErrorHint(73,'RunControl.nml:EmissionsMethod unusable',notUsed,notUsed,EmissionsMethod)
    ! ENDIF
    IF ( EmissionsMethod==0 ) THEN ! use observed qf
       qf = QF_obs
    ELSEIF ( (EmissionsMethod>0 .AND. EmissionsMethod<=6) .OR. EmissionsMethod>=11) THEN
       CALL AnthropogenicEmissions(&
            EmissionsMethod,&
            id,it,imin,DLS,nsh,DayofWeek_id,&
            EF_umolCO2perJ,FcEF_v_kgkm,EnEF_v_Jkm,TrafficUnits,&
            FrFossilFuel_Heat,FrFossilFuel_NonHeat,&
            MinQFMetab,MaxQFMetab,&
            NumCapita,PopDensDaytime,PopDensNighttime,&
            Temp_C,HDD_id,Qf_A,Qf_B,Qf_C,&
            AH_MIN,AH_SLOPE_Heating,AH_SLOPE_Cooling,&
            T_CRITIC_Heating,T_CRITIC_Cooling,&
            TrafficRate,&
            QF0_BEU,QF_SAHP,&
            Fc_anthro,Fc_metab,Fc_traff,Fc_build,&
            AHProf_24hr,HumActivity_24hr,TraffProf_24hr,PopProf_24hr)

    ELSE
       CALL ErrorHint(73,'RunControl.nml:EmissionsMethod unusable',notUsed,notUsed,EmissionsMethod)
    ENDIF


    IF(EmissionsMethod>=1) qf = QF_SAHP

    IF(EmissionsMethod>=11) THEN
       ! Calculate CO2 fluxes from biogenic components
       IF(Diagnose==1) WRITE(*,*) 'Calling CO2_biogen...'
       CALL CO2_biogen(EmissionsMethod,&
            ivConif,ivDecid,ivGrass,ConifSurf,DecidSurf,GrassSurf,BSoilSurf,&
            snowFrac,nsurf,NVegSurf,avkdn,Temp_C,sfr,LAI_id,LAIMin,LAIMax,&
            alpha_bioCO2,beta_bioCO2,theta_bioCO2,alpha_enh_bioCO2,beta_enh_bioCO2,&
            resp_a,resp_b,min_res_bioCO2,Fc_biogen,Fc_respi,Fc_photo,&
            notUsed,notUsedI)
    ENDIF

    IF(EmissionsMethod>=0 .AND. EmissionsMethod<=6)THEN
       Fc_anthro=0
       Fc_metab=0
       Fc_traff=0
       Fc_build=0
       Fc_biogen=0
       Fc_respi=0
       Fc_photo=0

    ENDIF
    ! Sum anthropogenic and biogenic CO2 flux components to find overall CO2 flux
    Fc = Fc_anthro + Fc_biogen

    ! =================STORAGE HEAT FLUX=======================================

  END SUBROUTINE SUEWS_cal_AnthropogenicEmission
  ! ================================================================================

  !=============net all-wave radiation=====================================
  SUBROUTINE SUEWS_cal_Qn(&
       NetRadiationMethod,snowUse,&!input
       Diagnose,snow_obs,ldown_obs,fcld_obs,&
       dectime,ZENITH_deg,avKdn,Temp_C,avRH,ea_hPa,qn1_obs,&
       SnowAlb,DiagQN,&
       NARP_TRANS_SITE,NARP_EMIS_SNOW,IceFrac,sfr,emis,&
       alb,albDecTr_id,DecidCap_id,albEveTr_id,albGrass_id,StoreDrainPrm,&!inout
       snowFrac,ldown,fcld,&!output
       qn1,qn1_snowfree,qn1_S,kclear,kup,lup,tsurf,&
       qn1_ind_snow,kup_ind_snow,Tsurf_ind_snow,Tsurf_ind)
    USE NARP_MODULE, ONLY: RadMethod,NARP

    IMPLICIT NONE
    ! INTEGER,PARAMETER ::nsurf     = 7 ! number of surface types
    ! INTEGER,PARAMETER ::ConifSurf = 3 !New surface classes: Grass = 5th/7 surfaces
    ! INTEGER,PARAMETER ::DecidSurf = 4 !New surface classes: Grass = 5th/7 surfaces
    ! INTEGER,PARAMETER ::GrassSurf = 5

    INTEGER,INTENT(in)::NetRadiationMethod
    INTEGER,INTENT(in)::snowUse
    INTEGER,INTENT(in)::Diagnose
    INTEGER,INTENT(in)::DiagQN

    REAL(KIND(1d0)),INTENT(in)::snow_obs
    REAL(KIND(1d0)),INTENT(in)::ldown_obs
    REAL(KIND(1d0)),INTENT(in)::fcld_obs
    REAL(KIND(1d0)),INTENT(in)::dectime
    REAL(KIND(1d0)),INTENT(in)::ZENITH_deg
    REAL(KIND(1d0)),INTENT(in)::avKdn
    REAL(KIND(1d0)),INTENT(in)::Temp_C
    REAL(KIND(1d0)),INTENT(in)::avRH
    REAL(KIND(1d0)),INTENT(in)::ea_hPa
    REAL(KIND(1d0)),INTENT(in)::qn1_obs
    REAL(KIND(1d0)),INTENT(in)::SnowAlb
    REAL(KIND(1d0)),INTENT(in)::NARP_EMIS_SNOW
    REAL(KIND(1d0)),INTENT(in)::NARP_TRANS_SITE


    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in):: IceFrac
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in):: sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in):: emis

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)  ::alb
    REAL(KIND(1d0)),INTENT(in)  ::albDecTr_id
    REAL(KIND(1d0)),INTENT(in)  ::DecidCap_id
    REAL(KIND(1d0)),INTENT(in)  ::albEveTr_id
    REAL(KIND(1d0)),INTENT(in)  ::albGrass_id
    REAL(KIND(1d0)),DIMENSION(6,nsurf),INTENT(inout)::StoreDrainPrm

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::snowFrac

    REAL(KIND(1d0)),INTENT(out)::ldown
    REAL(KIND(1d0)),INTENT(out)::fcld
    REAL(KIND(1d0)),INTENT(out)::qn1
    REAL(KIND(1d0)),INTENT(out)::qn1_snowfree
    REAL(KIND(1d0)),INTENT(out)::qn1_S
    REAL(KIND(1d0)),INTENT(out)::kclear
    REAL(KIND(1d0)),INTENT(out)::kup
    REAL(KIND(1d0)),INTENT(out)::lup
    REAL(KIND(1d0)),INTENT(out)::tsurf

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out) ::qn1_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out) ::kup_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out) ::Tsurf_ind_snow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out):: tsurf_ind


    REAL(KIND(1d0)),DIMENSION(nsurf):: lup_ind
    REAL(KIND(1d0)),DIMENSION(nsurf):: kup_ind
    REAL(KIND(1d0)),DIMENSION(nsurf):: qn1_ind

    REAL(KIND(1d0)),PARAMETER::NAN=-999
    INTEGER :: NetRadiationMethodX
    INTEGER::AlbedoChoice,ldown_option


    CALL RadMethod(&
         NetRadiationMethod,&!inout
         snowUse,&!input
         NetRadiationMethodX,AlbedoChoice,ldown_option)!output

    IF(NetRadiationMethodX>0)THEN

       ! IF (snowUse==0) snowFrac=snow_obs
       IF (snowUse==0) snowFrac=0

       IF(ldown_option==1) THEN !Observed ldown provided as forcing
          ldown=ldown_obs
       ELSE
          ldown=-9              !to be filled in NARP
       ENDIF

       IF(ldown_option==2) THEN !observed cloud fraction provided as forcing
          fcld=fcld_obs
       ENDIF

       !write(*,*) DecidCap(id), id, it, imin, 'Calc - near start'

       ! Update variables that change daily and represent seasonal variability
       alb(DecidSurf)    = albDecTr_id !Change deciduous albedo
       StoreDrainPrm(6,DecidSurf) = DecidCap_id !Change current storage capacity of deciduous trees
       ! Change EveTr and Grass albedo too
       alb(ConifSurf) = albEveTr_id
       alb(GrassSurf) = albGrass_id

       IF(Diagnose==1) WRITE(*,*) 'Calling NARP...'


       CALL NARP(&
            nsurf,sfr,snowFrac,alb,emis,IceFrac,&! input:
            NARP_TRANS_SITE,NARP_EMIS_SNOW,&
            dectime,ZENITH_deg,avKdn,Temp_C,avRH,ea_hPa,qn1_obs,&
            SnowAlb,&
            AlbedoChoice,ldown_option,NetRadiationMethodX,DiagQN,&
            qn1,qn1_snowfree,qn1_S,kclear,kup,LDown,lup,fcld,tsurf,&! output:
            qn1_ind_snow,kup_ind_snow,Tsurf_ind_snow,Tsurf_ind)

    ELSE ! NetRadiationMethod==0
       snowFrac  = snow_obs
       qn1       = qn1_obs
       qn1_snowfree    = qn1_obs
       qn1_s     = qn1_obs
       ldown     = NAN
       lup       = NAN
       kup       = NAN
       tsurf     = NAN
       lup_ind   = NAN
       kup_ind   = NAN
       tsurf_ind = NAN
       qn1_ind   = NAN
       Fcld      = NAN
    ENDIF

    IF(ldown_option==1) THEN
       Fcld = NAN
    ENDIF

  END SUBROUTINE SUEWS_cal_Qn
  !========================================================================

  !=============storage heat flux=========================================
  SUBROUTINE SUEWS_cal_Qs(&
       StorageHeatMethod,qs_obs,OHMIncQF,Gridiv,&!input
       id,tstep,dt_since_start,Diagnose,sfr,&
       OHM_coef,OHM_threshSW,OHM_threshWD,&
       soilmoist_id,soilstoreCap,state_id,nsh,SnowUse,DiagQS,&
       HDD_id,MetForcingData_grid,Ts5mindata_ir,qf,qn1,&
       avkdn, avu1, temp_c, zenith_deg, avrh, press_hpa, ldown,&
       bldgh,alb,emis,cpAnOHM,kkAnOHM,chAnOHM,EmissionsMethod,&
       Tair24HR,qn1_av,dqndt,qn1_s_av,dqnsdt,&!inout
       StoreDrainPrm,&
       qn1_S,snowFrac,dataOutLineESTM,qs,&!output
       deltaQi,a1,a2,a3)

    IMPLICIT NONE

    INTEGER,INTENT(in)  ::StorageHeatMethod
    INTEGER,INTENT(in)  ::OHMIncQF
    INTEGER,INTENT(in)  ::Gridiv
    INTEGER,INTENT(in)  ::id
    INTEGER,INTENT(in)  ::tstep ! time step [s]
    INTEGER,INTENT(in) ::dt_since_start  ! time since simulation starts [s]
    INTEGER,INTENT(in)  ::Diagnose
    INTEGER,INTENT(in)  ::nsh              ! number of timesteps in one hour
    INTEGER,INTENT(in)  ::SnowUse          ! option for snow related calculations
    INTEGER,INTENT(in)  ::DiagQS           ! diagnostic option
    INTEGER,INTENT(in)  :: EmissionsMethod !< AnthropHeat option [-]


    REAL(KIND(1d0)),INTENT(in)::OHM_coef(nsurf+1,4,3)                 ! OHM coefficients
    REAL(KIND(1d0)),INTENT(in)::OHM_threshSW(nsurf+1) ! OHM thresholds
    REAL(KIND(1d0)),INTENT(in)::OHM_threshWD(nsurf+1) ! OHM thresholds
    REAL(KIND(1d0)),INTENT(in)::soilmoist_id(nsurf)                ! soil moisture
    REAL(KIND(1d0)),INTENT(in)::soilstoreCap(nsurf)             ! capacity of soil store
    REAL(KIND(1d0)),INTENT(in)::state_id(nsurf) ! wetness status


    REAL(KIND(1d0)),DIMENSION(12),INTENT(in)::HDD_id
    REAL(KIND(1d0)),INTENT(in)::qf
    REAL(KIND(1d0)),INTENT(in)::qn1
    REAL(KIND(1d0)),INTENT(in)::qs_obs
    REAL(KIND(1d0)),INTENT(in)::avkdn, avu1, temp_c, zenith_deg, avrh, press_hpa, ldown
    REAL(KIND(1d0)),INTENT(in)::bldgh

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::alb  !< albedo [-]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::emis !< emissivity [-]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::cpAnOHM   !< heat capacity [J m-3 K-1]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::kkAnOHM   !< thermal conductivity [W m-1 K-1]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::chAnOHM   !< bulk transfer coef [J m-3 K-1]

    REAL(KIND(1d0)),DIMENSION(:,:),INTENT(in)::MetForcingData_grid !< met forcing array of grid

    REAL(KIND(1d0)),DIMENSION(:),INTENT(in)::Ts5mindata_ir

    REAL(KIND(1d0)),DIMENSION(24*nsh),INTENT(inout)::Tair24HR
    REAL(KIND(1d0)),INTENT(inout)                  ::qn1_av
    REAL(KIND(1d0)),INTENT(inout)                  ::dqndt!Rate of change of net radiation [W m-2 h-1] at t-1
    REAL(KIND(1d0)),INTENT(inout)                  ::qn1_s_av
    REAL(KIND(1d0)),INTENT(inout)                  ::dqnsdt !Rate of change of net radiation [W m-2 h-1] at t-1
    ! REAL(KIND(1d0)),DIMENSION(nsh),INTENT(inout)   ::qn1_store_grid
    ! REAL(KIND(1d0)),DIMENSION(nsh),INTENT(inout)   ::qn1_S_store_grid !< stored qn1 [W m-2]

    ! REAL(KIND(1d0)),DIMENSION(2*nsh+1),INTENT(inout)::qn1_av_store_grid
    ! REAL(KIND(1d0)),DIMENSION(2*nsh+1),INTENT(inout)::qn1_S_av_store_grid !< average net radiation over previous hour [W m-2]
    REAL(KIND(1d0)),DIMENSION(6,nsurf),INTENT(inout)::StoreDrainPrm


    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::deltaQi ! storage heat flux of snow surfaces
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::snowFrac

    REAL(KIND(1d0)),DIMENSION(27),INTENT(out):: dataOutLineESTM
    REAL(KIND(1d0)),INTENT(out)::qn1_S
    REAL(KIND(1d0)),INTENT(out):: qs ! storage heat flux
    REAL(KIND(1d0)),INTENT(out):: a1 !< AnOHM coefficients of grid [-]
    REAL(KIND(1d0)),INTENT(out):: a2 !< AnOHM coefficients of grid [h]
    REAL(KIND(1d0)),INTENT(out):: a3 !< AnOHM coefficients of grid [W m-2]


    REAL(KIND(1d0))::Tair_mav_5d ! Tair_mav_5d=HDD(id-1,4) HDD at the begining of today (id-1)
    REAL(KIND(1d0))::qn1_use ! qn used in OHM calculations

    ! initialise output variables
    deltaQi=0
    snowFrac=0
    qn1_S=0
    dataOutLineESTM=-999
    qs=-999
    a1=-999
    a2=-999
    a3=-999


    ! calculate qn if qf should be included
    IF(OHMIncQF == 1) THEN
       qn1_use= qf+qn1
    ELSEIF(OHMIncQF == 0) THEN
       qn1_use= qn1
    ENDIF

    IF(StorageHeatMethod==0) THEN           !Use observed QS
       qs=qs_obs


    ELSEIF(StorageHeatMethod==1) THEN           !Use OHM to calculate QS
       Tair_mav_5d=HDD_id(10)
       IF(Diagnose==1) WRITE(*,*) 'Calling OHM...'
       CALL OHM(qn1,qn1_av,dqndt,&
            qn1_S,qn1_s_av,dqnsdt,&
            tstep,dt_since_start,&
            sfr,nsurf,&
            Tair_mav_5d,&
            OHM_coef,&
            OHM_threshSW,OHM_threshWD,&
            soilmoist_id,soilstoreCap,state_id,&
            BldgSurf,WaterSurf,&
            SnowUse,SnowFrac,&
            DiagQS,&
            a1,a2,a3,qs,deltaQi)

       ! use AnOHM to calculate QS, TS 14 Mar 2016
    ELSEIF (StorageHeatMethod==3) THEN
       IF(Diagnose==1) WRITE(*,*) 'Calling AnOHM...'
       ! CALL AnOHM(qn1_use,qn1_store_grid,qn1_av_store_grid,qf,&
       !      MetForcingData_grid,state_id/StoreDrainPrm(6,:),&
       !      alb, emis, cpAnOHM, kkAnOHM, chAnOHM,&
       !      sfr,nsurf,nsh,EmissionsMethod,id,Gridiv,&
       !      a1,a2,a3,qs,deltaQi)
       CALL AnOHM(&
            tstep,dt_since_start,&
            qn1_use,qn1_av,dqndt,qf,&
            MetForcingData_grid,state_id/StoreDrainPrm(6,:),&
            alb, emis, cpAnOHM, kkAnOHM, chAnOHM,&! input
            sfr,nsurf,EmissionsMethod,id,Gridiv,&
            a1,a2,a3,qs,deltaQi)! output


       ! !Calculate QS using ESTM
    ELSEIF(StorageHeatMethod==4 .OR. StorageHeatMethod==14) THEN
       !    !CALL ESTM(QSestm,iMB)
       IF(Diagnose==1) WRITE(*,*) 'Calling ESTM...'
       CALL ESTM(&
            Gridiv,&!input
            nsh,tstep,&
            avkdn, avu1, temp_c, zenith_deg, avrh, press_hpa, ldown,&
            bldgh,Ts5mindata_ir,&
            Tair24HR,&!inout
            dataOutLineESTM,QS)!output
       !    CALL ESTM(QSestm,Gridiv,ir)  ! iMB corrected to Gridiv, TS 09 Jun 2016
       !    QS=QSestm   ! Use ESTM qs
    ENDIF

  END SUBROUTINE SUEWS_cal_Qs
  !=======================================================================

  !==========================water balance================================
  SUBROUTINE SUEWS_cal_Water(&
       Diagnose,&!input
       snowUse,NonWaterFraction,addPipes,addImpervious,addVeg,addWaterBody,&
       state_id,soilmoist_id,sfr,StoreDrainPrm,WaterDist,nsh_real,&
       drain_per_tstep,&  !output
       drain,AddWaterRunoff,&
       AdditionalWater,runoffPipes,runoff_per_interval,&
       AddWater,stateOld,soilmoistOld)

    IMPLICIT NONE
    ! INTEGER,PARAMETER :: nsurf=7! number of surface types
    ! INTEGER,PARAMETER ::WaterSurf = 7
    INTEGER,INTENT(in) ::Diagnose
    INTEGER,INTENT(in) ::snowUse

    REAL(KIND(1d0)),INTENT(in)::NonWaterFraction
    REAL(KIND(1d0)),INTENT(in)::addPipes
    REAL(KIND(1d0)),INTENT(in)::addImpervious
    REAL(KIND(1d0)),INTENT(in)::addVeg
    REAL(KIND(1d0)),INTENT(in)::addWaterBody
    REAL(KIND(1d0)),INTENT(in)::nsh_real !nsh cast as a real for use in calculations

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)          ::state_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)          ::soilmoist_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)          ::sfr
    REAL(KIND(1d0)),DIMENSION(6,nsurf),INTENT(in)        ::StoreDrainPrm
    REAL(KIND(1d0)),DIMENSION(nsurf+1,nsurf-1),INTENT(in)::WaterDist

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out):: drain         !Drainage of surface type "is" [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out):: AddWaterRunoff!Fraction of water going to runoff/sub-surface soil (WGWaterDist) [-]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out):: AddWater      !water from other surfaces (WGWaterDist in SUEWS_ReDistributeWater.f95) [mm]
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out):: stateOld
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out):: soilmoistOld

    REAL(KIND(1d0)),INTENT(out)::drain_per_tstep
    REAL(KIND(1d0)),INTENT(out)::AdditionalWater
    REAL(KIND(1d0)),INTENT(out)::runoffPipes
    REAL(KIND(1d0)),INTENT(out)::runoff_per_interval
    INTEGER:: is

    ! Retain previous surface state_id and soil moisture state_id
    stateOld     = state_id     !state_id of each surface [mm] for the previous timestep
    soilmoistOld = soilmoist_id !Soil moisture of each surface [mm] for the previous timestep


    !============= Grid-to-grid runoff =============
    ! Calculate additional water coming from other grids
    ! i.e. the variables addImpervious, addVeg, addWaterBody, addPipes
    !call RunoffFromGrid(GridFromFrac)  !!Need to code between-grid water transfer

    ! Sum water coming from other grids (these are expressed as depths over the whole surface)
    AdditionalWater = addPipes+addImpervious+addVeg+addWaterBody  ![mm]

    ! Initialise runoff in pipes
    runoffPipes         = addPipes !Water flowing in pipes from other grids. QUESTION: No need for scaling?
    !! CHECK p_i
    runoff_per_interval = addPipes !pipe plor added to total runoff.


    !================== Drainage ===================
    ! Calculate drainage for each soil subsurface (excluding water body)
    IF(Diagnose==1) WRITE(*,*) 'Calling Drainage...'

    IF (NonWaterFraction/=0) THEN !Soil states only calculated if soil exists. LJ June 2017
       DO is=1,nsurf-1

          CALL drainage(&
               is,&! input:
               state_id(is),&
               StoreDrainPrm(6,is),&
               StoreDrainPrm(2,is),&
               StoreDrainPrm(3,is),&
               StoreDrainPrm(4,is),&
               nsh_real,&
               drain(is))! output

          ! !HCW added and changed to StoreDrainPrm(6,is) here 20 Feb 2015
          ! drain_per_tstep=drain_per_tstep+(drain(is)*sfr(is)/NonWaterFraction)   !No water body included
       ENDDO
       drain_per_tstep=DOT_PRODUCT(drain(1:nsurf-1),sfr(1:nsurf-1))/NonWaterFraction !No water body included
    ELSE
       drain(1:nsurf-1)=0
       drain_per_tstep=0
    ENDIF

    drain(WaterSurf) = 0  ! Set drainage from water body to zero

    ! Distribute water within grid, according to WithinGridWaterDist matrix (Cols 1-7)
    IF(Diagnose==1) WRITE(*,*) 'Calling ReDistributeWater...'
    ! CALL ReDistributeWater
    !Calculates AddWater(is)
    CALL ReDistributeWater(&
         nsurf,& ! input:
         WaterSurf, snowUse, WaterDist,  sfr,   Drain,&
         AddWaterRunoff,&  ! output:
         AddWater)

  END SUBROUTINE SUEWS_cal_Water
  !=======================================================================

  !===============initialize sensible heat flux============================
  SUBROUTINE SUEWS_init_QH(&
       qh_obs,avdens,avcp,h_mod,qn1,dectime,&!input
       H_init)!output

    IMPLICIT NONE
    REAL(KIND(1d0)),INTENT(in)::qh_obs
    REAL(KIND(1d0)),INTENT(in)::avdens
    REAL(KIND(1d0)),INTENT(in)::avcp
    REAL(KIND(1d0)),INTENT(in)::h_mod
    REAL(KIND(1d0)),INTENT(in)::qn1
    REAL(KIND(1d0)),INTENT(in)::dectime
    REAL(KIND(1d0)),INTENT(out)::H_init


    REAL(KIND(1d0)),PARAMETER::NAN=-999
    INTEGER,PARAMETER::notUsedI=-999

    ! Calculate kinematic heat flux (w'T') from sensible heat flux [W m-2] from observed data (if available) or LUMPS
    IF(qh_obs/=NAN) THEN   !if(qh_obs/=NAN) qh=qh_obs   !Commented out by HCW 04 Mar 2015
       H_init=qh_obs/(avdens*avcp)  !Use observed value
    ELSE
       IF(h_mod/=NAN) THEN
          H_init = h_mod/(avdens*avcp)   !Use LUMPS value
       ELSE
          H_init=(qn1*0.2)/(avdens*avcp)   !If LUMPS has had a problem, we still need a value
          CALL ErrorHint(38,'LUMPS unable to calculate realistic value for H_mod.',h_mod, dectime, notUsedI)
       ENDIF
    ENDIF

  END SUBROUTINE SUEWS_init_QH
  !========================================================================

  !================latent heat flux and surface wetness===================
  ! TODO: optimise the structure of this function
  SUBROUTINE SUEWS_cal_QE(&
       Diagnose,&!input
       tstep,imin,it,EvapMethod,snowCalcSwitch,dayofWeek_id,CRWmin,CRWmax,&
       nsh_real,dectime,lvS_J_kg,lv_j_kg,avdens,avRh,Press_hPa,Temp_C,&
       RAsnow,psyc_hPa,avcp,sIce_hPa,&
       PervFraction,vegfraction,addimpervious,qn1_snowfree,qf,qs,vpd_hPa,s_hPa,&
       ResistSurf,RA,rb,tstep_real,snowdensmin,precip,PipeCapacity,RunoffToWater,&
       NonWaterFraction,wu_EveTr,wu_DecTr,wu_Grass,addVeg,addWaterBody,SnowLimPaved,SnowLimBuild,&
       SurfaceArea,FlowChange,drain,WetThresh,stateOld,mw_ind,soilstorecap,rainonsnow,&
       freezmelt,freezstate,freezstatevol,Qm_Melt,Qm_rain,Tsurf_ind,sfr,&
       StateLimit,AddWater,addwaterrunoff,StoreDrainPrm,snowD,&
       runoff_per_interval,state_id,soilmoist_id,SnowPack,snowFrac,MeltWaterStore,&! inout:
       iceFrac,SnowDens,&
       SnowProf_24hr,& ! output:
       runoffSnow,runoff,runoffSoil,chang,changSnow,&
       snowDepth,SnowToSurf,ev_snow,SnowRemoval,&
       evap,rss_nsurf,p_mm,rss,qe,state_per_tstep,NWstate_per_tstep,qeOut,&
       swe,ev,chSnow_per_interval,ev_per_tstep,qe_per_tstep,runoff_per_tstep,&
       surf_chang_per_tstep,runoffPipes,mwstore,runoffwaterbody,&
       runoffAGveg,runoffAGimpervious,runoffWaterBody_m3,runoffPipes_m3)

    IMPLICIT NONE

    INTEGER,INTENT(in) ::Diagnose
    INTEGER,INTENT(in) ::tstep
    INTEGER,INTENT(in) ::imin
    INTEGER,INTENT(in) ::it
    INTEGER,INTENT(in) ::EvapMethod !Evaporation calculated according to Rutter (1) or Shuttleworth (2)
    ! INTEGER,INTENT(in) ::snowfractionchoice

    INTEGER,DIMENSION(nsurf),INTENT(in)::snowCalcSwitch
    INTEGER,DIMENSION(3),INTENT(in)::dayofWeek_id

    REAL(KIND(1d0)),INTENT(in)::CRWmin
    REAL(KIND(1d0)),INTENT(in)::CRWmax
    REAL(KIND(1d0)),INTENT(in)::nsh_real
    REAL(KIND(1d0)),INTENT(in)::dectime
    REAL(KIND(1d0)),INTENT(in)::lvS_J_kg
    REAL(KIND(1d0)),INTENT(in)::lv_j_kg
    REAL(KIND(1d0)),INTENT(in)::avdens
    REAL(KIND(1d0)),INTENT(in)::avRh
    REAL(KIND(1d0)),INTENT(in)::Press_hPa
    REAL(KIND(1d0)),INTENT(in)::Temp_C
    REAL(KIND(1d0)),INTENT(in)::RAsnow
    REAL(KIND(1d0)),INTENT(in)::psyc_hPa
    REAL(KIND(1d0)),INTENT(in)::avcp
    REAL(KIND(1d0)),INTENT(in)::sIce_hPa
    REAL(KIND(1d0)),INTENT(in)::PervFraction
    REAL(KIND(1d0)),INTENT(in)::vegfraction
    REAL(KIND(1d0)),INTENT(in)::addimpervious
    REAL(KIND(1d0)),INTENT(in)::qn1_snowfree
    REAL(KIND(1d0)),INTENT(in)::qf
    REAL(KIND(1d0)),INTENT(in)::qs
    REAL(KIND(1d0)),INTENT(in)::vpd_hPa
    REAL(KIND(1d0)),INTENT(in)::s_hPa
    REAL(KIND(1d0)),INTENT(in)::ResistSurf
    REAL(KIND(1d0)),INTENT(in)::RA
    REAL(KIND(1d0)),INTENT(in)::rb
    REAL(KIND(1d0)),INTENT(in)::tstep_real
    REAL(KIND(1d0)),INTENT(in)::snowdensmin
    REAL(KIND(1d0)),INTENT(in)::precip
    REAL(KIND(1d0)),INTENT(in)::PipeCapacity
    REAL(KIND(1d0)),INTENT(in)::RunoffToWater
    REAL(KIND(1d0)),INTENT(in)::NonWaterFraction
    REAL(KIND(1d0)),INTENT(in)::wu_EveTr!Water use for evergreen trees/shrubs [mm]
    REAL(KIND(1d0)),INTENT(in)::wu_DecTr!Water use for deciduous trees/shrubs [mm]
    REAL(KIND(1d0)),INTENT(in)::wu_Grass!Water use for grass [mm]
    REAL(KIND(1d0)),INTENT(in)::addVeg!Water from vegetated surfaces of other grids [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(in)::addWaterBody!Water from water surface of other grids [mm] for whole surface area
    REAL(KIND(1d0)),INTENT(in)::SnowLimPaved
    REAL(KIND(1d0)),INTENT(in)::SnowLimBuild
    REAL(KIND(1d0)),INTENT(in)::SurfaceArea
    REAL(KIND(1d0)),INTENT(in)::FlowChange

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::drain
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::WetThresh
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::stateOld
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::mw_ind
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::soilstorecap
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::rainonsnow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::freezmelt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::freezstate
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::freezstatevol
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Qm_Melt
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Qm_rain
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::Tsurf_ind
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::snowD
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::StateLimit !Limit for state_id of each surface type [mm] (specified in input files)
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::AddWater
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::addwaterrunoff
    REAL(KIND(1d0)),DIMENSION(6,nsurf),INTENT(in)::StoreDrainPrm
    REAL(KIND(1d0)), DIMENSION(0:23,2),INTENT(in):: SnowProf_24hr

    !Updated status: input and output
    REAL(KIND(1d0)),INTENT(inout)::runoff_per_interval! Total water transported to each grid for grid-to-grid connectivity

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::state_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::soilmoist_id
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowPack
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::snowFrac
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::MeltWaterStore

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::iceFrac
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(inout)::SnowDens
    REAL(KIND(1d0)),DIMENSION(2)    ::SurplusEvap        !Surplus for evaporation in 5 min timestep


    ! output:
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::runoffSnow !Initialize for runoff caused by snowmelting
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::runoff
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::runoffSoil
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::chang
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::changSnow
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::snowDepth
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::SnowToSurf
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::ev_snow
    REAL(KIND(1d0)),DIMENSION(2),INTENT(out)::SnowRemoval
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::evap
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(out)::rss_nsurf

    REAL(KIND(1d0)),INTENT(out)::p_mm!Inputs to surface water balance
    REAL(KIND(1d0)),INTENT(out)::rss
    REAL(KIND(1d0)),INTENT(out)::qe ! latent heat flux [W m-2]
    REAL(KIND(1d0)),INTENT(out)::state_per_tstep
    REAL(KIND(1d0)),INTENT(out)::NWstate_per_tstep
    REAL(KIND(1d0)),INTENT(out)::qeOut
    REAL(KIND(1d0)),INTENT(out)::swe
    REAL(KIND(1d0)),INTENT(out)::ev
    REAL(KIND(1d0)),INTENT(out)::chSnow_per_interval
    REAL(KIND(1d0)),INTENT(out)::ev_per_tstep
    REAL(KIND(1d0)),INTENT(out)::qe_per_tstep
    REAL(KIND(1d0)),INTENT(out)::runoff_per_tstep
    REAL(KIND(1d0)),INTENT(out)::surf_chang_per_tstep
    REAL(KIND(1d0)),INTENT(out)::runoffPipes
    REAL(KIND(1d0)),INTENT(out)::mwstore
    REAL(KIND(1d0)),INTENT(out)::runoffwaterbody
    REAL(KIND(1d0)),INTENT(out)::runoffWaterBody_m3
    REAL(KIND(1d0)),INTENT(out)::runoffPipes_m3
    REAL(KIND(1d0)),INTENT(out)::runoffAGveg
    REAL(KIND(1d0)),INTENT(out)::runoffAGimpervious


    ! local:
    INTEGER:: is

    REAL(KIND(1d0))::surplusWaterBody
    REAL(KIND(1d0))::pin!Rain per time interval
    REAL(KIND(1d0))::sae
    REAL(KIND(1d0))::vdrc
    REAL(KIND(1d0))::sp
    REAL(KIND(1d0))::numPM
    REAL(KIND(1d0))::tlv
    REAL(KIND(1d0))::runoffAGimpervious_m3
    REAL(KIND(1d0))::runoffAGveg_m3

    REAL(KIND(1d0)),DIMENSION(7)::capStore ! current storage capacity [mm]

    capStore=0 !initialise capStore

    tlv=lv_J_kg/tstep_real !Latent heat of vapourisation per timestep

    pin=MAX(0.,Precip)!Initiate rain data [mm]


    ! Initialize the output variables
    qe                   = 0
    ev                   = 0
    swe                  = 0
    ev_snow              = 0
    ev_per_tstep         = 0
    surf_chang_per_tstep = 0
    runoff_per_tstep     = 0
    state_per_tstep      = 0
    NWstate_per_tstep    = 0
    qeOut                = 0
    runoffwaterbody      = 0
    chSnow_per_interval  = 0
    mwstore              = 0
    runoffAGveg          = 0
    runoffAGimpervious   = 0
    surplusWaterBody     = 0
    runoffSoil           = 0
    runoff               = 0
    chang                = 0
    SurplusEvap          = 0
    SnowRemoval          = 0

    !========= these need to be wrapped================================
    sae   = s_hPa*(qn1_snowfree+qf-qs)    !s_haPa - slope of svp vs t curve. qn1 changed to qn1_snowfree, lj in May 2013
    vdrc  = vpd_hPa*avdens*avcp
    sp    = s_hPa/psyc_hPa
    numPM = sae+vdrc/RA
    !write(*,*) numPM, sae, vdrc/RA, s_hPA+psyc_hPa, NumPM/(s_hPA+psyc_hPa)
    !========= these need to be wrapped end================================

    IF(Diagnose==1) WRITE(*,*) 'Calling evap_SUEWS and SoilStore...'
    DO is=1,nsurf   !For each surface in turn
       IF (snowCalcSwitch(is)==1) THEN
          IF (sfr(is)/=0) THEN
             IF(Diagnose==1) WRITE(*,*) 'Calling SnowCalc...'
             CALL SnowCalc(&
                  tstep,imin,it,dectime,is,&!input
                  EvapMethod,CRWmin,CRWmax,nsh_real,lvS_J_kg,lv_j_kg,avdens,&
                  avRh,Press_hPa,Temp_C,RAsnow,psyc_hPa,avcp,sIce_hPa,&
                  PervFraction,vegfraction,addimpervious,&
                  numPM,s_hPa,ResistSurf,sp,RA,rb,tlv,snowdensmin,SnowProf_24hr,precip,&
                  PipeCapacity,RunoffToWater,runoffAGimpervious,runoffAGveg,&
                  addVeg,surplusWaterBody,SnowLimPaved,SnowLimBuild,FlowChange,drain,&
                  WetThresh,stateOld,mw_ind,soilstorecap,rainonsnow,&
                  freezmelt,freezstate,freezstatevol,&
                  Qm_Melt,Qm_rain,Tsurf_ind,sfr,dayofWeek_id,StoreDrainPrm,snowD,&
                  AddWater,addwaterrunoff,&
                  SnowPack,SurplusEvap,&!inout
                  snowFrac,MeltWaterStore,iceFrac,SnowDens,&
                  runoffSnow,& ! output
                  runoff,runoffSoil,chang,changSnow,SnowToSurf,state_id,ev_snow,soilmoist_id,&
                  SnowDepth,SnowRemoval,swe,ev,chSnow_per_interval,&
                  ev_per_tstep,qe_per_tstep,runoff_per_tstep,surf_chang_per_tstep,&
                  runoffPipes,mwstore,runoffwaterbody)
          ELSE
             snowFrac(is) = 0
             SnowDens(is) = 0
             SnowPack(is) = 0
          ENDIF
       ELSE

          capStore(is)=StoreDrainPrm(6,is)
          !Calculates ev [mm]
          CALL Evap_SUEWS(&
               EvapMethod,&! input: !Evaporation calculated according to Rutter (1) or Shuttleworth (2)
               state_id(is),& ! wetness status
               WetThresh(is),&!When state_id > WetThresh, RS=0 limit in SUEWS_evap [mm] (specified in input files)
               capStore(is),& ! = StoreDrainPrm(6,is), current storage capacity [mm]
               numPM,&!numerator of P-M eqn
               s_hPa,&!Vapour pressure versus temperature slope in hPa
               psyc_hPa,&!Psychometric constant in hPa
               ResistSurf,&!Surface resistance
               sp,&!Term in calculation of E
               RA,&!Aerodynamic resistance
               rb,&!Boundary layer resistance
               tlv,&!Latent heat of vaporization per timestep [J kg-1 s-1], (tlv=lv_J_kg/tstep_real)
               rss,&! output:
               ev,& ! evapotranspiration [mm]
               qe) ! latent heat flux [W m-2]


          rss_nsurf(is) = rss !Store rss for each surface

          !Surface water balance and soil store updates (can modify ev, updates state_id)
          CALL soilstore(&
               is,& ! input: ! surface type
               sfr,&! surface fractions
               PipeCapacity,&!Capacity of pipes to transfer water
               RunoffToWater,&!Fraction of surface runoff going to water body
               pin,&!Rain per time interval
               wu_EveTr,&!Water use for evergreen trees/shrubs [mm]
               wu_DecTr,&!Water use for deciduous trees/shrubs [mm]
               wu_Grass,&!Water use for grass [mm]
               drain,&!Drainage of each surface type [mm]
               AddWater,&!Water from other surfaces (WGWaterDist in SUEWS_ReDistributeWater.f95) [mm]
               addImpervious,&!Water from impervious surfaces of other grids [mm] for whole surface area
               nsh_real,&!nsh cast as a real for use in calculations
               stateOld,&!Wetness status of each surface type from previous timestep [mm]
               AddWaterRunoff,&!Fraction of water going to runoff/sub-surface soil (WGWaterDist) [-]
               PervFraction,&! sum of surface cover fractions for impervious surfaces
               addVeg,&!Water from vegetated surfaces of other grids [mm] for whole surface area
               soilstoreCap,&!Capacity of soil store for each surface [mm]
               addWaterBody,&!Water from water surface of other grids [mm] for whole surface area
               FlowChange,&!Difference between the input and output flow in the water body
               StateLimit,&!Limit for state_id of each surface type [mm] (specified in input files)
               runoffAGimpervious,&!  inout:!Above ground runoff from impervious surface [mm] for whole surface area
               surplusWaterBody,&!Extra runoff that goes to water body [mm] as specified by RunoffToWater
               runoffAGveg,&!Above ground runoff from vegetated surfaces [mm] for whole surface area
               runoffPipes,&!Runoff in pipes [mm] for whole surface area
               ev,&!Evaporation
               soilmoist_id,&!Soil moisture of each surface type [mm]
               SurplusEvap,&!Surplus for evaporation in 5 min timestep
               runoffWaterBody,&!Above ground runoff from water surface [mm] for whole surface area
               runoff_per_interval,&! Total water transported to each grid for grid-to-grid connectivity
               p_mm,&!output: !Inputs to surface water balance
               chang,&!Change in state_id [mm]
               runoff,&!Runoff from each surface type [mm]
               state_id&!Wetness status of each surface type [mm]
               )

          evap(is) = ev !Store ev for each surface

          ! Sum evaporation from different surfaces to find total evaporation [mm]
          ev_per_tstep = ev_per_tstep+evap(is)*sfr(is)
          ! Sum change from different surfaces to find total change to surface state_id
          surf_chang_per_tstep = surf_chang_per_tstep+(state_id(is)-stateOld(is))*sfr(is)
          ! Sum runoff from different surfaces to find total runoff
          runoff_per_tstep = runoff_per_tstep+runoff(is)*sfr(is)
          ! Calculate total state_id (including water body)
          state_per_tstep = state_per_tstep+state_id(is)*sfr(is)
          ! Calculate total state_id (excluding water body)

          IF (NonWaterFraction/=0 .AND. is/=WaterSurf) THEN
             NWstate_per_tstep=NWstate_per_tstep+(state_id(is)*sfr(is)/NonWaterFraction)
          ENDIF

          ChangSnow(is)  = 0
          runoffSnow(is) = 0

       ENDIF
    ENDDO  !end loop over surfaces


    ! Convert evaporation to latent heat flux [W m-2]
    qe_per_tstep = ev_per_tstep*tlv
    qeOut        = qe_per_tstep

    ! Calculate volume of water that will move between grids
    ! Volume [m3] = Depth relative to whole area [mm] / 1000 [mm m-1] * SurfaceArea [m2]
    ! Need to use these volumes when converting back to addImpervious, AddVeg and AddWater
    runoffAGimpervious_m3 = runoffAGimpervious/1000 *SurfaceArea
    runoffAGveg_m3        = runoffAGveg/1000 *SurfaceArea
    runoffWaterBody_m3    = runoffWaterBody/1000 *SurfaceArea
    runoffPipes_m3        = runoffPipes/1000 *SurfaceArea

  END SUBROUTINE SUEWS_cal_QE
  !========================================================================

  !===============sensible heat flux======================================
  SUBROUTINE SUEWS_cal_QH(&
       QHMethod,&!input
       qn1,qf,QmRain,qeOut,qs,QmFreez,qm,avdens,avcp,tsurf,Temp_C,RA,&
       qh,qh_residual,qh_resist)!output
    IMPLICIT NONE

    INTEGER,INTENT(in) :: QHMethod ! option for QH calculation: 1, residual; 2, resistance-based

    REAL(KIND(1d0)),INTENT(in)::qn1
    REAL(KIND(1d0)),INTENT(in)::qf
    REAL(KIND(1d0)),INTENT(in)::QmRain
    REAL(KIND(1d0)),INTENT(in)::qeOut
    REAL(KIND(1d0)),INTENT(in)::qs
    REAL(KIND(1d0)),INTENT(in)::QmFreez
    REAL(KIND(1d0)),INTENT(in)::qm
    REAL(KIND(1d0)),INTENT(in)::avdens
    REAL(KIND(1d0)),INTENT(in)::avcp
    REAL(KIND(1d0)),INTENT(in)::tsurf
    REAL(KIND(1d0)),INTENT(in)::Temp_C
    REAL(KIND(1d0)),INTENT(in)::RA


    REAL(KIND(1d0)),INTENT(out)::qh
    REAL(KIND(1d0)),INTENT(out)::qh_resist
    REAL(KIND(1d0)),INTENT(out)::qh_residual

    REAL(KIND(1d0)),PARAMETER::NAN=-999

    ! Calculate sensible heat flux as a residual (Modified by LJ in Nov 2012)
    qh_residual=(qn1+qf+QmRain)-(qeOut+qs+Qm+QmFreez)     !qh=(qn1+qf+QmRain+QmFreez)-(qeOut+qs+Qm)

    ! ! Calculate QH using resistance method (for testing HCW 06 Jul 2016)
    ! Aerodynamic-Resistance-based method
    IF(RA/=0) THEN
       qh_resist = avdens*avcp*(tsurf-Temp_C)/RA
    ELSE
       qh_resist=NAN
    ENDIF

    ! choose output QH
    SELECT CASE (QHMethod)
    CASE (1)
       qh= qh_residual
    CASE (2)
       qh= qh_resist
    END SELECT


  END SUBROUTINE SUEWS_cal_QH
  !========================================================================

  !===============Resistance Calculations=======================
  SUBROUTINE SUEWS_cal_Resistance(&
       StabilityMethod,&!input:
       Diagnose,AerodynamicResistanceMethod,RoughLenHeatMethod,snowUse,&
       id,it,gsModel,SMDMethod,&
       qh_obs,avdens,avcp,h_mod,qn1,dectime,zzd,z0m,zdm,&
       avU1,Temp_C,VegFraction,&
       avkdn,Kmax,G1,G2,G3,G4,G5,G6,S1,S2,TH,TL,dq,&
       xsmd,vsmd,MaxConductance,LAIMax,LAI_id,snowFrac,sfr,&
       UStar,TStar,L_mod,&!output
       zL,gsc,ResistSurf,RA,RAsnow,rb)

    IMPLICIT NONE

    INTEGER,INTENT(in)::StabilityMethod
    INTEGER,INTENT(in)::Diagnose
    INTEGER,INTENT(in)::AerodynamicResistanceMethod
    INTEGER,INTENT(in)::RoughLenHeatMethod
    INTEGER,INTENT(in)::snowUse
    INTEGER,INTENT(in)::id
    INTEGER,INTENT(in)::it       !time: day of year and hour
    INTEGER,INTENT(in)::gsModel  !Choice of gs parameterisation (1 = Ja11, 2 = Wa16)
    INTEGER,INTENT(in)::SMDMethod!Method of measured soil moisture

    REAL(KIND(1d0)),INTENT(in)::qh_obs
    REAL(KIND(1d0)),INTENT(in)::avdens
    REAL(KIND(1d0)),INTENT(in)::avcp
    REAL(KIND(1d0)),INTENT(in)::h_mod
    REAL(KIND(1d0)),INTENT(in)::qn1
    REAL(KIND(1d0)),INTENT(in)::dectime    !Decimal time
    REAL(KIND(1d0)),INTENT(in)::zzd        !Active measurement height (meas. height-displac. height)
    REAL(KIND(1d0)),INTENT(in)::z0m        !Aerodynamic roughness length
    REAL(KIND(1d0)),INTENT(in)::zdm        !Displacement height
    REAL(KIND(1d0)),INTENT(in)::avU1       !Average wind speed
    REAL(KIND(1d0)),INTENT(in)::Temp_C     !Air temperature
    REAL(KIND(1d0)),INTENT(in)::VegFraction!Fraction of vegetation
    REAL(KIND(1d0)),INTENT(in)::avkdn      !Average downwelling shortwave radiation
    REAL(KIND(1d0)),INTENT(in)::Kmax       !Annual maximum hourly solar radiation
    REAL(KIND(1d0)),INTENT(in)::G1         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::G2         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::G3         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::G4         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::G5         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::G6         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::S1         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::S2         !Fitted parameters related to surface res. calculations
    REAL(KIND(1d0)),INTENT(in)::TH         !Maximum temperature limit
    REAL(KIND(1d0)),INTENT(in)::TL         !Minimum temperature limit
    REAL(KIND(1d0)),INTENT(in)::dq         !Specific humidity deficit
    REAL(KIND(1d0)),INTENT(in)::xsmd       !Measured soil moisture deficit
    REAL(KIND(1d0)),INTENT(in)::vsmd       !Soil moisture deficit for vegetated surfaces only (QUESTION: what about BSoil?)

    REAL(KIND(1d0)),DIMENSION(3),INTENT(in) ::MaxConductance!Max conductance [mm s-1]
    REAL(KIND(1d0)),DIMENSION(3),INTENT(in) ::LAIMax        !Max LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(3),INTENT(in) ::LAI_id        !=LAI_id(id-1,:), LAI for each veg surface [m2 m-2]

    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::snowFrac      !Surface fraction of snow cover
    REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr           !Surface fractions [-]

    REAL(KIND(1d0)),INTENT(out)::TStar     !T*
    REAL(KIND(1d0)),INTENT(out)  ::UStar     !Friction velocity
    ! REAL(KIND(1d0)),INTENT(out)::psim      !Stability function of momentum
    REAL(KIND(1d0)),INTENT(out)  ::zL        !
    REAL(KIND(1d0)),INTENT(out)  ::gsc       !Surface Layer Conductance
    REAL(KIND(1d0)),INTENT(out)  ::ResistSurf!Surface resistance
    REAL(KIND(1d0)),INTENT(out)  ::RA        !Aerodynamic resistance [s m^-1]
    REAL(KIND(1d0)),INTENT(out)  ::RAsnow    !Aerodynamic resistance for snow [s m^-1]
    REAL(KIND(1d0)),INTENT(out)  ::rb        !boundary layer resistance shuttleworth
    REAL(KIND(1d0)),INTENT(out)  ::L_mod     !Obukhov length
    REAL(KIND(1d0))              ::H_init    !Kinematic sensible heat flux [K m s-1] used to calculate friction velocity


    ! Get first estimate of sensible heat flux. Modified by HCW 26 Feb 2015
    CALL SUEWS_init_QH(&
         qh_obs,avdens,avcp,h_mod,qn1,dectime,&
         H_init)

    IF(Diagnose==1) WRITE(*,*) 'Calling STAB_lumps...'
    !u* and Obukhov length out
    CALL STAB_lumps(&
         StabilityMethod,&  ! input
         dectime,& !Decimal time
         zzd,&     !Active measurement height (meas. height-displac. height)
         z0m,&     !Aerodynamic roughness length
         zdm,&     !Displacement height
         avU1,&    !Average wind speed
         Temp_C,&  !Air temperature
         H_init,& !Kinematic sensible heat flux [K m s-1] used to calculate friction velocity
         L_mod,&! output: !Obukhov length
         TStar,& !T*
         UStar,& !Friction velocity
         zL)!Stability scale

    IF(Diagnose==1) WRITE(*,*) 'Calling AerodynamicResistance...'
    CALL AerodynamicResistance(&
         ZZD,&! input:
         z0m,&
         AVU1,&
         L_mod,&
         UStar,&
         VegFraction,&
         AerodynamicResistanceMethod,&
         StabilityMethod,&
         RoughLenHeatMethod,&
         RA) ! output:

    IF (snowUse==1) THEN
       IF(Diagnose==1) WRITE(*,*) 'Calling AerodynamicResistance for snow...'
       CALL AerodynamicResistance(&
            ZZD,&! input:
            z0m,&
            AVU1,&
            L_mod,&
            UStar,&
            VegFraction,&
            AerodynamicResistanceMethod,&
            StabilityMethod,&
            3,&
            RAsnow)     ! output:
    ENDIF

    IF(Diagnose==1) WRITE(*,*) 'Calling SurfaceResistance...'
    ! CALL SurfaceResistance(id,it)   !qsc and surface resistance out
    CALL SurfaceResistance(&
         id,it,&! input:
         SMDMethod,snowFrac,sfr,avkdn,Temp_C,dq,xsmd,vsmd,MaxConductance,&
         LAIMax,LAI_id,gsModel,Kmax,&
         G1,G2,G3,G4,G5,G6,TH,TL,S1,S2,&
         gsc,ResistSurf)! output:

    IF(Diagnose==1) WRITE(*,*) 'Calling BoundaryLayerResistance...'
    CALL BoundaryLayerResistance(&
         zzd,&! input:     !Active measurement height (meas. height-displac. height)
         z0m,&     !Aerodynamic roughness length
         avU1,&    !Average wind speed
         UStar,&  ! input/output:
         rb)  ! output:

  END SUBROUTINE SUEWS_cal_Resistance
  !========================================================================

  !==============Update output arrays=========================
  SUBROUTINE SUEWS_update_outputLine(&
       AdditionalWater,alb,avkdn,avU10_ms,azimuth,&!input
       chSnow_per_interval,dectime,&
       drain_per_tstep,E_mod,ev_per_tstep,ext_wu,Fc,Fc_build,fcld,&
       Fc_metab,Fc_photo,Fc_respi,Fc_traff,FlowChange,&
       h_mod,id,imin,int_wu,it,iy,&
       kup,LAI_id,ldown,l_mod,lup,mwh,&
       MwStore,&
       nsh_real,NWstate_per_tstep,Precip,q2_gkg,&
       qeOut,qf,qh,qh_resist,Qm,QmFreez,&
       QmRain,qn1,qn1_S,qn1_snowfree,qs,RA,&
       resistsurf,runoffAGimpervious,runoffAGveg,&
       runoff_per_tstep,runoffPipes,runoffSoil_per_tstep,&
       runoffWaterBody,sfr,smd,smd_nsurf,SnowAlb,SnowRemoval,&
       state_id,state_per_tstep,surf_chang_per_tstep,swe,t2_C,tskin_C,&
       tot_chang_per_tstep,tsurf,UStar,wu_DecTr,&
       wu_EveTr,wu_Grass,z0m,zdm,zenith_deg,&
       datetimeLine,dataOutLineSUEWS)!output
    IMPLICIT NONE

    REAL(KIND(1d0)),PARAMETER :: NAN=-999
    INTEGER,INTENT(in) :: iy
    ! INTEGER,INTENT(in) :: iy_prev_t
    INTEGER,INTENT(in) :: id
    ! INTEGER,INTENT(in) :: id_prev_t
    INTEGER,INTENT(in) :: it
    INTEGER,INTENT(in) :: imin

    REAL(KIND(1d0)),INTENT(in) :: AdditionalWater
    REAL(KIND(1d0)),INTENT(in) :: alb(nsurf)
    REAL(KIND(1d0)),INTENT(in) :: avkdn
    REAL(KIND(1d0)),INTENT(in) :: avU10_ms
    REAL(KIND(1d0)),INTENT(in) :: azimuth
    REAL(KIND(1d0)),INTENT(in) :: chSnow_per_interval
    REAL(KIND(1d0)),INTENT(in) :: dectime
    REAL(KIND(1d0)),INTENT(in) :: drain_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: E_mod
    REAL(KIND(1d0)),INTENT(in) :: ev_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: ext_wu
    REAL(KIND(1d0)),INTENT(in) :: Fc
    REAL(KIND(1d0)),INTENT(in) :: Fc_build
    REAL(KIND(1d0)),INTENT(in) :: Fc_metab
    REAL(KIND(1d0)),INTENT(in) :: Fc_photo
    REAL(KIND(1d0)),INTENT(in) :: Fc_respi
    REAL(KIND(1d0)),INTENT(in) :: Fc_traff
    REAL(KIND(1d0)),INTENT(in) :: fcld
    REAL(KIND(1d0)),INTENT(in) :: FlowChange
    REAL(KIND(1d0)),INTENT(in) :: h_mod
    REAL(KIND(1d0)),INTENT(in) :: int_wu
    REAL(KIND(1d0)),INTENT(in) :: kup
    REAL(KIND(1d0)),INTENT(in) :: l_mod
    REAL(KIND(1d0)),INTENT(in) :: LAI_id(nvegsurf)
    REAL(KIND(1d0)),INTENT(in) :: ldown
    REAL(KIND(1d0)),INTENT(in) :: lup
    REAL(KIND(1d0)),INTENT(in) :: mwh
    REAL(KIND(1d0)),INTENT(in) :: MwStore
    REAL(KIND(1d0)),INTENT(in) :: nsh_real
    REAL(KIND(1d0)),INTENT(in) :: NWstate_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: Precip
    REAL(KIND(1d0)),INTENT(in) :: q2_gkg
    REAL(KIND(1d0)),INTENT(in) :: qeOut
    REAL(KIND(1d0)),INTENT(in) :: qf
    REAL(KIND(1d0)),INTENT(in) :: qh
    REAL(KIND(1d0)),INTENT(in) :: qh_resist
    REAL(KIND(1d0)),INTENT(in) :: Qm
    REAL(KIND(1d0)),INTENT(in) :: QmFreez
    REAL(KIND(1d0)),INTENT(in) :: QmRain
    REAL(KIND(1d0)),INTENT(in) :: qn1
    REAL(KIND(1d0)),INTENT(in) :: qn1_S
    REAL(KIND(1d0)),INTENT(in) :: qn1_snowfree
    REAL(KIND(1d0)),INTENT(in) :: qs
    REAL(KIND(1d0)),INTENT(in) :: RA
    REAL(KIND(1d0)),INTENT(in) :: resistsurf
    REAL(KIND(1d0)),INTENT(in) :: runoff_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: runoffAGimpervious
    REAL(KIND(1d0)),INTENT(in) :: runoffAGveg
    REAL(KIND(1d0)),INTENT(in) :: runoffPipes
    REAL(KIND(1d0)),INTENT(in) :: runoffSoil_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: runoffWaterBody
    REAL(KIND(1d0)),INTENT(in) :: sfr(nsurf)
    REAL(KIND(1d0)),INTENT(in) :: smd
    REAL(KIND(1d0)),INTENT(in) :: smd_nsurf(nsurf)
    REAL(KIND(1d0)),INTENT(in) :: SnowAlb
    REAL(KIND(1d0)),INTENT(in) :: SnowRemoval(2)
    REAL(KIND(1d0)),INTENT(in) :: state_id(nsurf)
    REAL(KIND(1d0)),INTENT(in) :: state_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: surf_chang_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: swe
    REAL(KIND(1d0)),INTENT(in) :: t2_C
    REAL(KIND(1d0)),INTENT(in) :: tskin_C
    REAL(KIND(1d0)),INTENT(in) :: tot_chang_per_tstep
    REAL(KIND(1d0)),INTENT(in) :: tsurf
    REAL(KIND(1d0)),INTENT(in) :: UStar
    REAL(KIND(1d0)),INTENT(in) :: wu_DecTr
    REAL(KIND(1d0)),INTENT(in) :: wu_EveTr
    REAL(KIND(1d0)),INTENT(in) :: wu_Grass
    REAL(KIND(1d0)),INTENT(in) :: z0m
    REAL(KIND(1d0)),INTENT(in) :: zdm
    REAL(KIND(1d0)),INTENT(in) :: zenith_deg


    REAL(KIND(1D0)),DIMENSION(5),INTENT(OUT)::datetimeLine
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutSUEWS-5),INTENT(out) :: dataOutLineSUEWS
    ! REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutSnow-5),INTENT(out) :: dataOutLineSnow
    ! REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutESTM-5),INTENT(out) :: dataOutLineESTM

    ! INTEGER:: is
    REAL(KIND(1d0)):: LAI_wt

    ! the variables below with '_x' endings stand for 'exported' values
    REAL(KIND(1d0))::ResistSurf_x
    REAL(KIND(1d0))::l_mod_x
    REAL(KIND(1d0))::bulkalbedo
    REAL(KIND(1d0))::smd_nsurf_x(nsurf)
    REAL(KIND(1d0))::state_x(nsurf)

    !=====================================================================
    !====================== Prepare data for output ======================
    ! values outside of reasonable range are set as NAN-like numbers. TS 10 Jun 2018

    ! Remove non-existing surface type from surface and soil outputs   ! Added back in with NANs by HCW 24 Aug 2016
    state_x=UNPACK(SPREAD(NAN, dim=1, ncopies=SIZE(sfr)), mask=(sfr<0.00001), field=state_id)
    smd_nsurf_x=UNPACK(SPREAD(NAN, dim=1, ncopies=SIZE(sfr)), mask=(sfr<0.00001), field=smd_nsurf)

    ResistSurf_x=MIN(9999.,ResistSurf)

    l_mod_x=MAX(MIN(9999.,l_mod), -9999.)

    ! Calculate areally-weighted LAI
    ! IF(iy == (iy_prev_t  +1) .AND. (id-1) == 0) THEN   !Check for start of next year and avoid using LAI(id-1) as this is at the start of the year
    !    LAI_wt=DOT_PRODUCT(LAI(id_prev_t,:),sfr(1+2:nvegsurf+2))
    ! ELSE
    !    LAI_wt=DOT_PRODUCT(LAI(id-1,:),sfr(1+2:nvegsurf+2))
    ! ENDIF

    LAI_wt=DOT_PRODUCT(LAI_id(:),sfr(1+2:nvegsurf+2))

    ! Calculate areally-weighted albedo
    bulkalbedo=DOT_PRODUCT(alb,sfr)

    ! NB: this part needs to be reconsidered for calculation logic. TS, 27 Sep 2018
    ! TODO: this part should be reconnected to an improved CBL interface. TS 10 Jun 2018
    ! ! Save qh and qe for CBL in next iteration
    ! IF(Qh_choice==1) THEN   !use QH and QE from SUEWS
    !    qhforCBL(Gridiv) = qh
    !    qeforCBL(Gridiv) = qeOut
    ! ELSEIF(Qh_choice==2)THEN   !use QH and QE from LUMPS
    !    qhforCBL(Gridiv) = h_mod
    !    qeforCBL(Gridiv) = e_mod
    ! ELSEIF(qh_choice==3)THEN  !use QH and QE from OBS
    !    qhforCBL(Gridiv) = qh_obs
    !    qeforCBL(Gridiv) = qe_obs
    !    IF(qh_obs<-900.OR.qe_obs<-900)THEN  ! observed data has a problem
    !       CALL ErrorHint(22,'Unrealistic observed qh or qe_value.',qh_obs,qe_obs,qh_choice)
    !    ENDIF
    ! ENDIF



    !====================== update output line ==============================
    ! date & time:
    datetimeLine=[&
         REAL(iy,KIND(1D0)),REAL(id,KIND(1D0)),&
         REAL(it,KIND(1D0)),REAL(imin,KIND(1D0)),dectime]
    !Define the overall output matrix to be printed out step by step
    dataOutLineSUEWS=[&
         avkdn,kup,ldown,lup,tsurf,&
         qn1,qf,qs,qh,qeOut,&
         h_mod,e_mod,qh_resist,&
         precip,ext_wu,ev_per_tstep,runoff_per_tstep,tot_chang_per_tstep,&
         surf_chang_per_tstep,state_per_tstep,NWstate_per_tstep,drain_per_tstep,smd,&
         FlowChange/nsh_real,AdditionalWater,&
         runoffSoil_per_tstep,runoffPipes,runoffAGimpervious,runoffAGveg,runoffWaterBody,&
         int_wu,wu_EveTr,wu_DecTr,wu_Grass,&
         smd_nsurf_x(1:nsurf-1),&
         state_x(1:nsurf),&
         zenith_deg,azimuth,bulkalbedo,Fcld,&
         LAI_wt,z0m,zdm,&
         UStar,l_mod,RA,ResistSurf,&
         Fc,&
         Fc_photo,Fc_respi,Fc_metab,Fc_traff,Fc_build,&
         qn1_snowfree,qn1_S,SnowAlb,&
         Qm,QmFreez,QmRain,swe,mwh,MwStore,chSnow_per_interval,&
         SnowRemoval(1:2),&
         tskin_C,t2_C,q2_gkg,avU10_ms& ! surface-level diagonostics
         ]
    ! set invalid values to NAN
    ! dataOutLineSUEWS=set_nan(dataOutLineSUEWS)


    !====================update output line end==============================

  END SUBROUTINE SUEWS_update_outputLine
  !========================================================================

  !==============Update output arrays=========================
  SUBROUTINE SUEWS_update_output(&
       SnowUse,storageheatmethod,&!input
       ReadLinesMetdata,NumberOfGrids,&
       ir,gridiv,datetimeLine,dataOutLineSUEWS,dataOutLineSnow,dataOutLineESTM,&!input
       dataOutSUEWS,dataOutSnow,dataOutESTM)!inout
    IMPLICIT NONE

    INTEGER,INTENT(in) ::ReadLinesMetdata
    INTEGER,INTENT(in) ::NumberOfGrids
    INTEGER,INTENT(in) ::Gridiv
    INTEGER,INTENT(in) ::SnowUse
    INTEGER,INTENT(in) ::storageheatmethod
    INTEGER,INTENT(in) ::ir

    REAL(KIND(1d0)),DIMENSION(5),INTENT(in) :: datetimeLine
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutSUEWS-5),INTENT(in) :: dataOutLineSUEWS
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutESTM-5),INTENT(in) :: dataOutLineESTM
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutSnow-5),INTENT(in) :: dataOutLineSnow


    REAL(KIND(1d0)),INTENT(inout) :: dataOutSUEWS(ReadLinesMetdata,ncolumnsDataOutSUEWS,NumberOfGrids)
    REAL(KIND(1d0)),INTENT(inout) :: dataOutSnow(ReadLinesMetdata,ncolumnsDataOutSnow,NumberOfGrids)
    REAL(KIND(1d0)),INTENT(inout) :: dataOutESTM(ReadLinesMetdata,ncolumnsDataOutESTM,NumberOfGrids)


    !====================== update output arrays ==============================
    !Define the overall output matrix to be printed out step by step
    dataOutSUEWS(ir,1:ncolumnsDataOutSUEWS,Gridiv)=[datetimeLine,set_nan(dataOutLineSUEWS)]
    ! ! set invalid values to NAN
    ! dataOutSUEWS(ir,6:ncolumnsDataOutSUEWS,Gridiv)=set_nan(dataOutSUEWS(ir,6:ncolumnsDataOutSUEWS,Gridiv))

    IF (snowUse==1) THEN
       dataOutSnow(ir,1:ncolumnsDataOutSnow,Gridiv)=[datetimeLine,set_nan(dataOutLineSnow)]
    END IF

    IF (storageheatmethod==4) THEN
       dataOutESTM(ir,1:ncolumnsDataOutESTM,Gridiv)=[datetimeLine,set_nan(dataOutLineESTM)]
    END IF

    !====================update output arrays end==============================

  END SUBROUTINE SUEWS_update_output

  !========================================================================
  SUBROUTINE SUEWS_cal_Diagnostics(&
       dectime,&!input
       avU1,Temp_C,avRH,Press_hPa,&
       qh,qe,&
       VegFraction,zMeas,z0m,zdm,RA,avdens,avcp,lv_J_kg,tstep_real,&
       RoughLenHeatMethod,StabilityMethod,&
       avU10_ms,t2_C,q2_gkg,tskin_C)!output
    ! TS 03 Aug 2018: added limit on q2 by restricting RH2_max to 100%
    ! TS 31 Jul 2018: removed dependence on surface variables (Tsurf, qsat)
    ! TS 26 Jul 2018: improved the calculation logic
    ! TS 05 Sep 2017: improved interface
    ! TS 20 May 2017: calculate surface-level diagonostics
    IMPLICIT NONE
    REAL(KIND(1d0)),INTENT(in) ::dectime
    REAL(KIND(1d0)),INTENT(in) ::avU1,Temp_C,avRH
    REAL(KIND(1d0)),INTENT(in) ::qh
    REAL(KIND(1d0)),INTENT(in) ::Press_hPa,qe
    REAL(KIND(1d0)),INTENT(in) :: VegFraction,z0m,RA,avdens,avcp,lv_J_kg,tstep_real
    REAL(KIND(1d0)),INTENT(in) :: zMeas! height for measurement
    REAL(KIND(1d0)),INTENT(in) :: zdm ! displacement height

    ! INTEGER,INTENT(in)         :: opt ! 0 for momentum, 1 for temperature, 2 for humidity
    INTEGER,INTENT(in)         :: RoughLenHeatMethod,StabilityMethod

    REAL(KIND(1d0)),INTENT(out):: avU10_ms,t2_C,q2_gkg,tskin_C
    REAL(KIND(1d0))::qa_gkg,RH2
    REAL(KIND(1d0)),PARAMETER::k=0.4


    ! wind speed:
    CALL diagSfc(&
         0,&
         zMeas,avU1,0d0,10d0,avU10_ms,&
         VegFraction,&
         z0m,zdm,avdens,avcp,lv_J_kg,&
         avU1,Temp_C,qh,&
         RoughLenHeatMethod,StabilityMethod,tstep_real,dectime)

    ! temperature at 2 m agl:
    CALL diagSfc(&
         1,&
         zMeas,Temp_C,qh,2d0,t2_C,&
         VegFraction,&
         z0m,zdm,avdens,avcp,lv_J_kg,&
         avU1,Temp_C,qh,&
         RoughLenHeatMethod,StabilityMethod,tstep_real,dectime)

    ! skin temperature:
    tskin_C=qh/(avdens*avcp)*RA+temp_C


    ! humidity:
    qa_gkg=RH2qa(avRH/100,Press_hPa,Temp_c)
    CALL diagSfc(&
         2,&
         zMeas,qa_gkg,qe,2d0,q2_gkg,&
         VegFraction,&
         z0m,zdm,avdens,avcp,lv_J_kg,&
         avU1,Temp_C,qh,&
         RoughLenHeatMethod,StabilityMethod,tstep_real,dectime)
    ! re-examine if the diagnostic RH2 > 100% ?
    RH2=qa2RH(q2_gkg,Press_hPa,Temp_c)
    IF ( RH2>1 ) THEN
       ! if so, limit RH2 to 100%
       RH2=1d0
       ! and adjust the diagnostic q2_gkg
       q2_gkg=RH2qa(RH2,Press_hPa,Temp_c)
    END IF


  END SUBROUTINE SUEWS_cal_Diagnostics


  ! calculate several surface fraction related parameters
  SUBROUTINE SUEWS_cal_surf(&
       sfr,& !input
       vegfraction,ImpervFraction,PervFraction,NonWaterFraction) ! output
    IMPLICIT NONE

    REAL(KIND(1D0)),DIMENSION(NSURF),INTENT(IN)::sfr
    REAL(KIND(1D0)),INTENT(OUT)::VegFraction
    REAL(KIND(1D0)),INTENT(OUT)::ImpervFraction
    REAL(KIND(1D0)),INTENT(OUT)::PervFraction
    REAL(KIND(1D0)),INTENT(OUT)::NonWaterFraction


    VegFraction=sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)
    ImpervFraction=sfr(PavSurf)+sfr(BldgSurf)
    PervFraction=1-ImpervFraction
    NonWaterFraction=1 - sfr(WaterSurf)

  END SUBROUTINE SUEWS_cal_surf

  SUBROUTINE diagSfc(&
       opt,&
       zMeas,xMeas,xFlux,zDiag,xDiag,&
       VegFraction,&
       z0m,zd,avdens,avcp,lv_J_kg,&
       avU1,Temp_C,qh,&
       RoughLenHeatMethod,StabilityMethod,tstep_real,dectime)
    ! TS 31 Jul 2018: removed dependence on surface variables (Tsurf, qsat)
    ! TS 26 Jul 2018: improved the calculation logic
    ! TS 05 Sep 2017: improved interface
    ! TS 20 May 2017: calculate surface-level diagonostics


    IMPLICIT NONE
    REAL(KIND(1d0)),INTENT(in) :: dectime
    REAL(KIND(1d0)),INTENT(in) :: qh ! sensible heat flux
    REAL(KIND(1d0)),INTENT(in) :: z0m,avdens,avcp,lv_J_kg,tstep_real
    REAL(KIND(1d0)),INTENT(in) :: avU1,Temp_C ! atmospheric level variables
    REAL(KIND(1d0)),INTENT(in) :: zDiag ! height for diagonostics
    REAL(KIND(1d0)),INTENT(in) :: zMeas! height for measurement
    REAL(KIND(1d0)),INTENT(in) :: zd ! displacement height
    REAL(KIND(1d0)),INTENT(in) :: xMeas ! measurement at height
    REAL(KIND(1d0)),INTENT(in) :: xFlux!
    REAL(KIND(1d0)),INTENT(in) :: VegFraction ! vegetation fraction

    INTEGER,INTENT(in)         :: opt ! 0 for momentum, 1 for temperature, 2 for humidity
    INTEGER,INTENT(in)         :: RoughLenHeatMethod,StabilityMethod

    REAL(KIND(1d0)),INTENT(out):: xDiag

    REAL(KIND(1d0)) :: L_mod
    REAL(KIND(1d0)) :: psymz0,psyhzDiag,psyhzMeas,psyhz0,psymzDiag ! stability correction functions
    REAL(KIND(1d0)) :: z0h, cal_z0V ! Roughness length for heat
    REAL(KIND(1d0)) :: zDiagzd! height for diagnositcs
    REAL(KIND(1d0)) :: zMeaszd
    REAL(KIND(1d0)) :: tlv,H_kms,TStar,zL,UStar
    REAL(KIND(1d0)),PARAMETER :: muu=1.46e-5 !molecular viscosity
    REAL(KIND(1d0)),PARAMETER :: nan=-999
    REAL(KIND(1d0)),PARAMETER :: zdm=0 ! assuming Displacement height is ZERO
    REAL(KIND(1d0)),PARAMETER::k=0.4

    tlv=lv_J_kg/tstep_real !Latent heat of vapourisation per timestep
    zDiagzd=zDiag+z0m ! height at hgtX assuming Displacement height is ZERO; set lower limit as z0 to prevent arithmetic error, zd=0


    ! get !Kinematic sensible heat flux [K m s-1] used to calculate friction velocity
    CALL SUEWS_init_QH(&
         qh,avdens,avcp,qh,0d0,dectime,& ! use qh as qh_obs to initialise H_init
         H_kms)!output

    ! redo the calculation for stability correction
    CALL STAB_lumps(&
                                ! input
         StabilityMethod,&
         dectime,& !Decimal time
         zDiagzd,&     !Active measurement height (meas. height-displac. height)
         z0m,&     !Aerodynamic roughness length
         zdm,&     !Displacement height
         avU1,&    !Average wind speed
         Temp_C,&  !Air temperature
         H_kms,    & !Kinematic sensible heat flux [K m s-1] used to calculate friction velocity
                                ! output:
         L_MOD,& !Obukhov length
         TStar,& !T*
         UStar,& !Friction velocity
         zL)!Stability scale



    !***************************************************************
    ! log-law based stability corrections:
    ! Roughness length for heat
    z0h=cal_z0V(RoughLenHeatMethod,z0m,VegFraction,UStar)

    ! stability correction functions
    ! momentum:
    psymzDiag=stab_fn_mom(StabilityMethod,zDiagzd/L_mod,zDiagzd/L_mod)
    ! psymz2=stab_fn_mom(StabilityMethod,z2zd/L_mod,z2zd/L_mod)
    psymz0=stab_fn_mom(StabilityMethod,z0m/L_mod,z0m/L_mod)

    ! heat and vapor: assuming both are the same
    ! psyhz2=stab_fn_heat(StabilityMethod,z2zd/L_mod,z2zd/L_mod)
    psyhz0=stab_fn_heat(StabilityMethod,z0h/L_mod,z0h/L_mod)

    !***************************************************************
    SELECT CASE (opt)
    CASE (0) ! wind (momentum) at hgtX=10 m
       zDiagzd=zDiag+z0m! set lower limit as z0h to prevent arithmetic error, zd=0

       ! stability correction functions
       ! momentum:
       psymzDiag=stab_fn_mom(StabilityMethod,zDiagzd/L_mod,zDiagzd/L_mod)
       psymz0=stab_fn_mom(StabilityMethod,z0m/L_mod,z0m/L_mod)
       xDiag=UStar/k*(LOG(zDiagzd/z0m)-psymzDiag+psymz0) ! Brutsaert (2005), p51, eq.2.54

    CASE (1) ! temperature at hgtX=2 m
       zMeaszd=zMeas-zd
       zDiagzd=zDiag+z0h! set lower limit as z0h to prevent arithmetic error, zd=0

       ! heat and vapor: assuming both are the same
       psyhzMeas=stab_fn_heat(StabilityMethod,zMeaszd/L_mod,zMeaszd/L_mod)
       psyhzDiag=stab_fn_heat(StabilityMethod,zDiagzd/L_mod,zDiagzd/L_mod)
       ! psyhz0=stab_fn_heat(StabilityMethod,z0h/L_mod,z0h/L_mod)
       xDiag=xMeas+xFlux/(k*UStar*avdens*avcp)*(LOG(zMeaszd/zDiagzd)-(psyhzMeas-psyhzDiag)) ! Brutsaert (2005), p51, eq.2.55
       !  IF ( ABS((LOG(z2zd/z0h)-psyhz2+psyhz0))>10 ) THEN
       !     PRINT*, '#####################################'
       !     PRINT*, 'xSurf',xSurf
       !     PRINT*, 'xFlux',xFlux
       !     PRINT*, 'k*us*avdens*avcp',k*us*avdens*avcp
       !     PRINT*, 'k',k
       !     PRINT*, 'us',us
       !     PRINT*, 'avdens',avdens
       !     PRINT*, 'avcp',avcp
       !     PRINT*, 'xFlux/X',xFlux/(k*us*avdens*avcp)
       !     PRINT*, 'stab',(LOG(z2zd/z0h)-psyhz2+psyhz0)
       !     PRINT*, 'LOG(z2zd/z0h)',LOG(z2zd/z0h)
       !     PRINT*, 'z2zd',z2zd,'L_mod',L_mod,'z0h',z0h
       !     PRINT*, 'z2zd/L_mod',z2zd/L_mod
       !     PRINT*, 'psyhz2',psyhz2
       !     PRINT*, 'psyhz0',psyhz0
       !     PRINT*, 'psyhz2-psyhz0',psyhz2-psyhz0
       !     PRINT*, 'xDiag',xDiag
       !     PRINT*, '*************************************'
       !  END IF


    CASE (2) ! humidity at hgtX=2 m
       zMeaszd=zMeas-zd
       zDiagzd=zDiag+z0h! set lower limit as z0h to prevent arithmetic error, zd=0

       ! heat and vapor: assuming both are the same
       psyhzMeas=stab_fn_heat(StabilityMethod,zMeaszd/L_mod,zMeaszd/L_mod)
       psyhzDiag=stab_fn_heat(StabilityMethod,zDiagzd/L_mod,zDiagzd/L_mod)
       ! psyhz0=stab_fn_heat(StabilityMethod,z0h/L_mod,z0h/L_mod)

       xDiag=xMeas+xFlux/(k*UStar*avdens*tlv)*(LOG(zMeaszd/zDiagzd)-(psyhzMeas-psyhzDiag)) ! Brutsaert (2005), p51, eq.2.56


    END SELECT


  END SUBROUTINE diagSfc

  !===============set variable of invalid value to NAN=====================
  ELEMENTAL FUNCTION set_nan(x) RESULT(xx)
    IMPLICIT NONE
    REAL(KIND(1d0)),PARAMETER::pNAN=30000 ! 30000 to prevent water_state being filtered out as it can be large
    REAL(KIND(1d0)),PARAMETER::NAN=-999
    REAL(KIND(1d0)),INTENT(in)::x
    REAL(KIND(1d0))::xx

    IF(ABS(x)>pNAN) THEN
       xx=NAN
    ELSE
       xx=x
    ENDIF

  END FUNCTION set_nan
  !========================================================================

  !===============the functions below are only for test in f2py conversion===
  FUNCTION square(x) RESULT(xx)
    IMPLICIT NONE
    REAL(KIND(1d0)),PARAMETER::pNAN=9999
    REAL(KIND(1d0)),PARAMETER::NAN=-999
    REAL(KIND(1d0)),INTENT(in)::x
    REAL(KIND(1d0))::xx

    xx=x**2+nan/pNAN
    xx=x**2

  END FUNCTION square

  FUNCTION square_real(x) RESULT(xx)
    IMPLICIT NONE
    REAL,PARAMETER::pNAN=9999
    REAL,PARAMETER::NAN=-999
    REAL,INTENT(in)::x
    REAL::xx

    xx=x**2+nan/pNAN
    xx=x**2

  END FUNCTION square_real


END MODULE SUEWS_Driver

!SUEWS_Translate
!Translates - new input arrays (v2014b) to existing model variables
!           - between arrays for different grids and the model variables
!Made by HW&LJ Oct 2014
!-----------------------------------------------------------------------------------
! MH 21 Jun 2017 : Added anthropogenic CO2 charasteristic
! MH 16 Jun 2017 : Added biogenic CO2 characteristic
! HCW 13 Dec 2016 : LAIPower and LAIType for all vegetation types now used (previously only DecTr were used)
! HCW 12 Dec 2016 : Switched sign of lng so that input should be -ve for W, +ve for E, as is conventional
!Last modified HCW 26 Aug 2016
! NumCapita now uses average of day and night pop density, unless only one is specified
!Last modified HCW 06 Jul 2016
! Checks on ESTM fractions
!  - default setting to first ESTM Class code if surface not present and ESTM fractions do not sum to 1.
!Last modified HCW 29 Jun 2016
! Removed SoilMoistDay and StateDay
!Last modified: HCW 16 Jun 2016
! ESTM development for 7 surface types + snow, allowing 3x Paved classes and 5x Bldgs classes
! Currently surface characteristics are averaged here; probably want to average QS instead.
!Last modified: TS 13 Apr 2016
! Added AnOHM required variables.
!Last modified: LJ 06 Jul 2015
! Changed to read SnowAlb from ModelDailyState instead of SurfaceChar. Location also moved.
!Last modified: HCW 03 Jul 2015
! Use PopDensNighttime by default (not PopDensDaytime)
!Last modified: HCW 26 Jun 2015
! Translation of DailyState variables from the corresponding '_grids' arrays moved
! earlier in code in order to fix bug in DecidCap, AlbDec, Porosity.
!Last modified: HCW 28 Nov 2014
!
! To Do:
!       - Add AnOHM and ESTM info to FileChoices
!       - Check observed soil moisture works correctly!!
!       - Adjust model to allow water to runoff and sub-surface soil store for each surface type
!  - Adjust model to calculate LAI per surface
!  - Adjust model for SM per surface (measured characteristics)
!===================================================================================
SUBROUTINE SUEWS_Translate(Gridiv,ir,iMB)
  USE allocateArray
  USE ColNamesInputFiles
  USE ColNamesModelDailyState
  USE data_in
  USE defaultnotUsed, ONLY: notused, notusedi
  USE gis_data, ONLY: &
       areazh, vegfraction, veg_type, veg_fr, impervfraction, pervfraction, &
       nonwaterfraction, bldgh, evetreeh, dectreeh, treeh, faibldg, faievetree, faidectree, faitree
  USE mod_z, ONLY: z, z0m, z0m_in, zdm, zdm_in, zzd
  USE resist, ONLY: g1, g2, g3, g4, g5, g6, th, tl, s1, s2, kmax, gsmodel
  USE snowMod, ONLY: &
       snowlimpaved, snowlimbuild, radmeltfact, tempmeltfact, &
       snowAlbMin, snowAlbMax, tau_a, tau_f, preciplimitalb,&
       snowdensmin, snowdensmax, tau_r, crwmin, crwmax,&
       preciplimit, SnowProf_24hr, snowalb, snowfallcum
  USE sues_data, ONLY: &
       surfacearea_ha, surfacearea, irrfracconif, irrfracdecid, irrfracgrass,&
       soildensity, soildepthmeas, smcap, soilrocks, pipecapacity, flowchange,&
       runofftowater, ie_start, ie_end, internalwateruse_h, faut,&
       ie_a, ie_m, daywat, daywatper,&
       wuareaevetr_m2, wuareadectr_m2, wuareagrass_m2
  USE time, ONLY: iy, id, it, imin,isec, dectime
  USE ESTM_data
  USE WhereWhen, ONLY: gridid, gridid_text
  USE ESTM_module,ONLY:ESTM_translate


  IMPLICIT NONE

  INTEGER::Gridiv,&   !Index of the analysed grid (Gridcounter)
       ir,&       !Meteorological forcing file index (set to zero if SUEWS_Translate called from InitialState)
       iMB,&      !Chunk of met data
       id_prev

  INTEGER::iv,j,i
  !real (Kind(1d0)):: FCskip = -9   !NULL value used for output to FileChoices
  REAL (KIND(1d0)):: FCskip = -999  !NULL value used for output to FileChoices	(changed by HCW 24 May 2016)


  ! REAL(KIND(1d0)):: z0m_in, zdm_in  !Values of z0m and zdm provided in SiteSelect input file (do not get updated unlike z0d and z0m)

  CHARACTER(len=20):: grid_txt
  CHARACTER(len=4):: year_txt
  CHARACTER(len=12)::SsG_YYYY !Site, grid, year string

  CHARACTER(len=4):: iy_text
  CHARACTER(len=3):: id_text
  CHARACTER(len=2):: it_text, imin_text

  !write(*,*) '---- SUEWS_Translate ----'
  !write(*,*) 'Year:', SurfaceChar(Gridiv,c_Year)
  !write(*,*) 'Grid:', SurfaceChar(Gridiv,c_Grid)
  !write(*,*) 'Gridiv:', Gridiv
  !write(*,*) 'Met block (iMB or iv):',iMB
  !write(*,*) 'Met line (ir):',ir
  !write(*,*) '----'

  ! =================================================================================
  ! ======= Translate inputs from SurfaceChar to variable names used in model =======
  ! =================================================================================
  ! GridID = GridIDmatrix(Gridiv) ! also in SUEWS_Program so deleted here. TS 10 Jun 2018
  ! ---- Latitude and longitude
  lat = SurfaceChar(Gridiv,c_lat)
  lng = SurfaceChar(Gridiv,c_lng)
  ! ---- Timezone
  TIMEZONE = SurfaceChar(Gridiv,c_tz)
  ! ---- Altitude [m]
  Alt = SurfaceChar(Gridiv,c_Alt)
  ! ---- Measurement height [m]
  z = SurfaceChar(Gridiv,c_z)
  ! ---- Surface area [ha]
  SurfaceArea_ha = SurfaceChar(Gridiv,c_Area)
  ! Change from ha to m2 (was in RunControlByGridByYear)
  SurfaceArea = SurfaceArea_ha*10000 !Change surface area from ha to m^2

  ! ---- Surface fractions (previously in LUMPS_gis_read)
  sfr(PavSurf)   = SurfaceChar(Gridiv,c_FrPaved)  ! Paved
  sfr(BldgSurf)  = SurfaceChar(Gridiv,c_FrBldgs)  ! Bldgs
  sfr(ConifSurf) = SurfaceChar(Gridiv,c_FrEveTr)  ! Everg
  sfr(DecidSurf) = SurfaceChar(Gridiv,c_FrDecTr)  ! Decid
  sfr(GrassSurf) = SurfaceChar(Gridiv,c_FrGrass)  ! Grass
  sfr(BSoilSurf) = SurfaceChar(Gridiv,c_FrBSoil)  ! BSoil
  sfr(WaterSurf) = SurfaceChar(Gridiv,c_FrWater)  ! Water

  ! Check the surface fractions add up to 1 (or close to 1)
  IF(SUM(sfr)>1.001.OR.SUM(sfr)<0.999) CALL ErrorHint(10,'Surface fractions (Fr_) should add up to 1.',SUM(sfr),notUsed,notUsedI)

  ! ---- Irrigated fractions
  IrrFracConif = SurfaceChar(Gridiv,c_IrrEveTrFrac)  ! Everg
  IrrFracDecid = SurfaceChar(Gridiv,c_IrrDecTrFrac)  ! Decid
  IrrFracGrass = SurfaceChar(Gridiv,c_IrrGrassFrac)  ! Grass

  ! ---------------------------------------------------------------------------------
  ! --------- Surface cover calculations (previously in LUMPS_gis_read) -------------

  ! ---- Buildings and trees fraction ----
  areaZh = (sfr(BldgSurf) + sfr(ConifSurf) + sfr(DecidSurf))

  ! ---- Vegetated fraction ----
  VegFraction = (sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf) + sfr(BSoilSurf))
  !VegFraction = (sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf))

  ! ---- Vegetated fraction (for LUMPS) ----
  ! For LUMPS, vegetated fraction includes Water and Bare soil surfaces
  IF(veg_type==1) THEN          ! area vegetated
     veg_fr = (sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf) + sfr(BSoilSurf) + sfr(WaterSurf))
  ELSEIF(veg_type==2) THEN      ! area irrigated
     veg_fr = (IrrFracConif*sfr(ConifSurf) + IrrFracDecid*sfr(DecidSurf) + IrrFracGrass*sfr(GrassSurf))
  ENDIF

  ImpervFraction =  (sfr(PavSurf) + sfr(BldgSurf))
  PervFraction =  (sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf) + sfr(BSoilSurf) + sfr(WaterSurf))
  NonWaterFraction = (sfr(PavSurf) + sfr(BldgSurf) + sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf) + sfr(BSoilSurf))
  ! ---------------------------------------------------------------------------------

  ! ---- Heights & frontal areas
  BldgH      = SurfaceChar(Gridiv,c_HBldgs)                                                            ! Building height [m]
  EveTreeH   = SurfaceChar(Gridiv,c_HEveTr)                                                            ! Evergreen tree height [m]
  DecTreeH   = SurfaceChar(Gridiv,c_HDecTr)                                                            ! Deciduous tree height [m]
  IF ( sfr(ConifSurf)+sfr(DecidSurf)>0. ) THEN ! avoid arithmetic error
     TreeH = (EveTreeH*sfr(ConifSurf) + DecTreeH*sfr(DecidSurf))/(sfr(ConifSurf)+sfr(DecidSurf))     ! Average tree height [m]
  ELSE
     TreeH = 1.
  END IF

  FAIBldg    = SurfaceChar(Gridiv,c_FAIBldgs)                                                          ! Frontal area index for buildings
  FAIEveTree = SurfaceChar(Gridiv,c_FAIEveTr)                                                          ! Frontal area index for evergreen trees
  FAIDecTree = SurfaceChar(Gridiv,c_FAIDecTr)                                                          ! Frontal area index for deciduous trees
  IF ( sfr(ConifSurf)+sfr(DecidSurf)>0. ) THEN ! avoid arithmetic error
     FAITree    = (FAIEveTree*sfr(ConifSurf) + FAIDecTree*sfr(DecidSurf))/(sfr(ConifSurf)+sfr(DecidSurf)) ! Frontal area index for trees
  ELSE
     FAITree = 1.
  END IF

  z0m        = SurfaceChar(Gridiv,c_z0m)                                                               ! Roughness length [m]
  zdm        = SurfaceChar(Gridiv,c_zdm)                                                               ! Displacement height [m]
  ! z0m and zdm can vary in time depending on z0method selected. Save the input values here
  z0m_in = z0m
  zdm_in = zdm

  ! ---- Population
  PopDensDaytime   = SurfaceChar(Gridiv,c_PopDensDay)   ! Daytime population density [ha-1]
  PopDensNighttime = SurfaceChar(Gridiv,c_PopDensNight) ! Night-time population density [ha-1]
  ! Pop density [ha-1]
  IF(PopDensDaytime >= 0 .AND. PopDensNighttime <  0) PopDensNighttime = PopDensDaytime  !If only daytime data provided, use them
  IF(PopDensDaytime <  0 .AND. PopDensNighttime >= 0) PopDensDaytime = PopDensNighttime  !If only night-time data provided, use them
  IF(PopDensDaytime >= 0 .AND. PopDensNighttime >= 0) NumCapita = (PopDensDaytime+PopDensNighttime)/2  !If both, use average

  ! ---- Traffic rate
  TrafficRate = SurfaceChar(Gridiv,(/c_TrafficRate_WD,c_TrafficRate_WE/)) ! Mean traffic rate within modelled area
  ! ---- Building energy use
  QF0_BEU          = SurfaceChar(Gridiv,(/c_QF0_BEU_WD,c_QF0_BEU_WE/))   ! Building energy use within modelled area

  ! ---- Albedo [-]
  alb(1:nsurf) = SurfaceChar(Gridiv,c_AlbMax)   !Use maximum albedos as default value (AlbMin for veg surfaces handled below)

  ! ---- Set min & max albedo for vegetated surfaces (min albedo not currently used for NonVeg or Water surfaces)
  AlbMin_EveTr = SurfaceChar(Gridiv,c_AlbMin(ConifSurf))
  AlbMax_EveTr = SurfaceChar(Gridiv,c_AlbMax(ConifSurf))
  AlbMin_DecTr = SurfaceChar(Gridiv,c_AlbMin(DecidSurf))
  AlbMax_DecTr = SurfaceChar(Gridiv,c_AlbMax(DecidSurf))
  AlbMin_Grass = SurfaceChar(Gridiv,c_AlbMin(GrassSurf))
  AlbMax_Grass = SurfaceChar(Gridiv,c_AlbMax(GrassSurf))

  ! ---- Emissivity [-]
  emis(1:nsurf) = SurfaceChar(Gridiv,c_Emis)
  emis_snow     = SurfaceChar(Gridiv,c_SnowEmis)

  ! ---- Storage capacities [mm]
  StoreDrainPrm(1,1:nsurf) = SurfaceChar(Gridiv,c_StorMin)   ! Minimum
  StoreDrainPrm(5,1:nsurf) = SurfaceChar(Gridiv,c_StorMax)   ! Maximum
  StoreDrainPrm(6,1:nsurf) = StoreDrainPrm(1,1:nsurf)  !Set storage capacities for all surface to minimum (DecTr changes with time in Calculations).

  ! ---- Set min & max storage capacities for DecTr
  CapMin_dec = StoreDrainPrm(1,DecidSurf)
  CapMax_dec = StoreDrainPrm(5,DecidSurf)
  ! ---- Set min & max porosity for DecTr
  PorMin_dec = SurfaceChar(Gridiv,c_PorosityMin(ivDecid))   ! Minimum
  PorMax_dec = SurfaceChar(Gridiv,c_PorosityMax(ivDecid))   ! Minimum

  ! ---- Threshold for wet evaporation [mm]
  WetThresh(1:nsurf) = SurfaceChar(Gridiv,c_WetThresh)

  ! ---- Limit for state [mm]
  StateLimit(1:nsurf) = SurfaceChar(Gridiv,c_StateLimit)

  ! ---- Water depth [mm]
  WaterDepth = SurfaceChar(Gridiv,c_WaterDepth)

  ! ---- Drainage
  StoreDrainPrm(2,1:nsurf) = SurfaceChar(Gridiv,c_DrEq)      ! Drainage equation
  StoreDrainPrm(3,1:nsurf) = SurfaceChar(Gridiv,c_DrCoef1)   ! Drainage coef 1
  StoreDrainPrm(4,1:nsurf) = SurfaceChar(Gridiv,c_DrCoef2)   ! Drainage coef 2

  ! ---- Limit of SWE (each surface except Water)
  snowD(1:(nsurf-1)) = SurfaceChar(Gridiv,c_SnowLimPat(1:(nsurf-1)))

  ! ---- Snow limit for removal (only impervious surfaces)
  SnowLimPaved = SurfaceChar(Gridiv,c_SnowLimRem(PavSurf))
  SnowLimBuild = SurfaceChar(Gridiv,c_SnowLimRem(BldgSurf))
  !SnowLimBSoil = SurfaceChar(Gridiv,c_SnowLimRem(BSoilSurf))   !Snow clearing not applicable to bare soil surface

  ! ---- Soil characteristics (each surface except Water)
  SoilDepth(1:(nsurf-1))           = SurfaceChar(Gridiv,c_SoilDepth(1:(nsurf-1))) ! Depth of sub-surface soil store [mm]
  SoilStoreCap(1:(nsurf-1))        = SurfaceChar(Gridiv,c_SoilStCap(1:(nsurf-1))) ! Soil store capacity [mm]
  SatHydraulicConduct(1:(nsurf-1)) = SurfaceChar(Gridiv,c_KSat(1:(nsurf-1)))      ! Hydraulic conductivity of saturated soil [mm s-1]
  !SoilDensity(1:(nsurf-1)) = SurfaceChar(Gridiv,c_SoilDens(1:(nsurf-1))) ! Soil density [kg m-3]
  ! Not yet implemented in model
  !InfiltrationRate  (1:(nsurf-1)) = SurfaceChar(Gridiv,c_SoilInfRate(1:(nsurf-1))) ! Infiltration rate [mm h-1]

  !! Observed soil characteristics
  !SoilDensity  (1:(nsurf-1)) = SurfaceChar(Gridiv,c_SoilDens(1:(nsurf-1))) ! Soil density [kg m-3]
  !SoilDepthMeas(1:(nsurf-1)) = SurfaceChar(Gridiv,c_ObsSMDepth(1:(nsurf-1)))
  !SmCap        (1:(nsurf-1)) = SurfaceChar(Gridiv,c_ObsSMMax(1:(nsurf-1)))
  !SoilRocks    (1:(nsurf-1)) = SurfaceChar(Gridiv,c_ObsSNRFrac(1:(nsurf-1)))
  !!Obs soil characteristics now in SUEWS_Soil, i.e. per surface; single value was given previously in FunctionalTypes
  !!Take first row here for testing !! Need to alter model later...
  SoilDensity   = SurfaceChar(Gridiv,c_SoilDens(1)) !!Not sure this works correctly - need to check
  SoilDepthMeas = SurfaceChar(Gridiv,c_ObsSMDepth(1))
  SmCap         = SurfaceChar(Gridiv,c_ObsSMMax(1))
  SoilRocks     = SurfaceChar(Gridiv,c_ObsSNRFrac(1))

  ! ---- Vegetation characteristics (pervious surfaces)
  BaseT  (1:nvegsurf) = SurfaceChar(Gridiv,c_BaseT)
  BaseTe (1:nvegsurf) = SurfaceChar(Gridiv,c_BaseTe)
  GDDFull(1:nvegsurf) = SurfaceChar(Gridiv,c_GDDFull)
  SDDFull(1:nvegsurf) = SurfaceChar(Gridiv,c_SDDFull)
  LAIMin (1:nvegsurf) = SurfaceChar(Gridiv,c_LAIMin)
  LAIMax (1:nvegsurf) = SurfaceChar(Gridiv,c_LAIMax)
  MaxConductance(1:nvegsurf) = SurfaceChar(Gridiv,c_GsMax)

  alpha_bioCO2(1:nvegsurf)     = SurfaceChar(Gridiv,c_alpha_bioCO2)
  beta_bioCO2(1:nvegsurf)      = SurfaceChar(Gridiv,c_beta_bioCO2)
  theta_bioCO2(1:nvegsurf)     = SurfaceChar(Gridiv,c_theta_bioCO2)
  alpha_enh_bioCO2(1:nvegsurf) = SurfaceChar(Gridiv,c_alpha_enh_bioCO2)
  beta_enh_bioCO2(1:nvegsurf)  = SurfaceChar(Gridiv,c_beta_enh_bioCO2)
  resp_a(1:nvegsurf)           = SurfaceChar(Gridiv,c_resp_a)
  resp_b(1:nvegsurf)           = SurfaceChar(Gridiv,c_resp_b)
  min_res_bioCO2(1:nvegsurf)   = SurfaceChar(Gridiv,c_min_res_bioCO2)

  ! ---- LAI characteristics (updated HCW 13 Dec 2016)
  LAItype(1:nvegsurf) = INT(SurfaceChar(Gridiv,c_LAIEq(1:nvegsurf)))
  LAIPower(1,1:nvegsurf) = SurfaceChar(Gridiv,c_LeafGP1(1:nvegsurf))
  LAIPower(2,1:nvegsurf) = SurfaceChar(Gridiv,c_LeafGP2(1:nvegsurf))
  LAIPower(3,1:nvegsurf) = SurfaceChar(Gridiv,c_LeafOP1(1:nvegsurf))
  LAIPower(4,1:nvegsurf) = SurfaceChar(Gridiv,c_LeafOP2(1:nvegsurf))

  ! ---- LUMPS-related parameters
  DRAINRT    = SurfaceChar(Gridiv,c_LUMPSDr)      ! LUMPS Drainage rate [mm h-1]
  RAINCOVER  = SurfaceChar(Gridiv,c_LUMPSCover)   ! LUMPS Limit when surface totally wet [mm]
  RAINMAXRES = SurfaceChar(Gridiv,c_LUMPSMaxRes)  ! LUMPS Maximum water bucket reservoir [mm]

  ! ---- NARP-related parameters
  TRANS_SITE = SurfaceChar(Gridiv,c_NARPTrans)    ! NARP atmospheric transmissivity

  ! ---- Snow-related characteristics
  RadMeltFact    = SurfaceChar(Gridiv,c_SnowRMFactor)
  TempMeltFact   = SurfaceChar(Gridiv,c_SnowTMFactor)
  SnowAlbMin     = SurfaceChar(Gridiv,c_SnowAlbMin)
  SnowAlbMax     = SurfaceChar(Gridiv,c_SnowAlbMax)
  tau_a          = SurfaceChar(Gridiv,c_Snowtau_a)
  tau_f          = SurfaceChar(Gridiv,c_Snowtau_f)
  PrecipLimitAlb = SurfaceChar(Gridiv,c_SnowPlimAlb)
  SnowDensMin    = SurfaceChar(Gridiv,c_SnowSDMin)
  SnowDensMax    = SurfaceChar(Gridiv,c_SnowSDMax)
  tau_r          = SurfaceChar(Gridiv,c_Snowtau_r)
  CRWMin         = SurfaceChar(Gridiv,c_SnowCRWMin)
  CRWMax         = SurfaceChar(Gridiv,c_SnowCRWMax)
  PrecipLimit    = SurfaceChar(Gridiv,c_SnowPLimSnow)

  ! ---- Conductance parameters
  G1   = SurfaceChar(Gridiv,c_GsG1)
  G2   = SurfaceChar(Gridiv,c_GsG2)
  G3   = SurfaceChar(Gridiv,c_GsG3)
  G4   = SurfaceChar(Gridiv,c_GsG4)
  G5   = SurfaceChar(Gridiv,c_GsG5)
  G6   = SurfaceChar(Gridiv,c_GsG6)
  TH   = SurfaceChar(Gridiv,c_GsTH)
  TL   = SurfaceChar(Gridiv,c_GsTL)
  S1   = SurfaceChar(Gridiv,c_GsS1)
  S2   = SurfaceChar(Gridiv,c_GsS2)
  Kmax = SurfaceChar(Gridiv,c_GsKmax)
  gsModel = INT(SurfaceChar(Gridiv,c_gsModel))

  ! ---- Pipe capacity (was from SiteSpecificParam.txt)
  PipeCapacity = SurfaceChar(Gridiv,c_PipeCapacity)

  ! ---- Water flows (was from SiteSpecificParam.txt)
  FlowChange = SurfaceChar(Gridiv,c_FlowChange)
  RunoffToWater = SurfaceChar(Gridiv,c_RunoffToWater)

  ! ---- Daylight saving (was from ModelledYears.txt)
  startDLS = INT(SurfaceChar(Gridiv,c_StartDLS))
  endDLS = INT(SurfaceChar(Gridiv,c_EndDLS))

  ! ---- OHM coeffs (was in SUEWS_OHMnew.f95, subroutine OHMinitialize)
  OHM_coef = 0 ! Initialise OHM_coef
  ! Surface types in OHM_coef: Paved, Roof, Conif, Decid, Grass, BareSoil, Water, CANYON, Snow
  ! No canyon in SurfaceChar, so
  !  transfer coeffs for surface types 1-7,
  !  then skip row in OHM_coef (canyon),
  !  then transfer coeffs for snow surface (8th surface in SurfaceChar; 9th surface in OHM_Coefs)
  ! Summer wet
  OHM_coef(1:nsurf,1,1) = SurfaceChar(Gridiv,c_a1_SWet(1:nsurf)) !1:nsurf a1 Summer wet
  OHM_coef(nsurf+1,1,1) = SurfaceChar(Gridiv,c_a1_SWet(nsurf+1)) !Snow    a1 Summer wet
  OHM_coef(1:nsurf,1,2) = SurfaceChar(Gridiv,c_a2_SWet(1:nsurf)) !1:nsurf a2 Summer wet
  OHM_coef(nsurf+1,1,2) = SurfaceChar(Gridiv,c_a2_SWet(nsurf+1)) !Snow    a2 Summer wet
  OHM_coef(1:nsurf,1,3) = SurfaceChar(Gridiv,c_a3_SWet(1:nsurf)) !1:nsurf a3 Summer wet
  OHM_coef(nsurf+1,1,3) = SurfaceChar(Gridiv,c_a3_SWet(nsurf+1)) !Snow    a3 Summer wet
  ! Summer dry
  OHM_coef(1:nsurf,2,1) = SurfaceChar(Gridiv,c_a1_SDry(1:nsurf)) !1:nsurf a1 Summer dry
  OHM_coef(nsurf+1,2,1) = SurfaceChar(Gridiv,c_a1_SDry(nsurf+1)) !Snow    a1 Summer dry
  OHM_coef(1:nsurf,2,2) = SurfaceChar(Gridiv,c_a2_SDry(1:nsurf)) !1:nsurf a2 Summer dry
  OHM_coef(nsurf+1,2,2) = SurfaceChar(Gridiv,c_a2_SDry(nsurf+1)) !Snow    a2 Summer dry
  OHM_coef(1:nsurf,2,3) = SurfaceChar(Gridiv,c_a3_SDry(1:nsurf)) !1:nsurf a3 Summer dry
  OHM_coef(nsurf+1,2,3) = SurfaceChar(Gridiv,c_a3_SDry(nsurf+1)) !Snow    a3 Summer dry
  ! Winter wet
  OHM_coef(1:nsurf,3,1) = SurfaceChar(Gridiv,c_a1_WWet(1:nsurf)) !1:nsurf a1 Winter wet
  OHM_coef(nsurf+1,3,1) = SurfaceChar(Gridiv,c_a1_WWet(nsurf+1)) !Snow    a1 Winter wet
  OHM_coef(1:nsurf,3,2) = SurfaceChar(Gridiv,c_a2_WWet(1:nsurf)) !1:nsurf a2 Winter wet
  OHM_coef(nsurf+1,3,2) = SurfaceChar(Gridiv,c_a2_WWet(nsurf+1)) !Snow    a2 Winter wet
  OHM_coef(1:nsurf,3,3) = SurfaceChar(Gridiv,c_a3_WWet(1:nsurf)) !1:nsurf a3 Winter wet
  OHM_coef(nsurf+1,3,3) = SurfaceChar(Gridiv,c_a3_WWet(nsurf+1)) !Snow    a3 Winter wet
  ! Winter dry
  OHM_coef(1:nsurf,4,1) = SurfaceChar(Gridiv,c_a1_WDry(1:nsurf)) !1:nsurf a1 Winter dry
  OHM_coef(nsurf+1,4,1) = SurfaceChar(Gridiv,c_a1_WDry(nsurf+1)) !Snow    a1 Winter dry
  OHM_coef(1:nsurf,4,2) = SurfaceChar(Gridiv,c_a2_WDry(1:nsurf)) !1:nsurf a2 Winter dry
  OHM_coef(nsurf+1,4,2) = SurfaceChar(Gridiv,c_a2_WDry(nsurf+1)) !Snow    a2 Winter dry
  OHM_coef(1:nsurf,4,3) = SurfaceChar(Gridiv,c_a3_WDry(1:nsurf)) !1:nsurf a3 Winter dry
  OHM_coef(nsurf+1,4,3) = SurfaceChar(Gridiv,c_a3_WDry(nsurf+1)) !Snow    a3 Winter dry
  ! OHM thresholds
  OHM_threshSW(1:nsurf) = SurfaceChar(Gridiv,c_OHMThresh_SW(1:nsurf)) !1:nsurf
  OHM_threshSW(nsurf+1) = SurfaceChar(Gridiv,c_OHMThresh_SW(nsurf+1)) !Snow
  OHM_threshWD(1:nsurf) = SurfaceChar(Gridiv,c_OHMThresh_WD(1:nsurf)) !1:nsurf
  OHM_threshWD(nsurf+1) = SurfaceChar(Gridiv,c_OHMThresh_WD(nsurf+1)) !Snow

  ! ---- ESTM characteristics -------------------------
  ! HCW 16 Jun 2016
  ! Wall fraction for ESTM (in SiteSelect.txt)
  IF(StorageHeatMethod==4 .OR. StorageHeatMethod==14) THEN
     AreaWall = SurfaceChar(Gridiv,c_AreaWall)
     fwall=AreaWall/SurfaceArea

     ! Get surface fractions for ESTM classes for Bldgs and Paved surfaces
     ESTMsfr_Paved = SurfaceChar(Gridiv,c_Fr_ESTMClass_Paved)   !Dim 3
     ESTMsfr_Bldgs = SurfaceChar(Gridiv,c_Fr_ESTMClass_Bldgs)   !Dim 5
     !Check these sum to 1 and are consistent with sfr of Paved and Bldgs surface types
     IF(sfr(PavSurf) > 0) THEN  !If surface exists, ESTM fractions must be correct
        IF(SUM(ESTMsfr_Paved)>1.001.OR.SUM(ESTMsfr_Paved)<0.999) THEN
           CALL ErrorHint(10,'Surface fractions (Fr_ESTMClass_Paved) should sum to 1.',SUM(ESTMsfr_Paved),notUsed,notUsedI)
        ENDIF
     ELSEIF(sfr(PavSurf) == 0) THEN !If surface does not exist, ESTM fraction does not matter
        IF(SUM(ESTMsfr_Paved)>1.001.OR.SUM(ESTMsfr_Paved)<0.999) THEN   !If ESTM fractions do not sum to 1, set here
           ESTMsfr_Paved(1) = 1.000
           ESTMsfr_Paved(2:3) = 0.000
           CALL ErrorHint(67,'ESTM Paved classes do not sum to 1 (but no Paved surface present).',&
                SUM(ESTMsfr_Paved),notUsed,notUsedI)
        ENDIF
     ENDIF
     IF(sfr(BldgSurf) > 0) THEN
        IF(SUM(ESTMsfr_Bldgs)>1.001.OR.SUM(ESTMsfr_Bldgs)<0.999) THEN
           CALL ErrorHint(10,'Surface fractions (Fr_ESTMClass_Bldgs) should sum to 1.',SUM(ESTMsfr_Bldgs),notUsed,notUsedI)
        ENDIF
     ELSEIF(sfr(BldgSurf) == 0) THEN !If surface does not exist, ESTM fraction does not matter
        IF(SUM(ESTMsfr_Bldgs)>1.001.OR.SUM(ESTMsfr_Bldgs)<0.999) THEN   !If ESTM fractions do not sum to 1, set here
           ESTMsfr_Bldgs(1) = 1.000
           ESTMsfr_Bldgs(2:5) = 0.000
           CALL ErrorHint(67,'ESTM Bldgs classes do not sum to 1 (but no Bldgs surface present).',&
                SUM(ESTMsfr_Bldgs),notUsed,notUsedI)
        ENDIF
     ENDIF

     ! ===== PAVED =====
     ! First combine characteristics of the 3x Paved classes
     IF(SurfaceChar(Gridiv,c_ESTMCode(PavSurf)) == 0) THEN   ! If Code = 0, use multiple classes
        ! Get characteristics of each Paved class
        DO i=1,3
           zSurf_Paved(:,i) = SurfaceChar(Gridiv,(/c_Surf_thick1_Paved(i),c_Surf_thick2_Paved(i),c_Surf_thick3_Paved(i), &
                c_Surf_thick4_Paved(i),c_Surf_thick5_Paved(i)/))
           kSurf_Paved(:,i) = SurfaceChar(Gridiv,(/c_Surf_k1_Paved(i),c_Surf_k2_Paved(i),c_Surf_k3_Paved(i), &
                c_Surf_k4_Paved(i),c_Surf_k5_Paved(i)/))
           rSurf_Paved(:,i) = SurfaceChar(Gridiv,(/c_Surf_rhoCp1_Paved(i),c_Surf_rhoCp2_Paved(i),c_Surf_rhoCp3_Paved(i), &
                c_Surf_rhoCp4_Paved(i),c_Surf_rhoCp5_Paved(i)/))
        ENDDO
        ! Average characteristics of each Paved class according to surface fractions (these sum to 1)
        zSurf_SUEWSsurfs(:,PavSurf) = zSurf_Paved(:,1)*ESTMsfr_Paved(1) &
             + zSurf_Paved(:,2)*ESTMsfr_Paved(2) &
             + zSurf_Paved(:,3)*ESTMsfr_Paved(3)
        kSurf_SUEWSsurfs(:,PavSurf) = kSurf_Paved(:,1)*ESTMsfr_Paved(1) &
             + kSurf_Paved(:,2)*ESTMsfr_Paved(2) &
             + kSurf_Paved(:,3)*ESTMsfr_Paved(3)
        rSurf_SUEWSsurfs(:,PavSurf) = rSurf_Paved(:,1)*ESTMsfr_Paved(1) &
             + rSurf_Paved(:,2)*ESTMsfr_Paved(2) &
             + rSurf_Paved(:,3)*ESTMsfr_Paved(3)
     ELSEIF(SurfaceChar(Gridiv,c_ESTMCode(PavSurf)) /= 0) THEN   !Otherwise use single values
        zSurf_SUEWSsurfs(:,PavSurf) = SurfaceChar(Gridiv,(/c_Surf_thick1(PavSurf),c_Surf_thick2(PavSurf),c_Surf_thick3(PavSurf),&
             c_Surf_thick4(PavSurf),c_Surf_thick5(PavSurf)/))
        kSurf_SUEWSsurfs(:,PavSurf) = SurfaceChar(Gridiv,(/c_Surf_k1(PavSurf),c_Surf_k2(PavSurf),c_Surf_k3(PavSurf),&
             c_Surf_k4(PavSurf),c_Surf_k5(PavSurf)/))
        rSurf_SUEWSsurfs(:,PavSurf) = SurfaceChar(Gridiv,(/c_Surf_rhoCp1(PavSurf),c_Surf_rhoCp2(PavSurf),c_Surf_rhoCp3(PavSurf),&
             c_Surf_rhoCp4(PavSurf),c_Surf_rhoCp5(PavSurf)/))
     ENDIF

     ! ===== BLDGS =====
     ! Combine characteristics of 5x Bldgs classes into one
     IF(SurfaceChar(Gridiv,c_ESTMCode(BldgSurf)) == 0) THEN   ! If Code = 0, use multiple classes
        ! Get characteristics of each Bldgs class
        DO i=1,5
           zSurf_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Surf_thick1_Bldgs(i),c_Surf_thick2_Bldgs(i),c_Surf_thick3_Bldgs(i), &
                c_Surf_thick4_Bldgs(i),c_Surf_thick5_Bldgs(i)/))
           kSurf_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Surf_k1_Bldgs(i),c_Surf_k2_Bldgs(i),c_Surf_k3_Bldgs(i), &
                c_Surf_k4_Bldgs(i),c_Surf_k5_Bldgs(i)/))
           rSurf_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Surf_rhoCp1_Bldgs(i),c_Surf_rhoCp2_Bldgs(i),c_Surf_rhoCp3_Bldgs(i), &
                c_Surf_rhoCp4_Bldgs(i),c_Surf_rhoCp5_Bldgs(i)/))
           zwall_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Wall_thick1_Bldgs(i),c_Wall_thick2_Bldgs(i),c_Wall_thick3_Bldgs(i), &
                c_Wall_thick4_Bldgs(i),c_Wall_thick5_Bldgs(i)/))
           kwall_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Wall_k1_Bldgs(i),c_Wall_k2_Bldgs(i),c_Wall_k3_Bldgs(i), &
                c_Wall_k4_Bldgs(i),c_Wall_k5_Bldgs(i)/))
           rwall_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Wall_rhoCp1_Bldgs(i),c_Wall_rhoCp2_Bldgs(i),c_Wall_rhoCp3_Bldgs(i), &
                c_Wall_rhoCp4_Bldgs(i),c_Wall_rhoCp5_Bldgs(i)/))
           zibld_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Internal_thick1_Bldgs(i),c_Internal_thick2_Bldgs(i),&
                c_Internal_thick3_Bldgs(i), &
                c_Internal_thick4_Bldgs(i),c_Internal_thick5_Bldgs(i)/))
           kibld_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Internal_k1_Bldgs(i),c_Internal_k2_Bldgs(i),c_Internal_k3_Bldgs(i), &
                c_Internal_k4_Bldgs(i),c_Internal_k5_Bldgs(i)/))
           ribld_Bldgs(:,i) = SurfaceChar(Gridiv,(/c_Internal_rhoCp1_Bldgs(i),c_Internal_rhoCp2_Bldgs(i),&
                c_Internal_rhoCp3_Bldgs(i), &
                c_Internal_rhoCp4_Bldgs(i),c_Internal_rhoCp5_Bldgs(i)/))
           nroom_Bldgs(i)    = SurfaceChar(Gridiv,c_nroom_Bldgs(i))
           alb_ibld_Bldgs(i) = SurfaceChar(Gridiv,c_alb_ibld_Bldgs(i))
           em_ibld_Bldgs(i)  = SurfaceChar(Gridiv,c_em_ibld_Bldgs(i))
           CH_iwall_Bldgs(i) = SurfaceChar(Gridiv,c_CH_iwall_Bldgs(i))
           CH_iroof_Bldgs(i) = SurfaceChar(Gridiv,c_CH_iroof_Bldgs(i))
           CH_ibld_Bldgs(i)  = SurfaceChar(Gridiv,c_CH_ibld_Bldgs(i))
        ENDDO
        ! Average characteristics of each Bldgs class according to surface fractions (these sum to 1)
        zSurf_SUEWSsurfs(:,BldgSurf) = zSurf_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + zSurf_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + zSurf_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + zSurf_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + zSurf_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        kSurf_SUEWSsurfs(:,BldgSurf) = kSurf_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + kSurf_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + kSurf_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + kSurf_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + kSurf_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        rSurf_SUEWSsurfs(:,BldgSurf) = rSurf_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + rSurf_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + rSurf_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + rSurf_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + rSurf_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        !Wall
        zwall = zwall_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + zwall_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + zwall_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + zwall_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + zwall_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        kwall = kwall_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + kwall_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + kwall_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + kwall_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + kwall_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        rwall = rwall_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + rwall_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + rwall_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + rwall_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + rwall_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        !Internal
        zibld = zibld_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + zibld_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + zibld_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + zibld_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + zibld_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        kibld = kibld_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + kibld_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + kibld_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + kibld_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + kibld_Bldgs(:,5)*ESTMsfr_Bldgs(5)
        ribld = ribld_Bldgs(:,1)*ESTMsfr_Bldgs(1) &
             + ribld_Bldgs(:,2)*ESTMsfr_Bldgs(2) &
             + ribld_Bldgs(:,3)*ESTMsfr_Bldgs(3) &
             + ribld_Bldgs(:,4)*ESTMsfr_Bldgs(4) &
             + ribld_Bldgs(:,5)*ESTMsfr_Bldgs(5)

        nroom = nroom_Bldgs(1)*ESTMsfr_Bldgs(1) &
             + nroom_Bldgs(2)*ESTMsfr_Bldgs(2) &
             + nroom_Bldgs(3)*ESTMsfr_Bldgs(3) &
             + nroom_Bldgs(4)*ESTMsfr_Bldgs(4) &
             + nroom_Bldgs(5)*ESTMsfr_Bldgs(5)
        alb_ibld = alb_ibld_Bldgs(1)*ESTMsfr_Bldgs(1) &
             + alb_ibld_Bldgs(2)*ESTMsfr_Bldgs(2) &
             + alb_ibld_Bldgs(3)*ESTMsfr_Bldgs(3) &
             + alb_ibld_Bldgs(4)*ESTMsfr_Bldgs(4) &
             + alb_ibld_Bldgs(5)*ESTMsfr_Bldgs(5)
        em_ibld = em_ibld_Bldgs(1)*ESTMsfr_Bldgs(1) &
             + em_ibld_Bldgs(2)*ESTMsfr_Bldgs(2) &
             + em_ibld_Bldgs(3)*ESTMsfr_Bldgs(3) &
             + em_ibld_Bldgs(4)*ESTMsfr_Bldgs(4) &
             + em_ibld_Bldgs(5)*ESTMsfr_Bldgs(5)
        CH_iwall = CH_iwall_Bldgs(1)*ESTMsfr_Bldgs(1) &
             + CH_iwall_Bldgs(2)*ESTMsfr_Bldgs(2) &
             + CH_iwall_Bldgs(3)*ESTMsfr_Bldgs(3) &
             + CH_iwall_Bldgs(4)*ESTMsfr_Bldgs(4) &
             + CH_iwall_Bldgs(5)*ESTMsfr_Bldgs(5)
        CH_iroof = CH_iroof_Bldgs(1)*ESTMsfr_Bldgs(1) &
             + CH_iroof_Bldgs(2)*ESTMsfr_Bldgs(2) &
             + CH_iroof_Bldgs(3)*ESTMsfr_Bldgs(3) &
             + CH_iroof_Bldgs(4)*ESTMsfr_Bldgs(4) &
             + CH_iroof_Bldgs(5)*ESTMsfr_Bldgs(5)
        CH_ibld = CH_ibld_Bldgs(1)*ESTMsfr_Bldgs(1) &
             + CH_ibld_Bldgs(2)*ESTMsfr_Bldgs(2) &
             + CH_ibld_Bldgs(3)*ESTMsfr_Bldgs(3) &
             + CH_ibld_Bldgs(4)*ESTMsfr_Bldgs(4) &
             + CH_ibld_Bldgs(5)*ESTMsfr_Bldgs(5)

     ELSEIF(SurfaceChar(Gridiv,c_ESTMCode(BldgSurf)) /= 0) THEN   !Otherwise use single values
        zSurf_SUEWSsurfs(:,BldgSurf) = SurfaceChar(Gridiv,(/c_Surf_thick1(BldgSurf),c_Surf_thick2(BldgSurf),&
             c_Surf_thick3(BldgSurf),&
             c_Surf_thick4(BldgSurf),c_Surf_thick5(BldgSurf)/))
        kSurf_SUEWSsurfs(:,BldgSurf) = SurfaceChar(Gridiv,(/c_Surf_k1(BldgSurf),c_Surf_k2(BldgSurf),c_Surf_k3(BldgSurf),&
             c_Surf_k4(BldgSurf),c_Surf_k5(BldgSurf)/))
        rSurf_SUEWSsurfs(:,BldgSurf) = SurfaceChar(Gridiv,(/c_Surf_rhoCp1(BldgSurf),c_Surf_rhoCp2(BldgSurf),&
             c_Surf_rhoCp3(BldgSurf),&
             c_Surf_rhoCp4(BldgSurf),c_Surf_rhoCp5(BldgSurf)/))
        zwall = SurfaceChar(Gridiv,(/c_Wall_thick1,c_Wall_thick2,c_Wall_thick3,c_Wall_thick4,c_Wall_thick5/))
        kwall = SurfaceChar(Gridiv,(/c_Wall_k1,c_Wall_k2,c_Wall_k3,c_Wall_k4,c_Wall_k5/))
        rwall = SurfaceChar(Gridiv,(/c_Wall_rhoCp1,c_Wall_rhoCp2,c_Wall_rhoCp3,c_Wall_rhoCp4,c_Wall_rhoCp5/))
        zibld = SurfaceChar(Gridiv,(/c_Internal_thick1,c_Internal_thick2,c_Internal_thick3,c_Internal_thick4,c_Internal_thick5/))
        kibld = SurfaceChar(Gridiv,(/c_Internal_k1,c_Internal_k2,c_Internal_k3,c_Internal_k4,c_Internal_k5/))
        ribld = SurfaceChar(Gridiv,(/c_Internal_rhoCp1,c_Internal_rhoCp2,c_Internal_rhoCp3,c_Internal_rhoCp4,c_Internal_rhoCp5/))

        nroom = SurfaceChar(Gridiv,c_nroom)
        alb_ibld = SurfaceChar(Gridiv,c_alb_ibld)
        em_ibld = SurfaceChar(Gridiv,c_em_ibld)
        CH_iwall = SurfaceChar(Gridiv,c_CH_iwall)
        CH_iroof = SurfaceChar(Gridiv,c_CH_iroof)
        CH_ibld = SurfaceChar(Gridiv,c_CH_ibld)
     ENDIF

     !For other surfaces, only one ESTM class
     DO iv=ConifSurf, nsurfIncSnow
        zSurf_SUEWSsurfs(:,iv) = SurfaceChar(Gridiv,(/c_Surf_thick1(iv),c_Surf_thick2(iv),c_Surf_thick3(iv),&
             c_Surf_thick4(iv),c_Surf_thick5(iv)/))
        kSurf_SUEWSsurfs(:,iv) = SurfaceChar(Gridiv,(/c_Surf_k1(iv),c_Surf_k2(iv),c_Surf_k3(iv),&
             c_Surf_k4(iv),c_Surf_k5(iv)/))
        rSurf_SUEWSsurfs(:,iv) = SurfaceChar(Gridiv,(/c_Surf_rhoCp1(iv),c_Surf_rhoCp2(iv),c_Surf_rhoCp3(iv),&
             c_Surf_rhoCp4(iv),c_Surf_rhoCp5(iv)/))
     ENDDO

     ! Now combine SUEWS surfaces into ESTM facets
     !Surface fractions for ESTM facets (moved from SUEWS_ESTM_initials HCW 16 Jun 2016)
     !roof = Bldgs
     froof=sfr(BldgSurf)
     !ground = all except Bldgs
     fground=sfr(PavSurf)+sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)+sfr(BsoilSurf)+sfr(WaterSurf)
     !veg = EveTr, DecTr, Grass
     fveg=sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)

     ! Ground = all except buildings (exclude snow at the moment)
     zground = 0
     kground = 0
     rground = 0
     DO iv=1,nsurf
        IF(iv/=BldgSurf .AND. fground /= 0) THEN   !Bldgs surface excluded from ground facet
           zground = zground + zSurf_SUEWSsurfs(:,iv)*sfr(iv) /fground   !Normalised by ground fraction
           kground = kground + kSurf_SUEWSsurfs(:,iv)*sfr(iv) /fground   !Normalised by ground fraction
           rground = rground + rSurf_SUEWSsurfs(:,iv)*sfr(iv) /fground   !Normalised by ground fraction
        ELSEIF ( fground==0. ) THEN !check fground==0 (or HW==0) scenario to avoid division-by-zero error, TS 21 Jul 2016
           zground=zground+0.01
           kground=kground+0.01
           rground=rground+0.01
           ! PRINT*, zground
           ! PRINT*, kground
           ! PRINT*, rground
        ENDIF
     ENDDO
     ! Roof = buildings
     zroof = zSurf_SUEWSsurfs(:,BldgSurf)
     kroof = kSurf_SUEWSsurfs(:,BldgSurf)
     rroof = rSurf_SUEWSsurfs(:,BldgSurf)

     DO i=1,5
        IF (zground(i)<=0)THEN
           Nground=i-1
           EXIT
        ENDIF
     ENDDO
     DO i=1,5
        IF (zroof(i)<=0) THEN
           Nroof=i-1
           EXIT
        ENDIF
     ENDDO
     DO i=1,5
        IF (zwall(i)<=0) THEN
           Nwall=i-1
           EXIT
        ENDIF
     ENDDO
     DO i=1,5
        IF (zibld(i)<=0) THEN
           Nibld=i-1
           EXIT
        ENDIF
     ENDDO
  ENDIF ! ESTM related translation finished here.

  ! ---- AnOHM related ------------------------------
  IF ( StorageHeatMethod==3 ) THEN
     cpAnOHM(1:nsurf) = SurfaceChar(Gridiv,c_cpAnOHM) ! AnOHM TS
     kkAnOHM(1:nsurf) = SurfaceChar(Gridiv,c_kkAnOHM) ! AnOHM TS
     chAnOHM(1:nsurf) = SurfaceChar(Gridiv,c_chAnOHM) ! AnOHM TS

     ! cp and k are estimated from ESTM coefficients:
     ! cpAnOHM(1:nsurf)=rSurf_SUEWSsurfs(1,1:nsurf)
     ! kkAnOHM(1:nsurf)=kSurf_SUEWSsurfs(1,1:nsurf)
     ! IF ( ir ==1 .AND. iMb ==1) THEN
     !    PRINT*, 'StoreDrainPrm',PavSurf,':'
     !    PRINT'(a10,x,5f10.2)', 'Depth',zSurf_SUEWSsurfs(:,i)
     !    PRINT'(a10,x,5es10.2)', 'RhoCp',rSurf_SUEWSsurfs(:,i)
     !    PRINT'(a10,x,5es10.2)', 'avg_RhoCp',cpAnOHM(i)
     !    PRINT'(a10,x,5es10.2)', 'k',kSurf_SUEWSsurfs(:,i)
     !    PRINT'(a10,x,5es10.2)', 'avg_k',kkAnOHM(i)
     !    PRINT'(a10,x,5es10.2)', 'avg_Ch',chAnOHM(i)
     !
     ! END IF
     ! DO i = 1, nsurf, 1
     !    ! filter out invalid z values
     !    WHERE (  zSurf_SUEWSsurfs(:,i) == -999. ) zSurf_SUEWSsurfs(:,i)=0
     !
     !    ! cp: weight-averaged by depth
     !    cpAnOHM(i)=DOT_PRODUCT(rSurf_SUEWSsurfs(:,i),zSurf_SUEWSsurfs(:,i))/SUM(zSurf_SUEWSsurfs(:,i))
     !   !  IF ( i==PavSurf .AND. ir ==1 .AND. iMb ==1) THEN
     !   !     PRINT*, 'StoreDrainPrm',i,':'
     !   !     PRINT'(a10,x,5f10.2)', 'Depth',zSurf_SUEWSsurfs(:,i)
     !   !     PRINT'(a10,x,5es10.2)', 'RhoCp',rSurf_SUEWSsurfs(:,i)
     !   !     PRINT'(a10,x,5es10.2)', 'avg_RhoCp',cpAnOHM(i)
     !    !
     !   !  END IF
     !
     !    ! 1/k: weight-averaged by depth
     !    kkAnOHM(i)=DOT_PRODUCT(1/kSurf_SUEWSsurfs(:,i),zSurf_SUEWSsurfs(:,i))/SUM(zSurf_SUEWSsurfs(:,i))
     !    kkAnOHM(i)=1/kkAnOHM(i)
     !   !  IF ( i==PavSurf .AND. ir ==1 .AND. iMb ==1) THEN
     !   !     PRINT'(a10,x,5es10.2)', 'k',kSurf_SUEWSsurfs(:,i)
     !   !     PRINT'(a10,x,5es10.2)', 'avg_k',kkAnOHM(i)
     !   !     PRINT'(a10,x,5es10.2)', 'avg_Ch',chAnOHM(i)
     !    !
     !   !     PRINT'(a10,x,7f10.2)', 'fractions:',sfr
     !    !
     !   !  END IF
     !
     !
     !    ! restore invalid z values
     !    WHERE (  zSurf_SUEWSsurfs(:,i) == 0 ) zSurf_SUEWSsurfs(:,i)=nan
     !   !  IF ( i==PavSurf .AND. ir ==1 .AND. iMb ==1) THEN
     !   !     PRINT'(a10,x,5f10.2)', 'Depth',zSurf_SUEWSsurfs(:,i)
     !   !     PRINT*, '*****************'
     !   !  END IF
     !
     ! END DO
  END IF



  ! ---- QF coeffs (was in SUEWS_SAHP.f95, subroutine SAHP_Coefs)
  BaseTHDD         = -999 ! Initialise QF coeffs
  QF_A             = 0
  QF_B             = 0
  QF_C             = 0
  AH_min           = 0
  T_CRITIC_Heating = 0
  T_CRITIC_Cooling = 0
  AH_slope_Heating = 0
  AH_slope_Cooling = 0

  BaseTHDD             = SurfaceChar(Gridiv,c_BaseTHDD)
  QF_A                 = SurfaceChar(Gridiv,(/c_QF_A1,c_QF_A2/))
  QF_B                 = SurfaceChar(Gridiv,(/c_QF_B1,c_QF_B2/))
  QF_C                 = SurfaceChar(Gridiv,(/c_QF_C1,c_QF_C2/))
  AH_min               = SurfaceChar(Gridiv,(/c_AHMin_WD,c_AHMin_WE/))
  AH_slope_Heating     = SurfaceChar(Gridiv,(/c_AHSlopeHeating_WD,c_AHSlopeHeating_WE/))
  AH_slope_Cooling     = SurfaceChar(Gridiv,(/c_AHSlopeCooling_WD,c_AHSlopeCooling_WE/))
  T_Critic_Heating     = SurfaceChar(Gridiv,(/c_TCriticHeating_WD,c_TCriticHeating_WE/))
  T_Critic_Cooling     = SurfaceChar(Gridiv,(/c_TCriticCooling_WD,c_TCriticCooling_WE/))
  EnProfWD             = SurfaceChar(Gridiv,c_EnProfWD)
  EnProfWE             = SurfaceChar(Gridiv,c_EnProfWE)
  CO2mWD               = SurfaceChar(Gridiv,c_CO2mWD)
  CO2mWE               = SurfaceChar(Gridiv,c_CO2mWE)
  TraffProfWD          = SurfaceChar(Gridiv,c_TraffProfWD)
  TraffProfWE          = SurfaceChar(Gridiv,c_TraffProfWE)
  PopProfWD            = SurfaceChar(Gridiv,c_PopProfWD)
  PopProfWE            = SurfaceChar(Gridiv,c_PopProfWE)
  MinQFMetab           = SurfaceChar(Gridiv,c_MinQFMetab)
  MaxQFMetab           = SurfaceChar(Gridiv,c_MaxQFMetab)
  FrFossilFuel_heat    = SurfaceChar(Gridiv,c_FrFossilFuel_heat)
  FrFossilFuel_NonHeat = SurfaceChar(Gridiv,c_FrFossilFuel_NonHeat)
  EF_umolCO2perJ       = SurfaceChar(Gridiv,c_EF_umolCO2perJ)
  EnEF_v_Jkm           = SurfaceChar(Gridiv,c_EnEF_v_Jkm)
  FcEF_v_kgkm          = SurfaceChar(Gridiv,c_FcEF_v_kgkm)
  TrafficUnits         = SurfaceChar(Gridiv,c_TrafficUnits)

  ! ---- Irrigation
  Ie_start           = INT(SurfaceChar(Gridiv,c_IeStart))
  Ie_end             = INT(SurfaceChar(Gridiv,c_IeEnd))
  InternalWaterUse_h = SurfaceChar(Gridiv,c_IntWU)
  Faut               = SurfaceChar(Gridiv,c_Faut)
  Ie_a = SurfaceChar(Gridiv,c_Ie_a)   !Automatic irrigation model coefficients [mm d-1]; [mm d-1 degC-1]; [mm d-2]
  Ie_m = SurfaceChar(Gridiv,c_Ie_m)   !Manual irrigation model coefficients [mm d-1]; [mm d-1 degC-1]; [mm d-2]
  DayWat             = SurfaceChar(Gridiv,c_DayWat)
  DayWatPer          = SurfaceChar(Gridiv,c_DayWatPer)

  ! ---- Hourly profiles
  AHProf_24hr(0:23,1)      = SurfaceChar(Gridiv,c_HrProfEnUseWD)       ! Anthropogenic heat, weekdays
  AHProf_24hr(0:23,2)      = SurfaceChar(Gridiv,c_HrProfEnUseWE)       ! Anthropogenic heat, weekends
  WUProfM_24hr(0:23,1)     = SurfaceChar(Gridiv,c_HrProfWUManuWD)      ! Water use, manual, weekdays
  WUProfM_24hr(0:23,2)     = SurfaceChar(Gridiv,c_HrProfWUManuWE)      ! Water use, manual, weekends
  WUProfA_24hr(0:23,1)     = SurfaceChar(Gridiv,c_HrProfWUAutoWD)      ! Water use, automatic, weekdays
  WUProfA_24hr(0:23,2)     = SurfaceChar(Gridiv,c_HrProfWUAutoWE)      ! Water use, automatic, weekends
  SnowProf_24hr(0:23,1)    = SurfaceChar(Gridiv,c_HrProfSnowCWD)       ! Snow clearing, weekdays
  SnowProf_24hr(0:23,2)    = SurfaceChar(Gridiv,c_HrProfSnowCWE)       ! Snow clearing, weekends
  HumActivity_24hr(0:23,1) = SurfaceChar(Gridiv,c_HrProfHumActivityWD) ! Human activity, weekdays
  HumActivity_24hr(0:23,2) = SurfaceChar(Gridiv,c_HrProfHumActivityWE) ! Human activity, weekends
  TraffProf_24hr(0:23,1)   = SurfaceChar(Gridiv,c_HrProfTraffWD)       ! Traffic, weekdays
  TraffProf_24hr(0:23,2)   = SurfaceChar(Gridiv,c_HRProfTraffWE)       ! Traffic, weekends
  PopProf_24hr(0:23,1)     = SurfaceChar(Gridiv,c_HRProfPopWD)         ! Population, weekdays
  PopProf_24hr(0:23,2)     = SurfaceChar(Gridiv,c_HRProfPopWE)         ! Population, weekends



  ! ---- Profiles at the resolution of model time step
  ! AHProf_tstep(:,1)      = TstepProfiles(Gridiv,cTP_EnUseWD,:)       ! Anthropogenic heat, weekdays
  ! AHProf_tstep(:,2)      = TstepProfiles(Gridiv,cTP_EnUseWE,:)       ! Anthropogenic heat, weekends
  ! WUProfM_tstep(:,1)     = TstepProfiles(Gridiv,cTP_WUManuWD,:)      ! Water use, manual, weekdays
  ! WUProfM_tstep(:,2)     = TstepProfiles(Gridiv,cTP_WUManuWE,:)      ! Water use, manual, weekends
  ! WUProfA_tstep(:,1)     = TstepProfiles(Gridiv,cTP_WUAutoWD,:)      ! Water use, automatic, weekdays
  ! WUProfA_tstep(:,2)     = TstepProfiles(Gridiv,cTP_WUAutoWE,:)      ! Water use, automatic, weekends
  ! HumActivity_tstep(:,1) = TstepProfiles(Gridiv,cTP_HumActivityWD,:) ! Human activity, weekdays
  ! HumActivity_tstep(:,2) = TstepProfiles(Gridiv,cTP_HumActivityWE,:) ! Human activity, weekends
  ! TraffProf_tstep(:,1)   = TstepProfiles(Gridiv,cTP_TraffProfWD,:)   !Traffic, weekdays
  ! TraffProf_tstep(:,2)   = TstepProfiles(Gridiv,cTP_TraffProfWE,:)   !Traffic, weekends
  ! PopProf_tstep(:,1)     = TstepProfiles(Gridiv,cTP_PopProfWD,:)     !Population, weekdays
  ! PopProf_tstep(:,2)     = TstepProfiles(Gridiv,cTP_PopProfWE,:)     !Population, weekends


  ! ---- Within-grid water distribution
  ! N.B. Rows and columns of WaterDist are the other way round to the input info
  !! Model currently does not include above-ground flow from the Water surface
  !! - Probably should adjust WaterDist to have nsurf columns so that Water can behave like the other surfaces.
  ! Model returns an error if both ToRunoff and ToSoilStore are non-zero (in CodeMatchDist)
  ! For impervious surfaces, water goes to runoff; for pervious surfaces, water goes to soilstore
  WaterDist(PavSurf,  1:(nsurf-1)) = SurfaceChar(Gridiv,c_WGToPaved(1:(nsurf-1)))
  WaterDist(BldgSurf, 1:(nsurf-1)) = SurfaceChar(Gridiv,c_WGToBldgs(1:(nsurf-1)))
  WaterDist(ConifSurf,1:(nsurf-1)) = SurfaceChar(Gridiv,c_WGToEveTr(1:(nsurf-1)))
  WaterDist(DecidSurf,1:(nsurf-1)) = SurfaceChar(Gridiv,c_WGToDecTr(1:(nsurf-1)))
  WaterDist(GrassSurf,1:(nsurf-1)) = SurfaceChar(Gridiv,c_WGToGrass(1:(nsurf-1)))
  WaterDist(BSoilSurf,1:(nsurf-1)) = SurfaceChar(Gridiv,c_WGToBSoil(1:(nsurf-1)))
  WaterDist(WaterSurf,1:(nsurf-1)) = SurfaceChar(Gridiv,c_WGToWater(1:(nsurf-1)))
  ! Runoff or SoilStore row   !!Change later to allow both Runoff and SoilStore
  DO iv = 1,(nsurf-1)
     IF(SurfaceChar(Gridiv,c_WGToRunoff(iv)) /= 0) THEN
        WaterDist((nsurf+1),iv) = SurfaceChar(Gridiv,c_WGToRunoff(iv))
     ELSE
        WaterDist((nsurf+1),iv) = SurfaceChar(Gridiv,c_WGToSoilStore(iv))
     ENDIF
  ENDDO

  ! Access required DailyState variables for the current grid (moved HCW 26 Jun 2015)
  ! HDD(:,:)    = HDD_grids(:,:,Gridiv)
  ! GDD(:,:)    = GDD_grids(:,:,Gridiv)
  ! LAI(:,:)    = LAI_grids(:,:,Gridiv)
  ! WUDay(:,:) = WUDay_grids(:,:,Gridiv)
  ! AlbDecTr(:) = AlbDecTr_grids(:,Gridiv)
  ! DecidCap(:) = DecidCap_grids(:,Gridiv)
  ! Porosity(:) = Porosity_grids(:,Gridiv)
  ! AlbEveTr(:) = AlbEveTr_grids(:,Gridiv)
  ! AlbGrass(:) = AlbGrass_grids(:,Gridiv)
  SnowAlb     = ModelDailyState(Gridiv,cMDS_SnowAlb)


  !! ---- Between-grid water distribution
!!! Need to make these larger than MaxNumberOfGrids (and recode), as each grid can have 8 connections
  !!GridConnections(1,) = SurfaceChar(Gridiv,c_Grid)
  !!GridConnectionsFrac() = SurfaceChar(Gridiv,55)
  !!GridConnections(2,) = SurfaceChar(Gridiv,54)
  !
  !! Fraction of water from each grid
!!! N.B. will need to check input files are correctly set up
  !GridToFrac(1:NConns) = (SurfaceChar(Gridiv,55:69:2))
  !! Grid where water goes to
  !GridTo(1:NConns)     = (SurfaceChar(Gridiv,54:68:2))
  !! Come back to this later

  ! =================================================================================



  !-----------------------------------------------------
  !-----------------------------------------------------
  !NARP_CONFIGURATION if net radiation is to be modelled
  IF(NetRadiationMethod>0)THEN
     NARP_LAT = SurfaceChar(Gridiv,c_lat)
     NARP_LONG = SurfaceChar(Gridiv,c_lng)    ! New sun_position_v2 use degrees FL
     NARP_YEAR = INT(SurfaceChar(Gridiv,c_Year))
     NARP_TZ = TIMEZONE                           !not every 5-min
     NARP_EMIS_SNOW = SurfaceChar(Gridiv,c_SnowEmis)
     NARP_TRANS_SITE = TRANS_SITE

     !INTERVAL IS ONLY RELEVANT TO LUPCORR
     !ALL OTHER CALCULATIONS ARE INTERVAL INDEPENDENT
     !NB FOR INTERVALS LONGER THAN 15 MINUTES ERRORS IN KCLEAR WILL BE GREATER

     ! Commented out HCW 04 Mar 2015
     !NARP_NPERHOUR=MAX(3600/t_INTERVAL,1) !!Check this
     !IF(ALLOCATED(NARP_KDOWN_HR)) DEALLOCATE(NARP_KDOWN_HR)
     !ALLOCATE(NARP_KDOWN_HR(NARP_NPERHOUR))
     !NARP_KDOWN_HR=0.

     !IF (ldown_option==4.or.ldown_option==5) then !Added by LJ
     !  INIITIALIZE SMITH DAY OF YEAR GRID G
     !  NARP_G=SMITHLAMBDA(NINT(LAT))
     !ENDIF
  ENDIF


  !=================================================================================
  ! When SUEWS_Translate is called from InitialState (ir=0), inputs need translating
  IF(ir == 0) THEN
     !write(*,*) 'This should be seen only when called from InitialState and ir is 0. ir:',ir

     ! =============================================================================
     ! === Translate inputs from ModelDailyState to variable names used in model ===
     ! =============================================================================

     ! Get id_prev from ModelDailyState
     id_prev = INT(ModelDailyState(Gridiv,cMDS_id_prev))

     ! porosity    = ModelDailyState(Gridiv,cMDS_porosity)
     ! albDecTr    = ModelDailyState(Gridiv,cMDS_albDecTr)
     ! albEveTr    = ModelDailyState(Gridiv,cMDS_albEveTr)
     ! albGrass    = ModelDailyState(Gridiv,cMDS_albGrass)
     ! DecidCap    = ModelDailyState(Gridiv,cMDS_DecidCap)
     SnowfallCum = ModelDailyState(Gridiv,cMDS_SnowfallCum)
     SnowAlb     = ModelDailyState(Gridiv,cMDS_SnowAlb)

     porosity_id    = ModelDailyState(Gridiv,cMDS_porosity)
     albDecTr_id    = ModelDailyState(Gridiv,cMDS_albDecTr)
     albEveTr_id    = ModelDailyState(Gridiv,cMDS_albEveTr)
     albGrass_id    = ModelDailyState(Gridiv,cMDS_albGrass)
     DecidCap_id    = ModelDailyState(Gridiv,cMDS_DecidCap)

     DecidCap_id_grids(Gridiv) = DecidCap_id
     albDecTr_id_grids(Gridiv) = albDecTr_id
     albEveTr_id_grids(Gridiv) = albEveTr_id
     albGrass_id_grids(Gridiv) = albGrass_id
     porosity_id_grids(Gridiv) = porosity_id


     ! ---- LAI
     ! LAI=0
     ! LAI(id_prev,ivConif) = ModelDailyState(Gridiv,cMDS_LAIInitialEveTr)
     ! LAI(id_prev,ivDecid) = ModelDailyState(Gridiv,cMDS_LAIInitialDecTr)
     ! LAI(id_prev,ivGrass) = ModelDailyState(Gridiv,cMDS_LAIInitialGrass)

     ! ---- Growing degree days, GDD
     ! GDD = 0
     ! GDD(:,1)=0
     ! GDD(:,2)=0
     ! GDD(:,3) = ModelDailyState(Gridiv,cMDS_GDDMin)
     ! GDD(:,4) = ModelDailyState(Gridiv,cMDS_GDDMax)
     ! GDD(:,5)=0
     ! GDD(id_prev,1) = ModelDailyState(Gridiv,cMDS_GDD1_0)
     ! GDD(id_prev,2) = ModelDailyState(Gridiv,cMDS_GDD2_0)

     ! ---- Growing degree days, GDD_id: GDD Values for one day
     GDD_id = 0
     GDD_id(1)=0
     GDD_id(2)=0
     GDD_id(3) = ModelDailyState(Gridiv,cMDS_GDDMin)
     GDD_id(4) = ModelDailyState(Gridiv,cMDS_GDDMax)
     GDD_id(5)=0
     GDD_id_prev(1) = ModelDailyState(Gridiv,cMDS_GDD1_0)
     GDD_id_prev(2) = ModelDailyState(Gridiv,cMDS_GDD2_0)


     ! ---- Heating degree days, HDD
     ! HDD = 0
     ! HDD(id_prev,1)   = ModelDailyState(Gridiv,cMDS_HDD1)      ! 1 = Heating
     ! HDD(id_prev,2)   = ModelDailyState(Gridiv,cMDS_HDD2)      ! 2 = Cooling
     ! HDD(id_prev-3,3) = ModelDailyState(Gridiv,cMDS_TempCOld3) ! 3 will become average
     ! HDD(id_prev-2,3) = ModelDailyState(Gridiv,cMDS_TempCOld2)
     ! HDD(id_prev-1,3) = ModelDailyState(Gridiv,cMDS_TempCOld1)
     ! HDD(id_prev,3)   = ModelDailyState(Gridiv,cMDS_TempC)
     ! 4 = 5 day running mean
     ! 5 = daily precip total
     ! HDD(id_prev,6) = ModelDailyState(Gridiv,cMDS_DaysSinceRain) ! 6 = days since rain


     ! ---- Heating degree days, HDD_id: HDD Values for one day
     HDD_id(1:6)=0

     ! HDD_id(1)=ModelDailyState(Gridiv,cMDS_HDD1)
     ! HDD_id(2)=ModelDailyState(Gridiv,cMDS_HDD2)
     ! HDD_id(3)=ModelDailyState(Gridiv,cMDS_TempC)
     ! ! 4 = 5 day running mean
     ! ! 5 = daily precip total
     ! HDD_id(6) = ModelDailyState(Gridiv,cMDS_DaysSinceRain)


     ! Save required DailyState variables for the current grid (HCW 27 Nov 2014)
     ! HDD_grids(:,:,Gridiv)    = HDD(:,:)
     ! GDD_grids(:,:,Gridiv)    = GDD(:,:)
     ! LAI_grids(:,:,Gridiv)    = LAI(:,:)
     ! WUDay_grids(:,:,Gridiv) = WUDay(:,:)

     HDD_id_grids(:,Gridiv) = HDD_id(:)
     GDD_id_grids(:,Gridiv) = GDD_id(:)
     LAI_id_grids(:,Gridiv) = LAI_id(:)


     ! daily water use
     WUDay_id=0
     WUDay_id_grids(:,Gridiv) = WUDay_id(:)



     ! AlbDecTr_grids(:,Gridiv) = AlbDecTr(:)
     ! AlbEveTr_grids(:,Gridiv) = AlbEveTr(:)
     ! AlbGrass_grids(:,Gridiv) = AlbGrass(:)
     ! DecidCap_grids(:,Gridiv) = DecidCap(:)
     ! Porosity_grids(:,Gridiv) = Porosity(:)

     ! ---- Snow density of each surface
     SnowDens(1:nsurf) = ModelDailyState(Gridiv,cMDS_SnowDens(1:nsurf))

     ! =============================================================================
     ! === Translate inputs from ModelOutputData to variable names used in model ===
     ! =============================================================================
     ! ---- Above-ground state
     state_id(1:nsurf)             = ModelOutputData(0,cMOD_State(1:nsurf),Gridiv)
     !     stateDay(0,Gridiv,1:nsurf) = ModelOutputData(0,cMOD_State(1:nsurf),Gridiv)
     ! ---- Below-ground
     soilmoist_id(1:nsurf)             = ModelOutputData(0,cMOD_SoilState(1:nsurf),Gridiv)
     !     soilmoistDay(0,Gridiv,1:nsurf) = ModelOutputData(0,cMOD_SoilState(1:nsurf),Gridiv)
     ! ---- Snow fraction
     SnowFrac(1:nsurf)  = ModelOutputData(0,cMOD_SnowFrac(1:nsurf), Gridiv)
     ! ---- Snow water equivalent in SnowPack
     SnowPack(1:nsurf)  = ModelOutputData(0,cMOD_SnowPack(1:nsurf), Gridiv)
     ! ---- Liquid (melted) water in SnowPack
     MeltWaterStore(1:nsurf)  = ModelOutputData(0,cMOD_SnowWaterState(1:nsurf), Gridiv)

  ENDIF  !ir = 0
  !=================================================================================


  !=========================== Write FileChoices.txt ===============================
  !=================================================================================
  ! Do once per grid per year (was in SUEWS_Initial.f95)
  IF (ir==1.AND.iMB==1) THEN   !For first row of first block only
     !write(*,*) 'Writing to FileChoices for first chunk of met data per year per grid'
     FileChoices=TRIM(FileOutputPath)//TRIM(FileCode)//'_FileChoices.txt'
     OPEN(12,file=FileChoices,position='append')

     WRITE(grid_txt,'(I5)') INT(SurfaceChar(Gridiv,c_Grid))
     WRITE(year_txt,'(I4)') INT(SurfaceChar(Gridiv,c_Year))
     WRITE(SsG_YYYY,'(A12)') TRIM(FileCode)//TRIM(ADJUSTL(grid_txt))//'_'//TRIM(ADJUSTL(year_txt))

     !write(12,*) '--------------------------------------------------------------------------------'
     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Surface characteristics'//' -----'
     ! Characteristics that apply to some or all surface types
     WRITE(12,'(8a10,a16)') 'Paved','Bldgs','EveTr','DecTr','Grass','BSoil','Water','Snow', ' SurfType'
     WRITE(12,120) (sfr(iv),iv=1,nsurf),FCskip, ' SurfFr'
     WRITE(12,120) FCskip,FCskip,IrrFracConif,IrrFracDecid,IrrFracGrass,FCskip,FCskip,FCskip, ' IrrFr'
     WRITE(12,120) FCskip,FCskip,WUAreaEveTr_m2,WUAreaDecTr_m2,WUAreaGrass_m2,FCskip,FCskip,FCskip, ' WaterUseArea'
     WRITE(12,120) FCskip,BldgH,EveTreeH,DecTreeH,FCskip,FCskip,FCskip,FCskip, ' H'
     WRITE(12,120) FCskip,FAIBldg,FAIEveTree,FAIDecTree,FCskip,FCskip,FCskip,FCskip, ' FAI'
     WRITE(12,120) FCskip,FCskip,AlbMin_EveTr,AlbMin_DecTr,AlbMin_Grass,FCskip,FCskip,SnowAlbMin, ' AlbedoMin'
     WRITE(12,120) FCskip,FCskip,AlbMax_EveTr,AlbMax_DecTr,AlbMax_Grass,FCskip,FCskip,SnowAlbMax, ' AlbedoMax'
     !write(12,120) (alb(iv),iv=1,nsurf),SnowAlb, ' Albedo'   ! This is instantaneous value (not provided as input)
     WRITE(12,120) (emis(iv),iv=1,nsurf),emis_snow, ' Emissivity'
     WRITE(12,120) FCskip, FCskip,(baseT(iv),iv=1,nvegsurf), FCskip, FCskip, FCskip, ' BaseT'
     WRITE(12,120) FCskip, FCskip,(baseTe(iv),iv=1,nvegsurf),FCskip, FCskip, FCskip, ' BaseTe'
     WRITE(12,120) (StoreDrainPrm(1,iv),iv=1,nsurf), FCskip ,' StorageMin'
     WRITE(12,120) (StoreDrainPrm(5,iv),iv=1,nsurf), FCskip ,' StorageMax'
     WRITE(12,120) (WetThresh(iv),iv=1,nsurf), FCskip, ' WetThreshold'
     WRITE(12,120) (StateLimit(iv),iv=1,nsurf), FCskip,' StateLimit'
     WRITE(12,120) (StoreDrainPrm(2,iv),iv=1,nsurf), FCskip, ' DrainageEq'    !real
     WRITE(12,120) (StoreDrainPrm(3,iv),iv=1,nsurf), FCskip, ' DrainageCoef1'
     WRITE(12,120) (StoreDrainPrm(4,iv),iv=1,nsurf), FCskip, ' DrainageCoef2'
     WRITE(12,120) FCskip,FCskip,(GDDFull(iv),iv=1,nvegsurf),FCskip,FCskip,FCskip, ' GDDFull'
     WRITE(12,120) FCskip,FCskip,(SDDFull(iv),iv=1,nvegsurf),FCskip,FCskip,FCskip, ' SDDFull'
     WRITE(12,120) FCskip,FCskip,(LAImin(iv),iv=1,nvegsurf),FCskip,FCskip,FCskip, ' LAIMin'
     WRITE(12,120) FCskip,FCskip,(LAImax(iv),iv=1,nvegsurf),FCskip,FCskip,FCskip, ' LAIMax'
     WRITE(12,120) FCskip,FCskip,FCskip,PorMin_dec,FCSkip,FCskip,FCskip,FCskip, ' PorosityMin'
     WRITE(12,120) FCskip,FCskip,FCskip,PorMax_dec,FCSkip,FCskip,FCskip,FCskip, ' PorosityMax'
     WRITE(12,'(2f10.3,3i10,  3f10.3,a16)') FCskip,FCskip,LAItype(1:nvegsurf),FCskip,FCskip,FCskip, ' LAIEq'   !integer
     WRITE(12,'(2f10.3,3f10.5,3f10.3,a16)') FCskip,FCskip,LAIPower(1,1:nvegsurf),FCskip,FCskip,FCskip, ' LAI_LeafGP1'
     WRITE(12,'(2f10.3,3f10.5,3f10.3,a16)') FCskip,FCskip,LAIPower(2,1:nvegsurf),FCskip,FCskip,FCskip, ' LAI_LeafGP2'
     WRITE(12,'(2f10.3,3f10.5,3f10.3,a16)') FCskip,FCskip,LAIPower(3,1:nvegsurf),FCskip,FCskip,FCskip, ' LAI_LeafOP1'
     WRITE(12,'(2f10.3,3f10.5,3f10.3,a16)') FCskip,FCskip,LAIPower(4,1:nvegsurf),FCskip,FCskip,FCskip, ' LAI_LeafOP2'
     WRITE(12,120) FCskip,FCskip,(MaxConductance(iv),iv=1,nvegsurf),FCskip,FCskip,FCskip, ' MaxCond'
     WRITE(12,120) (SoilDepth(iv),iv=1,(nsurf-1)),FCskip,FCskip, ' SoilDepth'
     WRITE(12,120) (soilstoreCap(iv),iv=1,(nsurf-1)), FCskip, FCskip, ' SoilStoreCap'
     WRITE(12,'(6f10.5,2f10.3,a16)') (SatHydraulicConduct(iv),iv=1,(nsurf-1)),FCskip,FCskip, ' SatHydraulicConduct'
     ! Not currently coded, but add these later: SoilDensity, InfiltrationRate, OBS_SMDept, OBS_SMCap, OBS_SoilNotRocks
     WRITE(12,120) (snowD(iv),iv=1,(nsurf-1)),FCskip,FCskip, ' SnowLimPatch'
     WRITE(12,120) SnowLimPaved,SnowLimBuild,FCskip,FCskip,FCskip,FCskip,FCskip,FCskip, ' SnowLimRemove'
     WRITE(12,120) (OHM_coef(1:nsurf,1,1)),OHM_coef(nsurf+1,1,1), ' OHM_a1_Sum_Wet'
     WRITE(12,120) (OHM_coef(1:nsurf,2,1)),OHM_coef(nsurf+1,2,1), ' OHM_a1_Sum_Dry'
     WRITE(12,120) (OHM_coef(1:nsurf,3,1)),OHM_coef(nsurf+1,3,1), ' OHM_a1_Win_Wet'
     WRITE(12,120) (OHM_coef(1:nsurf,4,1)),OHM_coef(nsurf+1,4,1), ' OHM_a1_Win_Dry'
     WRITE(12,120) (OHM_coef(1:nsurf,1,2)),OHM_coef(nsurf+1,1,2), ' OHM_a2_Sum_Wet'
     WRITE(12,120) (OHM_coef(1:nsurf,2,2)),OHM_coef(nsurf+1,2,2), ' OHM_a2_Sum_Dry'
     WRITE(12,120) (OHM_coef(1:nsurf,3,2)),OHM_coef(nsurf+1,3,2), ' OHM_a2_Win_Wet'
     WRITE(12,120) (OHM_coef(1:nsurf,4,2)),OHM_coef(nsurf+1,4,2), ' OHM_a2_Win_Dry'
     WRITE(12,120) (OHM_coef(1:nsurf,1,3)),OHM_coef(nsurf+1,1,3), ' OHM_a3_Sum_Wet'
     WRITE(12,120) (OHM_coef(1:nsurf,2,3)),OHM_coef(nsurf+1,2,3), ' OHM_a3_Sum_Dry'
     WRITE(12,120) (OHM_coef(1:nsurf,3,3)),OHM_coef(nsurf+1,3,3), ' OHM_a3_Win_Wet'
     WRITE(12,120) (OHM_coef(1:nsurf,4,3)),OHM_coef(nsurf+1,4,3), ' OHM_a3_Win_Dry'
     WRITE(12,120) (OHM_threshSW(1:nsurf)),OHM_threshSW(nsurf+1), ' OHMthreshold_SW'
     WRITE(12,120) (OHM_threshWD(1:nsurf)),OHM_threshWD(nsurf+1), ' OHMthreshold_WD'

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Snow parameters'//' -----'
     WRITE(12,'(a12,11a10)') 'Grid','RadMeltF','TempMeltF','tau_a','tau_f','PLimAlb','SDensMin','SDensMax', &
          'tau_r','CRWMin','CRWMax','PLimSnow'
     WRITE(12,'(a12,11f10.4)') SsG_YYYY,RadMeltFact,TempMeltFact,tau_a,tau_f,PrecipLimitAlb,SnowDensMin,SnowDensMax, &
          tau_r,CRWmin,CRWmax,PrecipLimit

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Conductance parameters'//' -----'
     WRITE(12,'(a12,12a10)') 'Grid','G1','G2','G3','G4','G5','G6','TH','TL','S1','S2','Kmax','gsModel'
     WRITE(12,'(a12,11f10.3,i3)') SsG_YYYY,G1,G2,G3,G4,G5,G6,TH,TL,S1,S2,Kmax,gsModel

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Energy-use parameters'//' -----'
     WRITE(12,'(a12,11a10)') 'Grid','NumCapita','BaseTHDD','QF_A_WD','QF_A_WE','QF_B_WD','QF_B_WE','QF_C_WD','QF_C_WE', &
          'AH_Min','AH_Slope','T_critic_Heating'
     WRITE(12,'(a12,11f10.3)') SsG_YYYY,NumCapita,BaseTHDD,QF_A(1:2),QF_B(1:2),QF_C(1:2), &
          AH_Min,AH_Slope_Heating,T_critic_Heating

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Water-use parameters'//' -----'
     WRITE(12,'(a12,10a10)') 'Grid','IeStart','IeEnd','IntWatUse','Faut', &
          'Ie_a1','Ie_a2','Ie_a3','Ie_m1','Ie_m2','Ie_m3'
     WRITE(12,'(a12,2i10,8f10.3)') SsG_YYYY,Ie_start,Ie_end,InternalWaterUse_h,Faut, &
          Ie_a(1:3),Ie_m(1:3)

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Weekly profiles'//' -----'
     WRITE(12,'(a12,7a10,  a16)') 'Grid','1_Sun','2_Mon','3_Tue','4_Wed','5_Thu','6_Fri','7_Sat', ' DayOfWeek'
     WRITE(12,'(a12,7f10.3,a16)') SsG_YYYY,DayWat(1:7), ' Irr allowed'
     WRITE(12,'(a12,7f10.3,a16)') SsG_YYYY,DayWatPer(1:7), ' Frac properties'

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Hourly profiles'//' -----'
     WRITE(12,'(a12,24i10,a20)') 'Grid',(iv,iv=0,23),'HourOfDay'
     WRITE(12,121) SsG_YYYY,AHProf_24hr(0:23,1), ' Anthrop heat WD'
     WRITE(12,121) SsG_YYYY,AHProf_24hr(0:23,2), ' Anthrop heat WE'
     WRITE(12,121) SsG_YYYY,WUProfM_24hr(0:23,1),' Manual water use WD'
     WRITE(12,121) SsG_YYYY,WUProfM_24hr(0:23,2),' Manual water use WE'
     WRITE(12,121) SsG_YYYY,WUProfA_24hr(0:23,1),' Auto. water use WD'
     WRITE(12,121) SsG_YYYY,WUProfA_24hr(0:23,2),' Auto. water use WE'
     WRITE(12,121) SsG_YYYY,SnowProf_24hr(0:23,1), ' Snow clearing WD'
     WRITE(12,121) SsG_YYYY,SnowProf_24hr(0:23,2), ' Snow clearing WE'

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Within-grid water distribution'//' -----'
     WRITE(12,'(9a10)') 'ToPaved','ToBldgs','ToEveTr','ToDecTr','ToGrass','ToBSoil','ToWater','ToROorSS'

     DO iv=1,(nsurf-1)
        WRITE(12,'(8f10.4)')(WaterDist(j,iv),j=1,nsurf+1)
     ENDDO

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Other parameters'//' -----'
     WRITE(12,'(a12,7a10)') 'Grid','FlowChange','ROToWater','PipeCap', &   ! Water-related
          'DrRate','Cover','MaxRes',&   ! LUMPS-related
          'Trans'   ! NARP-related
     WRITE(12,'(a12,7f10.3)') SsG_YYYY,FlowChange,RunoffToWater,PipeCapacity, &
          DRAINRT,RAINCOVER,RAINMAXRES, &
          Trans_Site

     WRITE(12,*) '----- '//TRIM(ADJUSTL(SsG_YYYY))//' Site parameters'//' -----'
     WRITE(12,'(a12,9a10)') 'Grid','lat','lon','tz','alt','SurfA_ha','z','NumCapita','z0_input','zd_input','StartDLS','EndDLS'
     WRITE(12,'(a12,4f10.4,f10.2,4f10.4,2i10)') SsG_YYYY,lat,lng*(-1.0),timezone,alt,SurfaceArea_ha,z,NumCapita,z0m_in,zdm_in, &
          startDLS,endDLS! DayLightSavingDay(1:2)

     WRITE(12,*) ''



     CLOSE(12)


     !==============================================================================
     ! Check input values are reasonable ===========================================

     ! Coefficients for anthropogenic heat models ----------------------------------
     IF(EmissionsMethod==1) THEN   !Loridan et al. (2011) calculation
        IF(AH_min(1)==0.AND.Ah_slope_Heating(1)==0.AND.T_Critic_Heating(1)==0) THEN
           CALL ErrorHint(53,'Check QF calculation coefficients.',notUsed,notUsed,EmissionsMethod)
        ENDIF

     ELSEIF(EmissionsMethod==2) THEN   !Jarvi et al. (2011) calculation
        IF(SUM(QF_A)==0.AND.SUM(QF_B)==0.AND.SUM(QF_C)==0) THEN
           CALL ErrorHint(54,'Check QF calculation coefficients.',notUsed,notUsed,EmissionsMethod)
        ENDIF
     ENDIF

     ! Morphometric parameters -----------------------------------------------------
     IF(RoughLenMomMethod==1) THEN   !z0, zd values provided in input file
        ! Check z0m and zd are reasonable
        IF(z0m<0.00001) CALL ErrorHint(1,'z0 value provided is very small (RoughLenMomMethod=1).',z0m,notUsed,GridID)
        IF(zdm<0.00001) CALL ErrorHint(1,'zd value provided is very small (RoughLenMomMethod=1).',zdm,notUsed,GridID)
        zzd=z-zdm
     ELSEIF(RoughLenMomMethod==3) THEN   !z0, zd calculated using FAI provided in input file
        ! Check FAIs reasonable
        IF(FAIBLdg<0) CALL ErrorHint(1,'FAI_Bldgs value provided is very small (RoughLenMomMethod=3)',FAIBldg,notUsed,GridID)
        IF(FAITree<0) CALL ErrorHint(1,'FAI_EveTr/DecTr value provided is very small (RoughLenMomMethod=3)',FAITree,notUsed,GridID)
     ENDIF

  ENDIF   !End for first row of first block only ===================================


  !=================================================================================
  !For each row of the met forcing file (ir), translate correct info for each grid
  ! into model variables
  IF (ir>0) THEN
     ! =============================================================================
     ! === Translate met data from MetForcingData to variable names used in model ==
     ! =============================================================================
     iy        = INT(MetForcingData(ir, 1,Gridiv)) !Integer variables
     id        = INT(MetForcingData(ir, 2,Gridiv))
     it        = INT(MetForcingData(ir, 3,Gridiv))
     imin      = INT(MetForcingData(ir, 4,Gridiv))
     isec      = 0
     qn1_obs   = MetForcingData(ir, 5,Gridiv)      !Real values (kind(1d0))
     qh_obs    = MetForcingData(ir, 6,Gridiv)
     qe_obs    = MetForcingData(ir, 7,Gridiv)
     qs_obs    = MetForcingData(ir, 8,Gridiv)
     qf_obs    = MetForcingData(ir, 9,Gridiv)
     avu1      = MetForcingData(ir,10,Gridiv)
     avrh      = MetForcingData(ir,11,Gridiv)
     Temp_C    = MetForcingData(ir,12,Gridiv)
     Press_hPa = MetForcingData(ir,13,Gridiv)
     Precip    = MetForcingData(ir,14,Gridiv)
     avkdn     = MetForcingData(ir,15,Gridiv)
     snow_obs  = MetForcingData(ir,16,Gridiv)
     ldown_obs = MetForcingData(ir,17,Gridiv)
     fcld_obs  = MetForcingData(ir,18,Gridiv)
     wu_m3     = MetForcingData(ir,19,Gridiv)
     xsmd      = MetForcingData(ir,20,Gridiv)
     LAI_obs   = MetForcingData(ir,21,Gridiv)
     kdiff     = MetForcingData(ir,22,Gridiv)
     kdir      = MetForcingData(ir,23,Gridiv)
     wdir      = MetForcingData(ir,24,Gridiv)

     ! get qn1 memory for previous time steps
     ! qn1_store_grid(:)      = qn1_store(:,Gridiv)
     ! qn1_av_store_grid(:)   = qn1_av_store(:,Gridiv)
     dqndt  = dqndt_grids(Gridiv)
     qn1_av = qn1_av_grids(Gridiv)

     IF (SnowUse == 1) THEN
        ! qn1_S_store_grid(:)    = qn1_S_store(:,Gridiv)
        ! qn1_S_av_store_grid(:) = qn1_S_av_store(:,Gridiv)
        dqnsdt  = dqnsdt_grids(Gridiv)
        qn1_s_av = qn1_s_av_grids(Gridiv)
     ENDIF

     ! added by TS 29 Jun 2018 to remove annual loops in main calculation
     GDD_id      = GDD_id_grids(:,Gridiv)
     HDD_id      = HDD_id_grids(:,Gridiv)
     ! HDD_id_use = HDD_id_use_grids(:,Gridiv)
     LAI_id      = LAI_id_grids(:,Gridiv)
     WUDay_id    = WUDay_id_grids(:,Gridiv)

     DecidCap_id = DecidCap_id_grids(Gridiv)
     albDecTr_id = albDecTr_id_grids(Gridiv)
     albEveTr_id = albEveTr_id_grids(Gridiv)
     albGrass_id = albGrass_id_grids(Gridiv)
     porosity_id = porosity_id_grids(Gridiv)

     ! get met array for one grid used in AnOHM
     MetForcingData_grid=MetForcingData(:,:,Gridiv)

     ! Calculate dectime
     dectime = REAL(id-1,KIND(1d0))+REAL(it,KIND(1d0))/24+REAL(imin,KIND(1d0))/(60*24)
     ! Create datetime stamp for error/warnings file
     WRITE(iy_text,'(i4)') iy
     WRITE(id_text,'(i3)') id
     WRITE(it_text,'(i2)') it
     WRITE(imin_text,'(i2)') imin
     !     datetime = TRIM(ADJUSTL(iy_text))//' '//TRIM(ADJUSTL(id_text))//' '//TRIM(ADJUSTL(it_text))//' '//TRIM(ADJUSTL(imin_text))
     WRITE(GridID_text,'(i10)') GridID

     ! =============================================================================
     ! === Translate values from ModelDailyState to variable names used in model ===
     ! =============================================================================
     ! porosity(id) = ModelDailyState(Gridiv,cMDS_porosity)
     ! albDecTr(id) = ModelDailyState(Gridiv,cMDS_albDecTr)
     ! albEveTr(id) = ModelDailyState(Gridiv,cMDS_albEveTr)
     ! albGrass(id) = ModelDailyState(Gridiv,cMDS_albGrass)
     ! DecidCap(id) = ModelDailyState(Gridiv,cMDS_DecidCap)
     ! SnowfallCum  = ModelDailyState(Gridiv,cMDS_SnowfallCum)
     ! ---- Snow density of each surface
     SnowDens(1:nsurf) = ModelDailyState(Gridiv,cMDS_SnowDens(1:nsurf))

     ! =============================================================================
     ! === Translate values from ModelOutputData to variable names used in model ===
     ! =============================================================================
     ! ---- Above-ground state
     state_id(1:nsurf)       = ModelOutputData(ir-1,cMOD_State(1:nsurf),Gridiv)
     ! ---- Below-ground state
     soilmoist_id(1:nsurf)      = ModelOutputData(ir-1,cMOD_SoilState(1:nsurf),Gridiv)
     ! ---- Snow fraction
     SnowFrac(1:nsurf)       = ModelOutputData(ir-1,cMOD_SnowFrac(1:nsurf), Gridiv)
     ! ---- Snow water equivalent in SnowPack
     SnowPack(1:nsurf)       = ModelOutputData(ir-1,cMOD_SnowPack(1:nsurf), Gridiv)
     ! ---- Liquid (melted) water in SnowPack
     MeltWaterStore(1:nsurf) = ModelOutputData(ir-1,cMOD_SnowWaterState(1:nsurf), Gridiv)


     !Also translate ESTM forcing data
     IF(StorageHeatMethod==4 .OR. StorageHeatMethod==14) THEN
        !write(*,*) 'Translating ESTM forcing data'
        Ts5mindata(ir,1:ncolsESTMdata) = ESTMForcingData(ir,1:ncolsESTMdata,Gridiv)
        Ts5mindata_ir(1:ncolsESTMdata) = ESTMForcingData(ir,1:ncolsESTMdata,Gridiv)
        CALL ESTM_translate(Gridiv)
     ENDIF

  ENDIF !ir>0   !===================================================================

  ! --------------------------------------------------------------------------------
  ! Check Initial Conditions are reasonable ----------------------------------------
  IF (ir==1.AND.iMB==1) THEN   !For first row of first block only
     CALL CheckInitial
  ENDIF
  ! --------------------------------------------------------------------------------

  RETURN

120 FORMAT (8f10.3, a16)  !format (10g10.2)
121 FORMAT (a12,24f10.4, a20)

END SUBROUTINE SUEWS_Translate
!===================================================================================

!SUEWS_TranslateBack
!Translates model variables to arrays for each grid
!Runs at the end of SUEWS_Calculations to store correct info for each grid
!Made by HW Nov 2014
!-----------------------------------------------------------------------------------
!Last modified:LJ 14 Sep 2015
!              HCW 28 Nov 2014
!===================================================================================
SUBROUTINE SUEWS_TranslateBack(Gridiv,ir,irMax)

  USE allocateArray
  USE ColNamesInputFiles
  USE ColNamesModelDailyState
  USE data_in
  USE defaultnotUsed
  USE gis_data
  USE Initial
  USE mod_z
  USE resist
  USE snowMod
  USE sues_data
  USE time

  IMPLICIT NONE

  INTEGER::Gridiv,& ! Index of the analysed grid (Gridcounter)
       ir,        & ! Meteorological forcing file index (set to zero if SUEWS_Translate called from InitialState)
       irMax        ! Last row in current chunk of met data

  ! =============================================================================
  ! === Translate values from variable names used in model to ModelDailyState ===
  ! =============================================================================

  ! ModelDailyState(Gridiv,cMDS_porosity)    = porosity(id)
  ! ModelDailyState(Gridiv,cMDS_albDecTr)    = albDecTr(id)
  ! ModelDailyState(Gridiv,cMDS_albEveTr)    = albEveTr(id)
  ! ModelDailyState(Gridiv,cMDS_albGrass)    = albGrass(id)
  ! ModelDailyState(Gridiv,cMDS_DecidCap)    = DecidCap(id)
  ModelDailyState(Gridiv,cMDS_SnowfallCum) = SnowfallCum

  ModelDailyState(Gridiv,cMDS_porosity)    = porosity_id
  ModelDailyState(Gridiv,cMDS_albDecTr)    = albDecTr_id
  ModelDailyState(Gridiv,cMDS_albEveTr)    = albEveTr_id
  ModelDailyState(Gridiv,cMDS_albGrass)    = albGrass_id
  ModelDailyState(Gridiv,cMDS_DecidCap)    = DecidCap_id

  ! Save required DailyState variables for the current grid (HCW 27 Nov 2014)
  ! HDD_grids(:,:,Gridiv)    = HDD(:,:)
  ! GDD_grids(:,:,Gridiv)    = GDD(:,:)
  ! LAI_grids(:,:,Gridiv)    = LAI(:,:)
  ! WUDay_grids(:,:,Gridiv)  = WUDay(:,:)
  ! AlbDecTr_grids(:,Gridiv) = AlbDecTr(:)
  ! AlbEveTr_grids(:,Gridiv) = AlbEveTr(:)
  ! AlbGrass_grids(:,Gridiv) = AlbGrass(:)
  ! DecidCap_grids(:,Gridiv) = DecidCap(:)
  ! Porosity_grids(:,Gridiv) = Porosity(:)

  ! ! update qn1 memory with values of current time step
  ! qn1_store(:,Gridiv)      = qn1_store_grid(:)
  ! qn1_av_store(:,Gridiv)   = qn1_av_store_grid(:)
  ! IF (SnowUse == 1) THEN
  !    qn1_S_store(:,Gridiv)    = qn1_S_store_grid(:)
  !    qn1_S_av_store(:,Gridiv) = qn1_S_av_store_grid(:)
  ! ENDIF

  ! update averaged qn1 memory
  dqndt_grids(Gridiv)=dqndt
  qn1_av_grids(Gridiv)=qn1_av
  IF (SnowUse == 1) THEN
     dqnsdt_grids(Gridiv)=dqnsdt
     qn1_s_av_grids(Gridiv)=qn1_s_av
  ENDIF

  ! added by TS 29 Jun 2018 to remove annual loops in main calculation
  GDD_id_grids(:,Gridiv)=GDD_id
  HDD_id_grids(:,Gridiv)=HDD_id
  ! HDD_id_use_grids(:,Gridiv)=HDD_id_use
  LAI_id_grids(:,Gridiv)=LAI_id
  WUDay_id_grids(:,Gridiv)=WUDay_id

  DecidCap_id_grids(Gridiv)=DecidCap_id
  albDecTr_id_grids(Gridiv)=albDecTr_id
  albEveTr_id_grids(Gridiv)=albEveTr_id
  albGrass_id_grids(Gridiv)=albGrass_id
  porosity_id_grids(Gridiv)=porosity_id


  ! ---- Snow density of each surface
  ModelDailyState(Gridiv,cMDS_SnowDens(1:nsurf)) = SnowDens(1:nsurf)
  ModelDailyState(Gridiv,cMDS_SnowAlb) = SnowAlb


  ! =============================================================================
  ! === Translate values from variable names used in model to ModelOutputData ===
  ! =============================================================================

  ModelOutputData(ir,cMOD_State(1:nsurf),Gridiv)           = state_id(1:nsurf)
  ModelOutputData(ir,cMOD_SoilState(1:nsurf),Gridiv)       = soilmoist_id(1:nsurf)
  ModelOutputData(ir,cMOD_SnowFrac(1:nsurf), Gridiv)       = SnowFrac(1:nsurf)
  ModelOutputData(ir,cMOD_SnowPack(1:nsurf), Gridiv)       = SnowPack(1:nsurf)
  ModelOutputData(ir,cMOD_SnowWaterState(1:nsurf), Gridiv) = MeltWaterStore(1:nsurf)

  IF(ir==irMax) THEN   !Store variables ready for next chunk of met data
     ModelOutputData(0,cMOD_State(1:nsurf),Gridiv)          = state_id(1:nsurf)
     ModelOutputData(0,cMOD_SoilState(1:nsurf),Gridiv)      = soilmoist_id(1:nsurf)
     ModelOutputData(0,cMOD_SnowFrac(1:nsurf),Gridiv)       = SnowFrac(1:nsurf)
     ModelOutputData(0,cMOD_SnowPack(1:nsurf),Gridiv)       = SnowPack(1:nsurf)
     ModelOutputData(0,cMOD_SnowWaterState(1:nsurf),Gridiv) = MeltWaterStore(1:nsurf)
  ENDIF

  RETURN
endsubroutine SUEWS_TranslateBack
!===================================================================================

SUBROUTINE LUMPS_cal_QHQE(&
     veg_type,& !input
     snowUse,qn1,qf,qs,Qm,Temp_C,Veg_Fr,avcp,Press_hPa,lv_J_kg,&
     tstep_real,DRAINRT,nsh_real,&
     Precip,RainMaxRes,RAINCOVER,sfr,LAI_id_prev,LAImax,LAImin,&
     H_mod,& !output
     E_mod,psyc_hPa,s_hPa,sIce_hpa,TempVeg,VegPhenLumps)
  !Calculates QH and QE for LUMPS. See Loridan et al. (2011)
  ! ref: Grimmond and Oke (2002) JAM and references within that
  !      Offerle (2003) -- add water bucket
  ! ref: Loridan et al. (2011) JAMC dynamic water & vegetation
  ! Last modified:
  ! LJ 27 Jan 2016  - Removal of tabs, cleaning the code
  ! HCW 04 Mar 2015 - Modified to account for model timestep (rather than hourly resolution)
  ! LJ Feb 2014     - The bug related to VegMax has been fixed (cannot divide by zero)
  ! LJ/SG May 2012  - Changed phenology to be consistent with SUEWS LAI. No longer Loridan et al. (2011)
  ! LJ June 2012    - Modified to work with snow (Qm added in the equations!)
  ! SG Feb 2012     - added some comments
  ! --------------------------------------------------------------
  USE meteo,ONLY:psyc_const,slope_svp,slopeice_svp

  IMPLICIT NONE
  INTEGER,PARAMETER::ndays=366
  INTEGER,PARAMETER::NSurf=7
  INTEGER,PARAMETER::NVegSurf=3
  INTEGER,PARAMETER::ivConif=1
  INTEGER,PARAMETER::ivGrass=3

  INTEGER,INTENT(in) :: veg_type  !Defines how vegetation is calculated for LUMPS
  INTEGER,INTENT(in) :: snowUse ! option of snow module

  REAL(KIND(1d0)),INTENT(in) :: qn1! net all-wave radiation
  REAL(KIND(1d0)),INTENT(in) :: qf! anthropogenic heat flux
  REAL(KIND(1d0)),INTENT(in) :: qs! storage heat flux
  REAL(KIND(1d0)),INTENT(in) :: Qm!Snow melt associated heat flux
  REAL(KIND(1d0)),INTENT(in) :: Temp_C!air temperature in degC
  REAL(KIND(1d0)),INTENT(in) :: Veg_Fr!Vegetation fraction from land area
  REAL(KIND(1d0)),INTENT(in) :: avcp!Specific heat capacity
  REAL(KIND(1d0)),INTENT(in) :: Press_hPa!Station air pressure in hPa
  REAL(KIND(1d0)),INTENT(in) :: lv_J_kg!Latent heat of vaporization in [J kg-1]
  REAL(KIND(1d0)),INTENT(in) :: tstep_real ! time step in REAL
  REAL(KIND(1d0)),INTENT(in) :: DRAINRT!Drainage rate of the water bucket [mm hr-1]
  REAL(KIND(1d0)),INTENT(in) :: nsh_real! real cast of Number of timesteps per hour
  REAL(KIND(1d0)),INTENT(in) :: Precip!Precipitation per timestep [mm]
  REAL(KIND(1d0)),INTENT(in) :: RainMaxRes!Maximum water bucket reservoir [mm]
  REAL(KIND(1d0)),INTENT(in) :: RAINCOVER! LUMPS Limit when surface totally wet [mm]

  REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in) :: sfr! veg surface fractions [-]
  REAL(KIND(1D0)),DIMENSION(NVEGSURF),INTENT(in) :: LAI_id_prev! LAI(id-1,iv), LAI at the beginning of today
  REAL(KIND(1d0)),DIMENSION(3),INTENT(in) :: LAImax!Max LAI [m2 m-2]
  REAL(KIND(1d0)),DIMENSION(3),INTENT(in) :: LAImin    !Min LAI [m2 m-2]

  REAL(KIND(1d0)),INTENT(out) ::H_mod
  REAL(KIND(1d0)),INTENT(out) ::E_mod !turbulent fluxes: QH, QE
  REAL(KIND(1d0)),INTENT(out) ::psyc_hPa !Psychometric constant in hPa
  REAL(KIND(1d0)),INTENT(out) ::s_hPa!Vapour pressure versus temperature slope in hPa
  REAL(KIND(1d0)),INTENT(out) ::sIce_hpa!Vapour pressure versus temperature slope in hPa above ice/snow
  REAL(KIND(1d0)),INTENT(out) ::TempVeg !TEMPORARY VEGETATIVE SURFACE FRACTION ADJUSTED BY RAINFALL
  REAL(KIND(1d0)),INTENT(out) ::VegPhenLumps
  ! REAL(KIND(1d0)),INTENT(inout) ::RainBucket !RAINFALL RESERVOIR [mm]
  ! INTEGER::iv
  REAL(KIND(1d0)),DIMENSION(3) :: sfrVeg! veg surface fractions [-]                             !,start
  REAL(KIND(1d0))::VegPhen,VegMax,VegMin,&   !Vegetation phenology for LUMPS
       psyc_s,&       !Psychometric constant
       alpha_sl,alpha_in,&    	  !Parameters used in LUMPS QH and QE calculations
       beta,&                      !Beta parameter used in LUMPS QH and QE calculations [W m-2]
       alpha_qhqe,RAINRES,RainBucket,tlv

  tlv=lv_J_kg/tstep_real !Latent heat of vapourisation per timestep
  ! initialize VegPhenLumps to output
  VegPhenLumps=0

  ! initialize rain-related variables
  RainBucket=0.

  ! surface fractions fro veg surfaces
  sfrVeg=sfr(ivConif+2:ivGrass+2)


  ! Calculate slope of the saturation vapour pressure vs air temp.
  s_hPa=slope_svp(Temp_C)
  psyc_hPa=psyc_const(avcp,Press_hPa,lv_J_kg)
  psyc_s=psyc_hPa/s_hPa

  !Calculate also sublimation ones if snow calculations are made.
  !Used also for LUMPS
  IF (snowUse==1) THEN
     IF (Temp_C<=0) THEN
        sIce_hpa=slopeIce_svp(Temp_C)
     ELSE
        sIce_hpa=slope_svp(Temp_C)
     ENDIF
     psyc_s=psyc_hPa/sIce_hPa   !Psychometric constant divided by the slope
  ENDIF

  ! replaced by sinusoidal vegetation formulation
  !alpha=gis(idgis,itgis,1)*alpha_sl+alpha_in

  !THE FOLLOWING ADJUSTS THE ALPHA and BETA PARAMETERs FOR RAINFALL.
  !ASSUMES THE SURFACE IS VEGETATION COVERED WITH RAIN > RAINCOVER mm/DAY
  !OTHERWISE INCREASES VEGETATION LINEAR WITH AMOUNT OF RAIN.

  ! !IF (E_mod>0.) RainBucket=RainBucket-E_mod*1.44E-3 !1.44E-3 MM/(W/M^2)/HR (i.e. 3600/(lv_J_kg))
  ! IF (E_mod>0.) RainBucket=RainBucket-E_mod/tlv   !Adjusted for per model timestep instead of per hour HCW 04 Mar 2015
  ! IF (Temp_C>0.) RainBucket=RainBucket - DRAINRT/nsh_real  !DRAINRT is specified in mm h-1
  ! IF (RainBucket<0.) RainBucket=0.
  ! IF (Precip>0) RainBucket=MIN(RainMaxRes,RainBucket+Precip)
  !
  ! RAINRES = RainBucket
  ! IF (RAINRES>RAINCOVER) RAINRES=RAINCOVER

  !--------Calculate vegetation phenology for LUMPS------------------------
  ! VegPhen=0
  ! VegMax=0
  ! VegMin=0
  VegPhen=DOT_PRODUCT(sfrVeg,LAI_id_prev)
  VegMax=DOT_PRODUCT(sfrVeg,LAImax)
  VegMin=DOT_PRODUCT(sfrVeg,LAImin)

  ! DO iv=ivConif,ivGrass   !Normalized LAI for vegetation
  !    VegPhen = sfr(iv+2)*LAI(id-1,iv) + VegPhen
  !    VegMax  = sfr(iv+2)*LAImax(iv) + VegMax
  !    VegMin  = sfr(iv+2)*LAImax(iv) + VegMin
  ! ENDDO

  IF(VegMax<=0.01000) THEN   !If max vegetation is very small, TempVeg = 0;
     TempVeg=0
  ELSE
     VegPhenLumps=(VegPhen)/(VegMax)
     TempVeg=Veg_Fr*VegPhenLumps   !Now this is veg_fraction in general
  ENDIF

  IF (TempVeg>0.9000) THEN   !If vegetation fraction is larger than 0.9
     beta = (20-3)*TempVeg+3
     alpha_qhqe=TempVeg*0.8+0.2
  ELSE
     beta=3
     IF(veg_type==1) THEN   !Area vegetated, including bare soil and water
        alpha_sl=0.686
        alpha_in=0.189
     ELSEIF(veg_type==2) THEN   !Area irrigated vegetation
        alpha_sl=0.610
        alpha_in=0.222
     ENDIF
     alpha_qhqe=TempVeg*alpha_sl+alpha_in
  ENDIF

  ! Calculate the actual heat fluxes
  H_mod= ((1-alpha_qhqe)+psyc_s)/(1+psyc_s)*(qn1+qf-qs-Qm)-beta   !Eq 3, Grimmond & Oke (2002)
  E_mod= (alpha_qhqe/(1+psyc_s)*(qn1+qf-qs-Qm))+beta              !Eq 4, Grimmond & Oke (2002)

  ! adjust RAINRES after E_mod calculation is done: ! moved here from above. TS, 13 Jan 2018
  !IF (E_mod>0.) RainBucket=RainBucket-E_mod*1.44E-3 !1.44E-3 MM/(W/M^2)/HR (i.e. 3600/(lv_J_kg))
  IF (E_mod>0.) RainBucket=RainBucket-E_mod/tlv   !Adjusted for per model timestep instead of per hour HCW 04 Mar 2015
  IF (Temp_C>0.) RainBucket=RainBucket - DRAINRT/nsh_real  !DRAINRT is specified in mm h-1
  IF (RainBucket<0.) RainBucket=0.
  IF (Precip>0) RainBucket=MIN(RainMaxRes,RainBucket+Precip)

  RAINRES = RainBucket
  IF (RAINRES>RAINCOVER) RAINRES=RAINCOVER


  RETURN

END SUBROUTINE LUMPS_cal_QHQE

SUBROUTINE AerodynamicResistance(&

                                ! input:
     ZZD,&
     z0m,&
     AVU1,&
     L_mod,&
     UStar,&
     VegFraction,&
     AerodynamicResistanceMethod,&
     StabilityMethod,&
     RoughLenHeatMethod,&
                                ! output:
     RA)

  ! Returns Aerodynamic resistance (RA) to the main program SUEWS_Calculations
  ! All RA equations reported in Thom & Oliver (1977)
  ! Modified by TS 08 Aug 2017 - interface modified
  ! Modified by LJ
  !   -Removal of tabs and cleaning the code
  ! Modified by HCW 03 Dec 2015 - changed lower limit on RA from 2 s m-1 to 10 s m-1 (to avoid unrealistically high evaporation rates)
  ! Modified by LJ in 12 April to not to be used with global variables
  ! To Do:
  !       - Check whether the thresholds 2-200 s m-1 are suitable over a range of z0!! HCW 04 Mar 2015
  ! OUTPUT: RA - Aerodynamic resistance [s m^-1]
  ! INPUT:  AerodynamicResistanceMethod = Method to calculate RA
  !         StabilityMethod = defines the method to calculate atmospheric stability
  !         RoughLenHeatMethod = Method to calculate heat roughness length
  !         *Measurement height minus* Displacement height (m) (was incorrectly labelled, corrected HCW 25 May 2016
  !         z0m = Aerodynamic roughness length (m)
  !         k2 = Power of Van Karman's constant (= 0.16 = 0.4^2)
  !         AVU1 = Mean wind speed
  !         L_mod = Obukhov length (m)
  !         UStar = Friction velocity (m s-1)
  !         VegFraction = Fraction of vegetation
  !               (changed from veg_fr which also includes water surface by HCW 05 Nov 2015)


  USE AtmMoistStab_module,ONLY:stab_fn_heat,stab_fn_mom

  IMPLICIT NONE

  REAL(KIND(1d0)),INTENT(in)::ZZD!Active measurement height (meas. height-displac. height)
  REAL(KIND(1d0)),INTENT(in)::z0m!Aerodynamic roughness length
  REAL(KIND(1d0)),INTENT(in)::AVU1!Average wind speed
  REAL(KIND(1d0)),INTENT(in)::L_mod!Monin-Obukhov length (either measured or modelled)
  REAL(KIND(1d0)),INTENT(in)::UStar!Friction velocity
  REAL(KIND(1d0)),INTENT(in)::VegFraction!Fraction of vegetation

  INTEGER,INTENT(in)::AerodynamicResistanceMethod
  INTEGER,INTENT(in)::StabilityMethod
  INTEGER,INTENT(in)::RoughLenHeatMethod

  REAL(KIND(1d0)),INTENT(out)::RA !Aerodynamic resistance [s m^-1]

  INTEGER, PARAMETER :: notUsedI=-55

  REAL(KIND(1d0)), PARAMETER :: &
       notUsed=-55.5,&
       k2=0.16,& !Power of Van Karman's constant (= 0.16 = 0.4^2)
       muu=1.46e-5 !molecular viscosity
  REAL(KIND(1d0))::&
       psym,&
       psyh,z0V,cal_z0V

  !1)Monteith (1965)-neutral stability
  IF(AerodynamicResistanceMethod==1) THEN
     RA=(LOG(ZZD/z0m)**2)/(k2*AVU1)

     !2) Non-neutral stability
     !    PSIM - stability function for momentum
     !     PSYH - stability function for heat
     !    assuming stability functions the same for heat and water
  ELSEIF(AerodynamicResistanceMethod==2) THEN  !Dyer (1974)

     psym=stab_fn_mom(StabilityMethod,ZZD/L_mod,zzd/L_mod)
     psyh=stab_fn_heat(StabilityMethod,ZZD/L_mod,zzd/L_mod)

     !Z0V roughness length for vapour
     z0V=cal_z0V(RoughLenHeatMethod,z0m,VegFraction,UStar)
     ! IF (RoughLenHeatMethod==1) THEN !Brutasert (1982) Z0v=z0/10(see Grimmond & Oke, 1986)
     !    z0V=z0m/10
     ! ELSEIF (RoughLenHeatMethod==2) THEN ! Kawai et al. (2007)
     !   	!z0V=z0m*exp(2-(1.2-0.9*veg_fr**0.29)*(UStar*z0m/muu)**0.25)
     !    ! Changed by HCW 05 Nov 2015 (veg_fr includes water; VegFraction = veg + bare soil)
     !    z0V=z0m*EXP(2-(1.2-0.9*VegFraction**0.29)*(UStar*z0m/muu)**0.25)
     ! ELSEIF (RoughLenHeatMethod==3) THEN
     !    z0V=z0m*EXP(-20.) ! Voogt and Grimmond, JAM, 2000
     ! ELSEIF (RoughLenHeatMethod==4) THEN
     !    z0V=z0m*EXP(2-1.29*(UStar*z0m/muu)**0.25) !See !Kanda and Moriwaki (2007),Loridan et al. (2010)
     ! ENDIF

     IF(Zzd/L_mod==0.OR.UStar==0) THEN
        RA=(LOG(ZZD/z0m)*LOG(ZZD/z0V))/(k2*AVU1) !Use neutral equation
     ELSE
        RA=((LOG(ZZD/z0m)-PSYM)*(LOG(ZZD/z0V)-PSYH))/(K2*AVU1)
     ENDIF

     !3) Thom and Oliver (1977)
  ELSEIF(AerodynamicResistanceMethod==3) THEN
     RA=(4.72*LOG(ZZD/z0m)**2)/(1 + 0.54*AVU1)
  ENDIF

  !If RA outside permitted range, adjust extreme values !!Check whether these thresholds are suitable over a range of z0
  IF(RA>200) THEN   !was 175
     CALL errorHint(7,'In AerodynamicResistance.f95, calculated RA > 200 s m-1; RA set to 200 s m-1',RA,notUsed,notUsedI)
     RA=200
  ELSEIF(RA<10) THEN   !found  By Shiho - fix Dec 2012  !Threshold changed from 2 to 10 s m-1 (HCW 03 Dec 2015)
     CALL errorHint(7,'In AerodynamicResistance.f95, calculated RA < 10 s m-1; RA set to 10 s m-1',RA,notUsed,notUsedI)
     RA=10
     ! RA=(log(ZZD/z0m))**2/(k2*AVU1)
     IF(avu1<0) WRITE(*,*) avu1,RA
  ENDIF

  RETURN
END SUBROUTINE AerodynamicResistance

SUBROUTINE SurfaceResistance(&
     id,it,&! input:
     SMDMethod,snowFrac,sfr,avkdn,Temp_C,dq,xsmd,vsmd,MaxConductance,&
     LAIMax,LAI_id,gsModel,Kmax,&
     G1,G2,G3,G4,G5,G6,TH,TL,S1,S2,&
     gsc,ResistSurf)! output:
  ! Calculates bulk surface resistance (ResistSurf [s m-1]) based on Jarvis 1976 approach
  ! Last modified -----------------------------------------------------
  ! HCW 21 Jul 2016: If no veg surfaces, vsmd = NaN so QE & QH = NaN; if water surfaces only, smd = NaN so QE & QH = NaN.
  !                  Add checks here so that gs (soil part) = 0 in either of these situations.
  !                  This shouldn't change results but handles NaN error.
  ! HCW 01 Mar 2016: SM dependence is now on modelled smd for vegetated surfaces only (vsmd) (Note: obs smd still not operational!)
  ! HCW 18 Jun 2015: Alternative gs parameterisation added using different functional forms and new coefficients
  ! HCW 31 Jul 2014: Modified condition on g6 part to select meas/mod smd
  ! LJ  24 Apr 2013: Added impact of snow fraction in LAI and in soil moisture deficit
  ! -------------------------------------------------------------------

  ! USE allocateArray
  ! USE data_in
  ! USE defaultNotUsed
  ! USE gis_data
  ! USE moist
  ! USE resist
  ! USE sues_data

  IMPLICIT NONE
  ! INTEGER,PARAMETER::BldgSurf=2
  INTEGER,PARAMETER::ConifSurf=3
  INTEGER,PARAMETER::DecidSurf=4
  INTEGER,PARAMETER::GrassSurf=5
  ! INTEGER,PARAMETER::ivConif=1
  ! INTEGER,PARAMETER::ivGrass=3
  ! INTEGER,PARAMETER::MaxNumberOfGrids=2000
  ! INTEGER,PARAMETER::ndays=366
  INTEGER,PARAMETER::nsurf=7
  ! INTEGER,PARAMETER::NVegSurf=3
  ! INTEGER,PARAMETER::PavSurf=1
  INTEGER,PARAMETER::WaterSurf=7


  INTEGER,INTENT(in)::id
  INTEGER,INTENT(in)::it ! time: day of year and hour
  INTEGER,INTENT(in)::gsModel!Choice of gs parameterisation (1 = Ja11, 2 = Wa16)
  INTEGER,INTENT(in)::SMDMethod!Method of measured soil moisture
  ! INTEGER,INTENT(in)::ConifSurf!= 3, surface code
  ! INTEGER,INTENT(in)::DecidSurf!= 4, surface code
  ! INTEGER,INTENT(in)::GrassSurf!= 5, surface code
  ! INTEGER,INTENT(in)::WaterSurf!= 7, surface code
  ! INTEGER,INTENT(in)::nsurf!= 7, Total number of surfaces

  REAL(KIND(1d0)),INTENT(in)::avkdn!Average downwelling shortwave radiation
  REAL(KIND(1d0)),INTENT(in)::Temp_C!Air temperature
  REAL(KIND(1d0)),INTENT(in)::Kmax!Annual maximum hourly solar radiation
  REAL(KIND(1d0)),INTENT(in)::G1!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::G2!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::G3!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::G4!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::G5!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::G6!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::S1!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::S2!Fitted parameters related to surface res. calculations
  REAL(KIND(1d0)),INTENT(in)::TH!Maximum temperature limit
  REAL(KIND(1d0)),INTENT(in)::TL!Minimum temperature limit
  REAL(KIND(1d0)),INTENT(in)::dq!Specific humidity deficit
  REAL(KIND(1d0)),INTENT(in)::xsmd!Measured soil moisture deficit
  REAL(KIND(1d0)),INTENT(in)::vsmd!QUESTION: Soil moisture deficit for vegetated surfaces only (what about BSoil?)

  REAL(KIND(1d0)),DIMENSION(3),INTENT(in)    ::MaxConductance!Max conductance [mm s-1]
  REAL(KIND(1d0)),DIMENSION(3),INTENT(in)    ::LAIMax        !Max LAI [m2 m-2]
  REAL(KIND(1d0)),DIMENSION(3),INTENT(in)    ::LAI_id        !=LAI(id-1,:), LAI for each veg surface [m2 m-2]
  REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::snowFrac      !Surface fraction of snow cover
  REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::sfr           !Surface fractions [-]

  REAL(KIND(1d0)),INTENT(out)::gsc!Surface Layer Conductance
  REAL(KIND(1d0)),INTENT(out)::ResistSurf!Surface resistance

  REAL(KIND(1d0)):: &
       gl,&!G(LAI)
       QNM,&!QMAX/(QMAX+G2)
       gq,&!G(Q*)
       gdq,&!G(dq)
       TC,&!Temperature parameter 1
       TC2,&!Temperature parameter 2
       gtemp,&!G(T)
       sdp,&!S1/G6+S2
       gs!G(Soil moisture deficit)


  INTEGER:: iv
  REAL(KIND(1d0)):: id_real

  REAL(KIND(1d0)),PARAMETER :: notUsed=-55
  ! REAL(KIND(1d0)),PARAMETER :: notUsedi=-55.5

  id_real = REAL(id) !Day of year in real number

  !gsModel = 1 - original parameterisation (Jarvi et al. 2011)
  !gsModel = 2 - new parameterisation (Ward et al. 2016)

  IF(gsModel == 1) THEN
     IF(avkdn<=0) THEN   !At nighttime set gsc at arbitrary low value: gsc=0.1 mm/s (Shuttleworth, 1988b)
        gsc=0.1   !QUESTION: Is this limit good here? ZZ
     ELSE
        ! kdown ----
        QNM=Kmax/(Kmax+G2)
        !gq=(qn1/(g2+qn1))/qnm !With net all-wave radiation
        gq=(avkdn/(G2+avkdn))/QNM !With Kdown

        ! specific humidity deficit ----
        IF(dq<G4) THEN
           gdq=1-G3*dq
        ELSE
           gdq=1-G3*G4
        ENDIF

        ! air temperature ----
        TC=(TH-G5)/(G5-TL)
        TC2=(G5-TL)*(TH-G5)**TC
        !If air temperature below TL or above TH, fit it to TL+0.1/TH-0.1
        IF (Temp_C<=tl) THEN
           gtemp=(tl+0.1-tl)*(th-(tl+0.1))**tc/tc2

           !Call error only if no snow on ground
           !  IF (MIN(snowFrac(1),snowFrac(2),snowFrac(3),snowFrac(4),snowFrac(5),snowFrac(6))/=1) THEN
           IF (MINVAL(snowFrac(1:6))/=1) THEN
              CALL errorHint(29,'subroutine SurfaceResistance.f95: T changed to fit limits TL=0.1,Temp_c,id,it',&
                   REAL(Temp_c,KIND(1d0)),id_real,it)
           ENDIF

        ELSEIF (Temp_C>=th) THEN
           gtemp=((th-0.1)-tl)*(th-(th-0.1))**tc/tc2
           CALL errorHint(29,'subroutine SurfaceResistance.f95: T changed to fit limits TH=39.9,Temp_c,id,it',&
                REAL(Temp_c,KIND(1d0)),id_real,it)
        ELSE
           gtemp=(Temp_C-tl)*(th-Temp_C)**tc/tc2
        ENDIF

        ! soil moisture deficit ----
        sdp=S1/G6+S2
        IF(SMDMethod>0)THEN         !Modified from ==1 to > 0 by HCW 31/07/2014
           gs=1-EXP(g6*(xsmd-sdp))  !Measured soil moisture deficit is used
        ELSE
           gs=1-EXP(g6*(vsmd-sdp))   !Modelled is used
           IF(sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf) == 0 .OR. sfr(WaterSurf)==1 ) THEN
              gs=0   !If no veg so no vsmd, or all water so no smd, set gs=0 (HCW 21 Jul 2016)
           ENDIF
        ENDIF

        gs = gs*(1-SUM(snowFrac(1:6))/6)

        IF(gs<0)THEN
           CALL errorHint(65,'subroutine SurfaceResistance.f95 (gsModel=1): g(smd) < 0 calculated, setting to 0.0001',gs,id_real,it)
           gs=0.0001
        ENDIF

        !LAI
        !Original way
        !gl=((LAI(id,2)*areaunir/lm)+areair)/(areair+areaunir)
        !New way
        gl=0    !First initialize
        ! vegetated surfaces
        ! check basis for values koe - maximum surface conductance
        !  print*,id,it,sfr
        ! DO iv=ivConif,ivGrass
        DO iv=1,3
           ! gl=gl+(sfr(iv+2)*(1-snowFrac(iv+2)))*LAI(id-1,iv)/LAIMax(iv)*MaxConductance(iv)
           gl=gl+(sfr(iv+2)*(1-snowFrac(iv+2)))*LAI_id(iv)/LAIMax(iv)*MaxConductance(iv)
        ENDDO

        ! Multiply parts together
        gsc=(G1*gq*gdq*gtemp*gs*gl)

        IF(gsc<=0) THEN
           CALL errorHint(65,'subroutine SurfaceResistance.f95 (gsModel=1): gs <= 0, setting to 0.1 mm s-1',gsc,id_real,it)
           gsc=0.1
        ENDIF
     ENDIF

  ELSEIF(gsModel == 2) THEN
     IF(avkdn<=0) THEN      !At nighttime set gsc at arbitrary low value: gsc=0.1 mm/s (Shuttleworth, 1988b)
        gsc=0.1
     ELSE
        ! ---- g(kdown)----
        QNM = Kmax/(Kmax+G2)
        gq = (avkdn/(avkdn+G2))/QNM
        IF(avkdn >= Kmax) THEN   !! Add proper error handling later - HCW!!
           WRITE(*,*) 'Kmax exceeds Kdn setting to g(Kdn) to 1'
           gq = 1
        ENDIF
        ! ---- g(delq) ----
        gdq = G3 + (1-G3)*(G4**dq)   !Ogink-Hendriks (1995) Eq 12 (using G3 as Kshd and G4 as r)
        ! ---- g(Tair) ----
        Tc=(TH-G5)/(G5-TL)
        Tc2=(G5-TL)*(TH-G5)**Tc
        ! If air temperature below TL or above TH, then use value for TL+0.1 or TH-0.1
        IF (Temp_C <= TL) THEN
           gtemp=(TL+0.1-TL)*(TH-(TL+0.1))**Tc/Tc2
           ! Call error only if no snow on ground
           IF (MIN(snowFrac(1),snowFrac(2),snowFrac(3),snowFrac(4),snowFrac(5),snowFrac(6))/=1) THEN
              CALL errorHint(29,'subroutine SurfaceResistance.f95: T changed to fit limits TL+0.1,Temp_C,id,it',&
                   REAL(Temp_c,KIND(1d0)),id_real,it)
           ENDIF
        ELSEIF (Temp_C >= TH) THEN
           gtemp=((TH-0.1)-TL)*(TH-(TH-0.1))**Tc/Tc2
           CALL errorHint(29,'subroutine SurfaceResistance.f95: T changed to fit limits TH-0.1,Temp_C,id,it',&
                REAL(Temp_c,KIND(1d0)),id_real,it)
        ELSE
           gtemp=(Temp_C-TL)*(TH-Temp_C)**Tc/Tc2
        ENDIF
        ! ---- g(smd) ----
        sdp=S1/G6+S2
        IF(SMDMethod>0) THEN   !Modified from ==1 to > 0 by HCW 31/07/2014
           gs=(1-EXP(g6*(xsmd-sdp)))/(1-EXP(g6*(-sdp)))   !Use measured smd
        ELSE
           !gs=1-EXP(g6*(vsmd-sdp))   !Use modelled smd
           gs=(1-EXP(g6*(vsmd-sdp)))/(1-EXP(g6*(-sdp)))
           IF(sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf) == 0 .OR. sfr(WaterSurf)==1 ) THEN
              gs=0   !If no veg so no vsmd, or all water so no smd, set gs=0 HCW 21 Jul 2016
           ENDIF
        ENDIF

        gs = gs*(1-SUM(snowFrac(1:6))/6)

        IF(gs<0)THEN
           CALL errorHint(65,'subroutine SurfaceResistance.f95 (gsModel=2): gs < 0 calculated, setting to 0.0001',gs,id_real,it)
           gs=0.0001
        ENDIF

        ! ---- g(LAI) ----
        gl=0    !Initialise
        ! DO iv=ivConif,ivGrass   !For vegetated surfaces
        DO iv=1,3   !For vegetated surfaces
           !  gl=gl+(sfr(iv+2)*(1-snowFrac(iv+2)))*LAI(id-1,iv)/LAIMax(iv)*MaxConductance(iv)
           gl=gl+(sfr(iv+2)*(1-snowFrac(iv+2)))*LAI_id(iv)/LAIMax(iv)*MaxConductance(iv)
        ENDDO

        ! Multiply parts together
        gsc=(G1*gq*gdq*gtemp*gs*gl)

        IF(gsc<=0) THEN
           CALL errorHint(65,'subroutine SurfaceResistance.f95 (gsModel=2): gsc <= 0, setting to 0.1 mm s-1',gsc,id_real,it)
           gsc=0.1
        ENDIF

     ENDIF

  ELSEIF(gsModel < 1 .OR. gsModel > 2) THEN
     CALL errorHint(71,'Value of gsModel not recognised.',notUsed,NotUsed,gsModel)
  ENDIF

  ResistSurf=1/(gsc/1000)  ![s m-1]

  RETURN
END SUBROUTINE SurfaceResistance

SUBROUTINE BoundaryLayerResistance(&
     zzd,& ! input:    !Active measurement height (meas. height-displac. height)
     z0m,&     !Aerodynamic roughness length
     avU1,&    !Average wind speed
     UStar,&! input/output:
     rb)! output:

  IMPLICIT NONE

  REAL(KIND(1d0)),INTENT(in)::zzd     !Active measurement height (meas. height-displac. height)
  REAL(KIND(1d0)),INTENT(in)::z0m     !Aerodynamic roughness length
  REAL(KIND(1d0)),INTENT(in)::avU1    !Average wind speed

  REAL(KIND(1d0)),INTENT(inout)::UStar!Friction velocity

  REAL(KIND(1d0)),INTENT(out)::rb   !boundary layer resistance shuttleworth

  REAL(KIND(1d0)),PARAMETER :: k=0.4

  IF(UStar<0.01) THEN
     UStar=avu1/LOG(zzd/z0m)*k
  END IF

  rb=(1.1/UStar)+(5.6*(UStar**0.333333))!rb - boundary layer resistance shuttleworth

  RETURN
END SUBROUTINE BoundaryLayerResistance


SUBROUTINE SUEWS_cal_RoughnessParameters(&
     RoughLenMomMethod,&! input:
     sfr,&! surface fractions
     bldgH,EveTreeH,DecTreeH,&
     porosity_id,FAIBldg,FAIEveTree,FAIDecTree,&
     z0m_in,zdm_in,Z,&
     planF,&! output:
     Zh,z0m,zdm,ZZD)
  ! Get surface covers and frontal area fractions (LJ 11/2010)
  ! Last modified:
  ! TS  18 Sep 2017 - added explicit interface
  ! HCW 08 Feb 2017 - fixed bug in Zh between grids, added default z0m, zdm
  ! HCW 03 Mar 2015
  ! sg feb 2012 - made separate subroutine
  !--------------------------------------------------------------------------------

  IMPLICIT NONE

  INTEGER,PARAMETER:: nsurf     = 7 ! number of surface types
  INTEGER,PARAMETER:: PavSurf   = 1 !When all surfaces considered together (1-7)
  INTEGER,PARAMETER:: BldgSurf  = 2
  INTEGER,PARAMETER:: ConifSurf = 3
  INTEGER,PARAMETER:: DecidSurf = 4
  INTEGER,PARAMETER:: GrassSurf = 5 !New surface classes: Grass = 5th/7 surfaces
  INTEGER,PARAMETER:: BSoilSurf = 6 !New surface classes: Bare soil = 6th/7 surfaces
  INTEGER,PARAMETER:: WaterSurf = 7

  INTEGER, INTENT(in) ::RoughLenMomMethod

  REAL(KIND(1d0)), DIMENSION(nsurf),INTENT(in) ::sfr! surface fractions


  REAL(KIND(1d0)), INTENT(in) ::bldgH
  REAL(KIND(1d0)), INTENT(in) ::EveTreeH
  REAL(KIND(1d0)), INTENT(in) ::DecTreeH
  REAL(KIND(1d0)), INTENT(in) ::porosity_id
  REAL(KIND(1d0)), INTENT(in) ::FAIBldg
  REAL(KIND(1d0)), INTENT(in) ::FAIEveTree
  REAL(KIND(1d0)), INTENT(in) ::FAIDecTree
  REAL(KIND(1d0)), INTENT(in) ::z0m_in ! z0m set in SiteSelect
  REAL(KIND(1d0)), INTENT(in) ::zdm_in ! zdm set in SiteSelect
  REAL(KIND(1d0)), INTENT(in) ::Z

  REAL(KIND(1d0)), INTENT(out) ::planF
  REAL(KIND(1d0)), INTENT(out) ::Zh
  REAL(KIND(1d0)), INTENT(out) ::z0m
  REAL(KIND(1d0)), INTENT(out) ::zdm
  REAL(KIND(1d0)), INTENT(out) ::ZZD



  REAL(KIND(1d0)) ::areaZh
  INTEGER, PARAMETER :: notUsedI=-55
  REAL(KIND(1d0)),PARAMETER:: notUsed=-55.5
  REAL(KIND(1D0)):: z0m4Paved,z0m4Grass,z0m4BSoil,z0m4Water   !Default values for roughness lengths [m]

  areaZh =(sfr(BldgSurf)+sfr(ConifSurf)+sfr(DecidSurf)) !Total area of buildings and trees

  ! Set default values (using Moene & van Dam 2013, Atmos-Veg-Soil Interactions, Table 3.3)
  Z0m4Paved = 0.003 !estimate
  Z0m4Grass = 0.02
  Z0m4BSoil = 0.002
  Z0m4Water = 0.0005

  !------------------------------------------------------------------------------
  !If total area of buildings and trees is larger than zero, use tree heights and building heights to calculate zH
  IF (areaZh/=0) THEN
     Zh=bldgH*sfr(BldgSurf)/areaZh + EveTreeH*sfr(ConifSurf)/areaZh + DecTreeH*(1-porosity_id)*sfr(DecidSurf)/areaZh
  ELSE
     Zh=0   !Set Zh to zero if areaZh = 0
  ENDIF

  IF(Zh/=0)THEN
     !Calculate z0m and zdm depending on the Z0 method
     IF(RoughLenMomMethod==2) THEN  !Rule of thumb (G&O 1999)
        z0m=0.1*Zh
        zdm=0.7*Zh
     ELSEIF(RoughLenMomMethod==3)THEN !MacDonald 1998
        IF (areaZh/=0)THEN  !Plan area fraction
           !planF=FAIBldg*sfr(BldgSurf)/areaZh+FAItree*sfr(ConifSurf)/areaZh+FAItree*(1-porosity_id)*sfr(DecidSurf)/areaZh
           planF=FAIBldg*sfr(BldgSurf)/areaZh + FAIEveTree*sfr(ConifSurf)/areaZh + FAIDecTree*(1-porosity_id)*sfr(DecidSurf)/areaZh
        ELSE
           planF=0.00001
           Zh=1
        ENDIF
        zdm=(1+4.43**(-sfr(BldgSurf))*(sfr(BldgSurf)-1))*Zh
        z0m=((1-zdm/Zh)*EXP(-(0.5*1.0*1.2/0.4**2*(1-zdm/Zh)*planF)**(-0.5)))*Zh
     ENDIF
  ELSEIF(Zh==0)THEN   !If zh calculated to be zero, set default roughness length and displacement height
     IF(areaZh /= 0) CALL ErrorHint(15,'In SUEWS_RoughnessParameters.f95, zh = 0 m but areaZh > 0',zh,areaZh,notUsedI)
     !Estimate z0 and zd using default values and surfaces that do not contribute to areaZh
     IF(areaZh /= 1)THEN
        z0m = (z0m4Paved*sfr(PavSurf) + z0m4Grass*sfr(GrassSurf) + z0m4BSoil*sfr(BSoilSurf) + z0m4Water*sfr(WaterSurf))/(1-areaZh)
        zdm = 0
        CALL ErrorHint(15,'Setting z0m and zdm using default values',z0m,zdm,notUsedI)
     ELSEIF(areaZh==1)THEN  !If, for some reason, Zh = 0 and areaZh == 1, assume height of 10 m and use rule-of-thumb
        z0m = 1
        zdm = 7
        CALL ErrorHint(15,'Assuming mean height = 10 m, Setting z0m and zdm to default value',z0m,zdm,notUsedI)
     ENDIF
  ENDIF

  IF(RoughLenMomMethod==1) THEN  !use values set in SiteSelect
     z0m = z0m_in
     zdm = zdm_in
  ENDIF

  ZZD=Z-zdm

  ! Error messages if aerodynamic parameters negative
  IF(z0m<0) CALL ErrorHint(14,'In SUEWS_cal_RoughnessParameters, z0 < 0 m.',z0m,notUsed,notUsedI)
  IF(zdm<0) CALL ErrorHint(14,'In SUEWS_cal_RoughnessParameters, zd < 0 m.',zdm,notUsed,notUsedI)
  IF(zzd<0) CALL ErrorHint(14,'In SUEWS_cal_RoughnessParameters, (z-zd) < 0 m.',zzd,notUsed,notUsedI)
END SUBROUTINE SUEWS_cal_RoughnessParameters



FUNCTION cal_z0V(RoughLenHeatMethod,z0m,VegFraction,UStar) RESULT(z0V)
  ! TS 31 Jul 2018: make this a separate funciton for reuse
  !Z0V roughness length for vapour
  IMPLICIT NONE
  INTEGER,INTENT(in)::RoughLenHeatMethod
  REAL(KIND(1d0)),INTENT(in)::z0m!Aerodynamic roughness length
  REAL(KIND(1d0)),INTENT(in)::VegFraction!Fraction of vegetation
  REAL(KIND(1d0)),INTENT(in)::UStar!Friction velocity

  REAL(KIND(1d0))::z0V!Friction velocity


  REAL(KIND(1d0)),PARAMETER:: muu=1.46e-5 !molecular viscosity


  !Z0V roughness length for vapour
  IF (RoughLenHeatMethod==1) THEN !Brutasert (1982) Z0v=z0/10(see Grimmond & Oke, 1986)
     z0V=z0m/10
  ELSEIF (RoughLenHeatMethod==2) THEN ! Kawai et al. (2007)
     !z0V=z0m*exp(2-(1.2-0.9*veg_fr**0.29)*(UStar*z0m/muu)**0.25)
     ! Changed by HCW 05 Nov 2015 (veg_fr includes water; VegFraction = veg + bare soil)
     z0V=z0m*EXP(2-(1.2-0.9*VegFraction**0.29)*(UStar*z0m/muu)**0.25)
  ELSEIF (RoughLenHeatMethod==3) THEN
     z0V=z0m*EXP(-20.) ! Voogt and Grimmond, JAM, 2000
  ELSEIF (RoughLenHeatMethod==4) THEN
     z0V=z0m*EXP(2-1.29*(UStar*z0m/muu)**0.25) !See !Kanda and Moriwaki (2007),Loridan et al. (2010)
  ENDIF

END FUNCTION cal_z0v

SUBROUTINE ErrorHint(errh,ProblemFile,VALUE,value2,valueI)
  !errh        -- Create a numbered code for the situation so get a unique message to help solve the problem
  !ProblemFile -- Filename where the problem occurs/error message
  !value       -- Error value (real number with correct type)
  !value2      -- Second error value (real number with correct type)
  !valueI      -- Error value (integer)
  ! Last modified -----------------------------------------------------
  ! MH  12 Apr 2017: Error code for stability added
  ! HCW 17 Feb 2017: Write (serious) errors to problems.txt; write warnings to warnings.txt (program continues)
  ! HCW 13 Dec 2016: Tidied up and improved error hints
  ! HCW 25 May 2016: Added warning/error labels to distinguish serious errors (that stop program)
  ! LJ  02 Oct 2014: addition of comments
  ! sg  29 Jul 2014: close (500)
  ! LJ  08 Feb 2013
  !--------------------------------------------------------------------

  USE data_in
  USE defaultNotUsed
  ! USE WhereWhen

  IMPLICIT NONE

  REAL(KIND(1d0)):: VALUE,value2

  CHARACTER (len=*)::ProblemFile                 ! Name of the problem file
  CHARACTER (len=150)::text1                      ! Initialization of text
  CHARACTER (len=20)::filename                  !file name for writting out error info
  INTEGER:: errh,ValueI,ValueI2                  ! v7,v8 initialised as false, HCW 28/10/2014
  INTEGER,DIMENSION(80):: ErrhCount = 0             ! Counts each time a error hint is called. Initialise to zero
  ! INTEGER:: WhichFile                            ! Used to switch between 500 for error file, 501 for warnings file
  CHARACTER(len=1024) :: message ! Used to pass through function wrf_debug() by Zhenkun Li, 10/08/2018
  CHARACTER(len=1024) :: Errmessage

  ! TS 16 Jul 2018:
  ! these LOGICAL values should NOT be initialised as `SAVE` is implied
  ! which will cause cross-assignment in parallel mode and thus subsequent unintentional STOP
  LOGICAL:: v1,v2,v3,v4,v5,v6,v7,v8
  LOGICAL:: returnTrue

  text1='unknown problem' ! Initialization of text
  ! WhichFile = 0 ! Initialization of file code

  ! Initialise returnTrue as false (HCW 29/10/2014)
  ! - need to do this in Fortran as values assigned in declarations are not applied
  ! on subsequent calling of the subroutine
  returnTrue=.FALSE.
  ! Initialise v1-v8 as false
  v1=.FALSE.
  v2=.FALSE.
  v3=.FALSE.
  v4=.FALSE.
  v5=.FALSE.
  v6=.FALSE.
  v7=.FALSE.
  v8=.FALSE.



  !CALL gen_ProblemsText(ProblemFile)   !Call the subroutine that opens the problem.txt file !Moved below, HCW 17 Feb 2017

  !The list of knows possible problems of the code:
  !  text1 is the error message written to the ProblemFile.
  !  v1 -v7 are different possibilities for what numbers will be written out
  !  ReturnTrue is true if the model run can continue. (Comment modified by HCW 17/10/2014)
  IF(errh==1)THEN
     text1='Check value in SUEWS_SiteSelect.txt.'
     v5=.TRUE.
  ELSEIF(errh==2) THEN
     text1='Cannot perform disaggregation.'
     v6=.TRUE.
  ELSEIF(errh==3) THEN
     text1='Met forcing file should contain only 1 year of data.'
     v1=.TRUE.
  ELSEIF(errh==4) THEN
     text1='Rainfall in original met forcing file exceeds intensity threshold.'
     v2=.TRUE.
     returnTrue=.TRUE.
     !5
  ELSEIF(errh==6) THEN
     text1='Value obtained exceeds permitted range, setting to +/-9999 in output file.'
     v1=.TRUE.
     returnTrue=.TRUE.
  ELSEIF(errh==7) THEN
     text1='RA value obtained exceeds permitted range.'
     v1=.TRUE.
     returnTrue=.TRUE.
  ELSEIF(errh==8) THEN
     text1='Check values in SUEWS_WithinGridWaterDist.txt.'
     v1=.TRUE.
  ELSEIF(errh==9) THEN
     text1= 'Check ToRunoff and ToSoilStore values in SUEWS_WithinGridWaterDist.txt.'
     v2=.TRUE.
  ELSEIF(errh==10) THEN
     text1='Check values in SUEWS_SiteSelect.txt.'
     v1=.TRUE.
  ELSEIF(errh==11) THEN
     text1='File not found.'
     v3=.TRUE.
     ! 12
  ELSEIF(errh==13) THEN
     text1='Check met forcing file.'
     v8=.TRUE.
  ELSEIF(errh==14) THEN
     text1= 'Inappropriate value calculated.'
     v1=.TRUE.
  ELSEIF(errh==15) THEN
     text1= 'Check H_Bldgs, H_EveTr and H_DecTr in SUEWS_SiteSelect.txt'
     v2=.TRUE.
     returnTrue=.TRUE.
     ! 16
  ELSEIF(errh==17) THEN
     text1= 'Problem with (z-zd) and/or z0.'
     v2=.TRUE.
  ELSEIF(errh==18) THEN
     text1='Check soil depth relative to soil moisture and capacity.'
     v4=.TRUE.
  ELSEIF(errh==19)THEN
     text1='Caution - check range.'
     v4=.TRUE.
     returnTrue=.TRUE.
  ELSEIF(errh==20)THEN
     text1=' skip lines, ios_out.'
     v5=.TRUE.
  ELSEIF(errh==21)THEN
     text1='Bad input for OHM/AnOHM storage heat flux calculation. Check qn, qn_Sn, qf for issues.'
     v1=.TRUE.
  ELSEIF(errh==22)THEN
     text1=' QH_observed, QE_observed, QH_choice: '
     v4=.TRUE.
  ELSEIF(errh==23)THEN
     text1='CBL-sonde -need to increase size of izm:zmax,izm'
     v5=.TRUE.
  ELSEIF(errh==24) THEN
     text1='CBL file problem - opening'
     v8=.TRUE.
  ELSEIF(errh==25) THEN
     text1='CBL file problem -- reading sonde data, line:'
     v3=.TRUE.
  ELSEIF(errh==26) THEN
     text1='Check that FileCode, FileInputPath and FileOutputPath are specified correctly in RunControl.nml.'
     v8=.TRUE.
  ELSEIF(errh==27)THEN
     text1='Problems with Met data -forcing data: variable value, dectime'
     v2=.TRUE.  ! 2 real
  ELSEIF(errh==28) THEN
     text1='Processing in subroutine indicated has a problem, variables'
     returntrue=.TRUE.
     v3=.TRUE.  ! 1 integer
  ELSEIF(errh==29) THEN
     text1='Processing in subroutine indicated has a problem, time, variables'
     returntrue=.TRUE.
     v7=.TRUE.  ! 1 real, 2 integers
  ELSEIF(errh==30) THEN
     text1='Processing in subroutine indicated has a problem, time, variables'
     ! returntrue=.TRUE.
     v2=.TRUE.  ! 2 real
  ELSEIF(errh==31) THEN
     text1='Processing in subroutine indicated has a problem, time, variables'
     returntrue=.TRUE.
     v1=.TRUE.  ! 1 real
  ELSEIF(errh==32) THEN
     text1='Model applicable to local scale, z<z0d'
     v2=.TRUE.  ! 2 real
  ELSEIF(errh==33) THEN
     text1 = 'Number of snow layers too large.'
     v1=.TRUE.  ! 1 real
  ELSEIF(errh==34) THEN
     text1= 'Air temperature > 55 C -- will keep running'
     v1=.TRUE.  ! 1 real
     returntrue=.TRUE.
  ELSEIF(errh==35) THEN
     text1 = 'Problems with Met data -forcing data: doy, dectime'
     v2 = .TRUE.  ! 2 real
  ELSEIF(errh==36) THEN
     text1 = 'Problem found in InitialConditions file!'
     v8 = .TRUE.
  ELSEIF(errh==37) THEN
     text1 = 'Check inputs in InitialConditions file!'
     returntrue=.TRUE.
     v2 = .TRUE.  !2 real
  ELSEIF(errh==38) THEN
     text1 = 'H=(qn*0.2)/(avdens*avcp)'
     returntrue=.TRUE.
     v1 = .TRUE.  !2 real
  ELSEIF(errh==39) THEN
     text1 = 'Different value of TSTEP needed (300 s recommended). Resolution of forcing data must match TSTEP set in RunControl.'
     v4 = .TRUE.  !2 real, 1 int
  ELSEIF(errh==40) THEN
     text1='SOLWEIG file problem - opening'
     v8=.TRUE.
  ELSEIF(errh==41) THEN
     text1= ' addwaterbody= Error1-- but watersurf=  Error 2'
     v2=.TRUE. !2 real
  ELSEIF(errh==42)THEN
     text1= 'abs(rho_d)<0.001000.OR.abs(rho_v)<0.001000.OR.abs(rho_d+rho_v)<0.001000) rho_v,rho_d, T'
     returntrue=.TRUE.
     v4=.TRUE. !2 real, temperature as an integer
  ELSEIF(errh==43) THEN
     text1='Switching Years - will keep running'
     returntrue=.TRUE.
     v8=.TRUE.
  ELSEIF(errh==44)THEN
     text1='Initial File Name - will keep going'
     returntrue=.TRUE.
     v8=.TRUE.
  ELSEIF(errh==45)THEN
     text1='Pressure < 900 hPa, Loop Number'
     returntrue=.TRUE.
     v5 = .TRUE.
  ELSEIF(errh==46)THEN
     text1 = 'Pressure < 900 hPa'
     returntrue = .TRUE.
     v1 = .TRUE.
  ELSEIF(errh==47)THEN
     text1 = 'File missing'
     !returntrue = .TRUE.
  ELSEIF(errh==48)THEN
     text1 = 'Something wrong in the rows of the file'
     !returntrue = .TRUE.
  ELSEIF(errh==49)THEN
     text1 = 'Problems in saving to InitialConditionsYYYY.nml'
  ELSEIF(errh==50)THEN
     text1 = 'Wrong number of lines read: nsurf, [-1 EOF; -2 EOR]'
     v1 = .TRUE.
  ELSEIF(errh==51)THEN
     text1 = 'Problems in opening the file'
     WRITE(*,*) ProblemFile
  ELSEIF(errh==52)THEN
     text1 = 'Problems opening the output file.'
  ELSEIF(errh==53)THEN
     text1 = 'AH_min=0.and.Ah_slope=0.and.T_Critic=0, AnthropHeatMethod='
     returntrue = .TRUE.
     v3 = .TRUE.
  ELSEIF(errh==54)THEN
     text1 = 'QF_A=0.and.QF_B=0.and.QF_C=0, AnthropHeatMethod='
     returntrue = .TRUE.
     v3 = .TRUE.
  ELSEIF(errh==55)THEN
     text1 = 'InputmetFormat='
     returntrue = .TRUE.
     v3 = .TRUE.
  ELSEIF(errh==56)THEN
     text1 = 'Check input files against manual (N.B. Case sensitive).'
     v8 = .TRUE.
  ELSEIF(errh==57)THEN
     text1 = 'not found. Check input files.'
     v1 = .TRUE.
  ELSEIF(errh==58)THEN
     text1 = 'File header not specified in model code.'
     v8 = .TRUE.
  ELSEIF(errh==59)THEN
     text1 = 'not found. Check SUEWS_SiteSelect.txt.'
     v6 = .TRUE.
  ELSEIF(errh==60)THEN
     text1 = 'non-unique code.'
     v1 = .TRUE.
  ELSEIF(errh==61)THEN
     text1 = 'Check coefficients and drainage equation specified in input files.'
     v4 = .TRUE.
     returntrue = .TRUE.
  ELSEIF(errh==62)THEN
     text1 = 'Problem with soil moisture calculation.'
     v5 = .TRUE.
  ELSEIF(errh==63)THEN
     text1 = 'Problem with calculation.'
     v1 = .TRUE.
  ELSEIF(errh==64)THEN
     text1 = 'SUEWS cannot currently handle this many grids.'
     v6 = .TRUE.
  ELSEIF(errh==65) THEN
     text1='Negative gs calculated! Check suitability of parameters in SUEWS_Conductance.txt.'
     returntrue=.TRUE.
     v7=.TRUE.  ! 1 real, 2 integers
  ELSEIF(errh==66)THEN
     text1 = 'Different number of lines in ESTM forcing and Met forcing files.'
     v6 = .TRUE.
  ELSEIF(errh==67) THEN
     text1='ESTMClass1 automatically set to 100%.'
     returntrue=.TRUE.
     v1=.TRUE.
  ELSEIF(errh==68) THEN
     text1='Initial Bowen ratio automatically set to 1.'
     returntrue=.TRUE.
     v1=.TRUE.
  ELSEIF(errh==69) THEN
     text1='Setting QF_traff to zero. Check input data.'
     returntrue=.TRUE.
     v2=.TRUE.
  ELSEIF(errh==70) THEN
     text1='Specify profile values between 1 (night) and 2 (day).'
     v8=.TRUE.
  ELSEIF(errh==71) THEN
     text1='Check input file SUEWS_Conductance.txt.'
     v3=.TRUE.
  ELSEIF(errh==72) THEN
     text1='RunControl.nml: ResolutionFilesOut must be an integer multiple of TSTEP'
     v6=.TRUE.
  ELSEIF(errh==73) THEN
     text1='Iteration loop stopped for too stable conditions.'
     ! returnTrue=.TRUE.
     v2=.TRUE.
  ELSEIF(errh==74) THEN
     text1='Iteration loop stopped for too unstable conditions.'
     ! returnTrue=.TRUE.
     v2=.TRUE.
  ENDIF

  ErrhCount(errh) = ErrhCount(errh) + 1   ! Increase error count by 1
  ! PRINT*, 'returnTrue',returnTrue

  !---------------------------------------------------------------------
  !This part of the code determines how the error/warning message is written out
  IF(v1) THEN ! 1 real
     WRITE(Errmessage,'(a,f9.4)')' Value: ', VALUE
  ELSEIF(v2) THEN ! 2 real
     WRITE(Errmessage,'(a,2f9.4)')' Values: ', VALUE, value2
  ELSEIF(v3) THEN ! 1 integer
     WRITE(Errmessage,'(a,i10)')' Value: ', valueI
  ELSEIF(v4) THEN ! 2 real, 1 integer
     WRITE(Errmessage,'(a,2f9.4,i10)')' Values: ', VALUE, value2, valueI
  ELSEIF(v5) THEN ! 1 real 1 integer
     WRITE(Errmessage,'(a,f9.4,i10)')' Values: ', VALUE, valueI
  ELSEIF(v6) THEN ! 2 integer
     valueI2=INT(VALUE)
     WRITE(Errmessage,'(a,2i10)')' Values: ', valueI, valueI2
  ELSEIF(v7) THEN ! 1 real, 2 integer
     valueI2=INT(value2)
     WRITE(Errmessage,'(a,f9.4,2i10)')' Values: ', VALUE, valueI2, valueI
  ELSEIF(v8) THEN
     ! no error values
  ENDIF

  ! Write errors (that stop the program) to problems.txt; warnings to warnings.txt
  IF(returnTrue) THEN
     IF(SuppressWarnings==0) THEN
        WRITE(message,*)'Warning: ',TRIM(ProblemFile)
        CALL wrf_debug(100, message)
        WRITE(message,*) TRIM(text1)
        CALL wrf_debug(100, message)
        CALL wrf_debug(100, Errmessage)
        WRITE(message,'(a,i14)') ' Count: ',ErrhCount(errh)
        CALL wrf_debug(100, message)
     ENDIF

  ELSE

     WRITE(message,*)'Problem: ',TRIM(ProblemFile)
     CALL wrf_debug(100, message)
     WRITE(message,*)'ERROR! Program stopped: ',TRIM(text1)
     CALL wrf_debug(100, message)
     CALL wrf_debug(100, Errmessage)
     WRITE(message,'(i3)') errh
     CALL wrf_debug(100, message)
     WRITE(message,*) 'ERROR! SUEWS run stopped.'
     CALL wrf_debug(100, message)
     WRITE(message,*) 'fatal error in SUEWS:',TRIM(text1)
     CALL wrf_error_fatal ( message )
  ENDIF

END SUBROUTINE ErrorHint

!=============================================================

SUBROUTINE Evap_SUEWS(&
     EvapMethod,state_is,WetThresh_is,capStore_is,&!input
     numPM,s_hPa,psyc_hPa,ResistSurf,sp,RA,rb,tlv,&
     rss,ev,qe) !output
  !------------------------------------------------------------------------------
  !-Calculates evaporation for each surface from modified Penman-Monteith eqn
  !-State determines whether each surface type is dry or wet (wet/transition)
  !-Wet surfaces below storage capacity are in transition
  ! and QE depends on the state and storage capacity (i.e. varies with surface);
  ! for wet or dry surfaces QE does not vary between surface types
  !-See Sect 2.4 of Jarvi et al. (2011) Ja11
  !
  !Last modified:
  !  HCW 06 Jul 2016
  !   Moved rss declaration to LUMPS_Module_Constants so it can be written out
  !  HCW 11 Jun 2015
  !   Added WetThresh to distinguish wet/partially wet surfaces from the storage capacities used in SUEWS_drain
  !  HCW 30 Jan 2015
  !   Removed StorCap input because it is provided by module allocateArray
  !   Tidied and commented code
  !  LJ 10/2010
  !------------------------------------------------------------------------------

  IMPLICIT NONE
  INTEGER,INTENT(in) :: EvapMethod!Evaporation calculated according to Rutter (1) or Shuttleworth (2)

  REAL(KIND(1d0)),INTENT(in)::state_is ! wetness status
  REAL(KIND(1d0)),INTENT(in)::WetThresh_is!When State > WetThresh, RS=0 limit in SUEWS_evap [mm] (specified in input files)
  REAL(KIND(1d0)),INTENT(in)::capStore_is ! = StoreDrainPrm(6,is), current storage capacity [mm]
  REAL(KIND(1d0)),INTENT(in)::numPM!numerator of P-M eqn
  REAL(KIND(1d0)),INTENT(in)::s_hPa!Vapour pressure versus temperature slope in hPa
  REAL(KIND(1d0)),INTENT(in)::psyc_hPa!Psychometric constant in hPa
  REAL(KIND(1d0)),INTENT(in)::ResistSurf!Surface resistance
  REAL(KIND(1d0)),INTENT(in)::sp!Term in calculation of E
  REAL(KIND(1d0)),INTENT(in)::RA!Aerodynamic resistance
  REAL(KIND(1d0)),INTENT(in)::rb!Boundary layer resistance
  REAL(KIND(1d0)),INTENT(in)::tlv!Latent heat of vaporization per timestep [J kg-1 s-1], (tlv=lv_J_kg/tstep_real)

  REAL(KIND(1d0)),INTENT(out)::rss
  REAL(KIND(1d0)),INTENT(out)::ev
  REAL(KIND(1d0)),INTENT(out)::qe ! latent heat flux [W m-2]


  REAL(KIND(1d0))::rbsg  !Boundary-layer resistance x (slope/psychrometric const + 1) [s m-1]
  REAL(KIND(1d0))::rsrbsg  !RS + rbsg [s m-1]
  REAL(KIND(1d0))::rst
  REAL(KIND(1d0))::W  !Depends on the amount of water on the canopy [-]
  REAL(KIND(1d0))::x
  REAL(KIND(1d0))::r

  REAL(KIND(1d0)),PARAMETER::  NAN=-999

  ! Use Penman-Monteith eqn modified for urban areas (Eq6, Jarvi et al. 2011)
  ! Calculation independent of surface characteristics
  ! Uses value of RS for whole area (calculated based on LAI of veg surfaces in SUEWS_SurfaceResistance.f95)

  ! PRINT*, 'is',is,'SMOIS',state(is)
  ! PRINT*, 'SMOIS',state_is,state_is<=0.001
  ! PRINT*, 'EvapMethod',EvapMethod

  ! Dry surface ---------------------------------------------------------------
  IF(state_is<=0.001) THEN
     qe  = numPM/(s_hPa+psyc_hPa*(1+ResistSurf/RA))  !QE [W m-2] (numPM = numerator of P-M eqn)
     ev  = qe/tlv !Ev [mm] (qe[W m-2]/tlv[J kg-1 s-1]*1/density_water[1000 kg m-3])
     W   = NAN    !W not needed for dry surfaces (set to -999)
     rst = 1      !Set flag indicating dry surface(1)

     ! Wet surface ---------------------------------------------------------------
  ELSE
     rst=0   !Set flag=0 indicating wet surface(0)

     ! Evaporation calculated according to Rutter(EvapMethod=1) or Shuttleworth(EvapMethod=2).
     !Set in SUEWS_initial (so not an input to the model)
     IF(EvapMethod==2) THEN   !-- Shuttleworth (1978) --
        rbsg   = rb*(sp+1)           !Boundary-layer resistance x (slope/psychro + 1)
        rsrbsg = ResistSurf+rbsg   !RS + rsbg

        ! If surface is completely wet, set RS to zero -------------------
        !if(state(is)>=StoreDrainPrm(6,is).or.ResistSurf<25) then   !If at storage capacity or RS is small
        IF(state_is>=WetThresh_is.OR.ResistSurf<25) THEN   !If at storage capacity or RS is small
           W=1                                            !So that RS=0 (Eq7, Jarvi et al. 2011)
           ! If surface is in transition, use rss ---------------------------
        ELSE   !if((state(is)<StorCap).and.(state(is)>0.001).or.(ResistSurf<50)) then
           r = (ResistSurf/RA)*(RA-rb)/rsrbsg
           W = (r-1)/(r-(WetThresh_is/state_is))
        ENDIF

        ! PRINT*, 'r',r
        ! PRINT*, 'W',W

        rss=(1/((W/rbsg)+((1-W)/rsrbsg)))-rbsg !Redefined surface resistance for wet
        ! PRINT*, 'resistances:',rbsg,rsrbsg,rss
        !surfaces (zero if W=1). Eq7, Jarvi et al. (2011)
        qe = numPM/(s_hPa+psyc_hPa*(1+rss/RA))   !QE [W m-2]
        ev = qe/tlv                              !Ev [mm]
        ! PRINT*, 'numPM',numPM
        ! PRINT*, 'qe',qe

     ELSEIF(EvapMethod==1) THEN   !-- Rutter --
        qe = numPM/(s_hPa+psyc_hPa)
        ev = qe/tlv

        IF(state_is >= capStore_is) THEN
           x = 1.0
        ELSE
           x = state_is/capStore_is
        ENDIF
        ev = ev*x     !QE [W m-2]
        qe = ev*tlv   !Ev [mm]
     ENDIF   !Rutter/Shuttleworth calculation
  ENDIF   !Wet/dry surface



  ! IF ( id>190 ) THEN
  !    STOP "stop in Evap_SUEWS_new"
  !
  ! END IF
END SUBROUTINE Evap_SUEWS

!=========================================================================
! sg feb 2012
! only run once at start - fixed for all grids and all years

SUBROUTINE OverallRunControl
  ! Last modified:
  ! MH 21 Jun 2017 - Added anthropogenic CO2 parameters and changed AnthropogenicHeat to Anthropogenic
  ! MH 16 Jun 2017 - Added biogenic CO2 parameters
  ! HCW 21 Apr 2017 - Added new method for precip disaggregation
  ! HCW 13 Jan 2017 - Changes to RunControl and InitialConditions
  ! HCW 04 Nov 2016 - minor bug fix in LAImin/LAImax warnings related to 3 veg surface types out cf 7 surface types
  ! LJ 27 Jan 2016  - Removal of tabs, cleaning of the code
  ! HCW 06 Mar 2015 - Removed options 10,20,30 (NARPOutput) for NetRadiationMethod
  ! HCW 06 Feb 2015 - File ID numbers changed so they are unique
  ! HCW 19 Dec 2014
  ! To Do:
  !   - Holidays.txt input file needs to be read in and coded into model
  !  - Add column header checks for SiteSelect
  !-------------------------------------------------------------------------

  USE allocateArray
  USE ColNamesInputFiles
  USE data_in
  USE defaultNotUsed
  USE FileName
  USE initial
  USE gis_data
  USE mod_z
  USE resist
  USE snowMod
  USE sues_data
  USE time

  IMPLICIT NONE

  INTEGER:: iv,i,SkipCounter,iFile            !iv and i, ii are integers used in do loops
  CHARACTER(len=50):: FileN
  INTEGER, PARAMETER :: nFile = 13
  CHARACTER(len=50), DIMENSION(nFile) :: &
       FileNames = [CHARACTER(len=50) :: &
       'SUEWS_NonVeg.txt', 'SUEWS_Veg.txt', 'SUEWS_Water.txt', 'SUEWS_Snow.txt', &
       'SUEWS_Soil.txt', 'SUEWS_Conductance.txt', 'SUEWS_OHMCoefficients.txt', &
       'SUEWS_ESTMCoefficients.txt', 'SUEWS_AnthropogenicHeat.txt', 'SUEWS_Irrigation.txt', &
       'SUEWS_Profiles.txt', 'SUEWS_WithinGridWaterDist.txt', 'SUEWS_BiogenCO2.txt']

  ! ---- Namelist for RunControl.nml ----
  NAMELIST/RunControl/FileCode,&
       FileInputPath,&
       FileOutputPath,&
       Tstep,&
       MultipleMetFiles,&
       MultipleInitFiles,&
       MultipleESTMFiles,&
       KeepTstepFilesIn,&
       KeepTstepFilesOut,&
       WriteOutOption,&
       ResolutionFilesIn,&
       ResolutionFilesOut,&
       ResolutionFilesInESTM,&
       CBLuse,&
       SNOWuse,&
       SOLWEIGuse,&
       EmissionsMethod,&
       NetRadiationMethod,&
       RoughLenHeatMethod,&
       RoughLenMomMethod,&
       SMDMethod,&
       StabilityMethod,&
       StorageHeatMethod,&
       OHMIncQF,&
       WaterUseMethod,&
       DisaggMethod,&
       DisaggMethodESTM,&
       RainDisaggMethod,&
       RainAmongN,&
       MultRainAmongN,&
       MultRainAmongNUpperI,&
       KdownZen,&
       SuppressWarnings,&
       ncMode,&
       nRow,&
       nCol,&
       Diagnose,&
       DiagnoseDisagg,&
       DiagnoseDisaggESTM,&
       DiagQN,&
       DiagQS


  ! -------------------------------------

  !Initialise namelist with default values
  KeepTstepFilesIn = 0
  KeepTstepFilesOut = 0
  WriteOutOption = 0
  DisaggMethod = 1          ! linear disaggregation of averages
  DisaggMethodESTM = 1      ! linear disaggregation of averages
  RainDisaggMethod = 100    ! even distribution among all subintervals
  RainAmongN = -999         ! no default setting for number of rainy subintervals
  MultRainAmongN = -999     ! no default setting for number of rainy subintervals
  MultRainAmongNUpperI = -999   ! no default setting for rain intensity upper bound
  KdownZen = 1              ! use zenith angle by default

  SuppressWarnings=1        ! write warnings file
  ResolutionFilesIn=0       ! Set to zero so that if not found, automatically set to Tstep below

  ! Set Diagnose switch to off (0). If Diagnose = 1 is set in RunControl, model progress will be printed
  Diagnose = 0
  DiagnoseDisagg = 0
  DiagnoseDisaggESTM = 0
  DiagQN = 0
  DiagQS = 0

  FileCode='none'
  !smithFile='Smith1966.grd'

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  !Read in the RunControl.nml file
  OPEN(55,File='RunControl.nml',err=200,status='old') !Change with needs
  READ(55,nml=RunControl,err=201)
  CLOSE(55)

  ! set tstep_prev as tstep ! TS 04 Jul 2018
  ! tstep_prev is NOT used by SUEWS but by WRF-SUEWS through the main interface
  tstep_prev=tstep

  IF(Diagnose==1) WRITE(*,*) 'Diagnosis switched on (model progress will be printed to screen)...'

  !Check for problems with FileCode
  IF (FileCode=='none') CALL ErrorHint(26,TRIM("RunControl.nml FileCode is missing"),notUsed,notUsed,notUsedI)

  IF(ResolutionFilesIn==0) ResolutionFilesIn = Tstep   !If ResolutionFilesIn not found, automatically set to Tstep

  !-----------------------------------------------------------------------

  !Write RunControl information to FileChoices.txt
  FileChoices=TRIM(FileOutputPath)//TRIM(FileCode)//'_FileChoices.txt'
  OPEN (12,file=FileChoices,err=203)
  WRITE(12,*) '----- RunControl -----'
  WRITE(12,nml=RunControl)
  CLOSE(12)

  ! !Determine what should be done with respect to radiation
  ! ! TODO: this can be wrapped into a subroutine, TS 20 Oct 2017
  ! AlbedoChoice=0
  ! ldown_option=0
  ! IF(NetRadiationMethod==0)THEN    !Observed Q* from the met input file will be used
  !    IF(snowUse==1) THEN            !If snow is modelled, NARP is needed for surface temperature
  !       NetRadiationMethod=3000
  !       ldown_option=3              !Ldown will be modelled
  !       !NetRadiationMethod=NetRadiationMethod/1000
  !    ENDIF
  !
  ! ELSEIF(NetRadiationMethod>0)THEN  !Modelled Q* is used (NARP)
  !    AlbedoChoice=-9
  !    IF(NetRadiationMethod<10) THEN
  !       AlbedoChoice=0
  !       IF(NetRadiationMethod==1)ldown_option=1
  !       IF(NetRadiationMethod==2)ldown_option=2
  !       IF(NetRadiationMethod==3)ldown_option=3
  !
  !    ELSEIF(NetRadiationMethod>=100.AND.NetRadiationMethod<1000) THEN
  !       AlbedoChoice=1
  !       IF(NetRadiationMethod==100)ldown_option=1
  !       IF(NetRadiationMethod==200)ldown_option=2
  !       IF(NetRadiationMethod==300)ldown_option=3
  !       NetRadiationMethod=NetRadiationMethod/100
  !    ENDIF
  !
  !    !If bad NetRadiationMethod value
  !    IF(NetRadiationMethod>3.OR. AlbedoChoice==-9)THEN
  !       WRITE(*,*) 'NetRadiationMethod=',NetRadiationMethod
  !       WRITE(*,*) 'Value not usable'
  !       STOP
  !    ENDIF
  ! ENDIF

  ! Adjust input for precip downscaling using different intensities (HCW 21 Apr 2017)
  IF(RainDisaggMethod == 102) THEN
     DO i=1,5
        IF(MultRainAmongNUpperI(i) == -999) MultRainAmongNUpperI(i) = MAXVAL(MultRainAmongNUpperI)
     ENDDO
  ENDIF


  !------------------------------------------------------------------
  !Print run information on the screen
  WRITE(*,*)'--------------------------------------------------------'
  WRITE(*,*)"LUMPS/SUEWS - relevant references"
  WRITE(*,*)"LUMPS - Grimmond and Oke (2002) JAM, 41, 79-810"
  WRITE(*,*)"OHM - Grimmond and Oke (1999) JAM, 38, 922-940"
  WRITE(*,*)"NARP - Offerle et al. (2003) JAM"
  WRITE(*,*)"SUES - Evaporation Grimmond & Oke (1991) WRR"
  WRITE(*,*)"Water Balance Model Grimmond et al. (1986) WRR"
  WRITE(*,*)"NARP - Long wave improvements (Loridan et al. 2011 JAMC)"
  WRITE(*,*)"SUEWS - Anthropogenic heat, etc (Jarvi et al. 2011 JH)"
  WRITE(*,*)"SUEWS - Snow module included (Jarvi et al. 2014 GMD)"
  WRITE(*,*)"SUEWS - v2016a release (Ward et al. 2016 UC)"
  WRITE(*,*)'--------------------------------------------------------'


  !=======================================================================
  !======================== Read input files =============================
  ! This part reads the input files derived from the SiteInfo spreadsheet

  WRITE(*,*) 'Reading the following input files:'

  !=======================SUEWS_SiteSelect.txt============================
  FileN='SUEWS_SiteSelect.txt'
  CALL NumberRows(FileN,SkipHeaderSiteInfo)     !Find number of rows in input file
  nlinesSiteSelect=nlines
  ALLOCATE(SiteSelect(nlinesSiteSelect,ncolumnsSiteSelect))
  !Read input file
  OPEN(21,file=TRIM(FileInputPath)//TRIM(FileN),err=300,status='old')
  DO SkipCounter=1,(SkipHeaderSiteInfo-1)
     READ(21,*)   !Skip lines before header
  ENDDO
  READ(21,*) (HeaderSiteSelect_File(iv),iv=1,ncolumnsSiteSelect) !Get header

  DO i=1,nlinesSiteSelect
     READ(21,*) (SiteSelect(i,iv),iv=1,ncolumnsSiteSelect)
     !write(*,*) (SiteSelect(i,iv),iv=1,ncolumnsSiteSelect)
  ENDDO
  CLOSE(21)

  !call InputHeaderCheck(FileN) !! Need to add column checks for SiteSelect.txt

  ! FileNames = (/'SUEWS_NonVeg.txt', 'SUEWS_Veg.txt', 'SUEWS_Water.txt', 'SUEWS_Snow.txt', &
  !      'SUEWS_Soil.txt', 'SUEWS_Conductance.txt', 'SUEWS_OHMCoefficients.txt', &
  !      'SUEWS_ESTMCoefficients.txt', 'SUEWS_AnthropogenicHeat.txt', 'SUEWS_Irrigation.txt', &
  !      'SUEWS_Profiles.txt', 'SUEWS_WithinGridWaterDist.txt', 'SUEWS_BiogenCO2.txt'/)

  DO iFile = 1, nFile
     CALL NumberRows(FileNames(iFile), SkipHeaderSiteInfo)     !Find number of rows in input file
     SELECT CASE ( iFile )
     CASE ( 1 )
        nlinesNonVeg=nlines
        ALLOCATE(NonVeg_Coeff(nlinesNonVeg, ncolumnsNonVeg))
        CALL ReadCoeff(FileNames(iFile), nlinesNonVeg, ncolumnsNonVeg, HeaderNonVeg_File, NonVeg_Coeff)
     CASE ( 2 )
        nlinesVeg=nlines
        ALLOCATE(Veg_Coeff(nlinesVeg, ncolumnsVeg))
        CALL ReadCoeff(FileNames(iFile), nlinesVeg, ncolumnsVeg, HeaderVeg_File, Veg_Coeff)
     CASE ( 3 )
        nlinesWater=nlines
        ALLOCATE(Water_Coeff(nlinesWater, ncolumnsWater))
        CALL ReadCoeff(FileNames(iFile), nlinesWater, ncolumnsWater, HeaderWater_File, Water_Coeff)
     CASE ( 4 )
        nlinesSnow=nlines
        ALLOCATE(Snow_Coeff(nlinesSnow, ncolumnsSnow))
        CALL ReadCoeff(FileNames(iFile), nlinesSnow, ncolumnsSnow, HeaderSnow_File, Snow_Coeff)
     CASE ( 5 )
        nlinesSoil=nlines
        ALLOCATE(Soil_Coeff(nlinesSoil, ncolumnsSoil))
        CALL ReadCoeff(FileNames(iFile), nlinesSoil, ncolumnsSoil, HeaderSoil_File, Soil_Coeff)
     CASE ( 6 )
        nlinesConductance=nlines
        ALLOCATE(Conductance_Coeff(nlinesConductance, ncolumnsConductance))
        CALL ReadCoeff(FileNames(iFile), nlinesConductance, ncolumnsConductance, HeaderCond_File, Conductance_Coeff)
     CASE ( 7 )
        nlinesOHMCoefficients=nlines
        ALLOCATE(OHMCoefficients_Coeff(nlinesOHMCoefficients, ncolumnsOHMCoefficients))
        CALL ReadCoeff(FileNames(iFile), nlinesOHMCoefficients, ncolumnsOHMCoefficients, HeaderOHMCoefficients_File, &
             OHMCoefficients_Coeff)
     CASE ( 8 )
        nlinesESTMCoefficients=nlines
        ALLOCATE(ESTMCoefficients_Coeff(nlinesESTMCoefficients, ncolumnsESTMCoefficients))
        CALL ReadCoeff(FileNames(iFile), nlinesESTMCoefficients, ncolumnsESTMCoefficients, HeaderESTMCoefficients_File, &
             ESTMCoefficients_Coeff)
     CASE ( 9 )
        nlinesAnthropogenic=nlines
        ALLOCATE(Anthropogenic_Coeff(nlinesAnthropogenic, ncolumnsAnthropogenic))
        CALL ReadCoeff(FileNames(iFile), nlinesAnthropogenic, ncolumnsAnthropogenic, HeaderAnthropogenic_File, Anthropogenic_Coeff)
     CASE ( 10 )
        nlinesIrrigation=nlines
        ALLOCATE(Irrigation_Coeff(nlinesIrrigation, ncolumnsIrrigation))
        CALL ReadCoeff(FileNames(iFile), nlinesIrrigation, ncolumnsIrrigation, HeaderIrrigation_File, Irrigation_Coeff)
     CASE ( 11 )
        nlinesProfiles=nlines
        ALLOCATE(Profiles_Coeff(nlinesProfiles, ncolumnsProfiles))
        CALL ReadCoeff(FileNames(iFile), nlinesProfiles, ncolumnsProfiles, HeaderProfiles_File, Profiles_Coeff)
     CASE ( 12 )
        nlinesWGWaterDist=nlines
        ALLOCATE(WGWaterDist_Coeff(nlinesWGWaterDist, ncolumnsWGWaterDist))
        CALL ReadCoeff(FileNames(iFile), nlinesWGWaterDist, ncolumnsWGWaterDist, HeaderWGWaterDist_File, WGWaterDist_Coeff)
     CASE ( 13 )
        nlinesBiogen=nlines
        ALLOCATE(Biogen_Coeff(nlinesBiogen, ncolumnsBiogen))
        CALL ReadCoeff(FileNames(iFile), nlinesBiogen, ncolumnsBiogen, HeaderBiogen_File, Biogen_Coeff)
     END SELECT
  END DO

  !=======================================================================
  !=======================================================================

  !-----------------------------------------------------------------------
  !SUEWS run information
  InputMetFormat=10    !Input met data file in LUMPS format(1) or SUEWS format(10)
  LAICalcYes=1         !Use observed(0) or modelled(1) LAI
  EvapMethod=2                !Evaporation calculated according to Rutter(1) or Shuttleworth(2)
  WriteDailyState = 1  !Daily state file written
  tstepcount=0

  t_INTERVAL = 3600   !Number of seconds in an hour

  !Calculate nsh (number of steps per hour) from model timestep (tstep) set in in RunControl
  nsh_real = t_INTERVAL/REAL(tstep,KIND(1d0))

  ! Check nsh is an integer
  IF(nsh_real==INT(nsh_real)) THEN
     nsh = INT(nsh_real)
  ELSE
     CALL ErrorHint(39,'TSTEP must divide into t_INTERVAL exactly.',REAL(tstep,KIND(1d0)),REAL(t_INTERVAL,KIND(1d0)),notUsedI)
  ENDIF

  ! Check nsh is reasonable
  IF(nsh_real<6.OR.nsh_real>60) THEN
     CALL ErrorHint(39,'TSTEP is too small or too large.',REAL(tstep,KIND(1d0)),REAL(t_INTERVAL,KIND(1d0)),notUsedI)
  ENDIF

  ! Cast integer nsh as nsh_real for use in calculations
  nsh_real = REAL(nsh,KIND(1d0))
  ! Cast integer tstep as tstep_real for use in calculations
  tstep_real = REAL(tstep,KIND(1d0))
  ! get integer nsd from nsh for use in AnOHM checking, 20160708 TS
  nsd=24*nsh

  !! Check this is still valid for v2016a
  HalfTimeStep=REAL(tstep_real)/2/(24*3600)   !Used in NARP_cal_SunPosition to get sunpos in the middle of timestep

  RETURN

  !-------Possible problems-----------------------------------------------
200 CALL ErrorHint(47,'RunControl.nml',notUsed,notUsed,notUsedI)
201 CALL ErrorHint(48,'RunControl.nml',notUsed,notUsed,notUsedI)

203 CALL ErrorHint(47,TRIM(FileChoices),notUsed,notUsed,notUsedI)

300 CALL ErrorHint(48,TRIM(FileN),notUsed,notUsed,notUsedI)
  !-----------------------------------------------------------------------

  !pause

END SUBROUTINE OverallRunControl
!=========================================================================

SUBROUTINE ReadCoeff(FileName, nlines, ncolumns, HeaderFile, Coeff)

  USE data_in
  USE defaultNotUsed

  IMPLICIT NONE
  !----------------------------------------------------------------------
  ! dummy arguments
  !----------------------------------------------------------------------
  CHARACTER(len=*), INTENT(in)  :: FileName
  INTEGER, INTENT(in)           :: nlines, ncolumns
  CHARACTER(len=*), INTENT(out) :: HeaderFile(ncolumns)
  REAL(KIND(1d0)), INTENT(out)  :: Coeff(nlines, ncolumns)

  !----------------------------------------------------------------------
  ! local variables
  !----------------------------------------------------------------------
  INTEGER ::  SkipCounter, iv, i, ii

  !Read input file
  OPEN(22, file=TRIM(FileInputPath)//TRIM(FileName), err=301, status='old')

  DO SkipCounter = 1, SkipHeaderSiteInfo-1
     READ(22, *)   !Skip lines before header
  ENDDO
  READ(22, *) (HeaderFile(iv), iv = 1, ncolumns) !Get header

  DO i = 1, nlines
     READ(22, *) (Coeff(i,iv), iv = 1, ncolumns)
     !write(*,*) (NonVeg_Coeff(i,iv),iv=1,ncolumnsNonVeg)
  ENDDO
  CLOSE(22)

  CALL InputHeaderCheck(FileName)

  ! Check codes are unique
  DO i = 1, nlines
     DO ii = i+1, nlines
        IF(Coeff(i, 1) == Coeff(ii, 1) .AND. i /= ii) THEN
           WRITE(*, *) 'Code', Coeff(i, 1), 'in ', TRIM(FileName), ' not unique!'
           CALL ErrorHint(60, FileName, Coeff(i, 1), notUsed, notUsedI)
        ENDIF
     ENDDO
  ENDDO

  RETURN

301 CALL ErrorHint(48, TRIM(FileName), notUsed, notUsed, notUsedI)

END SUBROUTINE ReadCoeff

!=========================================================================
!This subroutine finds the number of rows in each input file
!INPUT: FileN          Name of the input file
!       SkipHeaderLines   Number of header rows to skip
!Made by LJ/HCW in Oct 2014

SUBROUTINE NumberRows(FileN,SkipHeaderLines)

  USE data_in
  USE DefaultNotUsed
  USE Initial

  IMPLICIT NONE

  CHARACTER(len=50):: FileN
  INTEGER:: SkipHeaderLines, RunNumber
  INTEGER:: SkipCounter
  INTEGER:: ios

  WRITE(*,*) FileN
  OPEN(39,file=TRIM(FileInputPath)//TRIM(FileN),err=204,status='old')

  IF(SkipHeaderLines > 0) THEN
     DO SkipCounter=1,SkipHeaderLines
        READ(39,*,err=205)
        !write(*,*) SkipCounter, SkipHeaderLines
     ENDDO
  ENDIF

  nlines = 0 !Initialize nlines
  DO
     READ(39,*, iostat=ios) RunNumber
     IF(ios<0 .OR. RunNumber == -9) EXIT   !IF(RunNumber==-9) EXIT
     nlines = nlines + 1
  END DO
  !write(*,*) 'nlines read: ',nlines
  CLOSE(39)

  RETURN

204 CALL ErrorHint(47,TRIM(FileInputPath)//TRIM(FileN),notUsed,notUsed,notUsedI)
205 CALL ErrorHint(48,TRIM(FileInputPath)//TRIM(FileN),notUsed,notUsed,notUsedI)

END SUBROUTINE NumberRows
!=========================================================================


!----------------------------------------------------------------------------------------------
!Moves input information corresponding to row rr of SiteSelect into row Gridiv of SurfaceChar
! - currently done once per year for each grid
!Made by HW&LJ Oct 2014.
!Last modified: HCW 26 Jan 2015
! Interpolated hourly energy use profiles to resolution of model timestep.
! Interpolated hourly water use profiles to resolution of model timestep.
! Normalised energy use & water use profiles as required.
! Hourly snow clearing profile is a 0-1 switch, and thus is not interpolated nor normalised.
!  - TODO: Rename profiles 1-24 rather than 0-23?
!----------------------------------------------------------------------------------------------
SUBROUTINE InitializeSurfaceCharacteristics(Gridiv,rr)

  USE allocateArray
  USE ColNamesInputFiles
  USE data_in
  USE defaultNotUsed
  USE Initial
  USE sues_data

  IMPLICIT NONE

  INTEGER:: Gridiv,&    !Row of SurfaceChar where input information will be stored
       rr          !Row of SiteSelect that matches current grid and year
  INTEGER:: iii, &
       ii

  !-------------------------------------------------------------------------------------------

  ! Initialise row of SurfaceChar
  SurfaceChar(Gridiv,:) = -999

  ! Transfer data in SiteSelect to SurfaceChar
  SurfaceChar(Gridiv,1:ncolumnsSiteSelect) = SiteSelect(rr,1:ncolumnsSiteSelect) !Cols in same order as in SiteSelect.txt

  ! ======== Retrieve information from other input files via codes ========

  ! ---- Find code for Paved surface (Impervious) ----
  CALL CodeMatchNonVeg(rr,c_PavedCode)
  ! Transfer characteristics to SurfaceChar for Paved surface
  SurfaceChar(gridiv,c_AlbMin(PavSurf))       = NonVeg_Coeff(iv5,ci_AlbMin)
  SurfaceChar(gridiv,c_AlbMax(PavSurf))       = NonVeg_Coeff(iv5,ci_AlbMax)
  SurfaceChar(gridiv,c_Emis(PavSurf))         = NonVeg_Coeff(iv5,ci_Emis)
  SurfaceChar(gridiv,c_StorMin(PavSurf))      = NonVeg_Coeff(iv5,ci_StorMin)
  SurfaceChar(gridiv,c_StorMax(PavSurf))      = NonVeg_Coeff(iv5,ci_StorMax)
  SurfaceChar(gridiv,c_WetThresh(PavSurf))    = NonVeg_Coeff(iv5,ci_WetThresh)
  SurfaceChar(gridiv,c_StateLimit(PavSurf))   = NonVeg_Coeff(iv5,ci_StateLimit)
  SurfaceChar(gridiv,c_DrEq(PavSurf))         = NonVeg_Coeff(iv5,ci_DrEq)
  SurfaceChar(gridiv,c_DrCoef1(PavSurf))      = NonVeg_Coeff(iv5,ci_DrCoef1)
  SurfaceChar(gridiv,c_DrCoef2(PavSurf))      = NonVeg_Coeff(iv5,ci_DrCoef2)
  SurfaceChar(gridiv,c_SoilTCode(PavSurf))    = NonVeg_Coeff(iv5,ci_SoilTCode)
  SurfaceChar(gridiv,c_SnowLimPat(PavSurf))   = NonVeg_Coeff(iv5,ci_SnowLimPat)
  SurfaceChar(gridiv,c_SnowLimRem(PavSurf))   = NonVeg_Coeff(iv5,ci_SnowLimRem)
  SurfaceChar(gridiv,c_OHMCode_SWet(PavSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(PavSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(PavSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(PavSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(PavSurf)) = NonVeg_Coeff(iv5,ci_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(PavSurf)) = NonVeg_Coeff(iv5,ci_OHMThresh_WD)
  SurfaceChar(gridiv,c_ESTMCode(PavSurf))     = NonVeg_Coeff(iv5,ci_ESTMCode)
  SurfaceChar(Gridiv,c_CpAnOHM(PavSurf))           = NonVeg_Coeff(iv5,ci_CpAnOHM)   ! heat capacity, AnOHM TS
  SurfaceChar(Gridiv,c_KkAnOHM(PavSurf))           = NonVeg_Coeff(iv5,ci_KkAnOHM)  ! heat conductivity, AnOHM TS
  SurfaceChar(Gridiv,c_ChAnOHM(PavSurf))           = NonVeg_Coeff(iv5,ci_ChAnOHM)  ! bulk transfer coef., AnOHM TS

  ! Use SoilCode for Paved to find code for soil characteristics
  CALL CodeMatchSoil(Gridiv,c_SoilTCode(PavSurf))
  ! Transfer soil characteristics to SurfaceChar
  SurfaceChar(gridiv,c_SoilDepth(PavSurf))    = Soil_Coeff(iv5,cSo_SoilDepth)
  SurfaceChar(gridiv,c_SoilStCap(PavSurf))    = Soil_Coeff(iv5,cSo_SoilStCap)
  SurfaceChar(gridiv,c_KSat(PavSurf))        = Soil_Coeff(iv5,cSo_KSat)
  SurfaceChar(gridiv,c_SoilDens(PavSurf))    = Soil_Coeff(iv5,cSo_SoilDens)
  SurfaceChar(gridiv,c_SoilInfRate(PavSurf)) = Soil_Coeff(iv5,cSo_SoilInfRate)
  SurfaceChar(gridiv,c_ObsSMDepth(PavSurf))  = Soil_Coeff(iv5,cSo_ObsSMDepth)
  SurfaceChar(gridiv,c_ObsSMMax(PavSurf))    = Soil_Coeff(iv5,cSo_ObsSMMax)
  SurfaceChar(gridiv,c_ObsSNRFrac(PavSurf))  = Soil_Coeff(iv5,cSo_ObsSNRFrac)

  ! Get OHM characteristics for Paved
  CALL CodeMatchOHM(Gridiv,PavSurf,'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,PavSurf,'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,PavSurf,'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,PavSurf,'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(PavSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)

  ! Get water distribution (within grid) for Paved
  CALL CodeMatchDist(rr,c_WGPavedCode,cWG_ToPaved)
  ! Transfer distribution to SurfaceChar
  SurfaceChar(Gridiv,c_WGToPaved(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToPaved)
  SurfaceChar(Gridiv,c_WGToBldgs(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBldgs)
  SurfaceChar(Gridiv,c_WGToEveTr(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToEveTr)
  SurfaceChar(Gridiv,c_WGToDecTr(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToDecTr)
  SurfaceChar(Gridiv,c_WGToGrass(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToGrass)
  SurfaceChar(Gridiv,c_WGToBSoil(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBSoil)
  SurfaceChar(Gridiv,c_WGToWater(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToWater)
  SurfaceChar(Gridiv,c_WGToRunoff(PavSurf))  = WGWaterDist_Coeff(iv5,cWG_ToRunoff)
  SurfaceChar(Gridiv,c_WGToSoilStore(PavSurf))    = WGWaterDist_Coeff(iv5,cWG_ToSoilStore)

  ! ---- Find code for Bldgs surface (Impervious) ----
  CALL CodeMatchNonVeg(rr,c_BldgsCode)
  ! Transfer characteristics to SurfaceChar for Bldgs surface
  SurfaceChar(gridiv,c_AlbMin(BldgSurf))       = NonVeg_Coeff(iv5,ci_AlbMin)
  SurfaceChar(gridiv,c_AlbMax(BldgSurf))       = NonVeg_Coeff(iv5,ci_AlbMax)
  SurfaceChar(gridiv,c_Emis(BldgSurf))         = NonVeg_Coeff(iv5,ci_Emis)
  SurfaceChar(gridiv,c_StorMin(BldgSurf))      = NonVeg_Coeff(iv5,ci_StorMin)
  SurfaceChar(gridiv,c_StorMax(BldgSurf))      = NonVeg_Coeff(iv5,ci_StorMax)
  SurfaceChar(gridiv,c_WetThresh(BldgSurf))    = NonVeg_Coeff(iv5,ci_WetThresh)
  SurfaceChar(gridiv,c_StateLimit(BldgSurf))   = NonVeg_Coeff(iv5,ci_StateLimit)
  SurfaceChar(gridiv,c_DrEq(BldgSurf))         = NonVeg_Coeff(iv5,ci_DrEq)
  SurfaceChar(gridiv,c_DrCoef1(BldgSurf))      = NonVeg_Coeff(iv5,ci_DrCoef1)
  SurfaceChar(gridiv,c_DrCoef2(BldgSurf))      = NonVeg_Coeff(iv5,ci_DrCoef2)
  SurfaceChar(gridiv,c_SoilTCode(BldgSurf))    = NonVeg_Coeff(iv5,ci_SoilTCode)
  SurfaceChar(gridiv,c_SnowLimPat(BldgSurf))   = NonVeg_Coeff(iv5,ci_SnowLimPat)
  SurfaceChar(gridiv,c_SnowLimRem(BldgSurf))   = NonVeg_Coeff(iv5,ci_SnowLimRem)
  SurfaceChar(gridiv,c_OHMCode_SWet(BldgSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(BldgSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(BldgSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(BldgSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(BldgSurf)) = NonVeg_Coeff(iv5,ci_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(Bldgsurf)) = NonVeg_Coeff(iv5,ci_OHMThresh_WD)
  SurfaceChar(gridiv,c_ESTMCode(BldgSurf))     = NonVeg_Coeff(iv5,ci_ESTMCode)
  SurfaceChar(Gridiv,c_CpAnOHM(BldgSurf))      = NonVeg_Coeff(iv5,ci_CpAnOHM)   ! heat capacity, AnOHM TS
  SurfaceChar(Gridiv,c_KkAnOHM(BldgSurf))      = NonVeg_Coeff(iv5,ci_KkAnOHM)  ! heat conductivity, AnOHM TS
  SurfaceChar(Gridiv,c_ChAnOHM(BldgSurf))      = NonVeg_Coeff(iv5,ci_ChAnOHM)  ! bulk transfer coef., AnOHM TS

  ! Use SoilCode for Bldgs to find code for soil characteristics
  CALL CodeMatchSoil(Gridiv,c_SoilTCode(BldgSurf))
  ! Transfer soil characteristics to SurfaceChar
  SurfaceChar(gridiv,c_SoilDepth(BldgSurf))   = Soil_Coeff(iv5,cSo_SoilDepth)
  SurfaceChar(gridiv,c_SoilStCap(BldgSurf))   = Soil_Coeff(iv5,cSo_SoilStCap)
  SurfaceChar(gridiv,c_KSat(BldgSurf))        = Soil_Coeff(iv5,cSo_KSat)
  SurfaceChar(gridiv,c_SoilDens(BldgSurf))    = Soil_Coeff(iv5,cSo_SoilDens)
  SurfaceChar(gridiv,c_SoilInfRate(BldgSurf)) = Soil_Coeff(iv5,cSo_SoilInfRate)
  SurfaceChar(gridiv,c_ObsSMDepth(BldgSurf))  = Soil_Coeff(iv5,cSo_ObsSMDepth)
  SurfaceChar(gridiv,c_ObsSMMax(BldgSurf))    = Soil_Coeff(iv5,cSo_ObsSMMax)
  SurfaceChar(gridiv,c_ObsSNRFrac(BldgSurf))  = Soil_Coeff(iv5,cSo_ObsSNRFrac)
  !Get OHM characteristics for Bldgs
  CALL CodeMatchOHM(Gridiv,BldgSurf,'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,BldgSurf,'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,BldgSurf,'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,BldgSurf,'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(BldgSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)

  ! Get water distribution (within grid) for Bldgs
  CALL CodeMatchDist(rr,c_WGBldgsCode,cWG_ToBldgs)
  ! Transfer distribution to SurfaceChar
  SurfaceChar(Gridiv,c_WGToPaved(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToPaved)
  SurfaceChar(Gridiv,c_WGToBldgs(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBldgs)
  SurfaceChar(Gridiv,c_WGToEveTr(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToEveTr)
  SurfaceChar(Gridiv,c_WGToDecTr(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToDecTr)
  SurfaceChar(Gridiv,c_WGToGrass(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToGrass)
  SurfaceChar(Gridiv,c_WGToBSoil(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBSoil)
  SurfaceChar(Gridiv,c_WGToWater(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToWater)
  SurfaceChar(Gridiv,c_WGToRunoff(BldgSurf))  = WGWaterDist_Coeff(iv5,cWG_ToRunoff)
  SurfaceChar(Gridiv,c_WGToSoilStore(BldgSurf))    = WGWaterDist_Coeff(iv5,cWG_ToSoilStore)

  ! ---- Find code for EveTr surface (Pervious) ----
  CALL CodeMatchVeg(rr,c_EveTrCode)
  ! Transfer characteristics to SurfaceChar for EveTr surface
  ! All surfaces (1-nsurf)
  SurfaceChar(gridiv,c_AlbMin(ConifSurf))     = Veg_Coeff(iv5,cp_AlbMin)
  SurfaceChar(gridiv,c_AlbMax(ConifSurf))     = Veg_Coeff(iv5,cp_AlbMax)
  SurfaceChar(gridiv,c_Emis(ConifSurf))       = Veg_Coeff(iv5,cp_Emis)
  SurfaceChar(gridiv,c_StorMin(ConifSurf))    = Veg_Coeff(iv5,cp_StorMin)
  SurfaceChar(gridiv,c_StorMax(ConifSurf))    = Veg_Coeff(iv5,cp_StorMax)
  SurfaceChar(gridiv,c_WetThresh(ConifSurf))  = Veg_Coeff(iv5,cp_WetThresh)
  SurfaceChar(gridiv,c_StateLimit(ConifSurf)) = Veg_Coeff(iv5,cp_StateLimit)
  SurfaceChar(gridiv,c_DrEq(ConifSurf))       = Veg_Coeff(iv5,cp_DrEq)
  SurfaceChar(gridiv,c_DrCoef1(ConifSurf))    = Veg_Coeff(iv5,cp_DrCoef1)
  SurfaceChar(gridiv,c_DrCoef2(ConifSurf))    = Veg_Coeff(iv5,cp_DrCoef2)
  SurfaceChar(gridiv,c_SoilTCode(ConifSurf))  = Veg_Coeff(iv5,cp_SoilTCode)
  SurfaceChar(gridiv,c_SnowLimPat(ConifSurf)) = Veg_Coeff(iv5,cp_SnowLimPat)
  ! Veg surfaces only (1-nvegsurf)
  SurfaceChar(gridiv,c_BaseT(ivConif))        = Veg_Coeff(iv5,cp_BaseT)
  SurfaceChar(gridiv,c_BaseTe(ivConif))       = Veg_Coeff(iv5,cp_BaseTe)
  SurfaceChar(gridiv,c_GDDFull(ivConif))      = Veg_Coeff(iv5,cp_GDDFull)
  SurfaceChar(gridiv,c_SDDFull(ivConif))      = Veg_Coeff(iv5,cp_SDDFull)
  SurfaceChar(gridiv,c_LAIMin(ivConif))       = Veg_Coeff(iv5,cp_LAIMin)
  SurfaceChar(gridiv,c_LAIMax(ivConif))       = Veg_Coeff(iv5,cp_LAIMax)
  SurfaceChar(gridiv,c_PorosityMin(ivConif))  = Veg_Coeff(iv5,cp_PorosityMin)
  SurfaceChar(gridiv,c_PorosityMax(ivConif))  = Veg_Coeff(iv5,cp_PorosityMax)
  SurfaceChar(gridiv,c_GsMax(ivConif))        = Veg_Coeff(iv5,cp_GsMax)
  SurfaceChar(gridiv,c_LAIEq(ivConif))        = Veg_Coeff(iv5,cp_LAIEq)
  SurfaceChar(gridiv,c_LeafGP1(ivConif))      = Veg_Coeff(iv5,cp_LeafGP1)
  SurfaceChar(gridiv,c_LeafGP2(ivConif))      = Veg_Coeff(iv5,cp_LeafGP2)
  SurfaceChar(gridiv,c_LeafOP1(ivConif))      = Veg_Coeff(iv5,cp_LeafOP1)
  SurfaceChar(gridiv,c_LeafOP2(ivConif))      = Veg_Coeff(iv5,cp_LeafOP2)
  ! OHM codes
  SurfaceChar(gridiv,c_OHMCode_SWet(ConifSurf)) = Veg_Coeff(iv5,cp_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(ConifSurf)) = Veg_Coeff(iv5,cp_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(ConifSurf)) = Veg_Coeff(iv5,cp_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(ConifSurf)) = Veg_Coeff(iv5,cp_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(ConifSurf)) = Veg_Coeff(iv5,cp_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(ConifSurf)) = Veg_Coeff(iv5,cp_OHMThresh_WD)
  ! ESTM code
  SurfaceChar(gridiv,c_ESTMCode(ConifSurf))     = Veg_Coeff(iv5,cp_ESTMCode)
  ! AnOHM TS
  SurfaceChar(Gridiv,c_CpAnOHM(ConifSurf))      = Veg_Coeff(iv5,cp_CpAnOHM) ! heat capacity, AnOHM TS
  SurfaceChar(Gridiv,c_KkAnOHM(ConifSurf))      = Veg_Coeff(iv5,cp_KkAnOHM)  ! heat conductivity, AnOHM TS
  SurfaceChar(Gridiv,c_ChAnOHM(ConifSurf))      = Veg_Coeff(iv5,cp_ChAnOHM)  ! bulk transfer coef., AnOHM TS

  SurfaceChar(Gridiv,c_BiogenCO2Code(ivConif)) = Veg_Coeff(iv5,cp_BiogenCO2Code)


  ! ---- Find code for Biogenic CO2 Method ----
  CALL CodeMatchBiogen(gridiv,c_BiogenCO2Code(ivConif))
  ! Transfer Biogenic CO2 characteristics to SurfaceChar
  SurfaceChar(gridiv,c_alpha_bioCO2(ivConif))     = Biogen_Coeff(iv5,cB_alpha)
  SurfaceChar(gridiv,c_beta_bioCO2(ivConif))      = Biogen_Coeff(iv5,cB_beta)
  SurfaceChar(gridiv,c_theta_bioCO2(ivConif))     = Biogen_Coeff(iv5,cB_theta)
  SurfaceChar(gridiv,c_alpha_enh_bioCO2(ivConif)) = Biogen_Coeff(iv5,cB_alpha_enh)
  SurfaceChar(gridiv,c_beta_enh_bioCO2(ivConif))  = Biogen_Coeff(iv5,cB_alpha_enh)
  SurfaceChar(gridiv,c_resp_a(ivConif))           = Biogen_Coeff(iv5,cB_resp_a)
  SurfaceChar(gridiv,c_resp_b(ivConif))           = Biogen_Coeff(iv5,cB_resp_b)
  SurfaceChar(gridiv,c_min_res_bioCO2(ivConif))   = Biogen_Coeff(iv5,cB_min_r)

  ! Use SoilCode for EveTr to find code for soil characteristics
  CALL CodeMatchSoil(Gridiv,c_SoilTCode(ConifSurf))
  ! Transfer soil characteristics to SurfaceChar
  SurfaceChar(gridiv,c_SoilDepth(ConifSurf))   = Soil_Coeff(iv5,cSo_SoilDepth)
  SurfaceChar(gridiv,c_SoilStCap(ConifSurf))   = Soil_Coeff(iv5,cSo_SoilStCap)
  SurfaceChar(gridiv,c_KSat(ConifSurf))        = Soil_Coeff(iv5,cSo_KSat)
  SurfaceChar(gridiv,c_SoilDens(ConifSurf))    = Soil_Coeff(iv5,cSo_SoilDens)
  SurfaceChar(gridiv,c_SoilInfRate(ConifSurf)) = Soil_Coeff(iv5,cSo_SoilInfRate)
  SurfaceChar(gridiv,c_ObsSMDepth(ConifSurf))  = Soil_Coeff(iv5,cSo_ObsSMDepth)
  SurfaceChar(gridiv,c_ObsSMMax(ConifSurf))    = Soil_Coeff(iv5,cSo_ObsSMMax)
  SurfaceChar(gridiv,c_ObsSNRFrac(ConifSurf))  = Soil_Coeff(iv5,cSo_ObsSNRFrac)
  !Get OHM characteristics for Conif
  CALL CodeMatchOHM(Gridiv,ConifSurf,'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,ConifSurf,'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,ConifSurf,'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,ConifSurf,'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(ConifSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)

  ! Get water distribution (within grid) for EveTr
  CALL CodeMatchDist(rr,c_WGEveTrCode,cWG_ToEveTr)
  ! Transfer distribution to SurfaceChar
  SurfaceChar(Gridiv,c_WGToPaved(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToPaved)
  SurfaceChar(Gridiv,c_WGToBldgs(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBldgs)
  SurfaceChar(Gridiv,c_WGToEveTr(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToEveTr)
  SurfaceChar(Gridiv,c_WGToDecTr(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToDecTr)
  SurfaceChar(Gridiv,c_WGToGrass(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToGrass)
  SurfaceChar(Gridiv,c_WGToBSoil(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBSoil)
  SurfaceChar(Gridiv,c_WGToWater(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToWater)
  SurfaceChar(Gridiv,c_WGToRunoff(ConifSurf))  = WGWaterDist_Coeff(iv5,cWG_ToRunoff)
  SurfaceChar(Gridiv,c_WGToSoilStore(ConifSurf))    = WGWaterDist_Coeff(iv5,cWG_ToSoilStore)

  ! ---- Find code for DecTr surface (Pervious) ----
  CALL CodeMatchVeg(rr,c_DecTrCode)
  ! Transfer characteristics to SurfaceChar for DecTr surface
  ! All surfaces (1-nsurf)
  SurfaceChar(gridiv,c_AlbMin(DecidSurf))     = Veg_Coeff(iv5,cp_AlbMin)
  SurfaceChar(gridiv,c_AlbMax(DecidSurf))     = Veg_Coeff(iv5,cp_AlbMax)
  SurfaceChar(gridiv,c_Emis(DecidSurf))       = Veg_Coeff(iv5,cp_Emis)
  SurfaceChar(gridiv,c_StorMin(DecidSurf))    = Veg_Coeff(iv5,cp_StorMin)
  SurfaceChar(gridiv,c_StorMax(DecidSurf))    = Veg_Coeff(iv5,cp_StorMax)
  SurfaceChar(gridiv,c_WetThresh(DecidSurf))  = Veg_Coeff(iv5,cp_WetThresh)
  SurfaceChar(gridiv,c_StateLimit(DecidSurf)) = Veg_Coeff(iv5,cp_StateLimit)
  SurfaceChar(gridiv,c_DrEq(DecidSurf))       = Veg_Coeff(iv5,cp_DrEq)
  SurfaceChar(gridiv,c_DrCoef1(DecidSurf))    = Veg_Coeff(iv5,cp_DrCoef1)
  SurfaceChar(gridiv,c_DrCoef2(DecidSurf))    = Veg_Coeff(iv5,cp_DrCoef2)
  SurfaceChar(gridiv,c_SoilTCode(DecidSurf))  = Veg_Coeff(iv5,cp_SoilTCode)
  SurfaceChar(gridiv,c_SnowLimPat(DecidSurf)) = Veg_Coeff(iv5,cp_SnowLimPat)
  ! Veg surfaces only (1-nvegsurf)
  SurfaceChar(gridiv,c_BaseT(ivDecid))        = Veg_Coeff(iv5,cp_BaseT)
  SurfaceChar(gridiv,c_BaseTe(ivDecid))       = Veg_Coeff(iv5,cp_BaseTe)
  SurfaceChar(gridiv,c_GDDFull(ivDecid))      = Veg_Coeff(iv5,cp_GDDFull)
  SurfaceChar(gridiv,c_SDDFull(ivDecid))      = Veg_Coeff(iv5,cp_SDDFull)
  SurfaceChar(gridiv,c_LAIMin(ivDecid))       = Veg_Coeff(iv5,cp_LAIMin)
  SurfaceChar(gridiv,c_LAIMax(ivDecid))       = Veg_Coeff(iv5,cp_LAIMax)
  SurfaceChar(gridiv,c_PorosityMin(ivDecid))  = Veg_Coeff(iv5,cp_PorosityMin)
  SurfaceChar(gridiv,c_PorosityMax(ivDecid))  = Veg_Coeff(iv5,cp_PorosityMax)
  SurfaceChar(gridiv,c_GsMax(ivDecid))        = Veg_Coeff(iv5,cp_GsMax)
  SurfaceChar(gridiv,c_LAIEq(ivDecid))        = Veg_Coeff(iv5,cp_LAIEq)
  SurfaceChar(gridiv,c_LeafGP1(ivDecid))      = Veg_Coeff(iv5,cp_LeafGP1)
  SurfaceChar(gridiv,c_LeafGP2(ivDecid))      = Veg_Coeff(iv5,cp_LeafGP2)
  SurfaceChar(gridiv,c_LeafOP1(ivDecid))      = Veg_Coeff(iv5,cp_LeafOP1)
  SurfaceChar(gridiv,c_LeafOP2(ivDecid))      = Veg_Coeff(iv5,cp_LeafOP2)
  ! OHM codes
  SurfaceChar(gridiv,c_OHMCode_SWet(DecidSurf)) = Veg_Coeff(iv5,cp_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(DecidSurf)) = Veg_Coeff(iv5,cp_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(DecidSurf)) = Veg_Coeff(iv5,cp_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(DecidSurf)) = Veg_Coeff(iv5,cp_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(DecidSurf)) = Veg_Coeff(iv5,cp_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(DecidSurf)) = Veg_Coeff(iv5,cp_OHMThresh_WD)
  ! ESTM code
  SurfaceChar(gridiv,c_ESTMCode(DecidSurf))     = Veg_Coeff(iv5,cp_ESTMCode)
  ! AnOHM TS
  SurfaceChar(Gridiv,c_CpAnOHM(DecidSurf))           = Veg_Coeff(iv5,cp_CpAnOHM) ! heat capacity, AnOHM TS
  SurfaceChar(Gridiv,c_KkAnOHM(DecidSurf))           = Veg_Coeff(iv5,cp_KkAnOHM)  ! heat conductivity, AnOHM TS
  SurfaceChar(Gridiv,c_ChAnOHM(DecidSurf))           = Veg_Coeff(iv5,cp_ChAnOHM)  ! bulk transfer coef., AnOHM TS

  SurfaceChar(Gridiv,c_BiogenCO2Code(ivDecid)) = Veg_Coeff(iv5,cp_BiogenCO2Code)

  ! ---- Find code for Biogenic CO2 Method ----
  CALL CodeMatchBiogen(gridiv,c_BiogenCO2Code(ivDecid))
  ! Transfer Biogenic CO2 characteristics to SurfaceChar
  SurfaceChar(gridiv,c_alpha_bioCO2(ivDecid))     = Biogen_Coeff(iv5,cB_alpha)
  SurfaceChar(gridiv,c_beta_bioCO2(ivDecid))      = Biogen_Coeff(iv5,cB_beta)
  SurfaceChar(gridiv,c_theta_bioCO2(ivDecid))     = Biogen_Coeff(iv5,cB_theta)
  SurfaceChar(gridiv,c_alpha_enh_bioCO2(ivDecid)) = Biogen_Coeff(iv5,cB_alpha_enh)
  SurfaceChar(gridiv,c_beta_enh_bioCO2(ivDecid))  = Biogen_Coeff(iv5,cB_alpha_enh)
  SurfaceChar(gridiv,c_resp_a(ivDecid))           = Biogen_Coeff(iv5,cB_resp_a)
  SurfaceChar(gridiv,c_resp_b(ivDecid))           = Biogen_Coeff(iv5,cB_resp_b)
  SurfaceChar(gridiv,c_min_res_bioCO2(ivDecid))   = Biogen_Coeff(iv5,cB_min_r)

  ! Use SoilCode for DecTr to find code for soil characteristics
  CALL CodeMatchSoil(Gridiv,c_SoilTCode(DecidSurf))
  ! Transfer soil characteristics to SurfaceChar
  SurfaceChar(gridiv,c_SoilDepth(DecidSurf))    = Soil_Coeff(iv5,cSo_SoilDepth)
  SurfaceChar(gridiv,c_SoilStCap(DecidSurf))    = Soil_Coeff(iv5,cSo_SoilStCap)
  SurfaceChar(gridiv,c_KSat(DecidSurf))        = Soil_Coeff(iv5,cSo_KSat)
  SurfaceChar(gridiv,c_SoilDens(DecidSurf))    = Soil_Coeff(iv5,cSo_SoilDens)
  SurfaceChar(gridiv,c_SoilInfRate(DecidSurf)) = Soil_Coeff(iv5,cSo_SoilInfRate)
  SurfaceChar(gridiv,c_ObsSMDepth(DecidSurf))  = Soil_Coeff(iv5,cSo_ObsSMDepth)
  SurfaceChar(gridiv,c_ObsSMMax(DecidSurf))    = Soil_Coeff(iv5,cSo_ObsSMMax)
  SurfaceChar(gridiv,c_ObsSNRFrac(DecidSurf))  = Soil_Coeff(iv5,cSo_ObsSNRFrac)
  !Get OHM characteristics for Decid
  CALL CodeMatchOHM(Gridiv,DecidSurf,'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,DecidSurf,'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,DecidSurf,'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,DecidSurf,'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(DecidSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)

  ! Get water distribution (within grid) for DecTr
  CALL CodeMatchDist(rr,c_WGDecTrCode,cWG_ToDecTr)
  ! Transfer distribution to SurfaceChar
  SurfaceChar(Gridiv,c_WGToPaved(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToPaved)
  SurfaceChar(Gridiv,c_WGToBldgs(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBldgs)
  SurfaceChar(Gridiv,c_WGToEveTr(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToEveTr)
  SurfaceChar(Gridiv,c_WGToDecTr(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToDecTr)
  SurfaceChar(Gridiv,c_WGToGrass(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToGrass)
  SurfaceChar(Gridiv,c_WGToBSoil(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBSoil)
  SurfaceChar(Gridiv,c_WGToWater(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToWater)
  SurfaceChar(Gridiv,c_WGToRunoff(DecidSurf))  = WGWaterDist_Coeff(iv5,cWG_ToRunoff)
  SurfaceChar(Gridiv,c_WGToSoilStore(DecidSurf))    = WGWaterDist_Coeff(iv5,cWG_ToSoilStore)

  ! ---- Find code for Grass surface (Pervious) ----
  CALL CodeMatchVeg(rr,c_GrassCode)
  ! Transfer characteristics to SurfaceChar for Grass surface
  ! All surfaces (1-nsurf)
  SurfaceChar(gridiv,c_AlbMin(GrassSurf))     = Veg_Coeff(iv5,cp_AlbMin)
  SurfaceChar(gridiv,c_AlbMax(GrassSurf))     = Veg_Coeff(iv5,cp_AlbMax)
  SurfaceChar(gridiv,c_Emis(GrassSurf))       = Veg_Coeff(iv5,cp_Emis)
  SurfaceChar(gridiv,c_StorMin(GrassSurf))    = Veg_Coeff(iv5,cp_StorMin)
  SurfaceChar(gridiv,c_StorMax(GrassSurf))    = Veg_Coeff(iv5,cp_StorMax)
  SurfaceChar(gridiv,c_WetThresh(GrassSurf))  = Veg_Coeff(iv5,cp_WetThresh)
  SurfaceChar(gridiv,c_StateLimit(GrassSurf)) = Veg_Coeff(iv5,cp_StateLimit)
  SurfaceChar(gridiv,c_DrEq(GrassSurf))       = Veg_Coeff(iv5,cp_DrEq)
  SurfaceChar(gridiv,c_DrCoef1(GrassSurf))    = Veg_Coeff(iv5,cp_DrCoef1)
  SurfaceChar(gridiv,c_DrCoef2(GrassSurf))    = Veg_Coeff(iv5,cp_DrCoef2)
  SurfaceChar(gridiv,c_SoilTCode(GrassSurf))  = Veg_Coeff(iv5,cp_SoilTCode)
  SurfaceChar(gridiv,c_SnowLimPat(GrassSurf)) = Veg_Coeff(iv5,cp_SnowLimPat)
  ! Veg surfaces only (1-nvegsurf)
  SurfaceChar(gridiv,c_BaseT(ivGrass))        = Veg_Coeff(iv5,cp_BaseT)
  SurfaceChar(gridiv,c_BaseTe(ivGrass))       = Veg_Coeff(iv5,cp_BaseTe)
  SurfaceChar(gridiv,c_GDDFull(ivGrass))      = Veg_Coeff(iv5,cp_GDDFull)
  SurfaceChar(gridiv,c_SDDFull(ivGrass))      = Veg_Coeff(iv5,cp_SDDFull)
  SurfaceChar(gridiv,c_LAIMin(ivGrass))       = Veg_Coeff(iv5,cp_LAIMin)
  SurfaceChar(gridiv,c_LAIMax(ivGrass))       = Veg_Coeff(iv5,cp_LAIMax)
  SurfaceChar(gridiv,c_PorosityMin(ivGrass))       = Veg_Coeff(iv5,cp_PorosityMin)
  SurfaceChar(gridiv,c_PorosityMax(ivGrass))       = Veg_Coeff(iv5,cp_PorosityMax)
  SurfaceChar(gridiv,c_GsMax(ivGrass))        = Veg_Coeff(iv5,cp_GsMax)
  SurfaceChar(gridiv,c_LAIEq(ivGrass))        = Veg_Coeff(iv5,cp_LAIEq)
  SurfaceChar(gridiv,c_LeafGP1(ivGrass))      = Veg_Coeff(iv5,cp_LeafGP1)
  SurfaceChar(gridiv,c_LeafGP2(ivGrass))      = Veg_Coeff(iv5,cp_LeafGP2)
  SurfaceChar(gridiv,c_LeafOP1(ivGrass))      = Veg_Coeff(iv5,cp_LeafOP1)
  SurfaceChar(gridiv,c_LeafOP2(ivGrass))      = Veg_Coeff(iv5,cp_LeafOP2)
  ! OHM codes
  SurfaceChar(gridiv,c_OHMCode_SWet(GrassSurf)) = Veg_Coeff(iv5,cp_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(GrassSurf)) = Veg_Coeff(iv5,cp_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(GrassSurf)) = Veg_Coeff(iv5,cp_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(GrassSurf)) = Veg_Coeff(iv5,cp_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(GrassSurf)) = Veg_Coeff(iv5,cp_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(GrassSurf)) = Veg_Coeff(iv5,cp_OHMThresh_WD)
  ! ESTM code
  SurfaceChar(gridiv,c_ESTMCode(GrassSurf))     = Veg_Coeff(iv5,cp_ESTMCode)
  ! AnOHM TS
  SurfaceChar(Gridiv,c_CpAnOHM(GrassSurf))           = Veg_Coeff(iv5,cp_CpAnOHM) ! heat capacity, AnOHM TS
  SurfaceChar(Gridiv,c_KkAnOHM(GrassSurf))           = Veg_Coeff(iv5,cp_KkAnOHM)  ! heat conductivity, AnOHM TS
  SurfaceChar(Gridiv,c_ChAnOHM(GrassSurf))           = Veg_Coeff(iv5,cp_ChAnOHM)  ! bulk transfer coef., AnOHM TS

  SurfaceChar(Gridiv,c_BiogenCO2Code(ivGrass)) = Veg_Coeff(iv5,cp_BiogenCO2Code)

  ! ---- Find code for Biogenic CO2 Method ----
  CALL CodeMatchBiogen(gridiv,c_BiogenCO2Code(ivGrass))
  ! Transfer Biogenic CO2 characteristics to SurfaceChar
  SurfaceChar(gridiv,c_alpha_bioCO2(ivGrass))     = Biogen_Coeff(iv5,cB_alpha)
  SurfaceChar(gridiv,c_beta_bioCO2(ivGrass))      = Biogen_Coeff(iv5,cB_beta)
  SurfaceChar(gridiv,c_theta_bioCO2(ivGrass))     = Biogen_Coeff(iv5,cB_theta)
  SurfaceChar(gridiv,c_alpha_enh_bioCO2(ivGrass)) = Biogen_Coeff(iv5,cB_alpha_enh)
  SurfaceChar(gridiv,c_beta_enh_bioCO2(ivGrass))  = Biogen_Coeff(iv5,cB_alpha_enh)
  SurfaceChar(gridiv,c_resp_a(ivGrass))           = Biogen_Coeff(iv5,cB_resp_a)
  SurfaceChar(gridiv,c_resp_b(ivGrass))           = Biogen_Coeff(iv5,cB_resp_b)
  SurfaceChar(gridiv,c_min_res_bioCO2(ivGrass))   = Biogen_Coeff(iv5,cB_min_r)

  ! Use SoilCode for Grass to find code for soil characteristics
  CALL CodeMatchSoil(Gridiv,c_SoilTCode(GrassSurf))
  ! Transfer soil characteristics to SurfaceChar
  SurfaceChar(gridiv,c_SoilDepth(GrassSurf))    = Soil_Coeff(iv5,cSo_SoilDepth)
  SurfaceChar(gridiv,c_SoilStCap(GrassSurf))    = Soil_Coeff(iv5,cSo_SoilStCap)
  SurfaceChar(gridiv,c_KSat(GrassSurf))        = Soil_Coeff(iv5,cSo_KSat)
  SurfaceChar(gridiv,c_SoilDens(GrassSurf))    = Soil_Coeff(iv5,cSo_SoilDens)
  SurfaceChar(gridiv,c_SoilInfRate(GrassSurf)) = Soil_Coeff(iv5,cSo_SoilInfRate)
  SurfaceChar(gridiv,c_ObsSMDepth(GrassSurf))  = Soil_Coeff(iv5,cSo_ObsSMDepth)
  SurfaceChar(gridiv,c_ObsSMMax(GrassSurf))    = Soil_Coeff(iv5,cSo_ObsSMMax)
  SurfaceChar(gridiv,c_ObsSNRFrac(GrassSurf))  = Soil_Coeff(iv5,cSo_ObsSNRFrac)
  !Get OHM characteristics for Grass
  CALL CodeMatchOHM(Gridiv,GrassSurf,'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,GrassSurf,'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,GrassSurf,'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,GrassSurf,'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(GrassSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)

  ! Get water distribution (within grid) for Grass
  CALL CodeMatchDist(rr,c_WGGrassCode,cWG_ToGrass)
  ! Transfer distribution to SurfaceChar
  SurfaceChar(Gridiv,c_WGToPaved(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToPaved)
  SurfaceChar(Gridiv,c_WGToBldgs(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBldgs)
  SurfaceChar(Gridiv,c_WGToEveTr(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToEveTr)
  SurfaceChar(Gridiv,c_WGToDecTr(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToDecTr)
  SurfaceChar(Gridiv,c_WGToGrass(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToGrass)
  SurfaceChar(Gridiv,c_WGToBSoil(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBSoil)
  SurfaceChar(Gridiv,c_WGToWater(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToWater)
  SurfaceChar(Gridiv,c_WGToRunoff(GrassSurf))  = WGWaterDist_Coeff(iv5,cWG_ToRunoff)
  SurfaceChar(Gridiv,c_WGToSoilStore(GrassSurf))    = WGWaterDist_Coeff(iv5,cWG_ToSoilStore)

  ! ---- Find code for BSoil surface (Impervious) ----
  CALL CodeMatchNonVeg(rr,c_BSoilCode)
  ! Transfer characteristics to SurfaceChar for BSoil surface
  ! All surfaces (1-nsurf)
  SurfaceChar(gridiv,c_AlbMin(BSoilSurf))     = NonVeg_Coeff(iv5,ci_AlbMin)
  SurfaceChar(gridiv,c_AlbMax(BSoilSurf))     = NonVeg_Coeff(iv5,ci_AlbMax)
  SurfaceChar(gridiv,c_Emis(BSoilSurf))       = NonVeg_Coeff(iv5,ci_Emis)
  SurfaceChar(gridiv,c_StorMin(BSoilSurf))    = NonVeg_Coeff(iv5,ci_StorMin)
  SurfaceChar(gridiv,c_StorMax(BSoilSurf))    = NonVeg_Coeff(iv5,ci_StorMax)
  SurfaceChar(gridiv,c_WetThresh(BSoilSurf))  = NonVeg_Coeff(iv5,ci_WetThresh)
  SurfaceChar(gridiv,c_StateLimit(BSoilSurf)) = NonVeg_Coeff(iv5,ci_StateLimit)
  SurfaceChar(gridiv,c_DrEq(BSoilSurf))       = NonVeg_Coeff(iv5,ci_DrEq)
  SurfaceChar(gridiv,c_DrCoef1(BSoilSurf))    = NonVeg_Coeff(iv5,ci_DrCoef1)
  SurfaceChar(gridiv,c_DrCoef2(BSoilSurf))    = NonVeg_Coeff(iv5,ci_DrCoef2)
  SurfaceChar(gridiv,c_SoilTCode(BSoilSurf))  = NonVeg_Coeff(iv5,ci_SoilTCode)
  SurfaceChar(gridiv,c_SnowLimPat(BSoilSurf)) = NonVeg_Coeff(iv5,ci_SnowLimPat)
  SurfaceChar(gridiv,c_SnowLimRem(BSoilSurf))   = NonVeg_Coeff(iv5,ci_SnowLimRem)
  SurfaceChar(gridiv,c_OHMCode_SWet(BSoilSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(BSoilSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(BSoilSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(BSoilSurf)) = NonVeg_Coeff(iv5,ci_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(BSoilSurf)) = NonVeg_Coeff(iv5,ci_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(BSoilSurf)) = NonVeg_Coeff(iv5,ci_OHMThresh_WD)
  SurfaceChar(gridiv,c_ESTMCode(BSoilSurf))     = NonVeg_Coeff(iv5,ci_ESTMCode)
  SurfaceChar(Gridiv,c_CpAnOHM(BSoilSurf))           = NonVeg_Coeff(iv5,ci_CpAnOHM) ! heat capacity, AnOHM TS
  SurfaceChar(Gridiv,c_KkAnOHM(BSoilSurf))           = NonVeg_Coeff(iv5,ci_KkAnOHM)  ! heat conductivity, AnOHM TS
  SurfaceChar(Gridiv,c_ChAnOHM(BSoilSurf))           = NonVeg_Coeff(iv5,ci_ChAnOHM)  ! bulk transfer coef., AnOHM TS


  ! Use SoilCode for BSoil to find code for soil characteristics
  CALL CodeMatchSoil(Gridiv,c_SoilTCode(BSoilSurf))
  ! Transfer soil characteristics to SurfaceChar
  SurfaceChar(gridiv,c_SoilDepth(BSoilSurf))    = Soil_Coeff(iv5,cSo_SoilDepth)
  SurfaceChar(gridiv,c_SoilStCap(BSoilSurf))    = Soil_Coeff(iv5,cSo_SoilStCap)
  SurfaceChar(gridiv,c_KSat(BSoilSurf))        = Soil_Coeff(iv5,cSo_KSat)
  SurfaceChar(gridiv,c_SoilDens(BSoilSurf))    = Soil_Coeff(iv5,cSo_SoilDens)
  SurfaceChar(gridiv,c_SoilInfRate(BSoilSurf)) = Soil_Coeff(iv5,cSo_SoilInfRate)
  SurfaceChar(gridiv,c_ObsSMDepth(BSoilSurf))  = Soil_Coeff(iv5,cSo_ObsSMDepth)
  SurfaceChar(gridiv,c_ObsSMMax(BSoilSurf))    = Soil_Coeff(iv5,cSo_ObsSMMax)
  SurfaceChar(gridiv,c_ObsSNRFrac(BSoilSurf))  = Soil_Coeff(iv5,cSo_ObsSNRFrac)


  ! Get OHM characteristics for BSoil
  CALL CodeMatchOHM(Gridiv,BSoilSurf,'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,BSoilSurf,'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,BSoilSurf,'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,BSoilSurf,'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(BSoilSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)

  ! Get water distribution (within grid) for Bare soil
  CALL CodeMatchDist(rr,c_WGBSoilCode,cWG_ToBSoil)
  ! Transfer distribution to SurfaceChar
  SurfaceChar(Gridiv,c_WGToPaved(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToPaved)
  SurfaceChar(Gridiv,c_WGToBldgs(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBldgs)
  SurfaceChar(Gridiv,c_WGToEveTr(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToEveTr)
  SurfaceChar(Gridiv,c_WGToDecTr(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToDecTr)
  SurfaceChar(Gridiv,c_WGToGrass(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToGrass)
  SurfaceChar(Gridiv,c_WGToBSoil(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBSoil)
  SurfaceChar(Gridiv,c_WGToWater(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToWater)
  SurfaceChar(Gridiv,c_WGToRunoff(BSoilSurf))  = WGWaterDist_Coeff(iv5,cWG_ToRunoff)
  SurfaceChar(Gridiv,c_WGToSoilStore(BSoilSurf))    = WGWaterDist_Coeff(iv5,cWG_ToSoilStore)


  ! ---- Find code for Water surface (Water) ----
  CALL CodeMatchWater(rr,c_WaterCode)
  ! Transfer characteristics to SurfaceChar for Water surface
  ! All surfaces (1-nsurf)
  SurfaceChar(gridiv,c_AlbMin(WaterSurf))     = Water_Coeff(iv5,cw_AlbMin)
  SurfaceChar(gridiv,c_AlbMax(WaterSurf))     = Water_Coeff(iv5,cw_AlbMax)
  SurfaceChar(gridiv,c_Emis(WaterSurf))       = Water_Coeff(iv5,cw_Emis)
  SurfaceChar(gridiv,c_StorMin(WaterSurf))    = Water_Coeff(iv5,cw_StorMin)
  SurfaceChar(gridiv,c_StorMax(WaterSurf))    = Water_Coeff(iv5,cw_StorMax)
  SurfaceChar(gridiv,c_WetThresh(WaterSurf))  = Water_Coeff(iv5,cw_WetThresh)
  SurfaceChar(gridiv,c_StateLimit(WaterSurf)) = Water_Coeff(iv5,cw_StateLimit)
  SurfaceChar(gridiv,c_DrEq(WaterSurf))       = Water_Coeff(iv5,cw_DrEq)
  SurfaceChar(gridiv,c_DrCoef1(WaterSurf))    = Water_Coeff(iv5,cw_DrCoef1)
  SurfaceChar(gridiv,c_DrCoef2(WaterSurf))    = Water_Coeff(iv5,cw_DrCoef2)
  ! Water surface only
  SurfaceChar(gridiv,c_WaterDepth) = Water_Coeff(iv5,cw_WaterDepth)
  ! OHM codes
  SurfaceChar(gridiv,c_OHMCode_SWet(WaterSurf)) = Water_Coeff(iv5,cw_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(WaterSurf)) = Water_Coeff(iv5,cw_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(WaterSurf)) = Water_Coeff(iv5,cw_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(WaterSurf)) = Water_Coeff(iv5,cw_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(WaterSurf)) = Water_Coeff(iv5,cw_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(WaterSurf)) = Water_Coeff(iv5,cw_OHMThresh_WD)
  ! ESTM code
  SurfaceChar(gridiv,c_ESTMCode(WaterSurf))     = Water_Coeff(iv5,cw_ESTMCode)
  ! AnOHM TS
  SurfaceChar(Gridiv,c_CpAnOHM(WaterSurf))           = Water_Coeff(iv5,cw_CpAnOHM) ! heat capacity, AnOHM TS
  SurfaceChar(Gridiv,c_KkAnOHM(WaterSurf))           = Water_Coeff(iv5,cw_KkAnOHM)  ! heat conductivity, AnOHM TS
  SurfaceChar(Gridiv,c_ChAnOHM(WaterSurf))           = Water_Coeff(iv5,cw_ChAnOHM)  ! bulk transfer coef., AnOHM TS
  ! Get OHM characteristics for Water
  CALL CodeMatchOHM(Gridiv,WaterSurf,'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,WaterSurf,'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,WaterSurf,'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,WaterSurf,'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(WaterSurf))    = OHMCoefficients_Coeff(iv5,cO_a3)

  ! Get water distribution (within grid) for Water
  CALL CodeMatchDist(rr,c_WGWaterCode,cWG_ToWater)
  ! Transfer distribution to SurfaceChar
  SurfaceChar(Gridiv,c_WGToPaved(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToPaved)
  SurfaceChar(Gridiv,c_WGToBldgs(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBldgs)
  SurfaceChar(Gridiv,c_WGToEveTr(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToEveTr)
  SurfaceChar(Gridiv,c_WGToDecTr(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToDecTr)
  SurfaceChar(Gridiv,c_WGToGrass(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToGrass)
  SurfaceChar(Gridiv,c_WGToBSoil(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToBSoil)
  SurfaceChar(Gridiv,c_WGToWater(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToWater)
  SurfaceChar(Gridiv,c_WGToRunoff(WaterSurf))  = WGWaterDist_Coeff(iv5,cWG_ToRunoff)
  SurfaceChar(Gridiv,c_WGToSoilStore(WaterSurf))    = WGWaterDist_Coeff(iv5,cWG_ToSoilStore)

  ! ---- Find code for Snow surface (Snow) ----
  CALL CodeMatchSnow(rr,c_SnowCode)
  ! Transfer characteristics to SurfaceChar for Snow surface
  SurfaceChar(gridiv,c_SnowRMFactor) = Snow_Coeff(iv5,cs_SnowRMFactor)
  SurfaceChar(gridiv,c_SnowTMFactor) = Snow_Coeff(iv5,cs_SnowTMFactor)
  SurfaceChar(gridiv,c_SnowAlbMin)   = Snow_Coeff(iv5,cs_SnowAlbMin)
  SurfaceChar(gridiv,c_SnowAlbMax)   = Snow_Coeff(iv5,cs_SnowAlbMax)
  !SurfaceChar(gridiv,c_SnowAlb)      = Snow_Coeff(iv5,cs_SnowAlb)
  SurfaceChar(gridiv,c_SnowEmis)     = Snow_Coeff(iv5,cs_SnowEmis)
  SurfaceChar(gridiv,c_Snowtau_a)    = Snow_Coeff(iv5,cs_Snowtau_a)
  SurfaceChar(gridiv,c_Snowtau_f)    = Snow_Coeff(iv5,cs_Snowtau_f)
  SurfaceChar(gridiv,c_SnowPLimAlb)  = Snow_Coeff(iv5,cs_SnowPLimAlb)
  SurfaceChar(gridiv,c_SnowSDMin)    = Snow_Coeff(iv5,cs_SnowSDMin)
  SurfaceChar(gridiv,c_SnowSDMax)    = Snow_Coeff(iv5,cs_SnowSDMax)
  SurfaceChar(gridiv,c_Snowtau_r)    = Snow_Coeff(iv5,cs_Snowtau_r)
  SurfaceChar(gridiv,c_SnowCRWMin)   = Snow_Coeff(iv5,cs_SnowCRWMin)
  SurfaceChar(gridiv,c_SnowCRWMax)   = Snow_Coeff(iv5,cs_SnowCRWMax)
  SurfaceChar(gridiv,c_SnowPLimSnow) = Snow_Coeff(iv5,cs_SnowPLimSnow)
  SurfaceChar(gridiv,c_OHMCode_SWet(nsurf+1)) = Snow_Coeff(iv5,cs_OHMCode_SWet)
  SurfaceChar(gridiv,c_OHMCode_SDry(nsurf+1)) = Snow_Coeff(iv5,cs_OHMCode_SDry)
  SurfaceChar(gridiv,c_OHMCode_WWet(nsurf+1)) = Snow_Coeff(iv5,cs_OHMCode_WWet)
  SurfaceChar(gridiv,c_OHMCode_WDry(nsurf+1)) = Snow_Coeff(iv5,cs_OHMCode_WDry)
  SurfaceChar(gridiv,c_OHMThresh_SW(nsurf+1)) = Snow_Coeff(iv5,cs_OHMThresh_SW)
  SurfaceChar(gridiv,c_OHMThresh_WD(nsurf+1)) = Snow_Coeff(iv5,cs_OHMThresh_WD)

  ! ESTM code
  SurfaceChar(gridiv,c_ESTMCode(nsurf+1))     = Snow_Coeff(iv5,cs_ESTMCode)
  !    SurfaceChar(Gridiv,c_CpAnOHM(nsurf+1))           = Snow_Coeff(iv5,cs_CpAnOHM)   ! heat capacity, AnOHM TS
  !    SurfaceChar(Gridiv,c_KkAnOHM(nsurf+1))           = Snow_Coeff(iv5,cs_KkAnOHM)  ! heat conductivity, AnOHM TS
  !    SurfaceChar(Gridiv,c_ChAnOHM(nsurf+1))           = Snow_Coeff(iv5,cs_ChAnOHM)  ! bulk transfer coef., AnOHM TS
  ! Get OHM characteristics for Snow
  CALL CodeMatchOHM(Gridiv,(nsurf+1),'SWet')  !Summer wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SWet(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SWet(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SWet(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,(nsurf+1),'SDry')  !Summer dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_SDry(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_SDry(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_SDry(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,(nsurf+1),'WWet')  !Winter wet
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WWet(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WWet(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WWet(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a3)
  CALL CodeMatchOHM(Gridiv,(nsurf+1),'WDry')  !Winter dry
  ! Transfer OHM characteristics to SurfaceChar
  SurfaceChar(Gridiv,c_a1_WDry(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a1)
  SurfaceChar(Gridiv,c_a2_WDry(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a2)
  SurfaceChar(Gridiv,c_a3_WDry(nsurf+1))    = OHMCoefficients_Coeff(iv5,cO_a3)

  !Transfer ESTM characteristics to SurfaceChar
  DO iii=1,(nsurf+1)
     IF(SurfaceChar(Gridiv,c_ESTMCode(iii)) /= 0) THEN !If ESTM Code not equal to zero, use code as normal
        CALL CodeMatchESTM(Gridiv,iii)
        SurfaceChar(Gridiv,c_Surf_thick1(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick1)
        SurfaceChar(Gridiv,c_Surf_thick2(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick2)
        SurfaceChar(Gridiv,c_Surf_thick3(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick3)
        SurfaceChar(Gridiv,c_Surf_thick4(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick4)
        SurfaceChar(Gridiv,c_Surf_thick5(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick5)
        SurfaceChar(Gridiv,c_Surf_k1(iii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k1)
        SurfaceChar(Gridiv,c_Surf_k2(iii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k2)
        SurfaceChar(Gridiv,c_Surf_k3(iii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k3)
        SurfaceChar(Gridiv,c_Surf_k4(iii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k4)
        SurfaceChar(Gridiv,c_Surf_k5(iii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k5)
        SurfaceChar(Gridiv,c_Surf_rhoCp1(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp1)
        SurfaceChar(Gridiv,c_Surf_rhoCp2(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp2)
        SurfaceChar(Gridiv,c_Surf_rhoCp3(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp3)
        SurfaceChar(Gridiv,c_Surf_rhoCp4(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp4)
        SurfaceChar(Gridiv,c_Surf_rhoCp5(iii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp5)
        !Extra characteristics for Bldg surfaces
        IF(iii==BldgSurf) THEN
           SurfaceChar(Gridiv,c_Wall_thick1) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick1)
           SurfaceChar(Gridiv,c_Wall_thick2) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick2)
           SurfaceChar(Gridiv,c_Wall_thick3) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick3)
           SurfaceChar(Gridiv,c_Wall_thick4) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick4)
           SurfaceChar(Gridiv,c_Wall_thick5) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick5)
           SurfaceChar(Gridiv,c_Wall_k1)     = ESTMCoefficients_Coeff(iv5,cE_Wall_k1)
           SurfaceChar(Gridiv,c_Wall_k2)     = ESTMCoefficients_Coeff(iv5,cE_Wall_k2)
           SurfaceChar(Gridiv,c_Wall_k3)     = ESTMCoefficients_Coeff(iv5,cE_Wall_k3)
           SurfaceChar(Gridiv,c_Wall_k4)     = ESTMCoefficients_Coeff(iv5,cE_Wall_k4)
           SurfaceChar(Gridiv,c_Wall_k5)     = ESTMCoefficients_Coeff(iv5,cE_Wall_k5)
           SurfaceChar(Gridiv,c_Wall_rhoCp1) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp1)
           SurfaceChar(Gridiv,c_Wall_rhoCp2) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp2)
           SurfaceChar(Gridiv,c_Wall_rhoCp3) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp3)
           SurfaceChar(Gridiv,c_Wall_rhoCp4) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp4)
           SurfaceChar(Gridiv,c_Wall_rhoCp5) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp5)
           SurfaceChar(Gridiv,c_Internal_thick1) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick1)
           SurfaceChar(Gridiv,c_Internal_thick2) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick2)
           SurfaceChar(Gridiv,c_Internal_thick3) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick3)
           SurfaceChar(Gridiv,c_Internal_thick4) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick4)
           SurfaceChar(Gridiv,c_Internal_thick5) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick5)
           SurfaceChar(Gridiv,c_Internal_k1)     = ESTMCoefficients_Coeff(iv5,cE_Internal_k1)
           SurfaceChar(Gridiv,c_Internal_k2)     = ESTMCoefficients_Coeff(iv5,cE_Internal_k2)
           SurfaceChar(Gridiv,c_Internal_k3)     = ESTMCoefficients_Coeff(iv5,cE_Internal_k3)
           SurfaceChar(Gridiv,c_Internal_k4)     = ESTMCoefficients_Coeff(iv5,cE_Internal_k4)
           SurfaceChar(Gridiv,c_Internal_k5)     = ESTMCoefficients_Coeff(iv5,cE_Internal_k5)
           SurfaceChar(Gridiv,c_Internal_rhoCp1) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp1)
           SurfaceChar(Gridiv,c_Internal_rhoCp2) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp2)
           SurfaceChar(Gridiv,c_Internal_rhoCp3) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp3)
           SurfaceChar(Gridiv,c_Internal_rhoCp4) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp4)
           SurfaceChar(Gridiv,c_Internal_rhoCp5) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp5)
           SurfaceChar(Gridiv,c_nroom)           = ESTMCoefficients_Coeff(iv5,cE_nroom)
           SurfaceChar(Gridiv,c_alb_ibld)        = ESTMCoefficients_Coeff(iv5,cE_alb_ibld)
           SurfaceChar(Gridiv,c_em_ibld)         = ESTMCoefficients_Coeff(iv5,cE_em_ibld)
           SurfaceChar(Gridiv,c_CH_iwall)        = ESTMCoefficients_Coeff(iv5,cE_CH_iwall)
           SurfaceChar(Gridiv,c_CH_iroof)        = ESTMCoefficients_Coeff(iv5,cE_CH_iroof)
           SurfaceChar(Gridiv,c_CH_ibld)         = ESTMCoefficients_Coeff(iv5,cE_CH_ibld)
        ENDIF
        !If ESTM Code equals zero, use codes and surface fractions from SiteSelect.txt for Paved and Bldgs
     ELSEIF(iii==PavSurf .AND. SurfaceChar(Gridiv,c_ESTMCode(iii)) == 0) THEN
        DO ii=1,3   !for the 3x Paved ESTM classes
           CALL CodeMatchESTM_Class(Gridiv,iii,ii)
           SurfaceChar(Gridiv,c_Surf_thick1_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick1)
           SurfaceChar(Gridiv,c_Surf_thick2_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick2)
           SurfaceChar(Gridiv,c_Surf_thick3_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick3)
           SurfaceChar(Gridiv,c_Surf_thick4_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick4)
           SurfaceChar(Gridiv,c_Surf_thick5_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick5)
           SurfaceChar(Gridiv,c_Surf_k1_Paved(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k1)
           SurfaceChar(Gridiv,c_Surf_k2_Paved(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k2)
           SurfaceChar(Gridiv,c_Surf_k3_Paved(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k3)
           SurfaceChar(Gridiv,c_Surf_k4_Paved(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k4)
           SurfaceChar(Gridiv,c_Surf_k5_Paved(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k5)
           SurfaceChar(Gridiv,c_Surf_rhoCp1_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp1)
           SurfaceChar(Gridiv,c_Surf_rhoCp2_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp2)
           SurfaceChar(Gridiv,c_Surf_rhoCp3_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp3)
           SurfaceChar(Gridiv,c_Surf_rhoCp4_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp4)
           SurfaceChar(Gridiv,c_Surf_rhoCp5_Paved(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp5)
        ENDDO
     ELSEIF(iii==BldgSurf .AND. SurfaceChar(Gridiv,c_ESTMCode(iii)) == 0) THEN
        DO ii=1,5   !for the 5x Bldgs ESTM classes
           CALL CodeMatchESTM_Class(Gridiv,iii,ii)
           SurfaceChar(Gridiv,c_Surf_thick1_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick1)
           SurfaceChar(Gridiv,c_Surf_thick2_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick2)
           SurfaceChar(Gridiv,c_Surf_thick3_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick3)
           SurfaceChar(Gridiv,c_Surf_thick4_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick4)
           SurfaceChar(Gridiv,c_Surf_thick5_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_thick5)
           SurfaceChar(Gridiv,c_Surf_k1_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k1)
           SurfaceChar(Gridiv,c_Surf_k2_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k2)
           SurfaceChar(Gridiv,c_Surf_k3_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k3)
           SurfaceChar(Gridiv,c_Surf_k4_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k4)
           SurfaceChar(Gridiv,c_Surf_k5_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Surf_k5)
           SurfaceChar(Gridiv,c_Surf_rhoCp1_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp1)
           SurfaceChar(Gridiv,c_Surf_rhoCp2_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp2)
           SurfaceChar(Gridiv,c_Surf_rhoCp3_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp3)
           SurfaceChar(Gridiv,c_Surf_rhoCp4_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp4)
           SurfaceChar(Gridiv,c_Surf_rhoCp5_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Surf_rhoCp5)
           !Extra characteristics for Bldgs surface
           SurfaceChar(Gridiv,c_Wall_thick1_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick1)
           SurfaceChar(Gridiv,c_Wall_thick2_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick2)
           SurfaceChar(Gridiv,c_Wall_thick3_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick3)
           SurfaceChar(Gridiv,c_Wall_thick4_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick4)
           SurfaceChar(Gridiv,c_Wall_thick5_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_thick5)
           SurfaceChar(Gridiv,c_Wall_k1_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Wall_k1)
           SurfaceChar(Gridiv,c_Wall_k2_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Wall_k2)
           SurfaceChar(Gridiv,c_Wall_k3_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Wall_k3)
           SurfaceChar(Gridiv,c_Wall_k4_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Wall_k4)
           SurfaceChar(Gridiv,c_Wall_k5_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Wall_k5)
           SurfaceChar(Gridiv,c_Wall_rhoCp1_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp1)
           SurfaceChar(Gridiv,c_Wall_rhoCp2_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp2)
           SurfaceChar(Gridiv,c_Wall_rhoCp3_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp3)
           SurfaceChar(Gridiv,c_Wall_rhoCp4_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp4)
           SurfaceChar(Gridiv,c_Wall_rhoCp5_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Wall_rhoCp5)
           SurfaceChar(Gridiv,c_Internal_thick1_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick1)
           SurfaceChar(Gridiv,c_Internal_thick2_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick2)
           SurfaceChar(Gridiv,c_Internal_thick3_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick3)
           SurfaceChar(Gridiv,c_Internal_thick4_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick4)
           SurfaceChar(Gridiv,c_Internal_thick5_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_thick5)
           SurfaceChar(Gridiv,c_Internal_k1_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Internal_k1)
           SurfaceChar(Gridiv,c_Internal_k2_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Internal_k2)
           SurfaceChar(Gridiv,c_Internal_k3_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Internal_k3)
           SurfaceChar(Gridiv,c_Internal_k4_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Internal_k4)
           SurfaceChar(Gridiv,c_Internal_k5_Bldgs(ii))     = ESTMCoefficients_Coeff(iv5,cE_Internal_k5)
           SurfaceChar(Gridiv,c_Internal_rhoCp1_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp1)
           SurfaceChar(Gridiv,c_Internal_rhoCp2_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp2)
           SurfaceChar(Gridiv,c_Internal_rhoCp3_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp3)
           SurfaceChar(Gridiv,c_Internal_rhoCp4_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp4)
           SurfaceChar(Gridiv,c_Internal_rhoCp5_Bldgs(ii)) = ESTMCoefficients_Coeff(iv5,cE_Internal_rhoCp5)
           SurfaceChar(Gridiv,c_nroom_Bldgs(ii))           = ESTMCoefficients_Coeff(iv5,cE_nroom)
           SurfaceChar(Gridiv,c_alb_ibld_Bldgs(ii))        = ESTMCoefficients_Coeff(iv5,cE_alb_ibld)
           SurfaceChar(Gridiv,c_em_ibld_Bldgs(ii))         = ESTMCoefficients_Coeff(iv5,cE_em_ibld)
           SurfaceChar(Gridiv,c_CH_iwall_Bldgs(ii))        = ESTMCoefficients_Coeff(iv5,cE_CH_iwall)
           SurfaceChar(Gridiv,c_CH_iroof_Bldgs(ii))        = ESTMCoefficients_Coeff(iv5,cE_CH_iroof)
           SurfaceChar(Gridiv,c_CH_ibld_Bldgs(ii))         = ESTMCoefficients_Coeff(iv5,cE_CH_ibld)
        ENDDO
     ENDIF
  ENDDO

  ! ---- Find code for Surface conductances ----
  CALL CodeMatchConductance(rr,c_CondCode)
  ! Transfer conductance characteristics to SurfaceChar
  SurfaceChar(gridiv,c_GsG1)       = Conductance_Coeff(iv5,cc_GsG1)
  SurfaceChar(gridiv,c_GsG2)       = Conductance_Coeff(iv5,cc_GsG2)
  SurfaceChar(gridiv,c_GsG3)       = Conductance_Coeff(iv5,cc_GsG3)
  SurfaceChar(gridiv,c_GsG4)       = Conductance_Coeff(iv5,cc_GsG4)
  SurfaceChar(gridiv,c_GsG5)       = Conductance_Coeff(iv5,cc_GsG5)
  SurfaceChar(gridiv,c_GsG6)       = Conductance_Coeff(iv5,cc_GsG6)
  SurfaceChar(gridiv,c_GsTH)       = Conductance_Coeff(iv5,cc_GsTH)
  SurfaceChar(gridiv,c_GsTL)       = Conductance_Coeff(iv5,cc_GsTL)
  SurfaceChar(gridiv,c_GsS1)       = Conductance_Coeff(iv5,cc_GsS1)
  SurfaceChar(gridiv,c_GsS2)       = Conductance_Coeff(iv5,cc_GsS2)
  SurfaceChar(gridiv,c_GsKmax)     = Conductance_Coeff(iv5,cc_GsKmax)
  SurfaceChar(gridiv,c_gsModel)    = Conductance_Coeff(iv5,cc_gsModel)

  ! ---- Find code for Anthropogenic heat ----
  CALL CodeMatchAnthropogenic(rr,c_QFCode)
  ! Transfer Anthropogenic heat characteristics to SurfaceChar
  SurfaceChar(gridiv,c_BaseTHDD)          = Anthropogenic_Coeff(iv5,cA_BaseTHDD)
  SurfaceChar(gridiv,c_QF_A1)             = Anthropogenic_Coeff(iv5,cA_QF_A1)
  SurfaceChar(gridiv,c_QF_B1)             = Anthropogenic_Coeff(iv5,cA_QF_B1)
  SurfaceChar(gridiv,c_QF_C1)             = Anthropogenic_Coeff(iv5,cA_QF_C1)
  SurfaceChar(gridiv,c_QF_A2)             = Anthropogenic_Coeff(iv5,cA_QF_A2)
  SurfaceChar(gridiv,c_QF_B2)             = Anthropogenic_Coeff(iv5,cA_QF_B2)
  SurfaceChar(gridiv,c_QF_C2)             = Anthropogenic_Coeff(iv5,cA_QF_C2)
  SurfaceChar(gridiv,c_AHMin_WD)          = Anthropogenic_Coeff(iv5,cA_AHMin_WD)
  SurfaceChar(gridiv,c_AHMin_WE)          = Anthropogenic_Coeff(iv5,cA_AHMin_WE)
  SurfaceChar(gridiv,c_AHSlopeHeating_WD) = Anthropogenic_Coeff(iv5,cA_AHSlopeHeating_WD)
  SurfaceChar(gridiv,c_AHSlopeHeating_WE) = Anthropogenic_Coeff(iv5,cA_AHSlopeHeating_WE)
  SurfaceChar(gridiv,c_AHSlopeCooling_WD) = Anthropogenic_Coeff(iv5,cA_AHSlopeCooling_WD)
  SurfaceChar(gridiv,c_AHSlopeCooling_WE) = Anthropogenic_Coeff(iv5,cA_AHSlopeCooling_WE)
  SurfaceChar(gridiv,c_TCriticHeating_WD) = Anthropogenic_Coeff(iv5,cA_TCriticHeating_WD)
  SurfaceChar(gridiv,c_TCriticHeating_WE) = Anthropogenic_Coeff(iv5,cA_TCriticHeating_WE)
  SurfaceChar(gridiv,c_TCriticCooling_WD) = Anthropogenic_Coeff(iv5,cA_TCriticCooling_WD)
  SurfaceChar(gridiv,c_TCriticCooling_WE) = Anthropogenic_Coeff(iv5,cA_TCriticCooling_WE)
  SurfaceChar(gridiv,c_EnProfWD)          = Anthropogenic_Coeff(iv5,cA_EnProfWD)
  SurfaceChar(gridiv,c_EnProfWE)          = Anthropogenic_Coeff(iv5,cA_EnProfWE)
  SurfaceChar(gridiv,c_CO2mWD)            = Anthropogenic_Coeff(iv5,cA_CO2mWD)
  SurfaceChar(gridiv,c_CO2mWE)            = Anthropogenic_Coeff(iv5,cA_CO2mWE)
  SurfaceChar(gridiv,c_TraffProfWD)       = Anthropogenic_Coeff(iv5,cA_TraffProfWD)
  SurfaceChar(gridiv,c_TraffProfWE)       = Anthropogenic_Coeff(iv5,cA_TraffProfWE)
  SurfaceChar(gridiv,c_PopProfWD)         = Anthropogenic_Coeff(iv5,cA_PopProfWD)
  SurfaceChar(gridiv,c_PopProfWE)         = Anthropogenic_Coeff(iv5,cA_PopProfWE)
  SurfaceChar(gridiv,c_MinQFMetab)        = Anthropogenic_Coeff(iv5,cA_MinQFMetab)
  SurfaceChar(gridiv,c_MaxQFMetab)        = Anthropogenic_Coeff(iv5,cA_MaxQFMetab)
  SurfaceChar(gridiv,c_FrFossilFuel_Heat) = Anthropogenic_Coeff(iv5,cA_FrFossilFuel_Heat)
  SurfaceChar(gridiv,c_FrFossilFuel_NonHeat) = Anthropogenic_Coeff(iv5,cA_FrFossilFuel_NonHeat)
  SurfaceChar(gridiv,c_EF_umolCO2perJ)    = Anthropogenic_Coeff(iv5,cA_EF_umolCO2perJ)
  SurfaceChar(gridiv,c_EnEF_v_Jkm)        = Anthropogenic_Coeff(iv5,cA_EnEF_v_Jkm)
  SurfaceChar(gridiv,c_FcEF_v_kgkm)       = Anthropogenic_Coeff(iv5,cA_FcEF_v_kgkm)
  SurfaceChar(gridiv,c_TrafficUnits)      = Anthropogenic_Coeff(iv5,cA_TrafficUnits)


  ! ---- Find code for Irrigation ----
  CALL CodeMatchIrrigation(rr,c_IrrCode)
  ! Transfer Irrigation characteristics to SurfaceChar
  SurfaceChar(gridiv,c_IeStart)     = Irrigation_Coeff(iv5,cIr_IeStart)
  SurfaceChar(gridiv,c_IeEnd)       = Irrigation_Coeff(iv5,cIr_IeEnd)
  SurfaceChar(gridiv,c_IntWU)       = Irrigation_Coeff(iv5,cIr_IntWU)
  SurfaceChar(gridiv,c_Faut)        = Irrigation_Coeff(iv5,cIr_Faut)
  SurfaceChar(gridiv,c_Ie_a)        = Irrigation_Coeff(iv5,cIr_Ie_a1:cIr_Ie_a3)
  SurfaceChar(gridiv,c_Ie_m)        = Irrigation_Coeff(iv5,cIr_Ie_m1:cIr_Ie_m3)
  SurfaceChar(gridiv,c_DayWat)      = Irrigation_Coeff(iv5,cIr_DayWat1:cIr_DayWat7)
  SurfaceChar(gridiv,c_DayWatPer)   = Irrigation_Coeff(iv5,cIr_DayWatPer1:cIr_DayWatPer7)

  ! ---- Find code for Hourly Profiles ----
  ! Energy use (weekdays)
  CALL CodeMatchProf(gridiv,c_EnProfWD)
  SurfaceChar(gridiv,c_HrProfEnUseWD) = Profiles_Coeff(iv5,cPr_Hours)
  ! Energy use (weekends)
  CALL CodeMatchProf(gridiv,c_EnProfWE)
  SurfaceChar(gridiv,c_HrProfEnUseWE) = Profiles_Coeff(iv5,cPr_Hours)
  ! Water use profile (manual, weekdays)
  CALL CodeMatchProf(gridiv,c_WProfManuWD)
  SurfaceChar(gridiv,c_HrProfWUManuWD)  = Profiles_Coeff(iv5,cPr_Hours)
  ! Water use profile (manual, weekends)
  CALL CodeMatchProf(gridiv,c_WProfManuWE)
  SurfaceChar(gridiv,c_HrProfWUManuWE)  = Profiles_Coeff(iv5,cPr_Hours)
  ! Water use profile (automatic, weekdays)
  CALL CodeMatchProf(gridiv,c_WProfAutoWD)
  SurfaceChar(gridiv,c_HrProfWUAutoWD) = Profiles_Coeff(iv5,cPr_Hours)
  ! Water use profile (automatic, weekends)
  CALL CodeMatchProf(gridiv,c_WProfAutoWE)
  SurfaceChar(gridiv,c_HrProfWUAutoWE) = Profiles_Coeff(iv5,cPr_Hours)
  ! Snow clearing profile (weekdays)
  CALL CodeMatchProf(gridiv,c_SnowProfWD)
  SurfaceChar(gridiv,c_HrProfSnowCWD) = Profiles_Coeff(iv5,cPr_Hours)
  ! Snow clearing profile (weekends)
  CALL CodeMatchProf(gridiv,c_SnowProfWE)
  SurfaceChar(gridiv,c_HrProfSnowCWE) = Profiles_Coeff(iv5,cPr_Hours)
  !Human activity (weekdays)
  CALL CodeMatchProf(gridiv,c_CO2mWD)
  SurfaceChar(gridiv,c_HrProfHumActivityWD) = Profiles_Coeff(iv5,cPr_Hours)
  !Human activity (weekends)
  CALL CodeMatchProf(gridiv,c_CO2mWE)
  SurfaceChar(gridiv,c_HrProfHumActivityWE) = Profiles_Coeff(iv5,cPr_Hours)
  !Traffic (weekdays)
  CALL CodeMatchProf(gridiv,c_TraffProfWD)
  SurfaceChar(gridiv,c_HrProfTraffWD) = Profiles_Coeff(iv5,cPr_Hours)
  !Traffic (weekends)
  CALL CodeMatchProf(gridiv,c_TraffProfWE)
  SurfaceChar(gridiv,c_HrProfTraffWE) = Profiles_Coeff(iv5,cPr_Hours)
  !Population (weekdays)
  CALL CodeMatchProf(gridiv,c_PopProfWD)
  SurfaceChar(gridiv,c_HrProfPopWD) = Profiles_Coeff(iv5,cPr_Hours)
  !Population (weekends)
  CALL CodeMatchProf(gridiv,c_PopProfWE)
  SurfaceChar(gridiv,c_HrProfPopWE) = Profiles_Coeff(iv5,cPr_Hours)


  ! TS 05 Jul 2018: No longer needed as interpolation is done through specific subroutines at each required instant
  ! the below is commented out by TS 05 Jul 2018
  ! ! ---- Interpolate Hourly Profiles to model timestep and normalise
  ! TstepProfiles(Gridiv,:,:) = -999   !Initialise TstepProfiles
  ! ! Energy use
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_EnUseWD,c_HrProfEnUseWD)
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_EnUseWE,c_HrProfEnUseWE)
  !
  ! ! For energy use, normalise so the AVERAGE of the multipliers is equal to 1
  ! TstepProfiles(Gridiv,cTP_EnUseWD,:) = TstepProfiles(Gridiv,cTP_EnUseWD,:) / SUM(TstepProfiles(Gridiv,cTP_EnUseWD,:))*24*nsh_real
  ! TstepProfiles(Gridiv,cTP_EnUseWE,:) = TstepProfiles(Gridiv,cTP_EnUseWE,:) / SUM(TstepProfiles(Gridiv,cTP_EnUseWE,:))*24*nsh_real
  !
  ! ! Water use
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_WUManuWD,c_HrProfWUManuWD)
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_WUManuWE,c_HrProfWUManuWE)
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_WUAutoWD,c_HrProfWUAutoWD)
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_WUAutoWE,c_HrProfWUAutoWE)
  ! ! For water use, normalise so the SUM of the multipliers is equal to 1 (profile is multiplied by daily water use)
  ! TstepProfiles(Gridiv,cTP_WUManuWD,:) = TstepProfiles(Gridiv,cTP_WUManuWD,:) / SUM(TstepProfiles(Gridiv,cTP_WUManuWD,:))
  ! TstepProfiles(Gridiv,cTP_WUManuWE,:) = TstepProfiles(Gridiv,cTP_WUManuWE,:) / SUM(TstepProfiles(Gridiv,cTP_WUManuWE,:))
  ! TstepProfiles(Gridiv,cTP_WUAutoWD,:) = TstepProfiles(Gridiv,cTP_WUAutoWD,:) / SUM(TstepProfiles(Gridiv,cTP_WUAutoWD,:))
  ! TstepProfiles(Gridiv,cTP_WUAutoWE,:) = TstepProfiles(Gridiv,cTP_WUAutoWE,:) / SUM(TstepProfiles(Gridiv,cTP_WUAutoWE,:))
  !
  ! ! Human activity for CO2 calculations
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_HumActivityWD,c_HrProfHumActivityWD)
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_HumActivityWE,c_HrProfHumActivityWE)
  !
  ! ! For human activity, check values are between 1 (night) and 2 (day)
  ! IF(ANY(TstepProfiles(Gridiv,cTP_HumActivityWD,:) < 1 .OR. TstepProfiles(Gridiv,cTP_HumActivityWD,:) > 2)) THEN
  !    CALL ErrorHint(70,'Profile value for human activity (WD) exceeds allowed range 1-2.',NotUsed,NotUsed,notUsedI)
  ! ENDIF
  ! IF(ANY(TstepProfiles(Gridiv,cTP_HumActivityWE,:) < 1 .OR. TstepProfiles(Gridiv,cTP_HumActivityWE,:) > 2)) THEN
  !    CALL ErrorHint(70,'Profile value for human activity (WE) exceeds allowed range 1-2.',NotUsed,NotUsed,notUsedI)
  ! ENDIF
  !
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_TraffProfWD,c_HrProfTraffWD)
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_TraffProfWE,c_HrProfTraffWE)
  ! ! For traffic, normalise so the AVERAGE of the multipliers is equal to 1
  ! TstepProfiles(Gridiv,cTP_TraffProfWD,:) = TstepProfiles(Gridiv,cTP_TraffProfWD,:) &
  !      / SUM(TstepProfiles(Gridiv,cTP_TraffProfWD,:))*24*nsh_real
  ! TstepProfiles(Gridiv,cTP_TraffProfWE,:) = TstepProfiles(Gridiv,cTP_TraffProfWE,:) &
  !      / SUM(TstepProfiles(Gridiv,cTP_TraffProfWE,:))*24*nsh_real
  !
  ! ! Population for CO2 calculations
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_PopProfWD,c_HrProfPopWD)
  ! CALL SUEWS_InterpHourlyProfiles(Gridiv,cTP_PopProfWE,c_HrProfPopWE)

END SUBROUTINE InitializeSurfaceCharacteristics


!----------------------------------------------------------------------------------------------
!Calculates the initial conditions for each grid on the first year of run
!Made by sg feb 2012 -
!Latest modified:
!20 Oct 2014, LJ: Saves to slot 0 of the output matrix
!06 Nov 2014 HCW
!----------------------------------------------------------------------------------------------


!-------------------------------------------------------------------------
SUBROUTINE InitialState(GridName,year_int,Gridiv,NumberOfGrids)
  ! Last modified HCW 13 Jan 2017 - Major changes to InitialConditions file
  ! Last modified HCW 24 May 2016 - Removed unused argument year_txt
  ! Last modified HCW 03 Jul 2015 - Added initial conditions albEveTr0 and albGrass0
  ! Last modified HCW 03 Dec 2014
  !------------------------------------------------------------------------

  USE AllocateArray
  USE data_in
  USE ColNamesModelDailyState
  USE defaultNotUsed
  USE FileName
  USE gis_data
  USE InitialCond
  USE mod_z
  USE resist
  USE snowMod
  USE sues_data
  USE time
  USE InitialCond
  use DailyState_module,only:update_WaterUse_X

  IMPLICIT NONE

  CHARACTER(len=20):: GridName    !Name of the evaluated grid
  CHARACTER(len=4)::  year_txt
  INTEGER:: NumberOfGrids

  CHARACTER(len=150):: fileInit   !Initial conditions filename
  INTEGER::DaysSinceRain,Gridiv,& !number of days since rain, grid number,
       gamma1,gamma2          !switches related to cooling and heating degree days
  INTEGER::wd,seas,date,mb,&      !weekday information, season, date, month
       year_int,switch=0,&    !year as an integer, switch related to previous day
       id_next           !next day,counter in irrigation calculations

  REAL (KIND(1d0))::PavedState,BldgsState,EveTrState,DecTrState,GrassState,BSoilState,WaterState,&
       SnowFracPaved,SnowFracBldgs,SnowFracEveTr,SnowFracDecTr,          &
       SnowFracGrass,SnowFracBSoil,SnowFracWater,                        &
       SnowDensPaved,SnowDensBldgs,SnowDensEveTr,SnowDensDecTr,          &
       SnowDensGrass,SnowDensBSoil,SnowDensWater

  INTEGER:: LeavesOutInitially   !Allows for quick setting of veg-related initial conditions for full leaf-out (1) or leaf-off (0)
  INTEGER:: SnowInitially        !Allows for quick setting of snow-related initial conditions for no snow initially (0)

  INTEGER:: GridsInitialised=0   ! Number of grids initialised at start of model run
  INTEGER:: YearsInitialised=0   ! Number of years initialised at start of model run
  INTEGER:: dayofWeek_id(3)
  REAL(KIND(1d0)):: NormalizeVegChar  !Function

  ! Define InitialConditions namelist ---------------------------------------
  NAMELIST/InitialConditions/DaysSinceRain,&
       Temp_C0,&
                                !ID_Prev,&  !Now calculated from met forcing file
       LeavesOutInitially,&
       GDD_1_0,&
       GDD_2_0,&
       LAIinitialEveTr,&
       LAIinitialDecTr,&
       LAIinitialGrass,&
       AlbEveTr0,&
       AlbDecTr0,&
       AlbGrass0,&
       DecidCap0,&
       Porosity0,&
       PavedState,&
       BldgsState,&
       EveTrState,&
       DecTrState,&
       GrassState,&
       BSoilState,&
       WaterState,&
       SoilStorePavedState,&
       SoilStoreBldgsState,&
       SoilStoreEveTrState,&
       SoilStoreDecTrState,&
       SoilStoreGrassState,&
       SoilStoreBSoilState,&
       SnowInitially,&
       SnowWaterPavedState,&
       SnowWaterBldgsState,&
       SnowWaterEveTrState,&
       SnowWaterDecTrState,&
       SnowWaterGrassState,&
       SnowWaterBSoilState,&
       SnowWaterWaterState,&
       SnowPackPaved,&
       SnowPackBldgs,&
       SnowPackEveTr,&
       SnowPackDecTr,&
       SnowPackGrass,&
       SnowPackBSoil,&
       SnowPackWater,&
       SnowFracPaved,&
       SnowFracBldgs,&
       SnowFracEveTr,&
       SnowFracDecTr,&
       SnowFracGrass,&
       SnowFracBSoil,&
       SnowFracWater,&
       SnowDensPaved,&
       SnowDensBldgs,&
       SnowDensEveTr,&
       SnowDensDecTr,&
       SnowDensGrass,&
       SnowDensBSoil,&
       SnowDensWater,&
       SnowAlb0!,&
  ! BoInit ! removed as no longer needed by AnOHM

  ! Initialise namelist to NAN ----------------------------------------------
  DaysSinceRain=INT(NAN)
  Temp_C0=NAN
  LeavesOutInitially=INT(NAN)
  GDD_1_0=NAN
  GDD_2_0=NAN
  LAIinitialEveTr=NAN
  LAIinitialDecTr=NAN
  LAIinitialGrass=NAN
  AlbEveTr0=NAN
  AlbDecTr0=NAN
  AlbGrass0=NAN
  DecidCap0=NAN
  Porosity0=NAN
  PavedState=NAN
  BldgsState=NAN
  EveTrState=NAN
  DecTrState=NAN
  GrassState=NAN
  BSoilState=NAN
  WaterState=NAN
  SoilStorePavedState=NAN
  SoilStoreBldgsState=NAN
  SoilStoreEveTrState=NAN
  SoilStoreDecTrState=NAN
  SoilStoreGrassState=NAN
  SoilStoreBSoilState=NAN
  SnowInitially=INT(NAN)
  SnowWaterPavedState=NAN
  SnowWaterBldgsState=NAN
  SnowWaterEveTrState=NAN
  SnowWaterDecTrState=NAN
  SnowWaterGrassState=NAN
  SnowWaterBSoilState=NAN
  SnowWaterWaterState=NAN
  SnowPackPaved=NAN
  SnowPackBldgs=NAN
  SnowPackEveTr=NAN
  SnowPackDecTr=NAN
  SnowPackGrass=NAN
  SnowPackBSoil=NAN
  SnowPackWater=NAN
  SnowFracPaved=NAN
  SnowFracBldgs=NAN
  SnowFracEveTr=NAN
  SnowFracDecTr=NAN
  SnowFracGrass=NAN
  SnowFracBSoil=NAN
  SnowFracWater=NAN
  SnowDensPaved=NAN
  SnowDensBldgs=NAN
  SnowDensEveTr=NAN
  SnowDensDecTr=NAN
  SnowDensGrass=NAN
  SnowDensBSoil=NAN
  SnowDensWater=NAN
  SnowAlb0=NAN
  ! BoInit=NAN

  WRITE(year_txt,'(I4)') year_int  !Get year as a text string

  ! Define InitialConditions file -------------------------------------------
  FileInit=TRIM(FileInputPath)//TRIM("InitialConditions")//TRIM(GridName)//'.nml'
  ! On very first InitialConditions for each grid, can use one initial conditions file specified for all grids
  IF(MultipleInitFiles == 0 .AND. YearsInitialised ==0 ) THEN
     FileInit=TRIM(FileInputPath)//TRIM("InitialConditions")//TRIM(FileCode)//'_'//TRIM(year_txt)//'.nml'
     GridsInitialised = GridsInitialised+1
     IF(GridsInitialised == NumberOfGrids) THEN
        YearsInitialised=YearsInitialised+1
        GridsInitialised=0   !reset GridsInitialised
     ENDIF
  ENDIF
  !write(*,*) TRIM(FileInit)

  ! Open, read and close InitialConditions file -----------------------------
  OPEN(56,File=TRIM(FileInit),err=600,status='old')
  READ(56,iostat=ios_out,nml=InitialConditions,err=601)
  CLOSE(56)

  ! Write InitialConditions to FileChoices ----------------------------------
  FileChoices=TRIM(FileOutputPath)//TRIM(FileCode)//'_FileChoices.txt'
  OPEN(12,file=FileChoices,position='append')
  WRITE(12,*) '----- '//TRIM("InitialConditions")//TRIM(GridName)//'.nml'//' -----'
  WRITE(12,nml=InitialConditions)
  CLOSE(12)


  !--------------------------------------------------------------------------
  ! Check initial conditions and assign values if not provided --------------

  ! Calculate previous day --------------------------------------------------
  id_prev = INT(MetForcingData(1,2,Gridiv)) - 1

  ! If no. days since rainfall unknown, set to zero -------------------------
  IF(DaysSinceRain == INT(NAN)) DaysSinceRain = 0

  ! If average temperature for previous day unknown, use average of first day
  IF(Temp_C0 == NAN) Temp_C0=SUM(MetForcingData(1:(24*nsh),12,Gridiv))/(24*nsh)

  ! Set vegetation-related initial conditions -------------------------------
  ! If LeavesOutInitially is -999, don't use and check all required conditions have been provided
  IF(LeavesOutInitially == INT(NAN)) THEN
     IF(GDD_1_0 == NAN .OR. GDD_2_0 == NAN) THEN
        CALL ErrorHint(36,'Specify values for GDD_1_0 and GDD_2_0.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(LAIinitialEveTr == NAN .OR. LAIinitialDecTr == NAN .OR. LAIinitialGrass == NAN) THEN
        CALL ErrorHint(36,'Specify initial values for LAI for all vegetated surface types.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(AlbEveTr0 == NAN .OR. AlbDecTr0 == NAN .OR. AlbGrass0 == NAN) THEN
        CALL ErrorHint(36,'Specify initial values for albedo for all vegetated surface types.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(DecidCap0 == NAN) THEN
        CALL ErrorHint(36,'Specify DecidCap0.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(Porosity0 == NAN) THEN
        CALL ErrorHint(36,'Specify Porosity0.', notUsed,notUsed,notUsedI)
     ENDIF
  ELSEIF(LeavesOutInitially == 1) THEN   !If leaves out, set to summertime values using SUEWS_Veg.txt
     GDD_1_0 = NormalizeVegChar(c_GDDFull,Gridiv)
     GDD_2_0 = 0
     LAIinitialEveTr = SurfaceChar(Gridiv,c_LAIMax(ivConif))   !Max LAI
     LAIinitialDecTr = SurfaceChar(Gridiv,c_LAIMax(ivDecid))
     LAIinitialGrass = SurfaceChar(Gridiv,c_LAIMax(ivGrass))
     AlbEveTr0 = SurfaceChar(Gridiv,c_AlbMax(ConifSurf))       !Max albedo
     AlbDecTr0 = SurfaceChar(Gridiv,c_AlbMax(DecidSurf))
     AlbGrass0 = SurfaceChar(Gridiv,c_AlbMax(GrassSurf))
     DecidCap0 = SurfaceChar(Gridiv,c_StorMax(DecidSurf))      !Max storage capacity (DecTr only)
     Porosity0 = SurfaceChar(Gridiv,c_PorosityMin(ivDecid))  !Min porosity (DecTr only)
  ELSEIF(LeavesOutInitially == 0) THEN   !If leaves off, set to wintertime values using SUEWS_Veg.txt
     GDD_1_0 = 0
     GDD_2_0 = NormalizeVegChar(c_SDDFull,Gridiv)
     LAIinitialEveTr = SurfaceChar(Gridiv,c_LAIMin(ivConif))   !Min LAI
     LAIinitialDecTr = SurfaceChar(Gridiv,c_LAIMin(ivDecid))
     LAIinitialGrass = SurfaceChar(Gridiv,c_LAIMin(ivGrass))
     AlbEveTr0 = SurfaceChar(Gridiv,c_AlbMin(ConifSurf))       !Min albedo
     AlbDecTr0 = SurfaceChar(Gridiv,c_AlbMin(DecidSurf))
     AlbGrass0 = SurfaceChar(Gridiv,c_AlbMin(GrassSurf))
     DecidCap0 = SurfaceChar(Gridiv,c_StorMin(DecidSurf))      !Min storage capacity (DecTr only)
     Porosity0 = SurfaceChar(Gridiv,c_PorosityMax(ivDecid))  !Max porosity (DecTr only)
  ELSE
     CALL ErrorHint(36,'LeavesOutInitially must be 0, 1, or -999 (or omitted from InitialConditions namelist)', &
          notUsed,notUsed,notUsedI)
  ENDIF

  ! If surface wetness states unknown, set to zero --------------------------
  IF(PavedState == NAN) PavedState = 0
  IF(BldgsState == NAN) BldgsState = 0
  IF(EveTrState == NAN) EveTrState = 0
  IF(DecTrState == NAN) DecTrState = 0
  IF(GrassState == NAN) GrassState = 0
  IF(BSoilState == NAN) BSoilState = 0
  ! except for water surface - set using WaterDepth in SUEWS_Water.txt
  IF(WaterState == NAN) WaterState = SurfaceChar(Gridiv,c_WaterDepth)

  ! Check initial soil moisture states are provided -------------------------
  IF(SoilStorePavedState == NAN .OR. SoilStoreBldgsState == NAN .OR. SoilStoreEveTrState == NAN .OR. &
       SoilStoreDecTrState == NAN .OR. SoilStoreGrassState == NAN .OR. SoilStoreBSoilState == NAN) THEN
     CALL ErrorHint(36,'Initial soil moisture must be provided for all surface types except water.', notUsed,notUsed,notUsedI)
  ENDIF

  ! Set snow-related initial conditions -------------------------------
  ! If snow part not used, or no snow initially, set all snow-related initial conditions to zero
  IF(SnowUse == 0 .OR. SnowInitially == 0) THEN
     SnowWaterPavedState = 0
     SnowWaterBldgsState = 0
     SnowWaterEveTrState = 0
     SnowWaterDecTrState = 0
     SnowWaterGrassState = 0
     SnowWaterBSoilState = 0
     SnowWaterWaterState = 0
     SnowPackPaved = 0
     SnowPackBldgs = 0
     SnowPackEveTr = 0
     SnowPackDecTr = 0
     SnowPackGrass = 0
     SnowPackBSoil = 0
     SnowPackWater = 0
     SnowFracPaved = 0
     SnowFracBldgs = 0
     SnowFracEveTr = 0
     SnowFracDecTr = 0
     SnowFracGrass = 0
     SnowFracBSoil = 0
     SnowFracWater = 0
     SnowDensPaved = 0
     SnowDensBldgs = 0
     SnowDensEveTr = 0
     SnowDensDecTr = 0
     SnowDensGrass = 0
     SnowDensBSoil = 0
     SnowDensWater = 0
     SnowAlb0 = 0
  ELSEIF(SnowInitially == INT(NAN)) THEN   !Check all required snow-related conditions are provided
     IF(SnowWaterPavedState == NAN .OR. SnowWaterBldgsState == NAN .OR. SnowWaterEveTrState == NAN .OR. &
          SnowWaterDecTrState == NAN .OR. SnowWaterGrassState == NAN .OR. SnowWaterBSoilState == NAN .OR. &
          SnowWaterWaterState == NAN) THEN
        CALL ErrorHint(36,'Specify SnowWater state for all 7 surface types.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(SnowPackPaved == NAN .OR. SnowPackBldgs == NAN .OR. SnowPackEveTr == NAN .OR. &
          SnowPackDecTr == NAN .OR. SnowPackGrass == NAN .OR. SnowPackBSoil == NAN .OR. &
          SnowPackWater == NAN) THEN
        CALL ErrorHint(36,'Specify SnowPack for all 7 surface types.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(SnowFracPaved == NAN .OR. SnowFracBldgs == NAN .OR. SnowFracEveTr == NAN .OR. &
          SnowFracDecTr == NAN .OR. SnowFracGrass == NAN .OR. SnowFracBSoil == NAN .OR. &
          SnowFracWater == NAN) THEN
        CALL ErrorHint(36,'Specify SnowFrac for all 7 surface types.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(SnowDensPaved == NAN .OR. SnowDensBldgs == NAN .OR. SnowDensEveTr == NAN .OR. &
          SnowDensDecTr == NAN .OR. SnowDensGrass == NAN .OR. SnowDensBSoil == NAN .OR. &
          SnowDensWater == NAN) THEN
        CALL ErrorHint(36,'Specify SnowDens for all 7 surface types.', notUsed,notUsed,notUsedI)
     ENDIF
     IF(SnowAlb0 == NAN) THEN
        CALL ErrorHint(36,'Specify SnowAlb0.', notUsed,notUsed,notUsedI)
     ENDIF
  ELSE
     CALL ErrorHint(36,'SnowInitially must be 0 or -999 (or omitted from InitialConditions namelist)', &
          notUsed,notUsed,notUsedI)
  ENDIF

  ! removed as no longer needed, TS 30 Jan 2018
  ! ! If AnOHM option selected, check initial Bowen ratio is provided ---------
  ! IF(StorageHeatMethod==3 .AND. BoInit == NAN) THEN
  !    CALL ErrorHint(36,'Specify BoInit for AnOHM calculations.', notUsed,notUsed,notUsedI)
  ! ENDIF

  ! -------------------------------------------------------------------------
  ! -------------------------------------------------------------------------

  ! Previous day DOY number (needed in file allocations)
  IF(id_prev>=364) id_prev=0  !If previous day is larger than 364, set this to zero

  ! Save initial conditions to ModelDailyState array ------------------------
  ModelDailyState(Gridiv,cMDS_id_prev) = id_prev
  ModelDailyState(Gridiv,cMDS_LAIInitialEveTr) = LAIInitialEveTr
  ModelDailyState(Gridiv,cMDS_LAIInitialDecTr) = LAIInitialDecTr
  ModelDailyState(Gridiv,cMDS_LAIInitialGrass) = LAIInitialGrass
  ModelDailyState(Gridiv,cMDS_GDD1_0) = GDD_1_0
  ModelDailyState(Gridiv,cMDS_GDD2_0) = GDD_2_0
  ModelDailyState(Gridiv,cMDS_GDDMin) =  90   !QUESTION: Going to check for minimum GDD
  ModelDailyState(Gridiv,cMDS_GDDMax) = -90   !QUESTION: Going to check for maximum GDD
  ModelDailyState(Gridiv,cMDS_albEveTr)    = AlbEveTr0
  ModelDailyState(Gridiv,cMDS_albDecTr)    = AlbDecTr0
  ModelDailyState(Gridiv,cMDS_albGrass)    = AlbGrass0
  ModelDailyState(Gridiv,cMDS_porosity)    = Porosity0
  ModelDailyState(Gridiv,cMDS_DecidCap)    = DecidCap0

  ModelDailyState(Gridiv,cMDS_SnowfallCum) = 0 !!Check this

  ModelDailyState(Gridiv,cMDS_DaysSinceRain) = REAL(DaysSinceRain,KIND(1d0))
  ModelDailyState(Gridiv,cMDS_TempC) = Temp_C0
  ! Assume that the temperature has been the same for the previous days
  ModelDailyState(Gridiv,cMDS_TempCOld1) = Temp_C0
  ModelDailyState(Gridiv,cMDS_TempCOld2) = Temp_C0
  ModelDailyState(Gridiv,cMDS_TempCOld3) = Temp_C0

  ! -- Anthropogenic heat flux initializations --
  ! Need to get BaseTHDD from SurfaceChar, as info not transferred until SUEWS_Translate called
  BaseTHDD = SurfaceChar(Gridiv,c_BaseTHDD)

  IF(EmissionsMethod>=0) THEN
     !Calculations related to heating and cooling degree days (BaseT is used always)
     IF ((Temp_C0-BaseTHDD)>=0) THEN   !Cooling
        gamma2=1
     ELSE
        gamma2=0
     ENDIF
     IF ((BaseTHDD-Temp_C0)>=0) THEN   !Heating
        gamma1=1
     ELSE
        gamma1=0
     ENDIF
     ModelDailyState(Gridiv,cMDS_HDD1) = gamma1*(BaseTHDD-Temp_C0) ! Heating
     ModelDailyState(Gridiv,cMDS_HDD2) = gamma2*(Temp_C0-BaseTHDD) ! Cooling
  ENDIF

  ! -- Save snow density and snow albedo info in InitialConditions to ModelDailyState array --
  ModelDailyState(Gridiv,cMDS_SnowDens(PavSurf))    = SnowDensPaved
  ModelDailyState(Gridiv,cMDS_SnowDens(BldgSurf))   = SnowDensBldgs
  ModelDailyState(Gridiv,cMDS_SnowDens(ConifSurf))  = SnowDensEveTr
  ModelDailyState(Gridiv,cMDS_SnowDens(DecidSurf))  = SnowDensDecTr
  ModelDailyState(Gridiv,cMDS_SnowDens(GrassSurf))  = SnowDensGrass
  ModelDailyState(Gridiv,cMDS_SnowDens(BSoilSurf))  = SnowDensBSoil
  ModelDailyState(Gridiv,cMDS_SnowDens(WaterSurf))  = SnowDensWater

  ModelDailyState(Gridiv,cMDS_SnowAlb)  = SnowAlb0

  ! -------------------------------------------------------------------------

  ! Saving to ModelOutputData array -----------------------------------------

  ! -- Initial wetness status of each surface (above ground) --
  ModelOutputData(0,cMOD_State(PavSurf),   Gridiv) = PavedState
  ModelOutputData(0,cMOD_State(BldgSurf),  Gridiv) = BldgsState
  ModelOutputData(0,cMOD_State(ConifSurf), Gridiv) = EveTrState
  ModelOutputData(0,cMOD_State(DecidSurf), Gridiv) = DecTrState
  ModelOutputData(0,cMOD_State(GrassSurf), Gridiv) = GrassState
  ModelOutputData(0,cMOD_State(BSoilSurf), Gridiv) = BSoilState
  ModelOutputData(0,cMOD_State(WaterSurf), Gridiv) = WaterState

  ! -- Initial soil stores for each surface (below ground) --
  ModelOutputData(0,cMOD_SoilState(PavSurf),   Gridiv) = SoilStorePavedState
  ModelOutputData(0,cMOD_SoilState(BldgSurf),  Gridiv) = SoilStoreBldgsState
  ModelOutputData(0,cMOD_SoilState(ConifSurf), Gridiv) = SoilStoreEveTrstate
  ModelOutputData(0,cMOD_SoilState(DecidSurf), Gridiv) = SoilStoreDecTrState
  ModelOutputData(0,cMOD_SoilState(GrassSurf), Gridiv) = SoilStoreGrassState
  ModelOutputData(0,cMOD_SoilState(BSoilSurf), Gridiv) = SoilStoreBSoilState
  ModelOutputData(0,cMOD_SoilState(WaterSurf), Gridiv) = 0 ! No soil layer for water surface

  ! -- Initial liquid (melted) water for each surface --
  ModelOutputData(0,cMOD_SnowWaterState(PavSurf),   Gridiv) = SnowWaterPavedState
  ModelOutputData(0,cMOD_SnowWaterState(BldgSurf),  Gridiv) = SnowWaterBldgsState
  ModelOutputData(0,cMOD_SnowWaterState(ConifSurf), Gridiv) = SnowWaterEveTrstate
  ModelOutputData(0,cMOD_SnowWaterState(DecidSurf), Gridiv) = SnowWaterDecTrState
  ModelOutputData(0,cMOD_SnowWaterState(GrassSurf), Gridiv) = SnowWaterGrassState
  ModelOutputData(0,cMOD_SnowWaterState(BSoilSurf), Gridiv) = SnowWaterBSoilState
  ModelOutputData(0,cMOD_SnowWaterState(WaterSurf), Gridiv) = SnowWaterWaterState

  ! -- Initial snow water equivalent for each surface --
  ModelOutputData(0,cMOD_SnowPack(PavSurf),   Gridiv) = SnowPackPaved
  ModelOutputData(0,cMOD_SnowPack(BldgSurf),  Gridiv) = SnowPackBldgs
  ModelOutputData(0,cMOD_SnowPack(ConifSurf), Gridiv) = SnowPackEveTr
  ModelOutputData(0,cMOD_SnowPack(DecidSurf), Gridiv) = SnowPackDecTr
  ModelOutputData(0,cMOD_SnowPack(GrassSurf), Gridiv) = SnowPackGrass
  ModelOutputData(0,cMOD_SnowPack(BSoilSurf), Gridiv) = SnowPackBSoil
  ModelOutputData(0,cMOD_SnowPack(WaterSurf), Gridiv) = SnowPackWater

  ! -- Initial fraction of snow on each surface --
  ModelOutputData(0,cMOD_SnowFrac(PavSurf),   Gridiv) = SnowFracPaved
  ModelOutputData(0,cMOD_SnowFrac(BldgSurf),  Gridiv) = SnowFracBldgs
  ModelOutputData(0,cMOD_SnowFrac(ConifSurf), Gridiv) = SnowFracEveTr
  ModelOutputData(0,cMOD_SnowFrac(DecidSurf), Gridiv) = SnowFracDecTr
  ModelOutputData(0,cMOD_SnowFrac(GrassSurf), Gridiv) = SnowFracGrass
  ModelOutputData(0,cMOD_SnowFrac(BSoilSurf), Gridiv) = SnowFracBSoil
  ModelOutputData(0,cMOD_SnowFrac(WaterSurf), Gridiv) = SnowFracWater


  IceFrac=0.2   !Estimated fraction of ice. Should be improved in the future

  ! At this point translate arrays to variables (needed for SUEWS_cal_RoughnessParameters)
  CALL SUEWS_Translate(Gridiv,0,0)

  !Calculation of roughness parameters (N.B. uses porosity)
  IF ( Diagnose == 1 ) PRINT*, 'calling in initial state: SUEWS_cal_RoughnessParameters'
  CALL SUEWS_cal_RoughnessParameters(&
       RoughLenMomMethod,sfr,&!input
       bldgH,EveTreeH,DecTreeH,&
       porosity_id,FAIBldg,FAIEveTree,FAIDecTree,&
       z0m_in,zdm_in,Z,&
       planF,&!output
       Zh,z0m,zdm,ZZD)


  !=============================================================================
  ! If the run start day is at previous year, then calculate the number of days
  ! in that year.

  !First we need to know if the previous day given in initial conditions (id_prev) is
  !on previous year as this is needed in the initialization of DayofWeek matrix.
  !In this case switch is set to one for date calculations.
  IF(id_prev==0)THEN                     !If id_prev = 0, means that the first modelled day is 1 Jan
     year_int=year_int-1                  !1) find the number of days on that year
     CALL LeapYearCalc (year_int,id_prev) !2) set switch to 1 so that the code knows to change back to current year (switch=0)
     switch=1
  ENDIF

  CALL day2month(id_prev,mb,date,seas,year_int,lat) !Calculate date information (mb = month, date = day,...)
  CALL Day_of_Week(date,mb,year_int,wd)             !Calculate weekday of the previous day (wd) (1=Sun, ..., 7=Sat)

  !After the day in previous year switch is changed back to zero:
  !    ie not previous day anymore
  !Also the size of DayofWeek is from 0:NdaysinYear meaning
  !that in zero slot is the previous day information
  IF(switch==1)THEN
     year_int=year_int+1
     id_prev=0
     switch=0
  ENDIF

  ! DayofWeek(id_prev,1)=wd   ! day of week
  ! DayofWeek(id_prev,2)=mb   ! month
  ! DayofWeek(id_prev,3)=seas ! season (summer=1, winter=2) needed for accumulation

  ! in case next day goes to next year calculate again the date information for DayofWeek matrix.
  id_next=id_prev+1
  IF(id_next>nofDaysThisYear) THEN
     id_next=1
     year_int=year_int+1
     switch=1
     CALL ErrorHint(43,'switch- years',notUsed,notUsed,notUsedI)
  ENDIF

  CALL day2month(id_next,mb,date,seas,year_int,lat) !Calculate real date from doy
  CALL Day_of_Week(date,mb,year_int,wd)             !Calculate weekday (1=Sun, ..., 7=Sat)

  IF(switch==1)THEN
     iy=iy-1
     switch=0
  ENDIF

  ! DayofWeek(id_next,1)=wd  ! day of week
  ! DayofWeek(id_next,2)=mb  ! month
  ! DayofWeek(id_next,3)=seas ! season

  !=============================================================================

  !id=id_prev
  !it= 23 !!LastTimeOfDay
  IF (id_prev>=startDLS.AND.id_prev<=endDLS) THEN  !Summertime
     DLS=1
  ELSE
     DLS=0
  ENDIF

  ! -----------------------------------------------------------------------
  ! Calculate daily water use if modelled (i.e. if WaterUseMethod = 0).
  ! Calculated from previous day information given in InitialConditions file
  CALL SUEWS_cal_weekday(&
       iy,id,lat,& !input
       dayofWeek_id) !output

  CALL update_WaterUse_X(&
       id,WaterUseMethod,DayofWeek_id,lat,Faut,HDD_id,&!input
       Ie_a,Ie_m,Ie_start,Ie_end,DayWatPer,DayWat,&
       WUDay_id) !output

  ! WUDay_id=0                !Initialize WUDay
  ! IF (WaterUseMethod==0) THEN  !Model water use
  !    calc=0
  !
  !    IF (DayWat(wd)==1.0) THEN !if DayWat(wd)=1.0 (irrigation occurs on this day)
  !       IF (lat>=0) THEN            !Northern Hemisphere
  !          IF (id>=Ie_start.AND.id<=Ie_end) calc=1 !if day between irrigation period
  !       ELSE                        !Southern Hemisphere
  !          calc=1
  !          IF (id>=Ie_end.AND.id<=Ie_start) calc=0 !if day between irrigation period
  !       ENDIF
  !       IF(calc==1) THEN
  !          ! Model daily water use based on HDD_id(6)(days since rain) and HDD_id(3)(average temp)
  !
  !          ! ---- Automatic irrigation (evergreen trees) ----
  !          WUDay_id(2) = Faut*(Ie_a(1)+Ie_a(2)*HDD_id(3)+Ie_a(3)*HDD_id(6))*sfr(ConifSurf)*IrrFracConif*DayWatPer(wd)
  !          IF (WUDay_id(2)<0) WUDay_id(2)=0   !If modelled WU is negative -> 0
  !
  !          ! ---- Manual irrigation (evergreen trees) ----
  !          WUDay_id(3) = (1-Faut)*(Ie_m(1)+Ie_m(2)*HDD_id(3)+Ie_m(3)*HDD_id(6))*sfr(ConifSurf)*IrrFracConif*DayWatPer(wd)
  !          IF (WUDay_id(3)<0) WUDay_id(3)=0   !If modelled WU is negative -> 0
  !
  !          ! ---- Total evergreen trees water use (automatic + manual) ----
  !          WUDay_id(1)=(WUDay_id(2)+WUDay_id(3))
  !
  !          ! ---- Automatic irrigation (deciduous trees) ----
  !          WUDay_id(5) = Faut*(Ie_a(1)+Ie_a(2)*HDD_id(3)+Ie_a(3)*HDD_id(6))*sfr(DecidSurf)*IrrFracDecid*DayWatPer(wd)
  !          IF (WUDay_id(5)<0) WUDay_id(5)=0   !If modelled WU is negative -> 0
  !
  !          ! ---- Manual irrigation (deciduous trees) ----
  !          WUDay_id(6) = (1-Faut)*(Ie_m(1)+Ie_m(2)*HDD_id(3)+Ie_m(3)*HDD_id(6))*sfr(DecidSurf)*&
  !               IrrFracDecid*DayWatPer(wd)
  !          IF (WUDay_id(6)<0) WUDay_id(6)=0   !If modelled WU is negative -> 0
  !
  !          ! ---- Total deciduous trees water use (automatic + manual) ----
  !          WUDay_id(4)=(WUDay_id(5)+WUDay_id(6))
  !
  !          ! ---- Automatic irrigation (grass) ----
  !          WUDay_id(8) = Faut*(Ie_a(1)+Ie_a(2)*HDD_id(3)+Ie_a(3)*HDD_id(6))*sfr(GrassSurf)*&
  !               IrrFracGrass*DayWatPer(wd)
  !          IF (WUDay_id(8)<0) WUDay_id(8)=0   !If modelled WU is negative -> 0
  !          ! ---- Manual irrigation (grass) ----
  !          WUDay_id(9) = (1-Faut)*(Ie_m(1)+Ie_m(2)*HDD_id(3)+Ie_m(3)*HDD_id(6))*sfr(GrassSurf)*&
  !               IrrFracGrass*DayWatPer(wd)
  !          IF (WUDay_id(9)<0) WUDay_id(9)=0   !If modelled WU is negative -> 0
  !          ! ---- Total grass water use (automatic + manual) ----
  !          WUDay_id(7)=(WUDay_id(8)+WUDay_id(9))
  !       ELSE
  !          WUDay_id(1)=0
  !          WUDay_id(2)=0
  !          WUDay_id(3)=0
  !          WUDay_id(4)=0
  !          WUDay_id(5)=0
  !          WUDay_id(6)=0
  !          WUDay_id(7)=0
  !          WUDay_id(8)=0
  !          WUDay_id(9)=0
  !       ENDIF
  !    ENDIF
  ! ENDIF

  ! -----------------------------------------------------------------------

  ! ---- AnOHM TS ---------------------
  ! initialize Bowen ratio
  ! Bo_grids(0,:)=2.
  ! mAH_grids(0,:)=25.

  ! -----------------------------------

  RETURN

600 CALL ErrorHint(47,TRIM(FileInit),notUsed,notUsed,notUsedI)
601 CALL ErrorHint(48,TRIM(FileInit),notUsed,notUsed,ios_out)

END SUBROUTINE InitialState


! ===========================================================================
FUNCTION NormalizeVegChar(VegCol,Gridiv) RESULT(NormVegResult)

  USE AllocateArray
  USE ColNamesInputFiles

  IMPLICIT NONE

  INTEGER,DIMENSION(nvegsurf):: VegCol  !Must be column numbers defined for veg surfaces only
  INTEGER:: Gridiv
  REAL(KIND(1d0)):: NormVegResult
  IF ( SurfaceChar(Gridiv,c_FrEveTr) + &
       SurfaceChar(Gridiv,c_FrDecTr) + &
       SurfaceChar(Gridiv,c_FrGrass) == 0. ) THEN ! prevent arithmetic error under a full impervious scenario
     NormVegResult=0.
  ELSE
     NormVegResult = (SurfaceChar(Gridiv,VegCol(ivConif))*SurfaceChar(Gridiv,c_FrEveTr) + &
          SurfaceChar(Gridiv,VegCol(ivDecid))*SurfaceChar(Gridiv,c_FrDecTr) + &
          SurfaceChar(Gridiv,VegCol(ivGrass))*SurfaceChar(Gridiv,c_FrGrass)) / &
          (SurfaceChar(Gridiv,c_FrEveTr) + SurfaceChar(Gridiv,c_FrDecTr) + SurfaceChar(Gridiv,c_FrGrass))
  END IF



  RETURN
END FUNCTION NormalizeVegChar
! ===========================================================================

!-------------------------------------------------------------------------
SUBROUTINE NextInitial(GridName,year_int)
  ! Last modified HCW 24 May 2016
  ! Year of InitialConditions output file fixed. _EndofRun appended to files where the run finishes before the year end
  ! Last modified LJ 06 Jul 2015
  ! Initial conditions of SnowAlb added, densSnow changed to SnowDens
  ! Last modified HCW 03 Jul 2015
  ! Added initial conditions albEveTr0 and albGrass0
  ! Modified by HCW 21 Nov 2014
  ! Last day of year is not anymore the number of days on that year, but rather
  ! id == 1. Thus nofDaysThisYear was changed to 1. LJ 9/4/2015
  !------------------------------------------------------------------------

  USE allocateArray
  USE ColNamesInputFiles
  USE ColNamesModelDailyState
  USE data_in
  USE defaultNotUsed
  USE Initial
  USE sues_data
  USE snowMod
  USE time
  USE InitialCond

  IMPLICIT NONE

  CHARACTER (len=15)::GridName
  CHARACTER (len=4)::year_txt2
  INTEGER:: year_int2
  INTEGER:: year_int
  INTEGER:: ID_Prev_Out ! ID_Prev written to next Initial Conditions file
  INTEGER:: nofDaysThisYear_ForOutput  !Added HCW 13 Jan 2017

  year=year_int   !HCW added 21 Nov 2014

  ! Modified by HCW 24 May 2016
  IF(id==1.AND.iy==(year+1)) THEN   !if id = 1 and this is the first row of next year
     year_int2=INT(year+1)
     WRITE(year_txt2,'(I4)')year_int2
     OPEN(57,File=TRIM(FileInputPath)//TRIM("InitialConditions")//TRIM(GridName)//'_'//TRIM(ADJUSTL(year_txt2))//'.nml',err=200)
     nofDaysThisYear_ForOutput = nofdaysthisyear
  ELSE
     year_int2=INT(year)  !End of Run but not end of year
     WRITE(year_txt2,'(I4)')year_int2
     OPEN(57,File=TRIM(FileInputPath)//TRIM("InitialConditions")//TRIM(GridName)//'_'//TRIM(ADJUSTL(year_txt2))// &
          '_EndofRun.nml',err=201)
     nofDaysThisYear_ForOutput = id-1
  ENDIF
  ID_Prev_Out=(id-1)


  !! If last time of day, then DailyState variables will have been updated so can write out arrays for id rather than id-1
  !if(it==23 .and. imin == (nsh_real-1)/nsh_real*60) then  !!LastTimeofday
  !   id=id+1
  !endif
  WRITE(57,*)'&InitialConditions'
  WRITE(57,*)'DaysSinceRain=',INT(HDD_id(12))
  WRITE(57,*)'Temp_C0=',HDD_id(9)
  !WRITE(57,*)'ID_Prev=',ID_Prev_Out  !No longer included in initial conditions (HCW 13 Jan 2017)
  WRITE(57,*)'GDD_1_0=',GDD_id(1)
  WRITE(57,*)'GDD_2_0=',GDD_id(2)
  WRITE(57,*)'LAIinitialEveTr=',LAI_id(ivConif)
  WRITE(57,*)'LAIinitialDecTr=',LAI_id(ivDecid)
  WRITE(57,*)'LAIinitialGrass=',LAI_id(ivGrass)
  WRITE(57,*)'AlbEveTr0=',AlbEveTr_id
  WRITE(57,*)'AlbDecTr0=',AlbDecTr_id
  WRITE(57,*)'AlbGrass0=',AlbGrass_id
  WRITE(57,*)'DecidCap0=',decidCap_id
  WRITE(57,*)'Porosity0=',porosity_id
  WRITE(57,*)'SoilStorePavedState=',soilmoist_id(PavSurf)
  WRITE(57,*)'SoilStoreBldgsState=',soilmoist_id(BldgSurf)
  WRITE(57,*)'SoilStoreEveTrState=',soilmoist_id(ConifSurf)
  WRITE(57,*)'SoilStoreDecTrState=',soilmoist_id(DecidSurf)
  WRITE(57,*)'SoilStoreGrassState=',soilmoist_id(GrassSurf)
  WRITE(57,*)'SoilStoreBSoilState=',soilmoist_id(BSoilSurf)
  WRITE(57,*)'PavedState=',state_id(PavSurf)
  WRITE(57,*)'BldgsState=',state_id(BldgSurf)
  WRITE(57,*)'EveTrState=',state_id(ConifSurf)
  WRITE(57,*)'DecTrState=',state_id(DecidSurf)
  WRITE(57,*)'GrassState=',state_id(GrassSurf)
  WRITE(57,*)'BSoilState=',state_id(BSoilSurf)
  WRITE(57,*)'WaterState=',state_id(WaterSurf)
  ! Only write snow variables if snow part is running
  IF(snowUse==1) THEN
     WRITE(57,*)'SnowWaterPavedState=',MeltWaterStore(PavSurf)
     WRITE(57,*)'SnowWaterBldgsState=',MeltWaterStore(BldgSurf)
     WRITE(57,*)'SnowWaterEveTrState=',MeltWaterStore(ConifSurf)
     WRITE(57,*)'SnowWaterDecTrState=',MeltWaterStore(DecidSurf)
     WRITE(57,*)'SnowWaterGrassState=',MeltWaterStore(GrassSurf)
     WRITE(57,*)'SnowWaterBSoilState=',MeltWaterStore(BSoilSurf)
     WRITE(57,*)'SnowWaterWaterState=',MeltWaterStore(WaterSurf)
     WRITE(57,*)'SnowPackPaved=',SnowPack(PavSurf)
     WRITE(57,*)'SnowPackBldgs=',SnowPack(BldgSurf)
     WRITE(57,*)'SnowPackEveTr=',SnowPack(ConifSurf)
     WRITE(57,*)'SnowPackDecTr=',SnowPack(DecidSurf)
     WRITE(57,*)'SnowPackGrass=',SnowPack(GrassSurf)
     WRITE(57,*)'SnowPackBSoil=',SnowPack(BSoilSurf)
     WRITE(57,*)'SnowPackWater=',SnowPack(WaterSurf)
     WRITE(57,*)'SnowFracPaved=',SnowFrac(PavSurf)
     WRITE(57,*)'SnowFracBldgs=',SnowFrac(BldgSurf)
     WRITE(57,*)'SnowFracEveTr=',SnowFrac(ConifSurf)
     WRITE(57,*)'SnowFracDecTr=',SnowFrac(DecidSurf)
     WRITE(57,*)'SnowFracGrass=',SnowFrac(GrassSurf)
     WRITE(57,*)'SnowFracBSoil=',SnowFrac(BSoilSurf)
     WRITE(57,*)'SnowFracWater=',SnowFrac(WaterSurf)
     WRITE(57,*)'SnowDensPaved=',SnowDens(PavSurf)
     WRITE(57,*)'SnowDensBldgs=',SnowDens(BldgSurf)
     WRITE(57,*)'SnowDensEveTr=',SnowDens(ConifSurf)
     WRITE(57,*)'SnowDensDecTr=',SnowDens(DecidSurf)
     WRITE(57,*)'SnowDensGrass=',SnowDens(GrassSurf)
     WRITE(57,*)'SnowDensBSoil=',SnowDens(BSoilSurf)
     WRITE(57,*)'SnowDensWater=',SnowDens(WaterSurf)
     WRITE(57,*)'SnowAlb0=',SnowAlb
  ENDIF
  ! WRITE(57,*)'BoInit=',BoInit
  WRITE(57,*)'/'
  CLOSE(57)

  IF(it==23 .AND. imin == (nsh_real-1)/nsh_real*60) THEN
     id=id-1
  ENDIF

  RETURN

200 CALL ErrorHint(49,TRIM("InitialConditions")//TRIM(GridName)// &
       '_'//TRIM(ADJUSTL(year_txt2))//'.nml',notUsed,notUsed,notUsedI)
201 CALL ErrorHint(49,TRIM("InitialConditions")//TRIM(GridName)// &
       '_'//TRIM(ADJUSTL(year_txt2))//'EoR.nml',notUsed,notUsed,notUsedI)

END SUBROUTINE NextInitial
!-------------------------------------------------------------------------



!=======================================================================
!=======================================================================
!This subroutine prepares a meteorological forcing file.

SUBROUTINE SUEWS_InitializeMetData(lunit)

  USE allocateArray
  USE data_in
  USE sues_data
  USE time
  USE defaultnotUsed
  USE Initial

  IMPLICIT NONE

  INTEGER::lunit,i,iyy !,RunNumber,NSHcounter
  REAL (KIND(1d0)),DIMENSION(24)::MetArray
  REAL(KIND(1d0)):: imin_prev, ih_prev, iday_prev, tstep_met, iy_only   !For checks on temporal resolution of met data

  !---------------------------------------------------------------

  !Open the file for reading and read the actual data
  !write(*,*) fileMet
  OPEN(lunit,file=TRIM(fileMet),status='old',err=314)
  CALL skipHeader(lunit,SkipHeaderMet)

  ! Skip to the right place in the met file, depending on how many chunks have been read already
  IF (skippedLines>0) THEN
     DO iyy=1,skippedLines
        READ(lunit,*)
     ENDDO
  ENDIF

  ! Read in next chunk of met data and fill MetForcingData array with data for every timestep
  !NSHcounter = 1
  !write(*,*) 'ReadlinesMetdata:',ReadlinesMetdata
  DO i=1,ReadlinesMetdata
     CALL MetRead(lunit,MetArray,InputmetFormat,ldown_option,NetRadiationMethod,&
          snowUse,SMDMethod,SoilDepthMeas,SoilRocks,SoilDensity,SmCap)
     !DO iv=1,NSH
     !    MetForcingData(NSHcounter,1:24,GridCounter) = MetArray
     !   NSHcounter = NSHcounter + 1
     !ENDDO
     MetForcingData(i,1:24,GridCounter) = MetArray
     ! Check timestamp of met data file matches TSTEP specified in RunControl
     IF(i==1) THEN
        imin_prev = MetArray(4)
        ih_prev   = MetArray(3)
        iday_prev = MetArray(2)
        iy_only   = MetArray(1)
     ELSEIF(i==2) THEN
        tstep_met = ((MetArray(4)+60*MetArray(3)) - (imin_prev+60*ih_prev))*60   !tstep in seconds
        IF(tstep_met/=tstep_real.AND.MetArray(2)==iday_prev) THEN
           CALL ErrorHint(39,'TSTEP in RunControl does not match TSTEP of met data (DOY).',REAL(tstep,KIND(1d0)),tstep_met,&
                INT(MetArray(2)))
        ENDIF
     ENDIF

     ! Check file only contains a single year --------------------------------------------
     ! Very last data point is allowed to be (should be) timestamped with following year
     IF(MetArray(1) /= iy_only) THEN
        IF(MetArray(1) == iy_only+1 .AND. MetArray(2) == 1 .AND. MetArray(3) == 0 .AND. MetArray(4) == 0) THEN
           !write(*,*) 'end of year - no problem'
        ELSE
           CALL errorHint(3,'Problem in SUEWS_Initial: multiple years found in met forcing file.', &
                MetArray(1),NotUsed,NotUsedI)
        ENDIF
     ENDIF

  ENDDO

  CLOSE(lunit)

  RETURN

314 CALL errorHint(11,TRIM(fileMet),notUsed,notUsed,ios_out)


END SUBROUTINE SUEWS_InitializeMetData
!----------------------------------------------------------------------------------------------

!====================================================================================
SUBROUTINE CheckInitial
  !Check the parameters in InitialConditions file.
  !Modified by HCW 04 Mar 2014, changed soilmoist_id(is) checks to use names given in InitialConditions
  !Added by LJ in 8/2/2013

  USE allocateArray
  USE data_in
  USE defaultNotUsed
  USE InitialCond
  USE snowMod
  USE time

  IMPLICIT NONE

  !real(kind(1d0)):: pTol   !Precision tolerance for range checks

  IF (Temp_C0<(Temp_C-10).OR.Temp_C0>(Temp_C+10)) THEN
     CALL ErrorHint(37,'Temp_C0 very different to Tair.', Temp_C0, Temp_C, notUsedI)
  ENDIF

  !Check more thoroughly if LAI values are OK. Need to treat different hemispheres as well as tropics separately.
  IF (lat>40) THEN
     IF ((LAIinitialEveTr>LAImin(ConifSurf-2)+1.AND.(id<60.OR.id>330)).OR.&
          (LAIinitialEveTr<LAImax(ConifSurf-2)-1.AND.(id>130.AND.id<244))) THEN
        CALL ErrorHint(37,'Check LAIinitialEveTr in InitialConditions file', LAIinitialEveTr, LAImin(ConifSurf-2), notUsedI)
     ENDIF
     IF ((LAIinitialDecTr>LAImin(DecidSurf-2)+1.AND.(id<60.OR.id>330)).OR.&
          (LAIinitialDecTr<LAImax(DecidSurf-2)-1.AND.(id>130.AND.id<244))) THEN
        CALL ErrorHint(37,'Check LAIinitialDecTr in InitialConditions file', LAIinitialDecTr, LAImin(DecidSurf-2), notUsedI)
     ENDIF
     IF ((LAIinitialGrass>LAImin(GrassSurf-2)+1.AND.(id<60.OR.id>330)).OR.&
          (LAIinitialGrass<LAImax(GrassSurf-2)-1.AND.(id>130.AND.id<244))) THEN
        CALL ErrorHint(37,'Check LAIinitialGrass in InitialConditions file', LAIinitialGrass, LAImin(GrassSurf-2), notUsedI)
     ENDIF

  ELSEIF (lat<-40) THEN
     IF ((LAIinitialEveTr<LAImax(ConifSurf-2)-1.AND.(id<60.OR.id>330)).OR.&
          (LAIinitialEveTr>LAImin(ConifSurf-2)+1.AND.(id>130.AND.id<244))) THEN
        CALL ErrorHint(37,'Check LAIinitialEveTr in InitialConditions file', LAIinitialEveTr, LAImax(ConifSurf-2), notUsedI)
     ENDIF
     IF ((LAIinitialDecTr>LAImax(DecidSurf-2)-1.AND.(id<60.OR.id>330)).OR.&
          (LAIinitialDecTr>LAImin(DecidSurf-2)+1.AND.(id>130.AND.id<244))) THEN
        CALL ErrorHint(37,'Check LAIinitialDecTr in InitialConditions file', LAIinitialDecTr, LAImax(DecidSurf-2), notUsedI)
     ENDIF
     IF ((LAIinitialGrass<LAImax(GrassSurf-2)-1.AND.(id<60.OR.id>330)) .OR.&
          (LAIinitialGrass>LAImin(GrassSurf-2)+1.AND.(id>130.AND.id<244))) THEN
        CALL ErrorHint(37,'Check LAIinitialGrass in InitialConditions file', LAIinitialGrass, LAImax(GrassSurf-2), notUsedI)
     ENDIF

  ELSEIF (lat<10.AND.lat>-10) THEN

     IF (LAIinitialEveTr<LAImax(ConifSurf-2)-0.5) THEN
        CALL ErrorHint(37,'Check LAIinitialEveTr in InitialConditions file', LAIinitialEveTr, LAImax(ConifSurf-2), notUsedI)
     ENDIF
     IF (LAIinitialDecTr<LAImax(DecidSurf-2)-0.5) THEN
        CALL ErrorHint(37,'Check LAIinitialDecTr in InitialConditions file', LAIinitialDecTr, LAImax(DecidSurf-2), notUsedI)
     ENDIF
     IF (LAIinitialGrass<LAImax(GrassSurf-2)-0.5) THEN
        CALL ErrorHint(37,'Check LAIinitialGrass in InitialConditions file', LAIinitialGrass, LAImax(GrassSurf-2), notUsedI)
     ENDIF

  ENDIF

  !Soilstore check
  IF (SoilstoreBldgsState>soilstoreCap(BldgSurf)) THEN
     CALL ErrorHint(37,'InitialCond: Check initial condition of building soil store.',&
          SoilstoreBldgsState, soilstoreCap(BldgSurf), notUsedI)
  ENDIF
  IF (SoilstorePavedState>soilstoreCap(PavSurf)) THEN
     CALL ErrorHint(37,'InitialCond: Check initial condition of paved soil store.',&
          SoilstorePavedState, soilstoreCap(PavSurf), notUsedI)
  ENDIF
  IF (SoilstoreEveTrState>soilstoreCap(ConifSurf)) THEN
     CALL ErrorHint(37,'InitialCond: Check initial condition of conif soil store.',&
          SoilstoreEveTrState, soilstoreCap(ConifSurf), notUsedI)
  ENDIF
  IF (SoilstoreDecTrState>soilstoreCap(DecidSurf)) THEN
     CALL ErrorHint(37,'InitialCond: Check initial condition of deciduous soil store.',&
          SoilstoreDecTrState, soilstoreCap(DecidSurf), notUsedI)
  ENDIF
  IF (SoilstoreBSoilState>soilstoreCap(BSoilSurf)) THEN
     CALL ErrorHint(37,'InitialCond: Check initial condition of bare soil soil store.',&
          SoilstoreBSoilState, soilstoreCap(BSoilSurf), notUsedI)
  ENDIF
  IF (SoilstoreGrassState>soilstoreCap(GrassSurf)) THEN
     CALL ErrorHint(37,'InitialCond: Check initial condition of grass soil store.',&
          SoilstoreGrassState, soilstoreCap(GrassSurf), notUsedI)
  ENDIF

  !Snow stuff
  IF (snowUse==1) THEN
     IF (SnowWaterBldgsState>CRWmax*SnowPackBldgs) THEN
        CALL ErrorHint(37,'InitialCond: SnowWaterBldgsState', SnowWaterBldgsState, SnowPackBldgs, notUsedI)
     ENDIF
     IF (SnowWaterPavedState>CRWmax*SnowPackPaved) THEN
        CALL ErrorHint(37,'InitialCond: SnowWaterPavedState', SnowWaterPavedState, SnowPackPaved, notUsedI)
     ENDIF
     IF (SnowWaterEveTrState>CRWmax*SnowPackEveTr) THEN
        CALL ErrorHint(37,'InitialCond: SnowWaterEveTrstate', SnowWaterEveTrstate, SnowPackEveTr, notUsedI)
     ENDIF
     IF (SnowWaterDecTrState>CRWmax*SnowPackDecTr) THEN
        CALL ErrorHint(37,'InitialCond: SnowWaterDecTrState', SnowWaterDecTrState, SnowPackDecTr, notUsedI)
     ENDIF
     IF (SnowWaterGrassState>CRWmax*SnowPackGrass) THEN
        CALL ErrorHint(37,'InitialCond: SnowWaterGrassState', SnowWaterGrassState, SnowPackGrass, notUsedI)
     ENDIF
     IF (SnowWaterBSoilState>CRWmax*SnowPackBSoil) THEN
        CALL ErrorHint(37,'InitialCond: SnowWaterGrassUnirState', SnowWaterBSoilState, SnowPackBSoil, notUsedI)
     ENDIF
  ENDIF

END SUBROUTINE CheckInitial

!===================================================================================
!Simple Anthropogenic Heat and Carbon Dioxide Parameterization routines
!This subroutine is still under development and in the equations concerning CO2 fluxes
!there are bugs and missing comments.
!Last modified
! TS 01 Jul 2018 - replaced annual HDD array with a simplied daily array HDD_id_use
! MH 29 Jun 2017 -  Finalised the code to calculate the anthropogenic emissions of heat and CO2
! HCW 21 Apr 2017 - renamed from SUEWS_SAHP.f95. Now includes CO2 fluxes as well as QF.
!                   Tidied code. Combined three subroutines into 1 to avoid repetition.
! HCW 24 Feb 2017 - Added new anthropogenic heat flux calculation (AnthropEmissionsMethod=3)
! HCW 25 Aug 2016 - Outputs base QF (part without temp. dependence)
! LJ 27 Jan 2016  - Removal of Tabs
! HCW 20 Jan 2015 - v2015 applies a profile at each model timestep
!                   these have been interpolated from the hourly profile input data (SUEWS_Profiles)
!                   vthey are now normalised (sum to 1) in InitializeSurfaceCharacteristics
!                   N.B. previous versions were not applying weekday/weekend profiles correctly
!
! EmissionsMethod = 0 - Use values in met forcing file, or default QF
! EmissionsMethod = 1 - Method according to Loridan et al. (2011) : SAHP
! EmissionsMethod = 2 - Method according to Jarvi et al. (2011)   : SAHP_2
!
!===================================================================================

SUBROUTINE AnthropogenicEmissions(&
     EmissionsMethod,&
     id,it,imin,DLS,nsh,DayofWeek_id,&
     EF_umolCO2perJ,FcEF_v_kgkm,EnEF_v_Jkm,TrafficUnits,&
     FrFossilFuel_Heat,FrFossilFuel_NonHeat,&
     MinQFMetab,MaxQFMetab,&
     NumCapita,PopDensDaytime,PopDensNighttime,&
     Temp_C,HDD_id,Qf_A,Qf_B,Qf_C,&
     AH_MIN,AH_SLOPE_Heating,AH_SLOPE_Cooling,&
     T_CRITIC_Heating,T_CRITIC_Cooling,&
     TrafficRate,&
     QF0_BEU,QF_SAHP,&
     Fc_anthro,Fc_metab,Fc_traff,Fc_build,&
     AHProf_24hr,HumActivity_24hr,TraffProf_24hr,PopProf_24hr)
  ! Simple anthropogenic heat parameterisation and co2 calculation
  ! Calculates QF_SAHP and Fc_anthro

  IMPLICIT NONE

  INTEGER,INTENT(in):: EmissionsMethod
  INTEGER,INTENT(in)::&
       id,     & !Hour
       it,     & !Hour
       imin,   & !Minutes
       DLS,    & !day lightsavings =1 +1h =0
       nsh !Number of timesteps per hour


  INTEGER,DIMENSION(3),INTENT(in)::DayofWeek_id   !1 - day of week; 2 - month; 3 - season

  REAL(KIND(1d0)),DIMENSION(12),INTENT(in):: HDD_id !Heating Degree Days (see SUEWS_DailyState.f95)

  REAL(KIND(1d0)),DIMENSION(2),INTENT(in)::&
       Qf_A,Qf_B,Qf_C,&    !Qf coefficients
       AH_MIN,&            !Minimum anthropogenic heat flux (AnthropHeatMethod = 1)
       AH_SLOPE_Heating,&  !Slope of the antrhropogenic heat flux calculation (AnthropHeatMethod = 1)
       AH_SLOPE_Cooling,&
       T_CRITIC_Heating,&  !Critical temperature
       T_CRITIC_Cooling,&  !Critical cooling temperature
       TrafficRate,&       !Traffic rate
       QF0_BEU



  REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in):: AHProf_24hr
  REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in):: HumActivity_24hr
  REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in):: TraffProf_24hr
  REAL(KIND(1d0)),DIMENSION(0:23,2),INTENT(in):: PopProf_24hr

  REAL(KIND(1D0)),INTENT(in):: &
       EF_umolCO2perJ,&
       FcEF_v_kgkm,&       !CO2 Emission factor
       EnEF_v_Jkm,&        !Energy Emission factor
       TrafficUnits,&      !Traffic Units choice
       FrFossilFuel_Heat,& !Fraction of Fossil Fuel heat
       FrFossilFuel_NonHeat,&!Fraction of Fossil Fuel non heat
       MinQFMetab,&        !Minimum QF Metabolism
       MaxQFMetab,&        !Maximum QF Metabolism
       NumCapita,&         !Number of people in the study area per hectare [ha-1]
       PopDensDaytime,&    !Daytime population density [ha-1] (i.e. workers)
       PopDensNighttime,&  !Nighttime population density [ha-1] (i.e. residents)
       Temp_C           !Air temperature


  REAL(KIND(1D0)),INTENT(out):: &
       QF_SAHP,&
       Fc_anthro,&
       Fc_metab,Fc_traff,Fc_build

  INTEGER::&
       iu,&               !1=weekday OR 2=weekend
       ih

  REAL(KIND(1D0)):: &
       get_Prof_SpecTime_inst,&
       get_Prof_SpecTime_mean,& !external function to get profile value at sepcified timestamp
       HDD_daily,& !daily HDD
       CDD_daily,& !daily HDD
       Tair_avg_daily,& !daily mean air temperature
       DP_x_RhoPop, DP_x_RhoPop_traff,&
       MinFcMetab, MaxFcMetab,&
       QF_build,QF_metab,QF_traff,&
       QF_SAHP_base,&     !Anthropogenic heat flux calculated by SAHP (temp independent part)
       QF_SAHP_heat,&     !Anthropogenic heat flux calculated by SAHP (heating part only)
       QF_SAHP_ac,&       !AC contribution
       PopDorNorT,&       ! Population
       ActDorNorT,&       ! Human activity
       TraffDorNorT,&     ! Traffic
       AHDorNorT          ! Anthropogenic heat

  ! transfer HDD values to local explict variables
  HDD_daily= HDD_id(7)
  CDD_daily= HDD_id(8)
  ! NB: temporarily use 5-day running mean to test the performance
  Tair_avg_daily= HDD_id(10)

  ! Tair_avg_daily= HDD_id_use(3) ! this is daily

  !-----------------------------------------------------------------------
  ! Account for Daylight saving
  ih=it-DLS
  IF(ih<0) ih=23

  ! Set weekday/weekend counter
  iu=1   !Set to 1=weekday
  IF(DayofWeek_id(1)==1 .OR. DayofWeek_id(1)==7) iu=2  !Set to 2=weekend

  ! Calculate energy emissions and CO2 from human metabolism -------------
  ! Pop dens (cap ha-1 -> cap m-2) x activity level (W cap-1)
  ! PopDorNorT   = PopProf_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)      ! 1=night, 2=day, 1-2=transition
  ! ActDorNorT   = HumActivity_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)  ! 1=night, 2=day, 1-2=transition
  ! TraffDorNorT = TraffProf_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)    ! normalise so the AVERAGE of the multipliers is equal to 1
  ! AHDorNorT    = AHProf_tstep((NSH*(ih+1-1)+imin*NSH/60+1),iu)       ! normalise so the AVERAGE of the multipliers is equal to 1
  ! PRINT*, ''
  ! PRINT*, 'AHDorNorT old:',AHDorNorT
  PopDorNorT   = get_Prof_SpecTime_inst(ih,imin,0,PopProf_24hr(:,iu))
  ActDorNorT   = get_Prof_SpecTime_mean(ih,imin,0,HumActivity_24hr(:,iu))
  TraffDorNorT = get_Prof_SpecTime_mean(ih,imin,0,TraffProf_24hr(:,iu))
  AHDorNorT    = get_Prof_SpecTime_mean(ih,imin,0,AHProf_24hr(:,iu))
  ! PRINT*, 'AHDorNorT new:',AHDorNorT
  ! Diurnal profile times population density [cap ha-1]
  DP_x_RhoPop = AHDorNorT * NumCapita

  MinFcMetab = 8/5. * MinQFMetab
  MaxFcMetab = 8/5. * MaxQFMetab ! Sailor & Lu (2004)

  !QF_metab = (PopDensNighttime*(2-PopDorNorT) + PopDensDaytime*(PopDorNorT-1))/10000 * &
  !              (MinQFMetab*(2-ActDorNorT) + MaxQFMetab*(ActDorNorT-1)) !W m-2
  !Fc_metab = (PopDensNighttime*(2-PopDorNorT) + PopDensDaytime*(PopDorNorT-1))/10000 * &
  !           (MinFcMetab*(2-ActDorNorT) + MinFcMetab*(ActDorNorT-1)) !umol m-2 s-1

  !QF_metab = (PopDensNighttime*MinQFMetab*((2-ActDorNorT)+(2-PopDorNorT))/2 + &
  !           PopDensDaytime*MaxQFMetab*((ActDorNorT-1)+(PopDorNorT-1))/2)/10000 !W m-2

  !Fc_metab = (PopDensNighttime*MinFcMetab*((2-ActDorNorT)+(2-PopDorNorT))/2 + &
  !           PopDensDaytime*MaxFcMetab*((ActDorNorT-1)+(PopDorNorT-1))/2)/10000 !umol m-2 s-1

  !----------------------------------------------------------------------------------------------------
  !Diffferent methods to calculate the anthopogenic heat and CO2 emissions.
  !1-3: CO2 emission is calculated from QF which can be calculated with three methods
  !41-43: CO2 emission is calculated with local information. QF methods are used for housing and human metabolism

  IF(EmissionsMethod==1 .OR. EmissionsMethod==4 .OR. EmissionsMethod==11 .OR. EmissionsMethod==14 .OR. &
       EmissionsMethod==21 .OR. EmissionsMethod==24 .OR. EmissionsMethod==31 .OR. EmissionsMethod==34) THEN   ! (formerly SAHP_1 subroutine)
     ! Loridan et al. (2011) JAMC Eq 13: linear relation with air temperature
     ! Weekday/weekend differences due to profile only
     ! Now scales with population density

     IF(Temp_C < T_CRITIC_Heating(iu)) THEN
        QF_SAHP = (AH_MIN(iu) + AH_SLOPE_Heating(iu)*(T_CRITIC_Heating(iu)-Temp_C)) * AHDorNorT
     ELSE
        QF_SAHP = AH_MIN(iu) * AHDorNorT
     ENDIF

     ! Need to be checked later, not recommended to use
     ! QF_SAHP_base = AH_MIN(iu) * DP_x_RhoPop     ! Temperature-independent contribution
     QF_SAHP_base = AH_MIN(iu) * AHDorNorT         ! Temperature-independent contribution
     QF_SAHP_heat = QF_SAHP - QF_SAHP_base         ! Heating contribution
     QF_SAHP_ac   = 0                              ! No AC contribution with this method


  ELSEIF(EmissionsMethod==2 .OR. EmissionsMethod==5 .OR. EmissionsMethod==12 .OR. EmissionsMethod==15 .OR. &
       EmissionsMethod==22 .OR. EmissionsMethod==25 .OR. EmissionsMethod==32 .OR. EmissionsMethod==35) THEN   ! (formerly SAHP_2 subroutine)
     ! Jarvi et al. (2011) JH Eq 3 using HDD and CDD
     ! Weekday/weekend differences due to profile and coefficients QF_a,b,c
     ! Scales with population density
     QF_SAHP      = (Qf_a(iu)+Qf_b(iu)*CDD_daily+Qf_c(iu)*HDD_daily) * DP_x_RhoPop  !This contains QF from all three sources: buildings, metabolism and traffic!
     QF_SAHP_base = (Qf_a(iu)) * DP_x_RhoPop                ! Temperature-independent contribution from buildings, traffic and human metabolism
     QF_SAHP_heat = (Qf_c(iu)*HDD_daily) * DP_x_RhoPop    ! Heating contribution
     QF_SAHP_ac   = (Qf_b(iu)*CDD_daily) * DP_x_RhoPop    ! Cooling (AC) contribution


  ELSEIF(EmissionsMethod==3 .OR. EmissionsMethod==6 .OR. EmissionsMethod==13 .OR. EmissionsMethod==16 .OR. &
       EmissionsMethod==23 .OR. EmissionsMethod==26 .OR. EmissionsMethod==33 .OR. EmissionsMethod==36) THEN
     ! Updated Loridan et al. (2011) method using daily (not instantaneous) air temperature (HDD_id_use(3))
     ! Linear relation with air temperature
     ! Weekday/weekend differences due to profile only
     ! Scales with population density

     ! Need to be checked later, not recommended to use
     ! QF_SAHP_base = AH_MIN(iu) * DP_x_RhoPop       ! Temperature-independent contribution
     QF_SAHP_base = AH_MIN(iu) * AHDorNorT           ! Temperature-independent contribution

     IF(Tair_avg_daily < T_CRITIC_Heating(iu)) THEN     ! Heating
        QF_SAHP = (AH_MIN(iu) + AH_SLOPE_Heating(iu)*(T_CRITIC_Heating(iu)-Tair_avg_daily))* AHDorNorT
        QF_SAHP_heat = QF_SAHP - QF_SAHP_base        ! Heating contribution
        QF_SAHP_ac = 0

     ELSEIF(Tair_avg_daily > T_CRITIC_Cooling(iu)) THEN ! Air-conditioning
        QF_SAHP = (AH_MIN(iu) + AH_SLOPE_Cooling(iu)*(Tair_avg_daily-T_CRITIC_Cooling(iu))) * AHDorNorT
        QF_SAHP_heat = 0
        QF_SAHP_ac = QF_SAHP - QF_SAHP_base          ! AC contribution

     ELSE
        QF_SAHP = AH_MIN(iu) * AHDorNorT
     ENDIF

  ! ELSEIF(EmissionsMethod==0) THEN
  !    QF_SAHP   = 0
  !    Fc_anthro = 0
  !    Fc_metab  = 0
  !    Fc_traff  = 0
  !    Fc_build  = 0
  ENDIF

  RETURN
ENDSUBROUTINE AnthropogenicEmissions
!========================================================================================

!========================================================================================
! Created by HCW Aug 2016 to calculate biogenic component of CO2 flux.
! This subroutine is still under development and in the equations there might be bugs and
! the code is not well commented.
!
! Last modified:
! MH 20 Jun 2017  - Tidied and renamed from SUEWS_CO2.f95 to SUEWS_CO2Biogen.f95
! HCW 11 Apr 2017 - Tidied and merged with LJ code
! LJ   6 Apr 2017 - Minimum limit for soil respiration with BiogenCO2Choice = 2 was set to 0.6 umol m-2 s-1
!                 - Choice for non-rectancular hyperbola to calculate the biogenic CO2 flux added (BiogenCO2Choice = 2)
!                    (Bellucco et al. 2017, Agric. Forest. Met. 236, 113-122).
!                 - Both the "local Helsinki model" (BiogenCO2Choice = 2)) and "general model" BiogenCO2Choice = 3) are implemented
!                 - Snow fraction added to the calculation of active vegetation fraction and the soil respiration
!
! To Do:
!  - Active vegetation goes to zero with LAI minimum, but this needs to be changed so some minimum value
!    especially in the case of evergreentrees
!  - Move some of the parameters to input files
!  - Now on weekend nighttime population is used throughout the day. Do we need extra column in SiteSelect for daytime weekend population?

! EmissionsMethod:
!  11-16 - Rectangular hyperbola (Ruimy, Schmid, Flanagan)
!  21-26 - Non-rectangular hyperbola, Helsinki (Bellucco et al. 2017)
!  31-36 - Non-rectangular hyperbola, general  (Bellucco et al. 2017)
!========================================================================================
SUBROUTINE CO2_biogen(EmissionsMethod,&
     ivConif,ivDecid,ivGrass,ConifSurf,DecidSurf,GrassSurf,BSoilSurf,&
     snowFrac,nsurf,NVegSurf,avkdn,Temp_C,sfr,LAI_id,LAIMin,LAIMax,&
     alpha_bioCO2,beta_bioCO2,theta_bioCO2,alpha_enh_bioCO2,beta_enh_bioCO2,&
     resp_a,resp_b,min_res_bioCO2,Fc_biogen,Fc_respi,Fc_photo,&
     notUsed,notUsedI)

  IMPLICIT NONE
  INTEGER,INTENT(in):: EmissionsMethod
  INTEGER,INTENT(in)::&
       ivConif,ivDecid,ivGrass,ConifSurf,DecidSurf,GrassSurf,BSoilSurf,&
       nsurf,nvegSurf,&
       notUsedI
  REAL(KIND(1d0)),INTENT(in)::&
       avkdn,&
       Temp_C,&
       notUsed

  REAL(KIND(1d0)),DIMENSION(nsurf),INTENT(in)::&
       sfr,&   !Surface fractions [-]
       snowFrac
  REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in):: LAI_id
  REAL(KIND(1d0)),DIMENSION(nvegsurf),INTENT(in)::&
       LAIMin, LAIMax,&      ! [m2 m-2]
                                !  BiogenCO2Code,&       !Biogenic CO2 Code for SUEWS_BiogenCO2.txt
       alpha_bioCO2,&
       beta_bioCO2,&
       theta_bioCO2,&
       alpha_enh_bioCO2,&
       beta_enh_bioCO2,&
       resp_a,&
       resp_b,&
       min_res_bioCO2
  REAL(KIND(1D0)),INTENT(out):: &
       Fc_biogen,&
       Fc_respi,Fc_photo

  INTEGER:: iv ! counter

  REAL(KIND(1d0)):: &
       PAR_umolm2s1,&
       Bellucco2017_Pho,&     ! Photosynthesis (Bellucco et al. 2016)
       Bellucco2017_Res,&     ! Respiration (Bellucco et al. 2016)
       Bellucco2017_Res_surf,&! Respiration for each vegetated surface
       VegFracSum             ! Sum of vegetation fractions without water. Could be moved elsewhere later.

  REAL(KIND(1d0)),DIMENSION(nvegsurf)::&
       active_veg_fr,&         ! Active vegetation fraction
       Fc_photo_surf,&         ! Photosynthesis for each vegetated surface
       Bellucco2017_Pho_surf ! Photosynthesis for each vegetated surface

  REAL(KIND(1d0)),DIMENSION(nvegsurf)::&
       alpha_bioCO2_v2,&
       beta_bioCO2_v2,&
       theta_bioCO2_v2

  REAL(KIND(1d0)),PARAMETER :: &
       JtoumolPAR = 4.6,&
       KdntoPAR = 0.46

  !-----------------------------------------------------------------------

  ! Calculate PAR from Kdown ----------------------------------
  PAR_umolm2s1 = JtoumolPAR * KdntoPAR * avKdn

  VegFracSum = sfr(ConifSurf) + sfr(DecidSurf) + sfr(GrassSurf)

  ! Calculate active vegetation surface -----------------------
  !Now this is zero always when LAI in its minimum values. This needs to vary between the summer time maximum and some minimum value
  !especially in the case of evergreen trees (i.e. in early March LAI can be in its minimum value, but air temperature and radiation
  !such that uptake can take place)
  DO iv=ivConif,ivGrass   !For vegetated surfaces. Snow included although quite often LAI will be in its minimum when snow on ground
     active_veg_fr(iv) = (sfr(iv+2)*(1-snowFrac(iv+2)))*(LAI_id(iv)-LAIMin(iv))/(LAIMax(iv)-LAIMin(iv))
  ENDDO
  !DO iv=ivConif,ivGrass   !For vegetated surfaces. Snow is not included?
  !   active_veg_fr(iv) = sfr(iv+2)*(LAI(id-1,iv)-LAIMin(iv))/(LAIMax(iv)-LAIMin(iv))
  !ENDDO


  IF(EmissionsMethod>=11 .AND. EmissionsMethod<=16) THEN   ! Rectangular hyperbola

     ! Calculate carbon uptake due to photosynthesis -------------
     Fc_photo = 0
     DO iv=ivConif,ivGrass
        Fc_photo_surf(iv) = -beta_bioCO2(iv)*alpha_bioCO2(iv)*PAR_umolm2s1/(alpha_bioCO2(iv)*PAR_umolm2s1 + beta_bioCO2(iv))
        ! For active vegetation fraction only
        Fc_photo = Fc_photo + Fc_photo_surf(iv)*active_veg_fr(iv)  !umol m-2 s-1
     ENDDO

  ELSEIF(EmissionsMethod>=21 .AND. EmissionsMethod<=26) THEN  !Local model, Bellucco et al. (2017)

     ! Calculate carbon uptake due to photosynthesis -------------
     Bellucco2017_Pho = 0
     DO iv=ivConif,ivGrass
        Bellucco2017_Pho_surf(iv) = -(1/(2*theta_bioCO2(iv))*(alpha_bioCO2(iv)*PAR_umolm2s1+beta_bioCO2(iv)- &
             SQRT((alpha_bioCO2(iv)*PAR_umolm2s1+beta_bioCO2(iv))**2-4* &
             alpha_bioCO2(iv)*beta_bioCO2(iv)*theta_bioCO2(iv)*PAR_umolm2s1)))
        ! For active vegetation fraction only
        Bellucco2017_Pho = Bellucco2017_Pho + Bellucco2017_Pho_surf(iv)*active_veg_fr(iv)
     ENDDO

     !Fc_photo = Bellucco2017_Pho*active_veg_fr(ConifSurf-2)+ &
     !           Bellucco2017_Pho*active_veg_fr(DecidSurf-2)+ &
     !           Bellucco2017_Pho*active_veg_fr(GrassSurf-2)

     Fc_photo = Bellucco2017_Pho

  ELSEIF(EmissionsMethod>=31 .AND. EmissionsMethod<=36) THEN  !General model, Bellucco et al. (2017)
     ! Not currently recommended as includes also some anthropogenic impacts. Should maybe be separate from other biogen choices?
     ! Alpha and beta calculated as a function of vegetation cover fraction

     !Different alpha, beta and theta vegetation cover values should be same in BiogenCO2Method = 3.
     IF(alpha_bioCO2(ivConif) == alpha_bioCO2(ivDecid) .AND. alpha_bioCO2(ivConif) == alpha_bioCO2(ivGrass) .AND. &
          beta_bioCO2(ivConif) == beta_bioCO2(ivDecid) .AND. beta_bioCO2(ivConif) == beta_bioCO2(ivGrass) .AND. &
          theta_bioCO2(ivConif) == theta_bioCO2(ivDecid) .AND. theta_bioCO2(ivConif) == theta_bioCO2(ivGrass)) THEN

        !Because different alpha, beta and theta values are same - only one vegetation type is needed.
        alpha_bioCO2_v2(ivConif) = alpha_bioCO2(ivConif) + alpha_enh_bioCO2(ivConif)* &
             (sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)+sfr(BSoilSurf))      !umol CO2 umol photons-1
        beta_bioCO2_v2(ivConif) = -beta_bioCO2(ivConif) + beta_enh_bioCO2(ivConif)* &
             (sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)+sfr(BSoilSurf))     !umol m^-2 s^-1

        !Photosynthesis
        !Bellucco2017_Pho = -(1/(2*theta_bioCO2(ivConif))*(alpha_bioCO2(ivConif)*PAR_umolm2s1+beta_bioCO2(ivConif)- &
        !                   sqrt((alpha_bioCO2(ivConif)*PAR_umolm2s1+beta_bioCO2(ivConif))**2-4* &
        !                   alpha_bioCO2(ivConif)*beta_bioCO2(ivConif)*theta_bioCO2(ivConif)*PAR_umolm2s1)))

        Bellucco2017_Pho = -(1/(2*theta_bioCO2(ivConif))*(alpha_bioCO2_v2(ivConif)*PAR_umolm2s1+beta_bioCO2_v2(ivConif)- &
             SQRT((alpha_bioCO2_v2(ivConif)*PAR_umolm2s1+beta_bioCO2_v2(ivConif))**2-4* &
             alpha_bioCO2_v2(ivConif)*beta_bioCO2_v2(ivConif)*theta_bioCO2(ivConif)*PAR_umolm2s1)))

     ELSE !If values are not same, then weighted average is calculated.
        CALL ErrorHint(74,'Check values in SUEWS_BiogenCO2.txt: ',notUsed,notUsed,notUsedI)

        ! Weighted averages
        alpha_bioCO2_v2(ivConif) = (alpha_bioCO2(ivConif)*sfr(ConifSurf)/VegFracSum + &
             alpha_bioCO2(ivDecid)*sfr(DecidSurf)/VegFracSum&
             + alpha_bioCO2(ivGrass)*sfr(GrassSurf)/VegFracSum) &
             / (alpha_bioCO2(ivConif) + alpha_bioCO2(ivDecid) + alpha_bioCO2(ivGrass))
        beta_bioCO2_v2(ivConif)  = (beta_bioCO2(ivConif)*sfr(ConifSurf)/VegFracSum + &
             beta_bioCO2(ivDecid)*sfr(DecidSurf)/VegFracSum&
             + beta_bioCO2(ivGrass)*sfr(GrassSurf)/VegFracSum )/ (beta_bioCO2(ivConif) + &
             beta_bioCO2(ivDecid) + beta_bioCO2(ivGrass))
        theta_bioCO2_v2(ivConif) = (theta_bioCO2(ivConif)*sfr(ConifSurf)/VegFracSum  + &
             theta_bioCO2(ivDecid)*sfr(DecidSurf)/VegFracSum&
             + theta_bioCO2(ivGrass)*sfr(GrassSurf)/VegFracSum )/( theta_bioCO2(ivConif) + &
             theta_bioCO2(ivDecid) + theta_bioCO2(ivGrass))

        ! Using weighted average values to calculate alpha and beta as a function of vegetation cover fraction
        alpha_bioCO2_v2(ivConif) = alpha_bioCO2_v2(ivConif) + alpha_enh_bioCO2(ivConif)* &
             (sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)+sfr(BSoilSurf))     !umol CO2 umol photons-1
        beta_bioCO2_v2(ivConif) = -beta_bioCO2_v2(ivConif) + beta_enh_bioCO2(ivConif)* &
             (sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)+sfr(BSoilSurf))     !umol m^-2 s^-1

        !Photosynthesis
        !Bellucco2017_Pho = -(1/(2*theta_bioCO2(ivConif))*(alpha_bioCO2(ivConif)*PAR_umolm2s1+beta_bioCO2(ivConif)- &
        !                   sqrt((alpha_bioCO2(ivConif)*PAR_umolm2s1+beta_bioCO2(ivConif))**2-4* &
        !                   alpha_bioCO2(ivConif)*beta_bioCO2(ivConif)*theta_bioCO2(ivConif)*PAR_umolm2s1)))
        Bellucco2017_Pho = -(1/(2*theta_bioCO2_v2(ivConif))*(alpha_bioCO2_v2(ivConif)*PAR_umolm2s1+beta_bioCO2_v2(ivConif)- &
             SQRT((alpha_bioCO2_v2(ivConif)*PAR_umolm2s1+beta_bioCO2_v2(ivConif))**2-4* &
             alpha_bioCO2_v2(ivConif)*beta_bioCO2_v2(ivConif)*theta_bioCO2_v2(ivConif)*PAR_umolm2s1)))

     ENDIF

     ! Calculate carbon uptake due to photosynthesis -------------
     Fc_photo = Bellucco2017_Pho*active_veg_fr(ConifSurf-2)+ &
          Bellucco2017_Pho*active_veg_fr(DecidSurf-2)+ &
          Bellucco2017_Pho*active_veg_fr(GrassSurf-2)

  ENDIF

  ! Calculate carbon uptake due to respiration -------------
  Bellucco2017_Res = 0.0
  Bellucco2017_Res_surf = 0.0
  IF (VegFracSum>0.01) THEN
     DO iv=ivConif,ivGrass
        IF (sfr(2+iv)>0.005) THEN
           Bellucco2017_Res_surf = MAX(min_res_bioCO2(iv), resp_a(iv)*EXP(resp_b(iv)*Temp_C))
           ! For active vegetation fraction only
           ! Bellucco2017_Res = Bellucco2017_Res + Bellucco2017_Res_surf(iv)*active_veg_fr(iv)
           Bellucco2017_Res = Bellucco2017_Res + Bellucco2017_Res_surf * sfr(2+iv)/VegFracSum
        ENDIF
     ENDDO
  ENDIF
  !Fc_respi = Bellucco2017_Res * (sfr(ConifSurf)*(1-snowFrac(ConifSurf))+sfr(DecidSurf)*(1-snowFrac(DecidSurf))+ &
  !                                  sfr(GrassSurf)*(1-snowFrac(GrassSurf))+sfr(BSoilSurf)*(1-snowFrac(BSoilSurf)))
  Fc_respi = Bellucco2017_Res * (sfr(ConifSurf)+sfr(DecidSurf)+sfr(GrassSurf)+sfr(BSoilSurf))

  ! Combine to find biogenic CO2 flux
  Fc_biogen = Fc_photo + Fc_respi


  RETURN

ENDSUBROUTINE CO2_biogen
!========================================================================================

! MODULE OHM_module
!   ! USE allocateArray
!   ! USE data_in
!   ! USE defaultNotUsed
!   ! USE gis_data
!   ! USE sues_data
!   ! USE time
!
!   IMPLICIT NONE
! CONTAINS
!========================================================================================
SUBROUTINE OHM(qn1,qn1_av,dqndt,&
     qn1_S,qn1_s_av,dqnsdt,&
     tstep,dt_since_start,&
     sfr,nsurf,&
     Tair_mav_5d,&
     OHM_coef,&
     OHM_threshSW,OHM_threshWD,&
     soilmoist_id,soilstoreCap,state_id,&
     BldgSurf,WaterSurf,&
     SnowUse,SnowFrac,&
     DiagQS,&
     a1,a2,a3,qs,deltaQi)!output
  ! Made by HCW Jan 2015 to replace OHMnew (no longer needed).
  ! Calculates net storage heat flux (QS) from Eq 4, Grimmond et al. 1991, Atm Env.
  ! Accounts for variable timesteps in dQ*/dt term.
  ! BareSoilSurfFraction removed so bare soil is now handled like other surfaces.
  ! Snow part changed from summer wet to winter wet coefficients.
  ! Changed -333 checks to -999 checks and added error handling
  ! Gradient now calculated for t-1 (was previously calculated for t-2).
  ! TS 28 Jun 2018:
  !  improved and tested the phase-in method for calculating dqndt
  ! TS & SG 30 Apr 2018:
  !  a new calculation scheme of dqndt by using a phase-in approach that releases
  !  the requirement for storeing multiple qn values for adapting SUEWS into WRF
  ! TS 07 Aug 2017:
  !  1. interface changed to account for explict passing
  !  2. calculation refactorization.
  ! HCW 25 Feb 2015:
  !  Adapted q1,q2,q3 & r1,r2,r3 for multiple grids
  ! HCW 14 Dec 2016:
  !  Thresholds for Summer/Winter and Wet/Dry now provided in input files
  !  Calculation of dqndt now uses hourly running mean rather than instantaneous values
  ! To Do:
  !   - No canyons implemented at the moment [OHM_coef(nsurf+1,,)]
  !========================================================================================


  IMPLICIT NONE
  INTEGER, INTENT(in) :: tstep          ! time step [s]
  INTEGER, INTENT(in) :: dt_since_start ! time since simulation starts [s]

  REAL(KIND(1d0)),INTENT(in)::qn1                             ! net all-wave radiation
  REAL(KIND(1d0)),INTENT(in)::qn1_S                           ! net all-wave radiation over snow
  REAL(KIND(1d0)),INTENT(in)::sfr(nsurf)                      ! surface fractions
  REAL(KIND(1d0)),INTENT(in)::SnowFrac(nsurf)                 ! snow fractions of each surface
  REAL(KIND(1d0)),INTENT(in)::Tair_mav_5d                          ! Tair_mav_5d=HDD(id-1,4) HDD at the begining of today (id-1)
  REAL(KIND(1d0)),INTENT(in)::OHM_coef(nsurf+1,4,3)                 ! OHM coefficients
  REAL(KIND(1d0)),INTENT(in)::OHM_threshSW(nsurf+1),OHM_threshWD(nsurf+1) ! OHM thresholds
  REAL(KIND(1d0)),INTENT(in)::soilmoist_id(nsurf)                ! soil moisture
  REAL(KIND(1d0)),INTENT(in)::soilstoreCap(nsurf)             ! capacity of soil store
  REAL(KIND(1d0)),INTENT(in)::state_id(nsurf) ! wetness status

  INTEGER,INTENT(in)::nsurf     ! number of surfaces
  ! INTEGER,INTENT(in)::nsh       ! number of timesteps in one hour
  ! integer,intent(in) :: dt      ! current timestep [second]
  ! integer,intent(INOUT) :: dt0  ! period length for qn1 memory
  INTEGER,INTENT(in)::BldgSurf  ! code for specific surfaces
  INTEGER,INTENT(in)::WaterSurf ! code for specific surfaces
  INTEGER,INTENT(in)::SnowUse   ! option for snow related calculations
  INTEGER,INTENT(in)::DiagQS    ! diagnostic option

  REAL(KIND(1d0)),INTENT(inout)::qn1_av
  REAL(KIND(1d0)),INTENT(inout)::dqndt  !Rate of change of net radiation [W m-2 h-1] at t-1
  REAL(KIND(1d0)),INTENT(inout)::qn1_s_av
  REAL(KIND(1d0)),INTENT(inout)::dqnsdt  !Rate of change of net radiation [W m-2 h-1] at t-1
  ! REAL(KIND(1d0)),INTENT(inout)::qn1_store_grid(nsh)
  ! REAL(KIND(1d0)),INTENT(inout)::qn1_av_store_grid(2*nsh+1)
  ! REAL(KIND(1d0)),INTENT(inout)::qn1_S_store_grid(nsh)
  ! REAL(KIND(1d0)),INTENT(inout)::qn1_S_av_store_grid(2*nsh+1)


  REAL(KIND(1d0)),INTENT(out):: qs ! storage heat flux
  ! REAL(KIND(1d0)),INTENT(out)::deltaQi(nsurf+1) ! storage heat flux of snow surfaces
  REAL(KIND(1d0)),INTENT(out)::deltaQi(nsurf) ! storage heat flux of snow surfaces

  REAL(KIND(1d0)),INTENT(out):: a1,a2,a3 ! OHM coefficients of grid

  ! REAL(KIND(1d0)):: nsh_nna ! number of timesteps per hour with non -999 values (used for spinup)

  ! REAL(KIND(1d0)):: dqndt    !Rate of change of net radiation [W m-2 h-1] at t-1
  ! REAL(KIND(1d0)):: surfrac  !Surface fraction accounting for SnowFrac if appropriate

  ! REAL(KIND(1d0)):: qn1_av, qn1_S_av    !Average net radiation over previous hour [W m-2]
  REAL(KIND(1d0)):: deltaQi0 ! temporarily store




  ! REAL(KIND(1d0)):: qn1_store_grid0(nsh), qn1_av_store_grid0(2*nsh+1) ! temporarily store

  !These are now provided in SiteInfo (OHMthresh for Summer/Winter and Wet/Dry)
  !!real(kind(1d0)):: OHM_TForSummer = 5  !Use summer coefficients if 5-day Tair >= 5 degC
  !real(kind(1d0)):: OHM_TForSummer = 10  !Use summer coefficients if 5-day Tair >= 10 degC - modified for UK HCW 14 Dec 2015
  !real(kind(1d0)):: OHM_SMForWet = 0.9  !Use wet coefficients if SM close to soil capacity

  CALL OHM_coef_cal(sfr,nsurf,&
       Tair_mav_5d,OHM_coef,OHM_threshSW,OHM_threshWD,&
       soilmoist_id,soilstoreCap,state_id,&
       BldgSurf,WaterSurf,&
       SnowUse,SnowFrac,&
       a1,a2,a3)
  ! WRITE(*,*) '----- OHM coeffs new-----'
  ! WRITE(*,*) a1,a2,a3


  ! Old OHM calculations (up to v2016a)
  !! Calculate radiation part ------------------------------------------------------------
  !qs=NAN              !qs  = Net storage heat flux  [W m-2]
  !if(qn1>-999) then   !qn1 = Net all-wave radiation [W m-2]
  !   !if(q1>-999.and.q3>-999) then
  !      !dqndt = 0.5*(q3-q1)*nsh_real                !gradient at t-2
  !      dqndt = 0.5*(qn1-q2_grids(Gridiv))*nsh_real   !gradient at t-1
  !
  !      !Calculate net storage heat flux
  !      qs = qn1*a1 + dqndt*a2 + a3   !Eq 4, Grimmond et al. 1991
  !   !endif
  !   !q1=q2  !q1 = net radiation at t-2 (at t-3 when q1 used in next timestep)
  !   !q2=q3  !q2 = net radiation at t-1
  !   !q3=qn1  !q3 = net radiation at t   (at t-1 when q3 used in next timestep)
  !   q1_grids(Gridiv) = q2_grids(Gridiv) !q1 = net radiation at t-2 (at t-3 when q1 used in next timestep)
  !   q2_grids(Gridiv) = q3_grids(Gridiv) !q2 = net radiation at t-1
  !   q3_grids(Gridiv) = qn1              !q3 = net radiation at t (at t-1 when q3 used in next timestep)
  !else
  !   call ErrorHint(21,'Bad value for qn1 found during OHM calculation',qn1,NotUsed,notUsedI)
  !endif


  ! New OHM calculations (v2017a onwards) using running mean (HCW Dec 2016)
  ! Calculate radiation part ------------------------------------------------------------
  qs=-999              !qs  = Net storage heat flux  [W m-2]
  IF(qn1>-999) THEN   !qn1 = Net all-wave radiation [W m-2]
     ! Store instantaneous qn1 values for previous hour (qn1_store_grid) and average (qn1_av)
     ! print*,''
     ! CALL OHM_dqndt_cal(nsh,qn1,qn1_store_grid,qn1_av_store_grid,dqndt)
     ! print*, 'old dqndt',dqndt
     CALL OHM_dqndt_cal_X(tstep,dt_since_start,qn1_av,qn1,dqndt)
     ! print*, 'new dqndt',dqndt


     ! Calculate net storage heat flux
     CALL OHM_QS_cal(qn1,dqndt,a1,a2,a3,qs)
     IF(DiagQS==1) WRITE(*,*) 'qs: ',qs,'qn1:',qn1,'dqndt: ',dqndt

  ELSE
     CALL ErrorHint(21,'In SUEWS_OHM.f95: bad value for qn1 found during qs calculation.',qn1,-55.55d0,-55)
  ENDIF

  !write(*,*) qs
  !write(*,*) '--------------------'

  ! Do snow calculations separately -----
  ! Added by LJ in August 2013
  IF(snowUse==1) THEN
     deltaQi=-999
     IF(qn1_S>-999) THEN
        ! Old OHM calculations (commented out HCW Dec 2016)
        !!if(r1>-999.and.r3>-999) then
        !   !dqndt = 0.5*(r3-r1)*nsh_real    !gradient at t-2
        !   dqndt = 0.5*(qn1_S-r2_grids(Gridiv))*nsh_real     !gradient at t-1
        !   ! Calculate net storage heat flux for snow surface (winter wet conditions HCW 15/01/2015)
        !   deltaQi = qn1_S*OHM_coef(nsurf+1,3,1) + dqndt*OHM_coef(nsurf+1,3,2) + OHM_coef(nsurf+1,3,3)
        !!endif
        !r1_grids(Gridiv)=r2_grids(Gridiv)
        !r2_grids(Gridiv)=r3_grids(Gridiv)
        !r3_grids(Gridiv)=qn1_S
        ! New OHM calculations
        ! Store instantaneous qn1 values for previous hour (qn1_store_grid) and average (qn1_av)
        ! CALL OHM_dqndt_cal(nsh,qn1_S,qn1_S_store_grid,qn1_S_av_store_grid,dqndt)

        CALL OHM_dqndt_cal_X(tstep,dt_since_start,qn1_s_av,qn1,dqnsdt)

        ! Calculate net storage heat flux for snow surface (winter wet conditions)
        CALL OHM_QS_cal(qn1_S,dqndt,&
             OHM_coef(nsurf+1,3,1),OHM_coef(nsurf+1,3,2),OHM_coef(nsurf+1,3,3),&
             deltaQi0)
        deltaQi=deltaQi0


     ELSE
        CALL ErrorHint(21,'In SUEWS_OHM.f95: bad value for qn1(snow) found during qs calculation.',qn1_S,-55.55d0,-55)
     ENDIF

  ENDIF

  RETURN
ENDSUBROUTINE OHM
!========================================================================================

SUBROUTINE OHM_coef_cal(sfr,nsurf,&
     Tair_mav_5d,OHM_coef,OHM_threshSW,OHM_threshWD,&
     soilmoist_id,soilstoreCap,state_id,&
     BldgSurf,WaterSurf,&
     SnowUse,SnowFrac,&
     a1,a2,a3)
  IMPLICIT NONE
  INTEGER , INTENT(in) :: &
       nsurf,& ! number of surfaces
       SnowUse,& ! option for snow related calculations
       BldgSurf,WaterSurf ! code for specific surfaces
  REAL(KIND(1d0)), INTENT(in) :: &
       sfr(nsurf),& ! surface cover fractions
       SnowFrac(nsurf),& ! snow fractions of each surface
       Tair_mav_5d,& ! Tair_mav_5d=HDD(id-1,4) HDD at the begining of today (id-1)
       OHM_coef(nsurf+1,4,3),&
       OHM_threshSW(nsurf+1),OHM_threshWD(nsurf+1),& ! OHM thresholds
       soilmoist_id(nsurf),& ! soil moisture
       soilstoreCap(nsurf),&! capacity of soil store
       state_id(nsurf) ! wetness status
  REAL(KIND(1d0)), INTENT(out):: a1,a2,a3

  REAL(KIND(1d0)) :: surfrac
  INTEGER :: i,ii,is

  ! OHM coefficients --------
  ! Set to zero initially
  a1=0   ![-]
  a2=0   ![h]
  a3=0   ![W m-2]
  ! -------------------------

  ! Loop through surface types ----------------------------------------------------------
  DO is=1,nsurf
     surfrac=sfr(is)

     ! Use 5-day running mean Tair to decide whether it is summer or winter ----------------
     IF(Tair_mav_5d >= OHM_threshSW(is)) THEN !Summer
        ii=0
     ELSE          !Winter
        ii=2
     ENDIF

     IF(state_id(is) > 0) THEN     !Wet surface
        i=ii+1
     ELSE                    !Dry surface
        i=ii+2
        ! If the surface is dry but SM is close to capacity, use coefficients for wet surfaces
        IF(is>BldgSurf.AND.is/=WaterSurf)THEN    !Wet soil (i.e. EveTr, DecTr, Grass, BSoil surfaces)
           IF(soilmoist_id(is)/soilstoreCap(is) > OHM_threshWD(is) ) THEN
              i=ii+1
           ENDIF
        ENDIF
     ENDIF

     ! If snow, adjust surface fractions accordingly
     IF(SnowUse==1.AND.is/=BldgSurf.AND.is/=WaterSurf) THEN   ! QUESTION: Why is BldgSurf excluded here?
        surfrac=surfrac*(1-SnowFrac(is))
     ENDIF

     ! Calculate the areally-weighted OHM coefficients
     a1 = a1+surfrac*OHM_coef(is,i,1)
     a2 = a2+surfrac*OHM_coef(is,i,2)
     a3 = a3+surfrac*OHM_coef(is,i,3)

  ENDDO  !end of loop over surface types ------------------------------------------------
END SUBROUTINE OHM_coef_cal

! Updated OHM calculations for WRF-SUEWS coupling (v2018b onwards) weighted mean (TS Apr 2018)
SUBROUTINE OHM_dqndt_cal_X(dt,dt_since_start,qn1_av,qn1,dqndt)
  IMPLICIT NONE
  INTEGER, INTENT(in)            :: dt              ! time step [s]
  INTEGER, INTENT(in)            :: dt_since_start  ! time since simulation starts [s]
  REAL(KIND(1d0)), INTENT(in)    :: qn1             ! new qn1 value [W m-2]
  REAL(KIND(1d0)), INTENT(inout) :: qn1_av          ! weighted average of qn1 [W m-2]
  REAL(KIND(1d0)), INTENT(inout) :: dqndt           ! dQ* per dt for 60 min [W m-2 h-1]
  REAL(KIND(1d0)), PARAMETER     :: dt0_thresh=3600 ! threshold for period of dqndt0 [s]
  REAL(KIND(1d0)), PARAMETER     :: window_hr=2     ! window size for Difference calculation [hr]

  INTEGER :: dt0 ! period of dqndt0 [s]

  REAL(KIND(1d0))  :: qn1_av_0 !, qn1_av_start,qn1_av_end

  ! if previous period shorter than dt0_thresh, expand the storage/memory period
  IF ( dt_since_start< dt0_thresh)  THEN ! spinup period
     dt0 = dt_since_start+dt

  ELSE ! effective period
     dt0 = dt0_thresh
  ENDIF

  ! get weighted average at a previous time specified by `window_hr`
  qn1_av_0=qn1_av-dqndt*(window_hr-dt/3600)

  ! averaged qn1 for previous period = dt0_thresh
  qn1_av=(qn1_av*(dt0-dt)+qn1*dt)/(dt0)

  ! do weighted average to calculate the difference by using the memory value and new forcing value
  ! NB: keep the output dqndt in [W m-2 h-1]
  dqndt=(qn1_av-qn1_av_0)/window_hr


END SUBROUTINE OHM_dqndt_cal_X


! New OHM calculations (v2017a-v2018a) using running mean (HCW Dec 2016)
SUBROUTINE OHM_dqndt_cal(nsh,qn1,qn1_store_grid,qn1_av_store_grid,dqndt)
  IMPLICIT NONE
  INTEGER, INTENT(in)            :: nsh                   ! number of timesteps in one hour
  REAL(KIND(1d0)), INTENT(in)    :: qn1
  REAL(KIND(1d0)), INTENT(inout) :: qn1_store_grid(nsh)        ! instantaneous qn1 values for previous hour
  REAL(KIND(1d0)), INTENT(inout) :: qn1_av_store_grid(2*nsh+1) ! average qn1 values for previous hour
  REAL(KIND(1d0)), INTENT(out)   :: dqndt                 !dQ* per dt for 60 min

  REAL(KIND(1d0)) :: qn1_av
  INTEGER :: nsh_nna

  dqndt=-999 ! initialise as -999

  ! Store instantaneous qn1 values for previous hour (qn1_store_grid) and average (qn1_av)
  IF(nsh > 1) THEN
     qn1_store_grid=CSHIFT(qn1_store_grid,1) ! shift to left with one place
     qn1_store_grid(nsh)=qn1
     nsh_nna = COUNT(qn1_store_grid/=-999, dim=1) !Find how many are not -999s  !bug fixed HCW 08 Feb 2017
     qn1_av = SUM(qn1_store_grid, mask=qn1_store_grid/= -999)/nsh_nna
  ELSEIF(nsh==1) THEN
     qn1_store_grid(:) = qn1
     qn1_av = qn1
  ENDIF
  ! Store hourly average values (calculated every timestep) for previous 2 hours
  IF(nsh > 1) THEN
     qn1_av_store_grid=CSHIFT(qn1_av_store_grid,1)
     qn1_av_store_grid(2*nsh+1) = qn1_av
  ELSEIF(nsh==1) THEN
     qn1_av_store_grid(:) = qn1_av
  ENDIF
  ! Calculate dQ* per dt for 60 min (using running mean Q* at t hours and (t-2) hours)
  IF(ANY(qn1_av_store_grid == -999)) THEN
     dqndt=0  ! Set dqndt term to zero for spinup
  ELSE
     dqndt=0.5*(qn1_av_store_grid((2*nsh+1))-qn1_av_store_grid(1))
  ENDIF

END SUBROUTINE OHM_dqndt_cal

SUBROUTINE OHM_QS_cal(qn1,dqndt,a1,a2,a3,qs)
  IMPLICIT NONE
  REAL(KIND(1d0)), INTENT(in) :: qn1,dqndt,a1,a2,a3
  REAL(KIND(1d0)), INTENT(out):: qs
  qs=-999 ! initialise as -999
  qs = qn1*a1 + dqndt*a2 + a3   !Eq 4, Grimmond et al. 1991

END SUBROUTINE OHM_QS_cal


! END MODULE OHM_module

!This subroutine does the actual calculations of the SUEWS code (mostly old SUEWS_Temporal).
!Made by LJ and HW Oct 2014
!Gives in the grid ID (Gridiv) and number of line in the met forcing data to be analyzed (ir)
!Last modification
!
!Last modification:
! TS  02 May 2018 - added explict interfaces
! LJ  15 Jun 2017 - Add parts where NonWaterFraction=0 is used as a divider so that the code won't crash with 100% water
! TS  20 May 2017 - Add surface-level diagonostics: T2, Q2, U10
! HCW 09 Dec 2016 - Add zenith and azimuth to output file
! HCw 24 Aug 2016 - smd and state for each surface set to NAN in output file if surface does not exist.
!                 - Added Fc to output file
! HCW 21 Jul 2016 - Set soil variables to -999 in output when grid is 100% water surface.
! HCW 29 Jun 2016 - Commented out StateDay and SoilMoistDay as creates jumps and should not be needed.
!                   Would not work unless each met block consists of a whole day for each grid.
! TS 09 Mar 2016  - Added AnOHM subroutine to calculate heat storage
! HCW 10 Mar 2016 - Calculation of soil moisture deficit of vegetated surfaces added (vsmd)
! LJ 2 Jan 2016   - Calculation of snow fraction moved from SUEWS_Calculations to SUEWS_Snow
! HCW 12 Nov 2015 - Added z0m and zdm to output file
! HCW 05 Nov 2015 - Changed Kawai et al. (2007) z0v calculation so VegFraction(veg+soil) rather than veg_fr(veg+soil+water) is used.
! HCW 29 Jun 2015 - Added albEveTr and albGrass
! HCW 25 Jun 2015 - Fixed bug in LAI calculation at year change.
!                 - Changed AlbDec to use id value (not (id-1) value) to avoid issues at year change.
! HCW 27 Apr 2015 - Correction to tot_chang_per_tstep calculation (water balance should now close)
! HCW 16 Feb 2015 - Updated water balance calculations
!                 - Corrected area-averaged calculations (soil moisture, drain, two versions of state with/out water)
!                 - Replaced soilmoist_state variable with SoilState (as seems to be duplicate)
! HCW 15 Jan 2015 - Added switch OHMIncQF to calculate QS with (1, default) or without (0) QF added to QSTAR
! To do
!      - add iy and imin to output files (may impact LUMPS_RunoffFromGrid)
!      - phase out _per_interval water balance variables
!      - renormalise by NonWaterFraction where necessary
!      - Update Snow subroutines similarly in terms of water balance
!==================================================================

SUBROUTINE SUEWS_Calculations(Gridiv, ir, iMB, irMax)
  USE data_in, ONLY: diagnose, ah_min, ah_slope_cooling, ah_slope_heating, &
       alt, avkdn, avrh, avu1, basetHDD, diagqn, diagqs, drainrt, ef_umolco2perj, &
       emissionsmethod, enef_v_jkm, enddls, fcef_v_kgkm, fcld_obs, &
       frfossilfuel_heat, frfossilfuel_nonheat, EvapMethod, &
       LAIcalcyes, LAI_obs, lat, ldown_obs, lng, maxqfmetab, minqfmetab, &
       netradiationmethod, numcapita, ohmincqf, popdensdaytime, popdensnighttime, &
       precip, press_hpa, qf0_beu, qf_a, qf_b, qf_c, &
       qh_obs, qn1_obs, qs_obs, qf_obs,&
       raincover, rainmaxres, &
       roughlenmommethod, smdmethod, snow_obs, snowuse, startdls, &
       storageheatmethod, t_critic_cooling, t_critic_heating, temp_c, &
       timezone, trafficrate, trafficunits, waterusemethod, xsmd
  USE time, ONLY : iy, id, it, imin, isec, dt_since_start
  USE allocateArray, ONLY: &
       alb, &
       AlbMax_DecTr, AlbMax_EveTr, AlbMax_grass, &
       AlbMin_dectr, AlbMin_evetr, AlbMin_grass, &
       alpha_bioco2, alpha_enh_bioco2, baset, basete, &
       beta_bioco2, beta_enh_bioco2, capmax_dec, capmin_dec, &
       chanohm, cpanohm, emis, GDD_id, GDDfull,&
       HDD_id, &
       DecidCap_id,&
       albDecTr_id,&
       albEveTr_id,&
       albGrass_id,&
       porosity_id,&
       icefrac, kkanohm, &
       LAI_id, LAImax, LAImin, LAIpower, LAItype, maxconductance, &
       meltwaterstore, metforcingdata_grid, min_res_bioco2, &
       narp_emis_snow, narp_trans_site, &
       ohm_coef, ohm_threshsw, ohm_threshwd, &
       pormax_dec, pormin_dec, &
       dqndt,qn1_av,&
       dqnsdt,qn1_s_av,&
       resp_a, resp_b, sathydraulicconduct, sddfull, &
       sfr, snowd, snowdens, snowfrac, snowpack, &
       soildepth, soilmoist_id, soilstorecap, state_id, statelimit, &
       StoreDrainPrm, tair24hr, theta_bioco2,ts5mindata_ir, &
       waterdist, wetthresh, &
       WUDay_id,&
       AHProf_24Hr,HumActivity_24Hr,PopProf_24Hr,TraffProf_24Hr,WUProfA_24hr, WUProfM_24hr, &
       datetimeline, dataoutlinesuews, dataoutlinesnow, &
       dataoutlineestm, dailystateline, dataoutdailystate, &
       dataoutsuews, dataoutsnow, dataoutestm

  USE sues_data, ONLY: &
       aerodynamicresistancemethod, daywat, daywatper, faut, flowchange, &
       ie_a, ie_end, ie_m, ie_start, internalwateruse_h, &
       irrfracconif, irrfracdecid, irrfracgrass,&
       pipecapacity, roughlenheatmethod, runofftowater, stabilitymethod,&
       surfacearea, tstep,tstep_prev
  USE snowMod, ONLY: &
       crwmax, crwmin, preciplimit, preciplimitalb, radmeltfact,&
       snowalb, snowAlbMax, snowAlbMin, &
       snowdensmax, snowdensmin, snowfallcum, snowlimbuild, &
       snowlimpaved, SnowProf_24hr,&
       tau_a, tau_f, tau_r, tempmeltfact
  USE gis_data, ONLY: &
       bldgh, dectreeh, evetreeh, faibldg, faidectree, faievetree, veg_type
  USE initial, ONLY : NumberOfGrids, ReadLinesMetdata
  USE mod_z, ONLY : z, z0m_in, zdm_in
  USE SUEWS_Driver, ONLY: suews_update_output
  USE resist, ONLY: g1, g2, g3, g4, g5, g6, gsmodel, kmax, s1, s2, th, tl
  USE DailyState_module, ONLY : SUEWS_update_DailyState
  USE SUEWS_Driver,ONLY: SUEWS_cal_Main

  IMPLICIT NONE

  INTEGER :: Gridiv
  INTEGER :: ir
  INTEGER :: iMB
  INTEGER :: irMax

  !==================================================================


  !Translate all data to the variables used in the model calculations
  IF(Diagnose==1) WRITE(*, *) 'Calling SUEWS_Translate...'
  CALL SUEWS_Translate(Gridiv, ir, iMB)


  IF(Diagnose==1) PRINT*, 'Calling SUEWS_cal_Main...'
  CALL SUEWS_cal_Main(&
       AerodynamicResistanceMethod,AH_MIN,AHProf_24hr,AH_SLOPE_Cooling,& ! input&inout in alphabetical order
       AH_SLOPE_Heating,&
       alb,AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
       AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
       alpha_bioCO2,alpha_enh_bioCO2,alt,avkdn,avRh,avU1,BaseT,BaseTe,&
       BaseTHDD,beta_bioCO2,beta_enh_bioCO2,bldgH,CapMax_dec,CapMin_dec,&
       chAnOHM,cpAnOHM,CRWmax,CRWmin,DayWat,DayWatPer,&
       DecTreeH,Diagnose,DiagQN,DiagQS,DRAINRT,&
       dt_since_start,dqndt,qn1_av,dqnsdt,qn1_s_av,&
       EF_umolCO2perJ,emis,EmissionsMethod,EnEF_v_Jkm,endDLS,EveTreeH,FAIBldg,&
       FAIDecTree,FAIEveTree,Faut,FcEF_v_kgkm,fcld_obs,FlowChange,&
       FrFossilFuel_Heat,FrFossilFuel_NonHeat,G1,G2,G3,G4,G5,G6,GDD_id,&
       GDDFull,Gridiv,gsModel,HDD_id,HumActivity_24hr,&
       IceFrac,id,Ie_a,Ie_end,Ie_m,Ie_start,imin,&
       InternalWaterUse_h,IrrFracConif,IrrFracDecid,IrrFracGrass,isec,it,EvapMethod,&
       iy,kkAnOHM,Kmax,LAI_id,LAICalcYes,LAIMax,LAIMin,LAI_obs,&
       LAIPower,LAIType,lat,ldown_obs,lng,MaxConductance,MaxQFMetab,&
       MeltWaterStore,MetForcingData_grid,MinQFMetab,min_res_bioCO2,&
       NARP_EMIS_SNOW,NARP_TRANS_SITE,NetRadiationMethod,&
       NumCapita,OHM_coef,OHMIncQF,OHM_threshSW,&
       OHM_threshWD,PipeCapacity,PopDensDaytime,&
       PopDensNighttime,PopProf_24hr,PorMax_dec,PorMin_dec,&
       Precip,PrecipLimit,PrecipLimitAlb,Press_hPa,&
       QF0_BEU,Qf_A,Qf_B,Qf_C,&
       qn1_obs,qh_obs,qs_obs,qf_obs,&
       RadMeltFact,RAINCOVER,RainMaxRes,resp_a,resp_b,&
       RoughLenHeatMethod,RoughLenMomMethod,RunoffToWater,S1,S2,&
       SatHydraulicConduct,SDDFull,sfr,SMDMethod,SnowAlb,SnowAlbMax,&
       SnowAlbMin,snowD,SnowDens,SnowDensMax,SnowDensMin,SnowfallCum,snowFrac,&
       SnowLimBuild,SnowLimPaved,snow_obs,SnowPack,SnowProf_24hr,snowUse,SoilDepth,&
       soilmoist_id,soilstoreCap,StabilityMethod,startDLS,state_id,StateLimit,&
       StorageHeatMethod,StoreDrainPrm,SurfaceArea,Tair24HR,tau_a,tau_f,tau_r,&
       T_CRITIC_Cooling,T_CRITIC_Heating,Temp_C,TempMeltFact,TH,&
       theta_bioCO2,timezone,TL,TrafficRate,TrafficUnits,&
       TraffProf_24hr,Ts5mindata_ir,tstep,tstep_prev,veg_type,&
       WaterDist,WaterUseMethod,WetThresh,&
       WUDay_id,DecidCap_id,albDecTr_id,albEveTr_id,albGrass_id,porosity_id,&
       WUProfA_24hr,WUProfM_24hr,xsmd,Z,z0m_in,zdm_in,&
       datetimeLine,dataOutLineSUEWS,dataOutLineSnow,dataOutLineESTM,&!output
       DailyStateLine)!output

  !============ update and write out SUEWS_cal_DailyState ===============
  ! only works at the last timestep of a day
  CALL SUEWS_update_DailyState(&
       id, datetimeLine, &!input
       Gridiv, NumberOfGrids, &
       DailyStateLine, &
       dataOutDailyState)!inout

  !============ write out results ===============
  ! works at each timestep
  CALL SUEWS_update_output(&
       SnowUse, storageheatmethod, &!input
       ReadLinesMetdata, NumberOfGrids, &
       ir, gridiv, datetimeLine, dataOutLineSUEWS, dataOutLineSnow, dataOutLineESTM, &!input
       dataOutSUEWS, dataOutSnow, dataOutESTM)!inout


  ! NB: CBL disabled for the moment for interface improvement
  ! NB: CBL be decoupled from SUEWS TS 10 Jun 2018
  ! IF(CBLuse>=1)THEN ! If CBL is used, calculated Temp_C and RH are replaced with the obs.
  !    IF(Diagnose==1) WRITE(*,*) 'Calling CBL...'
  !    CALL CBL(ir,iMB,Gridiv)   !ir=1 indicates first row of each met data block
  ! ENDIF


  ! NB: SOLWEIG can be treated as a separate part:
  ! NB: SOLWEIG is disabled for v2018a TS 10 Jun 2018
  ! ===================SOLWEIG OUTPUT ========================================
  ! IF (SOLWEIGuse==1) THEN
  !    IF (OutInterval==imin) THEN
  !       IF (RunForGrid==-999) THEN
  !          IF(Diagnose==1) WRITE(*,*) 'Calling SOLWEIG_2014a_core...'
  !          CALL SOLWEIG_2014a_core(iMB)
  !          SolweigCount=SolweigCount+1
  !       ELSE
  !          IF (Gridiv == RunForGrid) THEN
  !             IF(Diagnose==1) WRITE(*,*) 'Calling SOLWEIG_2014a_core...'
  !             CALL SOLWEIG_2014a_core(iMB)
  !             SolweigCount=SolweigCount+1
  !          ENDIF
  !       ENDIF
  !    ENDIF
  ! ELSE
  ! SOLWEIGpoi_out=0 ! NB: turn off SOLWEIG for the moment
  ! ENDIF
  ! ===================SOLWEIG END================================

  IF(Diagnose==1) WRITE(*, *) 'Calling SUEWS_TranslateBack...'
  CALL SUEWS_TranslateBack(Gridiv, ir, irMax)

END SUBROUTINE SUEWS_Calculations

!========================================================================================
! a mini version of SUEWS to be coupled with WRF
! TS 22 Apr 2018: initial
! TS 11 Jun 2018: modified according to recent SUEWS development


MODULE SuMin_Module
  USE SUEWS_Driver,ONLY:SUEWS_cal_Main,&
       PavSurf,BldgSurf,ConifSurf,DecidSurf,GrassSurf,BSoilSurf,WaterSurf,&
       ivConif,ivDecid,ivGrass,&
       ncolumnsDataOutSUEWS,ncolumnsDataOutSnow,&
       ncolumnsDataOutESTM,ncolumnsDataOutDailyState

  IMPLICIT NONE

CONTAINS

  ! a mini version of SUEWS
  SUBROUTINE SuMin(&
       snowUse,EmissionsMethod,NetRadiationMethod,RoughLenHeatMethod,&! model options
       RoughLenMomMethod,StorageHeatMethod,AerodynamicResistanceMethod,OHMIncQF,&! model options
       iy,id,it,imin,isec,dt_since_start,tstep,tstep_prev,startDLS,endDLS,&! time-related input
       alt,lat,lng,Z,timezone,SurfaceArea,sfr,&! site-specific geographical settings
       z0m_in,zdm_in,&! roughness related settings
       alb,emis,SnowAlb,OHM_coef,WaterDist,&
       AHProf_24hr,HumActivity_24hr,PopProf_24hr,TraffProf_24hr,WUProfA_24hr,WUProfM_24hr,&
       qn1_av,dqndt,qn1_s_av,dqnsdt,&
       surf_var_id,DecidCap_id,albDecTr_id,albEveTr_id,albGrass_id,porosity_id,&
       GDD_id,HDD_id,LAI_id,WUDay_id,soilmoist_id,state_id,MeltWaterStore,&
       avkdn,avRh,avU1,Press_hPa,Temp_C,Precip,& ! forcing variables
       qf,qs,qh,qe,qsfc,tsk,CHKLOWQ)!output

    ! model configurations
    INTEGER,INTENT(in) ::snowUse
    INTEGER,INTENT(in) ::EmissionsMethod
    INTEGER,INTENT(in) ::NetRadiationMethod
    INTEGER,INTENT(IN) ::RoughLenHeatMethod
    INTEGER,INTENT(IN) ::RoughLenMomMethod
    INTEGER,INTENT(IN) ::StorageHeatMethod
    INTEGER,INTENT(IN) ::AerodynamicResistanceMethod
    INTEGER,INTENT(IN) ::OHMIncQF  !OHM calculation uses Q* only (0) or Q*+QF (1)

    ! time-related input
    INTEGER,INTENT(IN) ::iy
    INTEGER,INTENT(IN) ::id
    INTEGER,INTENT(IN) ::it
    INTEGER,INTENT(IN) ::imin
    INTEGER,INTENT(in) ::isec
    INTEGER,INTENT(in) ::dt_since_start ! time since simulation starts [s]
    INTEGER,INTENT(IN) ::tstep
    INTEGER,INTENT(IN) ::tstep_prev ! tstep size of the previous step
    INTEGER,INTENT(IN) ::startDLS ! start of daylight saving (inclusive)
    INTEGER,INTENT(IN) ::endDLS ! end of daylight saving (inclusive)


    ! site-specific geographical settings
    REAL(KIND(1D0)),INTENT(IN)              ::alt
    REAL(KIND(1D0)),INTENT(IN)              ::lat
    REAL(KIND(1D0)),INTENT(IN)              ::lng
    REAL(KIND(1D0)),INTENT(IN)              ::Z
    REAL(KIND(1D0)),INTENT(IN)              ::timezone
    REAL(KIND(1D0)),INTENT(IN)              ::SurfaceArea
    REAL(KIND(1D0)),DIMENSION(7),INTENT(IN) ::sfr


    ! roughness related settings
    REAL(KIND(1D0)),INTENT(in) ::z0m_in
    REAL(KIND(1D0)),INTENT(in) ::zdm_in

    ! radiation related settings:
    REAL(KIND(1D0)),DIMENSION(7),INTENT(INOUT) ::alb
    REAL(KIND(1D0)),DIMENSION(7),INTENT(IN)    ::emis
    REAL(KIND(1D0)),INTENT(INOUT) ::SnowAlb

    ! OHM coeffcients
    REAL(KIND(1D0)),DIMENSION(7+1,4,3),INTENT(IN) ::OHM_coef

    ! hydrology related settings
    REAL(KIND(1D0)),DIMENSION(7+1,7-1),INTENT(IN) ::WaterDist

    ! profiles at 24 hours
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(in) :: AHProf_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(in) :: HumActivity_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(in) :: PopProf_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(in) :: TraffProf_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(in) :: WUProfA_24hr
    REAL(KIND(1D0)),DIMENSION(0:23,2),INTENT(in) :: WUProfM_24hr


    ! daily states, also initial conditions

    REAL(KIND(1d0)),INTENT(INOUT) ::qn1_av
    REAL(KIND(1d0)),INTENT(INOUT) ::dqndt
    REAL(KIND(1d0)),INTENT(INOUT) ::qn1_s_av !qn1_av for snow
    REAL(KIND(1d0)),INTENT(INOUT) ::dqnsdt !dqndt for snow
    REAL(KIND(1d0)),INTENT(INOUT) ::DecidCap_id
    REAL(KIND(1d0)),INTENT(INOUT) ::albDecTr_id
    REAL(KIND(1d0)),INTENT(INOUT) ::albEveTr_id
    REAL(KIND(1d0)),INTENT(INOUT) ::albGrass_id
    REAL(KIND(1d0)),INTENT(INOUT) ::porosity_id
    REAL(KIND(1d0)),DIMENSION(5),INTENT(INOUT)   ::GDD_id       !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(12),INTENT(INOUT)  ::HDD_id       !Growing Degree Days (see SUEWS_DailyState.f95)
    REAL(KIND(1d0)),DIMENSION(3),INTENT(INOUT)   ::LAI_id       !LAI for each veg surface [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(9),INTENT(INOUT)   ::WUDay_id
    REAL(KIND(1D0)),DIMENSION(7),INTENT(INOUT)   ::soilmoist_id
    REAL(KIND(1D0)),DIMENSION(7),INTENT(INOUT)   ::state_id
    REAL(KIND(1d0)),DIMENSION(7),INTENT(INOUT)   ::surf_var_id !variable to store the current states
    REAL(KIND(1D0)),DIMENSION(7),INTENT(INOUT)   ::MeltWaterStore


    ! forcing variables
    REAL(KIND(1D0)),INTENT(IN)::avkdn
    REAL(KIND(1D0)),INTENT(IN)::avRh
    REAL(KIND(1D0)),INTENT(IN)::avU1
    REAL(KIND(1D0)),INTENT(IN)::Press_hPa
    REAL(KIND(1D0)),INTENT(IN)::Temp_C
    REAL(KIND(1D0)),INTENT(IN)::Precip

    ! output for WRF
    REAL(KIND(1D0)),INTENT(out)::qf
    REAL(KIND(1D0)),INTENT(out)::qs
    REAL(KIND(1D0)),INTENT(out)::qh
    REAL(KIND(1D0)),INTENT(out)::qe
    REAL(KIND(1D0)),INTENT(out)::qsfc
    REAL(KIND(1D0)),INTENT(out)::tsk
    REAL(KIND(1D0)),INTENT(out)::CHKLOWQ


    ! fixed settings in SuMin
    INTEGER,PARAMETER ::veg_type        = 1
    INTEGER,PARAMETER ::gsModel         = 2
    INTEGER,PARAMETER ::StabilityMethod = 3
    INTEGER,PARAMETER ::SMDMethod       = 0
    INTEGER,PARAMETER ::DiagQN          = 0
    INTEGER,PARAMETER ::DiagQS          = 0
    INTEGER,PARAMETER ::Diagnose        = 0
    INTEGER,PARAMETER ::EvapMethod             = 2
    INTEGER,PARAMETER ::LAICalcYes      = 1
    INTEGER,PARAMETER ::WaterUseMethod  = 0

    REAL(KIND(1D0)),PARAMETER:: LAI_obs   = 0
    REAL(KIND(1D0)),PARAMETER:: ldown_obs = 0
    REAL(KIND(1D0)),PARAMETER:: fcld_obs  = 0
    REAL(KIND(1D0)),PARAMETER:: snow_obs  = 0
    REAL(KIND(1D0)),PARAMETER:: qn1_obs   = 0
    REAL(KIND(1D0)),PARAMETER:: qh_obs    = 0
    REAL(KIND(1D0)),PARAMETER:: qf_obs    = 0
    REAL(KIND(1D0)),PARAMETER:: qs_obs    = 0




    ! local variables not used for WRF coupling
    INTEGER::Gridiv
    INTEGER::Ie_end
    INTEGER::Ie_start

    ! parameters used in SUEWS for now:
    REAL(KIND(1d0)),DIMENSION(7),PARAMETER ::SoilStoreCap        = [150., 150., 150., 150., 150., 150., 0.] !Capacity of soil store for each surface [mm]
    REAL(KIND(1D0)),DIMENSION(7),PARAMETER ::SoilDepth           = 350                                      !Depth of sub-surface soil store for each surface [mm]
    REAL(KIND(1D0)),DIMENSION(7),PARAMETER ::SatHydraulicConduct = 5E-4                                     !Saturated hydraulic conductivity for each soil subsurface [mm s-1]

    REAL(KIND(1d0)),PARAMETER:: AlbMin_DecTr=0.12   !Min albedo for deciduous trees [-]
    REAL(KIND(1d0)),PARAMETER:: AlbMax_DecTr=0.18   !Max albedo for deciduous trees [-]
    REAL(KIND(1d0)),PARAMETER:: AlbMin_EveTr=0.11   !Min albedo for evergreen trees [-]
    REAL(KIND(1d0)),PARAMETER:: AlbMax_EveTr=0.12   !Max albedo for evergreen trees [-]
    REAL(KIND(1d0)),PARAMETER:: AlbMin_Grass=0.18   !Min albedo for grass [-]
    REAL(KIND(1d0)),PARAMETER:: AlbMax_Grass=0.21    !Max albedo for grass [-]

    REAL(KIND(1d0)),PARAMETER:: CapMin_dec=0.3   !Min storage capacity for deciduous trees [mm] (from input information)
    REAL(KIND(1d0)),PARAMETER:: CapMax_dec=0.8   !Max storage capacity for deciduous trees [mm] (from input information)
    REAL(KIND(1d0)),PARAMETER:: PorMin_dec=0.2   !Min porosity for deciduous trees
    REAL(KIND(1d0)),PARAMETER:: PorMax_dec=0.6   !Max porosity for deciduous trees

    REAL(KIND(1d0)),PARAMETER:: FAIbldg    = 0. !Frontal area fraction of buildings
    REAL(KIND(1d0)),PARAMETER:: FAIEveTree = 0. !Frontal area fraction of evergreen trees
    REAL(KIND(1d0)),PARAMETER:: FAIDecTree = 0. !Frontal area fraction of deciduous trees

    REAL (KIND(1d0)),PARAMETER :: bldgH    = 10 !Mean building height
    REAL (KIND(1d0)),PARAMETER :: EveTreeH = 10 !Height of evergreen trees
    REAL (KIND(1d0)),PARAMETER :: DecTreeH = 10 !Height of deciduous trees

    REAL(KIND(1d0)),DIMENSION(3),PARAMETER:: BaseT          = [5,5,5]          !Base temperature for growing degree days [degC]
    REAL(KIND(1d0)),DIMENSION(3),PARAMETER:: BaseTe         = [11,11,11]       !Base temperature for senescence degree days [degC]
    REAL(KIND(1d0)),DIMENSION(3),PARAMETER:: GDDFull        = [300,300,300]    !Growing degree days needed for full capacity [degC]
    REAL(KIND(1d0)),DIMENSION(3),PARAMETER:: SDDFull        = [-450,-450,-450] !Senescence degree days needed to initiate leaf off [degC]
    REAL(KIND(1d0)),DIMENSION(3),PARAMETER:: LaiMin         = [4.,1.,1.6]      !Min LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(3),PARAMETER:: LaiMax         = [5.1,5.5,5.9]    !Max LAI [m2 m-2]
    REAL(KIND(1d0)),DIMENSION(3),PARAMETER:: MaxConductance = [7.4,11.7,30.1]  !Max conductance [mm s-1]

    REAL(KIND(1d0)),DIMENSION(4,3),PARAMETER:: LaiPower = RESHAPE(& !Coeffs for LAI equation: 1,2 - leaf growth; 3,4 - leaf off
         [[0.03,0.03,0.03],                                       &
         [0.0005,0.0005,0.0005],                                  &
         [0.03,0.03,0.03],                                        &
         [0.0005,0.0005,0.0005]],                                 &
         [4,3],order=[2,1])

    INTEGER,DIMENSION(3),PARAMETER:: LAIType=0     !LAI equation to use: original (0) or new (1)


    REAL (KIND(1D0)),PARAMETER ::DRAINRT       = 0.25 !Drainage rate of the water bucket [mm hr-1]
    REAL (KIND(1D0)),PARAMETER ::RAINCOVER     = 1
    REAL (KIND(1D0)),PARAMETER ::RAINMAXRES    = 10   !Maximum water bucket reservoir [mm]
    REAL (KIND(1d0)),PARAMETER ::FlowChange    = 0    !Difference between the input and output flow in the water body
    REAL (KIND(1d0)),PARAMETER ::PipeCapacity  = 100  !Capacity of pipes to transfer water
    REAL (KIND(1d0)),PARAMETER ::RunoffToWater = 0.1  !Fraction of surface runoff going to water body


    REAL(KIND(1d0)),DIMENSION(7),PARAMETER:: StateLimit = [0.48, 0.25, 1.3, 0.8, 1.9, 1.0, 30000.] !Limit for state of each surface type [mm] (specified in input files)
    REAL(KIND(1d0)),DIMENSION(7),PARAMETER:: WetThresh  = [0.48, 0.25, 1.3, 0.8, 1.9, 1., 0.5]     !When State > WetThresh, rs=0 limit in SUEWS_evap [mm] (specified in input files)

    ! ---- Drainage characteristics ----------------------------------------------------------------
    ! 1 - min storage capacity [mm]
    ! 2 - Drainage equation to use
    ! 3 - Drainage coeff 1 [units depend on choice of eqn]
    ! 4 - Drainage coeff 2 [units depend on choice of eqn]
    ! 5 - max storage capacity [mm]
    REAL(KIND(1d0)),DIMENSION(5,7),PARAMETER:: surf_attr = RESHAPE(& ! variable to store the above five properties
         [[ 0.48 , 0.25 , 1.3   , 0.3   , 1.9   , 0.8 , 0.5 ]  , &
         [ 3.    , 3.   , 2.    , 2.    , 2.    , 3.  , 0. ]   , &
         [10.    , 10.  , 0.013 , 0.013 , 0.013 , 10. , 0. ]   , &
         [ 3.    , 3.   , 1.71  , 1.71  , 1.71  , 3.  , 0. ]   , &
         [ 0.48  , 0.25 , 1.3   , 0.8   , 1.9   , 0.8 , 0.5 ]] , &
         [5,7],order=[2,1])


    ! these will be assigned locally as data
    ! use gsModel=2 as in Ward et al. (2016)
    REAL (KIND(1d0)),PARAMETER::th   = 55   !Maximum temperature limit
    REAL (KIND(1d0)),PARAMETER::tl   = -10  !Minimum temperature limit
    REAL (KIND(1d0)),PARAMETER::Kmax = 1200 !Annual maximum hourly solar radiation
    REAL (KIND(1d0)),PARAMETER::g1   = 3.5  !Fitted parameter
    REAL (KIND(1d0)),PARAMETER::g2   = 200  !Fitted parameter
    REAL (KIND(1d0)),PARAMETER::g3   = 0.13 !Fitted parameter
    REAL (KIND(1d0)),PARAMETER::g4   = 0.7  !Fitted parameter
    REAL (KIND(1d0)),PARAMETER::g5   = 30   !Fitted parameter
    REAL (KIND(1d0)),PARAMETER::g6   = 0.05 !Fitted parameter
    REAL (KIND(1d0)),PARAMETER::s1   = 5.56 !Fitted parameter
    REAL (KIND(1d0)),PARAMETER::s2   = 0    !surface res. calculations



    REAL(KIND(1d0)),DIMENSION(7+1),PARAMETER:: OHM_threshSW = [10,10,10,10,10,10,10,10]         !Arrays for OHM thresholds
    REAL(KIND(1d0)),DIMENSION(7+1),PARAMETER:: OHM_threshWD = [0.9,0.9,0.9,0.9,0.9,0.9,0.9,0.9] !Arrays for OHM thresholds

    REAL (KIND(1d0)),PARAMETER::  BaseTHDD=18.9  !Base temperature for QF

    REAL(KIND(1D0)),PARAMETER::xsmd=0. !Measured soil moisture deficit

    REAL(KIND(1D0)),PARAMETER::Faut=0  !Fraction of irrigated area using automatic irrigation
    REAL(KIND(1D0)),PARAMETER::InternalWaterUse_h=0 !Internal water use [mm h-1]
    REAL(KIND(1D0)),PARAMETER::IrrFracConif=0 !Fraction of evergreen trees which are irrigated
    REAL(KIND(1D0)),PARAMETER::IrrFracDecid=0 !Fraction of deciduous trees which are irrigated
    REAL(KIND(1D0)),PARAMETER::IrrFracGrass=0 !Fraction of grass which is irrigated

    REAL(KIND(1D0)),DIMENSION(7),PARAMETER ::DayWat    = 0                     !Days of watering allowed
    REAL(KIND(1D0)),DIMENSION(7),PARAMETER ::DayWatPer = 0                     !% of houses following daily water
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::Ie_a      = [-84.535, 9.959, 3.674] !Coefficients for automatic irrigation models
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::Ie_m      = [-25.36 ,2.988, 1.102]  !Coefficients for manual irrigation models


    ! local variables
    REAL(KIND(1D0)),PARAMETER::NARP_EMIS_SNOW =0.9 !NARP-specific parameters
    REAL(KIND(1D0))::NARP_TRANS_SITE!NARP-specific parameters QUESTION: not used by SUEWS?

    REAL(KIND(1D0)),PARAMETER::NumCapita        = 0 !Number of people in the study area per hectare [ha-1]
    REAL(KIND(1D0)),PARAMETER::PopDensDaytime   = 0 ! Daytime population density [ha-1] (i.e. workers)
    REAL(KIND(1D0)),PARAMETER::PopDensNighttime = 0 ! Nighttime population density [ha-1] (i.e. residents)

    ! snow related local variables
    REAL(KIND(1D0)),PARAMETER                   ::CRWmax         = 0.2   !Free water holding capacity of shallow SnowPack
    REAL(KIND(1D0)),PARAMETER                   ::CRWmin         = 0.05  !Free water holding capacity of deep SnowPack
    REAL(KIND(1D0)),PARAMETER                   ::PrecipLimit    = 2.2   !Temperature limit when precipitation occurs as snow
    REAL(KIND(1D0)),PARAMETER                   ::PrecipLimitAlb = 2     !Precipitation limit for albedo change (in mm)
    REAL(KIND(1D0)),PARAMETER                   ::RadMeltFact    = 0.001 !Radiation melt factor
    REAL(KIND(1D0)),PARAMETER                   ::SnowAlbMax     = 0.8   !Minimum snow albedo
    REAL(KIND(1D0)),PARAMETER                   ::SnowAlbMin     = 0.18 !Maximum snow albedo
    REAL(KIND(1D0)),PARAMETER                   ::SnowDensMax    = 450   !Minimum density of snow
    REAL(KIND(1D0)),PARAMETER                   ::SnowDensMin    = 100   !Maximum density of snow
    REAL(KIND(1D0)),PARAMETER                   ::SnowLimBuild   = 100   !Snow removal limits for roofs in mm)
    REAL(KIND(1D0)),PARAMETER                   ::SnowLimPaved   = 100   !Snow removal limits for paved surfaces in mm)
    REAL(KIND(1D0)),PARAMETER                   ::tau_a          = 0.01  !Time constans related to albedo change
    REAL(KIND(1D0)),PARAMETER                   ::tau_f          = 0.1   !Time constans related to albedo change
    REAL(KIND(1D0)),PARAMETER                   ::tau_r          = 0.02  !Time constans related to albedo change
    REAL(KIND(1D0)),PARAMETER                   ::TempMeltFact   = 0.12  !Temperature melt factor
    REAL(KIND(1D0)),DIMENSION(7),PARAMETER      ::snowD          = 0
    REAL(KIND(1D0)),DIMENSION(0:23,2),PARAMETER ::snowProf_24hr  = 0     ! Timing of snow removal (0 or 1) Hourly, WD/WE


    ! Anthropogenic heat related variables
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::AH_MIN =10!Minimum anthropogenic heat flux (AnthropHeatMethod = 1)
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::AH_SLOPE_Cooling=[2.7,2.7]!Slope of the antrhropogenic heat flux calculation (AnthropHeatMethod = 1)
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::AH_SLOPE_Heating=[2.7,2.7]!Slope of the antrhropogenic heat flux calculation (AnthropHeatMethod = 1)
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::QF0_BEU=[0.7442,0.7955]
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::Qf_A=[0.1,0.1]!Qf coefficients
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::Qf_B=[0.00986,0.00986]!Qf coefficients
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::Qf_C=[0.0102,0.0102]!Qf coefficients
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::T_CRITIC_Cooling=[7,7] !Critical temperature
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::T_CRITIC_Heating=[7,7] !Critical temperature
    REAL(KIND(1D0)),DIMENSION(2),PARAMETER ::TrafficRate=[0.0134,0.0095]
    REAL(KIND(1D0)),PARAMETER::EF_umolCO2perJ=1.159
    REAL(KIND(1D0)),PARAMETER::EnEF_v_Jkm=4e6
    REAL(KIND(1D0)),PARAMETER::FcEF_v_kgkm=0.285
    REAL(KIND(1D0)),PARAMETER::FrFossilFuel_Heat=0.05
    REAL(KIND(1D0)),PARAMETER::FrFossilFuel_NonHeat=0
    REAL(KIND(1D0)),PARAMETER::TrafficUnits=1
    REAL(KIND(1D0)),PARAMETER::MaxQFMetab=175
    REAL(KIND(1D0)),PARAMETER::MinQFMetab=75




    ! AnOHM related: not used
    REAL(KIND(1D0)),DIMENSION(7),PARAMETER ::chAnOHM = 3   ! bulk transfer coef., added by TS AnOHM
    REAL(KIND(1D0)),DIMENSION(7),PARAMETER ::cpAnOHM = 2e6 ! heat capacity, added by TS AnOHM
    REAL(KIND(1D0)),DIMENSION(7),PARAMETER ::kkAnOHM = 1.2 ! heat conductivity, added by TS AnOHM
    REAL(KIND(1D0)),DIMENSION(:,:),ALLOCATABLE ::MetForcingData_grid


    !Biogenic CO2 related parameters
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::alpha_bioCO2     = 0.005
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::alpha_enh_bioCO2 = 0.016
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::beta_bioCO2      = 8.747
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::beta_enh_bioCO2  = 33.454
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::min_res_bioCO2   = 0.6
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::resp_a           = 2.43
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::resp_b           = 0
    REAL(KIND(1D0)),DIMENSION(3),PARAMETER ::theta_bioCO2     = 0.96


    ! ESTM related variables
    REAL(KIND(1d0)),DIMENSION(24*3600/tstep)   ::Tair24HR
    REAL(KIND(1d0)),DIMENSION(:),ALLOCATABLE   ::Ts5mindata_ir !TODO:allocatable array can't serve as argument?


    REAL(KIND(1D0))              ::SnowfallCum = 0   !Cumulative snowfall
    REAL(KIND(1D0)),DIMENSION(7) ::IceFrac     = 0.2 !Estimated fraction of ice. Should be improved in the future
    REAL(KIND(1D0)),DIMENSION(7) ::SnowDens    = 300 !Density of snow
    REAL(KIND(1D0)),DIMENSION(7) ::snowFrac    = 0   !!Surface fraction of snow cover
    REAL(KIND(1D0)),DIMENSION(7) ::SnowPack    = 0   !Amount of snow on each surface in mm

    REAL(KIND(1D0)),DIMENSION(5)                           ::datetimeLine
    REAL(KIND(1D0)),DIMENSION(ncolumnsDataOutSUEWS-5)      ::dataOutLineSUEWS
    REAL(KIND(1D0)),DIMENSION(ncolumnsDataOutSnow-5)       ::dataOutLineSnow
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutESTM-5)       ::dataOutLineESTM
    REAL(KIND(1d0)),DIMENSION(ncolumnsDataOutDailyState-5) ::DailyStateLine

    ! drainage related parameters
    REAL(KIND(1D0)),DIMENSION(6,7)::StoreDrainPrm
    StoreDrainPrm(1:5,:)=surf_attr
    StoreDrainPrm(6,:)=surf_var_id

    ! PRINT*,''
    ! PRINT*, 'soilmoist_id',soilmoist_id
    ! soilmoist_id=MERGE(soilmoist_id,soilmoist_id*0,soilmoist_id>0)
    ! print*, 'soilmoist_id modified',soilmoist_id
    ! PRINT*, 'state_id',state_id


    CALL SUEWS_cal_Main(&
         AerodynamicResistanceMethod,AH_MIN,AHProf_24hr,AH_SLOPE_Cooling,& ! input&inout in alphabetical order
         AH_SLOPE_Heating,&
         alb,AlbMax_DecTr,AlbMax_EveTr,AlbMax_Grass,&
         AlbMin_DecTr,AlbMin_EveTr,AlbMin_Grass,&
         alpha_bioCO2,alpha_enh_bioCO2,alt,avkdn,avRh,avU1,BaseT,BaseTe,&
         BaseTHDD,beta_bioCO2,beta_enh_bioCO2,bldgH,CapMax_dec,CapMin_dec,&
         chAnOHM,cpAnOHM,CRWmax,CRWmin,DayWat,DayWatPer,&
         DecTreeH,Diagnose,DiagQN,DiagQS,DRAINRT,&
         dt_since_start,dqndt,qn1_av,dqnsdt,qn1_s_av,&
         EF_umolCO2perJ,emis,EmissionsMethod,EnEF_v_Jkm,endDLS,EveTreeH,FAIBldg,&
         FAIDecTree,FAIEveTree,Faut,FcEF_v_kgkm,fcld_obs,FlowChange,&
         FrFossilFuel_Heat,FrFossilFuel_NonHeat,G1,G2,G3,G4,G5,G6,GDD_id,&
         GDDFull,Gridiv,gsModel,HDD_id,HumActivity_24hr,&
         IceFrac,id,Ie_a,Ie_end,Ie_m,Ie_start,imin,&
         InternalWaterUse_h,IrrFracConif,IrrFracDecid,IrrFracGrass,isec,it,EvapMethod,&
         iy,kkAnOHM,Kmax,LAI_id,LAICalcYes,LAIMax,LAIMin,LAI_obs,&
         LAIPower,LAIType,lat,ldown_obs,lng,MaxConductance,MaxQFMetab,&
         MeltWaterStore,MetForcingData_grid,MinQFMetab,min_res_bioCO2,&
         NARP_EMIS_SNOW,NARP_TRANS_SITE,NetRadiationMethod,&
         NumCapita,OHM_coef,OHMIncQF,OHM_threshSW,&
         OHM_threshWD,PipeCapacity,PopDensDaytime,&
         PopDensNighttime,PopProf_24hr,PorMax_dec,PorMin_dec,&
         Precip,PrecipLimit,PrecipLimitAlb,Press_hPa,&
         QF0_BEU,Qf_A,Qf_B,Qf_C,&
         qn1_obs,qh_obs,qs_obs,qf_obs,&
         RadMeltFact,RAINCOVER,RainMaxRes,resp_a,resp_b,&
         RoughLenHeatMethod,RoughLenMomMethod,RunoffToWater,S1,S2,&
         SatHydraulicConduct,SDDFull,sfr,SMDMethod,SnowAlb,SnowAlbMax,&
         SnowAlbMin,snowD,SnowDens,SnowDensMax,SnowDensMin,SnowfallCum,snowFrac,&
         SnowLimBuild,SnowLimPaved,snow_obs,SnowPack,SnowProf_24hr,snowUse,SoilDepth,&
         soilmoist_id,soilstoreCap,StabilityMethod,startDLS,state_id,StateLimit,&
         StorageHeatMethod,StoreDrainPrm,SurfaceArea,Tair24HR,tau_a,tau_f,tau_r,&
         T_CRITIC_Cooling,T_CRITIC_Heating,Temp_C,TempMeltFact,TH,&
         theta_bioCO2,timezone,TL,TrafficRate,TrafficUnits,&
         TraffProf_24hr,Ts5mindata_ir,tstep,tstep_prev,veg_type,&
         WaterDist,WaterUseMethod,WetThresh,&
         WUDay_id,&
         DecidCap_id,&
         albDecTr_id,&
         albEveTr_id,&
         albGrass_id,&
         porosity_id,&
         WUProfA_24hr,&
         WUProfM_24hr,xsmd,Z,z0m_in,zdm_in,&
         datetimeLine,dataOutLineSUEWS,dataOutLineSnow,dataOutLineESTM,&!output
         DailyStateLine)!output


    surf_var_id=StoreDrainPrm(6,:) ! update surf_var_id
    qf=dataOutLineSUEWS(7)
    qs=dataOutLineSUEWS(8)
    qh=dataOutLineSUEWS(9)
    qe=dataOutLineSUEWS(10)
    qsfc=dataOutLineSUEWS(16)
    tsk=dataOutLineSUEWS(77)+273.15
    CHKLOWQ=1

    ! PRINT*,''
    ! PRINT*, 'avkdn,kup,ldown,lup,tsurf'
    ! PRINT*, dataOutLineSUEWS(1:5)
    ! PRINT*, 'qn1,qf,qs,qh,qe'
    ! PRINT*, dataOutLineSUEWS(6:10)
    ! PRINT*,''
    ! IF ( ABS(qe)>1000 ) THEN
    !    zdm_in=0.
    !    PRINT*, 10./zdm_in
    ! END IF

  END SUBROUTINE SuMin


END MODULE SuMin_Module

